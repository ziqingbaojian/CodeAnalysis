[
    {
        "name": "clang-tidy-16",
        "display_name": "Clang-Tidy-16",
        "description": "clang-tidy v16.0.0，是一个基于clang的c++检查工具。它提供一个可扩展的框架，用于诊断和修复典型的编程错误，比如样式冲突、接口误用或可以通过静态分析推断出的错误。",
        "license": "Apache License v2.0 with LLVM Exceptions",
        "image_url": null,
        "task_processes": [
            "analyze",
            "datahandle"
        ],
        "scan_app": "codelint",
        "scm_url": "clang-tidy-16",
        "run_cmd": "python3 src/run.py scan",
        "envs": "",
        "build_flag": false,
        "checkrule_set": [
            {
                "real_name": "abseil-cleanup-ctad",
                "display_name": "abseil-cleanup-ctad",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-cleanup-ctadÂ¶\n\nSuggests switching the initialization pattern of `absl::Cleanup` instances\nfrom the factory function to class template argument deduction (CTAD), in\nC++17 and higher.\n\n    \n    \n    auto c1 = absl::MakeCleanup([] {});\n    \n    const auto c2 = absl::MakeCleanup(std::function<void()>([] {}));\n    \n\nbecomes\n\n    \n    \n    absl::Cleanup c1 = [] {};\n    \n    const absl::Cleanup c2 = std::function<void()>([] {});",
                "disable": false
            },
            {
                "real_name": "abseil-duration-addition",
                "display_name": "abseil-duration-addition",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-additionÂ¶\n\nCheck for cases where addition should be performed in the `absl::Time` domain.\nWhen adding two values, and one is known to be an `absl::Time`, we can infer\nthat the other should be interpreted as an `absl::Duration` of a similar\nscale, and make that inference explicit.\n\nExamples:\n\n    \n    \n    // Original - Addition in the integer domain\n    int x;\n    absl::Time t;\n    int result = absl::ToUnixSeconds(t) + x;\n    \n    // Suggestion - Addition in the absl::Time domain\n    int result = absl::ToUnixSeconds(t + absl::Seconds(x));",
                "disable": false
            },
            {
                "real_name": "abseil-duration-comparison",
                "display_name": "abseil-duration-comparison",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-comparisonÂ¶\n\nChecks for comparisons which should be in the `absl::Duration` domain instead\nof the floating point or integer domains.\n\nN.B.: In cases where a `Duration` was being converted to an integer and then\ncompared against a floating-point value, truncation during the `Duration`\nconversion might yield a different result. In practice this is very rare, and\nstill indicates a bug which should be fixed.\n\nExamples:\n\n    \n    \n    // Original - Comparison in the floating point domain\n    double x;\n    absl::Duration d;\n    if (x < absl::ToDoubleSeconds(d)) ...\n    \n    // Suggested - Compare in the absl::Duration domain instead\n    if (absl::Seconds(x) < d) ...\n    \n    \n    // Original - Comparison in the integer domain\n    int x;\n    absl::Duration d;\n    if (x < absl::ToInt64Microseconds(d)) ...\n    \n    // Suggested - Compare in the absl::Duration domain instead\n    if (absl::Microseconds(x) < d) ...",
                "disable": false
            },
            {
                "real_name": "abseil-duration-conversion-cast",
                "display_name": "abseil-duration-conversion-cast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-conversion-castÂ¶\n\nChecks for casts of `absl::Duration` conversion functions, and recommends the\nright conversion function instead.\n\nExamples:\n\n    \n    \n    // Original - Cast from a double to an integer\n    absl::Duration d;\n    int i = static_cast<int>(absl::ToDoubleSeconds(d));\n    \n    // Suggested - Use the integer conversion function directly.\n    int i = absl::ToInt64Seconds(d);\n    \n    \n    // Original - Cast from a double to an integer\n    absl::Duration d;\n    double x = static_cast<double>(absl::ToInt64Seconds(d));\n    \n    // Suggested - Use the integer conversion function directly.\n    double x = absl::ToDoubleSeconds(d);\n    \n\nNote: In the second example, the suggested fix could yield a different result,\nas the conversion to integer could truncate. In practice, this is very rare,\nand you should use `absl::Trunc` to perform this operation explicitly instead.",
                "disable": false
            },
            {
                "real_name": "abseil-duration-division",
                "display_name": "abseil-duration-division",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-divisionÂ¶\n\n`absl::Duration` arithmetic works like it does with integers. That means that\ndivision of two `absl::Duration` objects returns an `int64` with any\nfractional component truncated toward 0. See [this\nlink](https://github.com/abseil/abseil-\ncpp/blob/29ff6d4860070bf8fcbd39c8805d0c32d56628a3/absl/time/time.h#L137) for\nmore information on arithmetic with `absl::Duration`.\n\nFor example:\n\n    \n    \n    absl::Duration d = absl::Seconds(3.5);\n    int64 sec1 = d / absl::Seconds(1);     // Truncates toward 0.\n    int64 sec2 = absl::ToInt64Seconds(d);  // Equivalent to division.\n    assert(sec1 == 3 && sec2 == 3);\n    \n    double dsec = d / absl::Seconds(1);  // WRONG: Still truncates toward 0.\n    assert(dsec == 3.0);\n    \n\nIf you want floating-point division, you should use either the\n`absl::FDivDuration()` function, or one of the unit conversion functions such\nas `absl::ToDoubleSeconds()`. For example:\n\n    \n    \n    absl::Duration d = absl::Seconds(3.5);\n    double dsec1 = absl::FDivDuration(d, absl::Seconds(1));  // GOOD: No truncation.\n    double dsec2 = absl::ToDoubleSeconds(d);                 // GOOD: No truncation.\n    assert(dsec1 == 3.5 && dsec2 == 3.5);\n    \n\nThis check looks for uses of `absl::Duration` division that is done in a\nfloating-point context, and recommends the use of a function that returns a\nfloating-point value.",
                "disable": false
            },
            {
                "real_name": "abseil-duration-factory-float",
                "display_name": "abseil-duration-factory-float",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-factory-floatÂ¶\n\nChecks for cases where the floating-point overloads of various\n`absl::Duration` factory functions are called when the more-efficient integer\nversions could be used instead.\n\nThis check will not suggest fixes for literals which contain fractional\nfloating point values or non-literals. It will suggest removing superfluous\ncasts.\n\nExamples:\n\n    \n    \n    // Original - Providing a floating-point literal.\n    absl::Duration d = absl::Seconds(10.0);\n    \n    // Suggested - Use an integer instead.\n    absl::Duration d = absl::Seconds(10);\n    \n    \n    // Original - Explicitly casting to a floating-point type.\n    absl::Duration d = absl::Seconds(static_cast<double>(10));\n    \n    // Suggested - Remove the explicit cast\n    absl::Duration d = absl::Seconds(10);",
                "disable": false
            },
            {
                "real_name": "abseil-duration-factory-scale",
                "display_name": "abseil-duration-factory-scale",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-factory-scaleÂ¶\n\nChecks for cases where arguments to `absl::Duration` factory functions are\nscaled internally and could be changed to a different factory function. This\ncheck also looks for arguments with a zero value and suggests using\n`absl::ZeroDuration()` instead.\n\nExamples:\n\n    \n    \n    // Original - Internal multiplication.\n    int x;\n    absl::Duration d = absl::Seconds(60 * x);\n    \n    // Suggested - Use absl::Minutes instead.\n    absl::Duration d = absl::Minutes(x);\n    \n    \n    // Original - Internal division.\n    int y;\n    absl::Duration d = absl::Milliseconds(y / 1000.);\n    \n    // Suggested - Use absl:::Seconds instead.\n    absl::Duration d = absl::Seconds(y);\n    \n    \n    // Original - Zero-value argument.\n    absl::Duration d = absl::Hours(0);\n    \n    // Suggested = Use absl::ZeroDuration instead\n    absl::Duration d = absl::ZeroDuration();",
                "disable": false
            },
            {
                "real_name": "abseil-duration-subtraction",
                "display_name": "abseil-duration-subtraction",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-subtractionÂ¶\n\nChecks for cases where subtraction should be performed in the `absl::Duration`\ndomain. When subtracting two values, and the first one is known to be a\nconversion from `absl::Duration`, we can infer that the second should also be\ninterpreted as an `absl::Duration`, and make that inference explicit.\n\nExamples:\n\n    \n    \n    // Original - Subtraction in the double domain\n    double x;\n    absl::Duration d;\n    double result = absl::ToDoubleSeconds(d) - x;\n    \n    // Suggestion - Subtraction in the absl::Duration domain instead\n    double result = absl::ToDoubleSeconds(d - absl::Seconds(x));\n    \n    // Original - Subtraction of two Durations in the double domain\n    absl::Duration d1, d2;\n    double result = absl::ToDoubleSeconds(d1) - absl::ToDoubleSeconds(d2);\n    \n    // Suggestion - Subtraction in the absl::Duration domain instead\n    double result = absl::ToDoubleSeconds(d1 - d2);\n    \n\nNote: As with other `clang-tidy` checks, it is possible that multiple fixes\nmay overlap (as in the case of nested expressions), so not all occurrences can\nbe transformed in one run. In particular, this may occur for nested\nsubtraction expressions. Running `clang-tidy` multiple times will find and fix\nthese overlaps.",
                "disable": false
            },
            {
                "real_name": "abseil-duration-unnecessary-conversion",
                "display_name": "abseil-duration-unnecessary-conversion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-duration-unnecessary-conversionÂ¶\n\nFinds and fixes cases where `absl::Duration` values are being converted to\nnumeric types and back again.\n\nFloating-point examples:\n\n    \n    \n    // Original - Conversion to double and back again\n    absl::Duration d1;\n    absl::Duration d2 = absl::Seconds(absl::ToDoubleSeconds(d1));\n    \n    // Suggestion - Remove unnecessary conversions\n    absl::Duration d2 = d1;\n    \n    // Original - Division to convert to double and back again\n    absl::Duration d2 = absl::Seconds(absl::FDivDuration(d1, absl::Seconds(1)));\n    \n    // Suggestion - Remove division and conversion\n    absl::Duration d2 = d1;\n    \n\nInteger examples:\n\n    \n    \n    // Original - Conversion to integer and back again\n    absl::Duration d1;\n    absl::Duration d2 = absl::Hours(absl::ToInt64Hours(d1));\n    \n    // Suggestion - Remove unnecessary conversions\n    absl::Duration d2 = d1;\n    \n    // Original - Integer division followed by conversion\n    absl::Duration d2 = absl::Seconds(d1 / absl::Seconds(1));\n    \n    // Suggestion - Remove division and conversion\n    absl::Duration d2 = d1;\n    \n\nUnwrapping scalar operations:\n\n    \n    \n    // Original - Multiplication by a scalar\n    absl::Duration d1;\n    absl::Duration d2 = absl::Seconds(absl::ToInt64Seconds(d1) * 2);\n    \n    // Suggestion - Remove unnecessary conversion\n    absl::Duration d2 = d1 * 2;\n    \n\nNote: Converting to an integer and back to an `absl::Duration` might be a\ntruncating operation if the value is not aligned to the scale of conversion.\nIn the rare case where this is the intended result, callers should use\n`absl::Trunc` to truncate explicitly.",
                "disable": false
            },
            {
                "real_name": "abseil-faster-strsplit-delimiter",
                "display_name": "abseil-faster-strsplit-delimiter",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-faster-strsplit-delimiterÂ¶\n\nFinds instances of `absl::StrSplit()` or `absl::MaxSplits()` where the\ndelimiter is a single character string literal and replaces with a character.\nThe check will offer a suggestion to change the string literal into a\ncharacter. It will also catch code using `absl::ByAnyChar()` for just a single\ncharacter and will transform that into a single character as well.\n\nThese changes will give the same result, but using characters rather than\nsingle character string literals is more efficient and readable.\n\nExamples:\n\n    \n    \n    // Original - the argument is a string literal.\n    for (auto piece : absl::StrSplit(str, \"B\")) {\n    \n    // Suggested - the argument is a character, which causes the more efficient\n    // overload of absl::StrSplit() to be used.\n    for (auto piece : absl::StrSplit(str, 'B')) {\n    \n    \n    // Original - the argument is a string literal inside absl::ByAnyChar call.\n    for (auto piece : absl::StrSplit(str, absl::ByAnyChar(\"B\"))) {\n    \n    // Suggested - the argument is a character, which causes the more efficient\n    // overload of absl::StrSplit() to be used and we do not need absl::ByAnyChar\n    // anymore.\n    for (auto piece : absl::StrSplit(str, 'B')) {\n    \n    \n    // Original - the argument is a string literal inside absl::MaxSplits call.\n    for (auto piece : absl::StrSplit(str, absl::MaxSplits(\"B\", 1))) {\n    \n    // Suggested - the argument is a character, which causes the more efficient\n    // overload of absl::StrSplit() to be used.\n    for (auto piece : absl::StrSplit(str, absl::MaxSplits('B', 1))) {",
                "disable": false
            },
            {
                "real_name": "abseil-no-internal-dependencies",
                "display_name": "abseil-no-internal-dependencies",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-no-internal-dependenciesÂ¶\n\nWarns if code using Abseil depends on internal details. If something is in a\nnamespace that includes the word âinternalâ, code is not allowed to depend\nupon it because itâs an implementation detail. They cannot friend it,\ninclude it, you mention it or refer to it in any way. Doing so violates\nAbseilâs compatibility guidelines and may result in breakage. See\n<https://abseil.io/about/compatibility> for more information.\n\nThe following cases will result in warnings:\n\n    \n    \n    absl::strings_internal::foo();\n    // warning triggered on this line\n    class foo {\n      friend struct absl::container_internal::faa;\n      // warning triggered on this line\n    };\n    absl::memory_internal::MakeUniqueResult();\n    // warning triggered on this line",
                "disable": false
            },
            {
                "real_name": "abseil-no-namespace",
                "display_name": "abseil-no-namespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-no-namespaceÂ¶\n\nEnsures code does not open `namespace absl` as that violates Abseilâs\ncompatibility guidelines. Code should not open `namespace absl` as that\nconflicts with Abseilâs compatibility guidelines and may result in breakage.\n\nAny code that uses:\n\n    \n    \n    namespace absl {\n     ...\n    }\n    \n\nwill be prompted with a warning.\n\nSee [the full Abseil compatibility\nguidelines](https://abseil.io/about/compatibility) for more information.",
                "disable": false
            },
            {
                "real_name": "abseil-redundant-strcat-calls",
                "display_name": "abseil-redundant-strcat-calls",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-redundant-strcat-callsÂ¶\n\nSuggests removal of unnecessary calls to `absl::StrCat` when the result is\nbeing passed to another call to `absl::StrCat` or `absl::StrAppend`.\n\nThe extra calls cause unnecessary temporary strings to be constructed.\nRemoving them makes the code smaller and faster.\n\nExamples:\n\n    \n    \n    std::string s = absl::StrCat(\"A\", absl::StrCat(\"B\", absl::StrCat(\"C\", \"D\")));\n    //before\n    \n    std::string s = absl::StrCat(\"A\", \"B\", \"C\", \"D\");\n    //after\n    \n    absl::StrAppend(&s, absl::StrCat(\"E\", \"F\", \"G\"));\n    //before\n    \n    absl::StrAppend(&s, \"E\", \"F\", \"G\");\n    //after",
                "disable": false
            },
            {
                "real_name": "abseil-str-cat-append",
                "display_name": "abseil-str-cat-append",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-str-cat-appendÂ¶\n\nFlags uses of `absl::StrCat()` to append to a `std::string`. Suggests\n`absl::StrAppend()` should be used instead.\n\nThe extra calls cause unnecessary temporary strings to be constructed.\nRemoving them makes the code smaller and faster.\n\n    \n    \n    a = absl::StrCat(a, b); // Use absl::StrAppend(&a, b) instead.\n    \n\nDoes not diagnose cases where `absl::StrCat()` is used as a template argument\nfor a functor.",
                "disable": false
            },
            {
                "real_name": "abseil-string-find-startswith",
                "display_name": "abseil-string-find-startswith",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-string-find-startswithÂ¶\n\nChecks whether a `std::string::find()` or `std::string::rfind()` result is\ncompared with 0, and suggests replacing with `absl::StartsWith()`. This is\nboth a readability and performance issue.\n\n    \n    \n    string s = \"...\";\n    if (s.find(\"Hello World\") == 0) { /* do something */ }\n    if (s.rfind(\"Hello World\", 0) == 0) { /* do something */ }\n    \n\nbecomes\n\n    \n    \n    string s = \"...\";\n    if (absl::StartsWith(s, \"Hello World\")) { /* do something */ }\n    if (absl::StartsWith(s, \"Hello World\")) { /* do something */ }\n    \n\n## OptionsÂ¶\n\n`StringLikeClasses```Â¶\n\n    \n\nSemicolon-separated list of names of string-like classes. By default only\n`std::basic_string` is considered. The list of methods to considered is fixed.\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`AbseilStringsMatchHeader```Â¶\n\n    \n\nThe location of Abseilâs `strings/match.h`. Defaults to\n`absl/strings/match.h`.",
                "disable": false
            },
            {
                "real_name": "abseil-string-find-str-contains",
                "display_name": "abseil-string-find-str-contains",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-string-find-str-containsÂ¶\n\nFinds `s.find(...) == string::npos` comparisons (for various string-like\ntypes) and suggests replacing with `absl::StrContains()`.\n\nThis improves readability and reduces the likelihood of accidentally mixing\n`find()` and `npos` from different string-like types.\n\nBy default, âstring-like typesâ includes `::std::basic_string`,\n`::std::basic_string_view`, and `::absl::string_view`. See the\nStringLikeClasses option to change this.\n\n    \n    \n    std::string s = \"...\";\n    if (s.find(\"Hello World\") == std::string::npos) { /* do something */ }\n    \n    absl::string_view a = \"...\";\n    if (absl::string_view::npos != a.find(\"Hello World\")) { /* do something */ }\n    \n\nbecomes\n\n    \n    \n    std::string s = \"...\";\n    if (!absl::StrContains(s, \"Hello World\")) { /* do something */ }\n    \n    absl::string_view a = \"...\";\n    if (absl::StrContains(a, \"Hello World\")) { /* do something */ }\n    \n\n## OptionsÂ¶\n\n`StringLikeClasses```Â¶\n\n    \n\nSemicolon-separated list of names of string-like classes. By default includes\n`::std::basic_string`, `::std::basic_string_view`, and `::absl::string_view`.\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`AbseilStringsMatchHeader```Â¶\n\n    \n\nThe location of Abseilâs `strings/match.h`. Defaults to\n`absl/strings/match.h`.",
                "disable": false
            },
            {
                "real_name": "abseil-time-comparison",
                "display_name": "abseil-time-comparison",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-time-comparisonÂ¶\n\nPrefer comparisons in the `absl::Time` domain instead of the integer domain.\n\nN.B.: In cases where an `absl::Time` is being converted to an integer,\nalignment may occur. If the comparison depends on this alignment, doing the\ncomparison in the `absl::Time` domain may yield a different result. In\npractice this is very rare, and still indicates a bug which should be fixed.\n\nExamples:\n\n    \n    \n    // Original - Comparison in the integer domain\n    int x;\n    absl::Time t;\n    if (x < absl::ToUnixSeconds(t)) ...\n    \n    // Suggested - Compare in the absl::Time domain instead\n    if (absl::FromUnixSeconds(x) < t) ...",
                "disable": false
            },
            {
                "real_name": "abseil-time-subtraction",
                "display_name": "abseil-time-subtraction",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-time-subtractionÂ¶\n\nFinds and fixes `absl::Time` subtraction expressions to do subtraction in the\nTime domain instead of the numeric domain.\n\nThere are two cases of Time subtraction in which deduce additional type\ninformation:\n\n  * When the result is an `absl::Duration` and the first argument is an `absl::Time`.\n  * When the second argument is a `absl::Time`.\n\nIn the first case, we must know the result of the operation, since without\nthat the second operand could be either an `absl::Time` or an\n`absl::Duration`. In the second case, the first operand _must_ be an\n`absl::Time`, because subtracting an `absl::Time` from an `absl::Duration` is\nnot defined.\n\nExamples:\n\n    \n    \n    int x;\n    absl::Time t;\n    \n    // Original - absl::Duration result and first operand is an absl::Time.\n    absl::Duration d = absl::Seconds(absl::ToUnixSeconds(t) - x);\n    \n    // Suggestion - Perform subtraction in the Time domain instead.\n    absl::Duration d = t - absl::FromUnixSeconds(x);\n    \n    \n    // Original - Second operand is an absl::Time.\n    int i = x - absl::ToUnixSeconds(t);\n    \n    // Suggestion - Perform subtraction in the Time domain instead.\n    int i = absl::ToInt64Seconds(absl::FromUnixSeconds(x) - t);",
                "disable": false
            },
            {
                "real_name": "abseil-upgrade-duration-conversions",
                "display_name": "abseil-upgrade-duration-conversions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# abseil-upgrade-duration-conversionsÂ¶\n\nFinds calls to `absl::Duration` arithmetic operators and factories whose\nargument needs an explicit cast to continue compiling after upcoming API\nchanges.\n\nThe operators `*=`, `/=`, `*`, and `/` for `absl::Duration` currently accept\nan argument of class type that is convertible to an arithmetic type. Such a\ncall currently converts the value to an `int64_t`, even in a case such as\n`std::atomic<float>` that would result in lossy conversion.\n\nAdditionally, the `absl::Duration` factory functions (`absl::Hours`,\n`absl::Minutes`, etc) currently accept an `int64_t` or a floating-point type.\nSimilar to the arithmetic operators, calls with an argument of class type that\nis convertible to an arithmetic type go through the `int64_t` path.\n\nThese operators and factories will be changed to only accept arithmetic types\nto prevent unintended behavior. After these changes are released, passing an\nargument of class type will no longer compile, even if the type is implicitly\nconvertible to an arithmetic type.\n\nHere are example fixes created by this check:\n\n    \n    \n    std::atomic<int> a;\n    absl::Duration d = absl::Milliseconds(a);\n    d *= a;\n    \n\nbecomes\n\n    \n    \n    std::atomic<int> a;\n    absl::Duration d = absl::Milliseconds(static_cast<int64_t>(a));\n    d *= static_cast<int64_t>(a);\n    \n\nNote that this check always adds a cast to `int64_t` in order to preserve the\ncurrent behavior of user code. It is possible that this uncovers unintended\nbehavior due to types implicitly convertible to a floating-point type.",
                "disable": false
            },
            {
                "real_name": "altera-id-dependent-backward-branch",
                "display_name": "altera-id-dependent-backward-branch",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# altera-id-dependent-backward-branchÂ¶\n\nFinds ID-dependent variables and fields that are used within loops. This\ncauses branches to occur inside the loops, and thus leads to performance\ndegradation.\n\n    \n    \n    // The following code will produce a warning because this ID-dependent\n    // variable is used in a loop condition statement.\n    int ThreadID = get_local_id(0);\n    \n    // The following loop will produce a warning because the loop condition\n    // statement depends on an ID-dependent variable.\n    for (int i = 0; i < ThreadID; ++i) {\n      std::cout << i << std::endl;\n    }\n    \n    // The following loop will not produce a warning, because the ID-dependent\n    // variable is not used in the loop condition statement.\n    for (int i = 0; i < 100; ++i) {\n      std::cout << ThreadID << std::endl;\n    }\n    \n\nBased on the [Altera SDK for OpenCL: Best Practices\nGuide](https://www.altera.com/en_US/pdfs/literature/hb/opencl-\nsdk/aocl_optimization_guide.pdf).",
                "disable": false
            },
            {
                "real_name": "altera-kernel-name-restriction",
                "display_name": "altera-kernel-name-restriction",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# altera-kernel-name-restrictionÂ¶\n\nFinds kernel files and include directives whose filename is kernel.cl,\nVerilog.cl, or VHDL.cl. The check is case insensitive.\n\nSuch kernel file names cause the offline compiler to generate intermediate\ndesign files that have the same names as certain internal files, which leads\nto a compilation error.\n\nBased on the Guidelines for Naming the Kernel section in the [Intel FPGA SDK\nfor OpenCL Pro Edition: Programming\nGuide](https://www.intel.com/content/www/us/en/programmable/documentation/mwh1391807965224.html#ewa1412973930963).",
                "disable": false
            },
            {
                "real_name": "altera-single-work-item-barrier",
                "display_name": "altera-single-work-item-barrier",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# altera-single-work-item-barrierÂ¶\n\nFinds OpenCL kernel functions that call a barrier function but do not call an\nID function (`get_local_id`, `get_local_id`, `get_group_id`, or\n`get_local_linear_id`).\n\nThese kernels may be viable single work-item kernels, but will be forced to\nexecute as NDRange kernels if using a newer version of the Altera Offline\nCompiler (>= v17.01).\n\nIf using an older version of the Altera Offline Compiler, these kernel\nfunctions will be treated as single work-item kernels, which could be\ninefficient or lead to errors if NDRange semantics were intended.\n\nBased on the [Altera SDK for OpenCL: Best Practices\nGuide](https://www.altera.com/en_US/pdfs/literature/hb/opencl-\nsdk/aocl_optimization_guide.pdf).\n\nExamples:\n\n    \n    \n    // error: function calls barrier but does not call an ID function.\n    void __kernel barrier_no_id(__global int * foo, int size) {\n      for (int i = 0; i < 100; i++) {\n        foo[i] += 5;\n      }\n      barrier(CLK_GLOBAL_MEM_FENCE);\n    }\n    \n    // ok: function calls barrier and an ID function.\n    void __kernel barrier_with_id(__global int * foo, int size) {\n      for (int i = 0; i < 100; i++) {\n        int tid = get_global_id(0);\n        foo[tid] += 5;\n      }\n      barrier(CLK_GLOBAL_MEM_FENCE);\n    }\n    \n    // ok with AOC Version 17.01: the reqd_work_group_size turns this into\n    // an NDRange.\n    __attribute__((reqd_work_group_size(2,2,2)))\n    void __kernel barrier_with_id(__global int * foo, int size) {\n      for (int i = 0; i < 100; i++) {\n        foo[tid] += 5;\n      }\n      barrier(CLK_GLOBAL_MEM_FENCE);\n    }\n    \n\n## OptionsÂ¶\n\n`AOCVersion```Â¶\n\n    \n\nDefines the version of the Altera Offline Compiler. Defaults to `1600`\n(corresponding to version 16.00).",
                "disable": false
            },
            {
                "real_name": "altera-struct-pack-align",
                "display_name": "altera-struct-pack-align",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# altera-struct-pack-alignÂ¶\n\nFinds structs that are inefficiently packed or aligned, and recommends packing\nand/or aligning of said structs as needed.\n\nStructs that are not packed take up more space than they should, and accessing\nstructs that are not well aligned is inefficient.\n\nFix-its are provided to fix both of these issues by inserting and/or amending\nrelevant struct attributes.\n\nBased on the [Altera SDK for OpenCL: Best Practices\nGuide](https://www.altera.com/en_US/pdfs/literature/hb/opencl-\nsdk/aocl_optimization_guide.pdf).\n\n    \n    \n    // The following struct is originally aligned to 4 bytes, and thus takes up\n    // 12 bytes of memory instead of 10. Packing the struct will make it use\n    // only 10 bytes of memory, and aligning it to 16 bytes will make it\n    // efficient to access.\n    struct example {\n      char a;    // 1 byte\n      double b;  // 8 bytes\n      char c;    // 1 byte\n    };\n    \n    // The following struct is arranged in such a way that packing is not needed.\n    // However, it is aligned to 4 bytes instead of 8, and thus needs to be\n    // explicitly aligned.\n    struct implicitly_packed_example {\n      char a;  // 1 byte\n      char b;  // 1 byte\n      char c;  // 1 byte\n      char d;  // 1 byte\n      int e;   // 4 bytes\n    };\n    \n    // The following struct is explicitly aligned and packed.\n    struct good_example {\n      char a;    // 1 byte\n      double b;  // 8 bytes\n      char c;    // 1 byte\n    } __attribute__((packed)) __attribute__((aligned(16));\n    \n    // Explicitly aligning a struct to the wrong value will result in a warning.\n    // The following example should be aligned to 16 bytes, not 32.\n    struct badly_aligned_example {\n      char a;    // 1 byte\n      double b;  // 8 bytes\n      char c;    // 1 byte\n    } __attribute__((packed)) __attribute__((aligned(32)));",
                "disable": false
            },
            {
                "real_name": "altera-unroll-loops",
                "display_name": "altera-unroll-loops",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# altera-unroll-loopsÂ¶\n\nFinds inner loops that have not been unrolled, as well as fully unrolled loops\nwith unknown loop bounds or a large number of iterations.\n\nUnrolling inner loops could improve the performance of OpenCL kernels.\nHowever, if they have unknown loop bounds or a large number of iterations,\nthey cannot be fully unrolled, and should be partially unrolled.\n\nNotes:\n\n  * This check is unable to determine the number of iterations in a `while` or `do..while` loop; hence if such a loop is fully unrolled, a note is emitted advising the user to partially unroll instead.\n  * In `for` loops, our check only works with simple arithmetic increments ( `+`, `-`, `*`, `/`). For all other increments, partial unrolling is advised.\n  * Depending on the exit condition, the calculations for determining if the number of iterations is large may be off by 1. This should not be an issue since the cut-off is generally arbitrary.\n\nBased on the [Altera SDK for OpenCL: Best Practices\nGuide](https://www.altera.com/en_US/pdfs/literature/hb/opencl-\nsdk/aocl_optimization_guide.pdf).\n\n    \n    \n    for (int i = 0; i < 10; i++) {  // ok: outer loops should not be unrolled\n       int j = 0;\n       do {  // warning: this inner do..while loop should be unrolled\n          j++;\n       } while (j < 15);\n    \n       int k = 0;\n       #pragma unroll\n       while (k < 20) {  // ok: this inner loop is already unrolled\n          k++;\n       }\n    }\n    \n    int A[1000];\n    #pragma unroll\n    // warning: this loop is large and should be partially unrolled\n    for (int a : A) {\n       printf(\"%d\", a);\n    }\n    \n    #pragma unroll 5\n    // ok: this loop is large, but is partially unrolled\n    for (int a : A) {\n       printf(\"%d\", a);\n    }\n    \n    #pragma unroll\n    // warning: this loop is large and should be partially unrolled\n    for (int i = 0; i < 1000; ++i) {\n       printf(\"%d\", i);\n    }\n    \n    #pragma unroll 5\n    // ok: this loop is large, but is partially unrolled\n    for (int i = 0; i < 1000; ++i) {\n       printf(\"%d\", i);\n    }\n    \n    #pragma unroll\n    // warning: << operator not supported, recommend partial unrolling\n    for (int i = 0; i < 1000; i<<1) {\n       printf(\"%d\", i);\n    }\n    \n    std::vector<int> someVector (100, 0);\n    int i = 0;\n    #pragma unroll\n    // note: loop may be large, recommend partial unrolling\n    while (i < someVector.size()) {\n       someVector[i]++;\n    }\n    \n    #pragma unroll\n    // note: loop may be large, recommend partial unrolling\n    while (true) {\n       printf(\"In loop\");\n    }\n    \n    #pragma unroll 5\n    // ok: loop may be large, but is partially unrolled\n    while (i < someVector.size()) {\n       someVector[i]++;\n    }\n    \n\n## OptionsÂ¶\n\n`MaxLoopIterations```Â¶\n\n    \n\nDefines the maximum number of loop iterations that a fully unrolled loop can\nhave. By default, it is set to 100.\n\nIn practice, this refers to the integer value of the upper bound within the\nloop statementâs condition expression.",
                "disable": false
            },
            {
                "real_name": "android-cloexec-accept",
                "display_name": "android-cloexec-accept",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-acceptÂ¶\n\nThe usage of `accept()` is not recommended, itâs better to use `accept4()`.\nWithout this flag, an opened sensitive file descriptor would remain open\nacross a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    accept(sockfd, addr, addrlen);\n    \n    // becomes\n    \n    accept4(sockfd, addr, addrlen, SOCK_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-accept4",
                "display_name": "android-cloexec-accept4",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-accept4Â¶\n\n`accept4()` should include `SOCK_CLOEXEC` in its type argument to avoid the\nfile descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    accept4(sockfd, addr, addrlen, SOCK_NONBLOCK);\n    \n    // becomes\n    \n    accept4(sockfd, addr, addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-creat",
                "display_name": "android-cloexec-creat",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-creatÂ¶\n\nThe usage of `creat()` is not recommended, itâs better to use `open()`.\n\nExamples:\n\n    \n    \n    int fd = creat(path, mode);\n    \n    // becomes\n    \n    int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, mode);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-dup",
                "display_name": "android-cloexec-dup",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-dupÂ¶\n\nThe usage of `dup()` is not recommended, itâs better to use `fcntl()`, which\ncan set the close-on-exec flag. Otherwise, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    int fd = dup(oldfd);\n    \n    // becomes\n    \n    int fd = fcntl(oldfd, F_DUPFD_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-epoll-create",
                "display_name": "android-cloexec-epoll-create",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-epoll-createÂ¶\n\nThe usage of `epoll_create()` is not recommended, itâs better to use\n`epoll_create1()`, which allows close-on-exec.\n\nExamples:\n\n    \n    \n    epoll_create(size);\n    \n    // becomes\n    \n    epoll_create1(EPOLL_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-epoll-create1",
                "display_name": "android-cloexec-epoll-create1",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-epoll-create1Â¶\n\n`epoll_create1()` should include `EPOLL_CLOEXEC` in its type argument to avoid\nthe file descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    epoll_create1(0);\n    \n    // becomes\n    \n    epoll_create1(EPOLL_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-fopen",
                "display_name": "android-cloexec-fopen",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-fopenÂ¶\n\n`fopen()` should include `e` in their mode string; so `re` would be valid.\nThis is equivalent to having set `FD_CLOEXEC on` that descriptor.\n\nExamples:\n\n    \n    \n    fopen(\"fn\", \"r\");\n    \n    // becomes\n    \n    fopen(\"fn\", \"re\");",
                "disable": false
            },
            {
                "real_name": "android-cloexec-inotify-init",
                "display_name": "android-cloexec-inotify-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-inotify-initÂ¶\n\nThe usage of `inotify_init()` is not recommended, itâs better to use\n`inotify_init1()`.\n\nExamples:\n\n    \n    \n    inotify_init();\n    \n    // becomes\n    \n    inotify_init1(IN_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-inotify-init1",
                "display_name": "android-cloexec-inotify-init1",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-inotify-init1Â¶\n\n`inotify_init1()` should include `IN_CLOEXEC` in its type argument to avoid\nthe file descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    inotify_init1(IN_NONBLOCK);\n    \n    // becomes\n    \n    inotify_init1(IN_NONBLOCK | IN_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-memfd-create",
                "display_name": "android-cloexec-memfd-create",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-memfd-createÂ¶\n\n`memfd_create()` should include `MFD_CLOEXEC` in its type argument to avoid\nthe file descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    memfd_create(name, MFD_ALLOW_SEALING);\n    \n    // becomes\n    \n    memfd_create(name, MFD_ALLOW_SEALING | MFD_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-open",
                "display_name": "android-cloexec-open",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-openÂ¶\n\nA common source of security bugs is code that opens a file without using the\n`O_CLOEXEC` flag. Without that flag, an opened sensitive file would remain\nopen across a fork+exec to a lower-privileged SELinux domain, leaking that\nsensitive data. Open-like functions including `open()`, `openat()`, and\n`open64()` should include `O_CLOEXEC` in their flags argument.\n\nExamples:\n\n    \n    \n    open(\"filename\", O_RDWR);\n    open64(\"filename\", O_RDWR);\n    openat(0, \"filename\", O_RDWR);\n    \n    // becomes\n    \n    open(\"filename\", O_RDWR | O_CLOEXEC);\n    open64(\"filename\", O_RDWR | O_CLOEXEC);\n    openat(0, \"filename\", O_RDWR | O_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-pipe",
                "display_name": "android-cloexec-pipe",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-pipeÂ¶\n\nThis check detects usage of `pipe()`. Using `pipe()` is not recommended,\n`pipe2()` is the suggested replacement. The check also adds the O_CLOEXEC flag\nthat marks the file descriptor to be closed in child processes. Without this\nflag a sensitive file descriptor can be leaked to a child process, potentially\ninto a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    pipe(pipefd);\n    \n\nSuggested replacement:\n\n    \n    \n    pipe2(pipefd, O_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-pipe2",
                "display_name": "android-cloexec-pipe2",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-pipe2Â¶\n\nThis check ensures that pipe2() is called with the O_CLOEXEC flag. The check\nalso adds the O_CLOEXEC flag that marks the file descriptor to be closed in\nchild processes. Without this flag a sensitive file descriptor can be leaked\nto a child process, potentially into a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    pipe2(pipefd, O_NONBLOCK);\n    \n\nSuggested replacement:\n\n    \n    \n    pipe2(pipefd, O_NONBLOCK | O_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-cloexec-socket",
                "display_name": "android-cloexec-socket",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-cloexec-socketÂ¶\n\n`socket()` should include `SOCK_CLOEXEC` in its type argument to avoid the\nfile descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\n    \n    \n    socket(domain, type, SOCK_STREAM);\n    \n    // becomes\n    \n    socket(domain, type, SOCK_STREAM | SOCK_CLOEXEC);",
                "disable": false
            },
            {
                "real_name": "android-comparison-in-temp-failure-retry",
                "display_name": "android-comparison-in-temp-failure-retry",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# android-comparison-in-temp-failure-retryÂ¶\n\nDiagnoses comparisons that appear to be incorrectly placed in the argument to\nthe `TEMP_FAILURE_RETRY` macro. Having such a use is incorrect in the vast\nmajority of cases, and will often silently defeat the purpose of the\n`TEMP_FAILURE_RETRY` macro.\n\nFor context, `TEMP_FAILURE_RETRY` is [a convenience\nmacro](https://www.gnu.org/software/libc/manual/html_node/Interrupted-\nPrimitives.html) provided by both glibc and Bionic. Its purpose is to\nrepeatedly run a syscall until it either succeeds, or fails for reasons other\nthan being interrupted.\n\nExample buggy usage looks like:\n\n    \n    \n    char cs[1];\n    while (TEMP_FAILURE_RETRY(read(STDIN_FILENO, cs, sizeof(cs)) != 0)) {\n      // Do something with cs.\n    }\n    \n\nBecause TEMP_FAILURE_RETRY will check for whether the result _of the\ncomparison_ is `-1`, and retry if so.\n\nIf you encounter this, the fix is simple: lift the comparison out of the\n`TEMP_FAILURE_RETRY` argument, like so:\n\n    \n    \n    char cs[1];\n    while (TEMP_FAILURE_RETRY(read(STDIN_FILENO, cs, sizeof(cs))) != 0) {\n      // Do something with cs.\n    }\n    \n\n## OptionsÂ¶\n\n`RetryMacros```Â¶\n\n    \n\nA comma-separated list of the names of retry macros to be checked.",
                "disable": false
            },
            {
                "real_name": "arm-asm-check",
                "display_name": "arm-asm-check",
                "severity": "warning",
                "category": "usability",
                "rule_title": "检测ASM指令是否适用于ARM64平台。",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "替换成ARM64对应的ASM指令，或者使用C/C++重构实现。",
                "owner": "",
                "labels": [],
                "description": "检测ASM指令是否适用于ARM64平台。",
                "disable": false
            },
            {
                "real_name": "arm-cacheline-align",
                "display_name": "arm-cacheline-align",
                "severity": "warning",
                "category": "performance",
                "rule_title": "检测ARM64下的代码是否Cacheline对齐。",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "建议查询当前处理器的Cacheline大小（getconf LEVEL1_DCACHE_LINESIZE），并修改代码确保数据结构在Cacheline边界上对齐，提高访问速度。",
                "owner": "",
                "labels": [],
                "description": "检测ARM64下的代码是否Cacheline对齐。",
                "disable": false
            },
            {
                "real_name": "boost-use-to-string",
                "display_name": "boost-use-to-string",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# boost-use-to-stringÂ¶\n\nThis check finds conversion from integer type like `int` to `std::string` or\n`std::wstring` using `boost::lexical_cast`, and replace it with calls to\n`std::to_string` and `std::to_wstring`.\n\nIt doesnât replace conversion from floating points despite the `to_string`\noverloads, because it would change the behavior.\n\n    \n    \n    auto str = boost::lexical_cast<std::string>(42);\n    auto wstr = boost::lexical_cast<std::wstring>(2137LL);\n    \n    // Will be changed to\n    auto str = std::to_string(42);\n    auto wstr = std::to_wstring(2137LL);",
                "disable": false
            },
            {
                "real_name": "bugprone-argument-comment",
                "display_name": "bugprone-argument-comment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-argument-commentÂ¶\n\nChecks that argument comments match parameter names.\n\nThe check understands argument comments in the form `/*parameter_name=*/` that\nare placed right before the argument.\n\n    \n    \n    void f(bool foo);\n    \n    ...\n    \n    f(/*bar=*/true);\n    // warning: argument name 'bar' in comment does not match parameter name 'foo'\n    \n\nThe check tries to detect typos and suggest automated fixes for them.\n\n## OptionsÂ¶\n\n`StrictMode```Â¶\n\n    \n\nWhen false (default value), the check will ignore leading and trailing\nunderscores and case when comparing names â otherwise they are taken into\naccount.\n\n`IgnoreSingleArgument```Â¶\n\n    \n\nWhen true, the check will ignore the single argument.\n\n`CommentBoolLiterals```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the boolean literal argument.\n\nBefore:\n\n    \n    \n    void foo(bool TurnKey, bool PressButton);\n    \n    foo(true, false);\n    \n\nAfter:\n\n    \n    \n    void foo(bool TurnKey, bool PressButton);\n    \n    foo(/*TurnKey=*/true, /*PressButton=*/false);\n    \n\n`CommentIntegerLiterals```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the integer literal argument.\n\nBefore:\n\n    \n    \n    void foo(int MeaningOfLife);\n    \n    foo(42);\n    \n\nAfter:\n\n    \n    \n    void foo(int MeaningOfLife);\n    \n    foo(/*MeaningOfLife=*/42);\n    \n\n`CommentFloatLiterals```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the float/double literal argument.\n\nBefore:\n\n    \n    \n    void foo(float Pi);\n    \n    foo(3.14159);\n    \n\nAfter:\n\n    \n    \n    void foo(float Pi);\n    \n    foo(/*Pi=*/3.14159);\n    \n\n`CommentStringLiterals```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the string literal argument.\n\nBefore:\n\n    \n    \n    void foo(const char *String);\n    void foo(const wchar_t *WideString);\n    \n    foo(\"Hello World\");\n    foo(L\"Hello World\");\n    \n\nAfter:\n\n    \n    \n    void foo(const char *String);\n    void foo(const wchar_t *WideString);\n    \n    foo(/*String=*/\"Hello World\");\n    foo(/*WideString=*/L\"Hello World\");\n    \n\n`CommentCharacterLiterals```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the character literal argument.\n\nBefore:\n\n    \n    \n    void foo(char *Character);\n    \n    foo('A');\n    \n\nAfter:\n\n    \n    \n    void foo(char *Character);\n    \n    foo(/*Character=*/'A');\n    \n\n`CommentUserDefinedLiterals```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the user defined literal argument.\n\nBefore:\n\n    \n    \n    void foo(double Distance);\n    \n    double operator\"\" _km(long double);\n    \n    foo(402.0_km);\n    \n\nAfter:\n\n    \n    \n    void foo(double Distance);\n    \n    double operator\"\" _km(long double);\n    \n    foo(/*Distance=*/402.0_km);\n    \n\n`CommentNullPtrs```Â¶\n\n    \n\nWhen true, the check will add argument comments in the format\n`/*ParameterName=*/` right before the nullptr literal argument.\n\nBefore:\n\n    \n    \n    void foo(A* Value);\n    \n    foo(nullptr);\n    \n\nAfter:\n\n    \n    \n    void foo(A* Value);\n    \n    foo(/*Value=*/nullptr);",
                "disable": false
            },
            {
                "real_name": "bugprone-assert-side-effect",
                "display_name": "bugprone-assert-side-effect",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-assert-side-effectÂ¶\n\nFinds `assert()` with side effect.\n\nThe condition of `assert()` is evaluated only in debug builds so a condition\nwith side effect can cause different behavior in debug / release builds.\n\n## OptionsÂ¶\n\n`AssertMacros```Â¶\n\n    \n\nA comma-separated list of the names of assert macros to be checked.\n\n`CheckFunctionCalls```Â¶\n\n    \n\nWhether to treat non-const member and non-member functions as they produce\nside effects. Disabled by default because it can increase the number of false\npositive warnings.\n\n`IgnoredFunctions```Â¶\n\n    \n\nA semicolon-separated list of the names of functions or methods to be\nconsidered as not having side-effects. Regular expressions are accepted, e.g.\n[Rr]ef(erence)?$ matches every type with suffix Ref, ref, Reference and\nreference. The default is empty. If a name in the list contains the sequence\n:: it is matched against the qualified typename (i.e. namespace::Type,\notherwise it is matched against only the type name (i.e. Type).",
                "disable": false
            },
            {
                "real_name": "bugprone-assignment-in-if-condition",
                "display_name": "bugprone-assignment-in-if-condition",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-assignment-in-if-conditionÂ¶\n\nFinds assignments within conditions of if statements. Such assignments are\nbug-prone because they may have been intended as equality tests.\n\nThis check finds all assignments within if conditions, including ones that are\nnot flagged by -Wparentheses due to an extra set of parentheses, and including\nassignments that call an overloaded operator=(). The identified assignments\nviolate [BARR group âRule 8.2.câ](https://barrgroup.com/embedded-\nsystems/books/embedded-c-coding-standard/statement-rules/if-else-statements).\n\n    \n    \n    int f = 3;\n    if(f = 4) { // This is identified by both `Wparentheses` and this check - should it have been: `if (f == 4)` ?\n      f = f + 1;\n    }\n    \n    if((f == 5) || (f = 6)) { // the assignment here `(f = 6)` is identified by this check, but not by `-Wparentheses`. Should it have been `(f == 6)` ?\n      f = f + 2;\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-bad-signal-to-kill-thread",
                "display_name": "bugprone-bad-signal-to-kill-thread",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-bad-signal-to-kill-threadÂ¶\n\nFinds `pthread_kill` function calls when a thread is terminated by raising\n`SIGTERM` signal and the signal kills the entire process, not just the\nindividual thread. Use any signal except `SIGTERM`.\n\nThis check corresponds to the CERT C Coding Standard rule [POS44-C. Do not use\nsignals to terminate\nthreads](https://wiki.sei.cmu.edu/confluence/display/c/POS44-C.+Do+not+use+signals+to+terminate+threads).",
                "disable": false
            },
            {
                "real_name": "bugprone-bool-pointer-implicit-conversion",
                "display_name": "bugprone-bool-pointer-implicit-conversion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-bool-pointer-implicit-conversionÂ¶\n\nChecks for conditions based on implicit conversion from a `bool` pointer to\n`bool`.\n\nExample:\n\n    \n    \n    bool *p;\n    if (p) {\n      // Never used in a pointer-specific way.\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-branch-clone",
                "display_name": "bugprone-branch-clone",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-branch-cloneÂ¶\n\nChecks for repeated branches in `if/else if/else` chains, consecutive repeated\nbranches in `switch` statements and identical true and false branches in\nconditional operators.\n\n    \n    \n    if (test_value(x)) {\n      y++;\n      do_something(x, y);\n    } else {\n      y++;\n      do_something(x, y);\n    }\n    \n\nIn this simple example (which could arise e.g. as a copy-paste error) the\n`then` and `else` branches are identical and the code is equivalent the\nfollowing shorter and cleaner code:\n\n    \n    \n    test_value(x); // can be omitted unless it has side effects\n    y++;\n    do_something(x, y);\n    \n\nIf this is the intended behavior, then there is no reason to use a conditional\nstatement; otherwise the issue can be solved by fixing the branch that is\nhandled incorrectly.\n\nThe check also detects repeated branches in longer `if/else if/else` chains\nwhere it would be even harder to notice the problem.\n\nIn `switch` statements the check only reports repeated branches when they are\nconsecutive, because it is relatively common that the `case:` labels have some\nnatural ordering and rearranging them would decrease the readability of the\ncode. For example:\n\n    \n    \n    switch (ch) {\n    case 'a':\n      return 10;\n    case 'A':\n      return 10;\n    case 'b':\n      return 11;\n    case 'B':\n      return 11;\n    default:\n      return 10;\n    }\n    \n\nHere the check reports that the `'a'` and `'A'` branches are identical (and\nthat the `'b'` and `'B'` branches are also identical), but does not report\nthat the `default:` branch is also identical to the first two branches. If\nthis is indeed the correct behavior, then it could be implemented as:\n\n    \n    \n    switch (ch) {\n    case 'a':\n    case 'A':\n      return 10;\n    case 'b':\n    case 'B':\n      return 11;\n    default:\n      return 10;\n    }\n    \n\nHere the check does not warn for the repeated `return 10;`, which is good if\nwe want to preserve that `'a'` is before `'b'` and `default:` is the last\nbranch.\n\nFinally, the check also examines conditional operators and reports code like:\n\n    \n    \n    return test_value(x) ? x : x;\n    \n\nUnlike if statements, the check does not detect chains of conditional\noperators.\n\nNote: This check also reports situations where branches become identical only\nafter preprocessing.",
                "disable": false
            },
            {
                "real_name": "bugprone-copy-constructor-init",
                "display_name": "bugprone-copy-constructor-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-copy-constructor-initÂ¶\n\nFinds copy constructors where the constructor doesnât call the copy\nconstructor of the base class.\n\n    \n    \n    class Copyable {\n    public:\n      Copyable() = default;\n      Copyable(const Copyable &) = default;\n    };\n    class X2 : public Copyable {\n      X2(const X2 &other) {} // Copyable(other) is missing\n    };\n    \n\nAlso finds copy constructors where the constructor of the base class donât\nhave parameter.\n\n    \n    \n    class X4 : public Copyable {\n      X4(const X4 &other) : Copyable() {} // other is missing\n    };\n    \n\nThe check also suggests a fix-its in some cases.",
                "disable": false
            },
            {
                "real_name": "bugprone-dangling-handle",
                "display_name": "bugprone-dangling-handle",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-dangling-handleÂ¶\n\nDetect dangling references in value handles like `std::string_view`. These\ndangling references can be a result of constructing handles from temporary\nvalues, where the temporary is destroyed soon after the handle is created.\n\nExamples:\n\n    \n    \n    string_view View = string();  // View will dangle.\n    string A;\n    View = A + \"A\";  // still dangle.\n    \n    vector<string_view> V;\n    V.push_back(string());  // V[0] is dangling.\n    V.resize(3, string());  // V[1] and V[2] will also dangle.\n    \n    string_view f() {\n      // All these return values will dangle.\n      return string();\n      string S;\n      return S;\n      char Array[10]{};\n      return Array;\n    }\n    \n\n## OptionsÂ¶\n\n`HandleClasses```Â¶\n\n    \n\nA semicolon-separated list of class names that should be treated as handles.\nBy default only `std::basic_string_view` and\n`std::experimental::basic_string_view` are considered.",
                "disable": false
            },
            {
                "real_name": "bugprone-dynamic-static-initializers",
                "display_name": "bugprone-dynamic-static-initializers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-dynamic-static-initializersÂ¶\n\nFinds instances of static variables that are dynamically initialized in header\nfiles.\n\nThis can pose problems in certain multithreaded contexts. For example, when\ndisabling compiler generated synchronization instructions for static variables\ninitialized at runtime (e.g. by `-fno-threadsafe-statics`), even if a\nparticular project takes the necessary precautions to prevent race conditions\nduring initialization by providing their own synchronization, header files\nincluded from other projects may not. Therefore, such a check is helpful for\nensuring that disabling compiler generated synchronization for static variable\ninitialization will not cause problems.\n\nConsider the following code:\n\n    \n    \n    int foo() {\n      static int k = bar();\n      return k;\n    }\n    \n\nWhen synchronization of static initialization is disabled, if two threads both\ncall foo for the first time, there is the possibility that k will be double\ninitialized, creating a race condition.",
                "disable": false
            },
            {
                "real_name": "bugprone-easily-swappable-parameters",
                "display_name": "bugprone-easily-swappable-parameters",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-easily-swappable-parametersÂ¶\n\nFinds function definitions where parameters of convertible types follow each\nother directly, making call sites prone to calling the function with swapped\n(or badly ordered) arguments.\n\n    \n    \n    void drawPoint(int X, int Y) { /* ... */ }\n    FILE *open(const char *Dir, const char *Name, Flags Mode) { /* ... */ }\n    \n\nA potential call like `drawPoint(-2, 5)` or `openPath(\"a.txt\", \"tmp\", Read)`\nis perfectly legal from the languageâs perspective, but might not be what\nthe developer of the function intended.\n\nMore elaborate and type-safe constructs, such as opaque typedefs or strong\ntypes should be used instead, to prevent a mistaken order of arguments.\n\n    \n    \n    struct Coord2D { int X; int Y; };\n    void drawPoint(const Coord2D Pos) { /* ... */ }\n    \n    FILE *open(const Path &Dir, const Filename &Name, Flags Mode) { /* ... */ }\n    \n\nDue to the potentially elaborate refactoring and API-breaking that is\nnecessary to strengthen the type safety of a project, no automatic fix-its are\noffered.\n\n## OptionsÂ¶\n\n### Extension/relaxation optionsÂ¶\n\nRelaxation (or extension) options can be used to broaden the scope of the\nanalysis and fine-tune the enabling of more mixes between types. Some mixes\nmay depend on coding style or preference specific to a project, however, it\nshould be noted that enabling _all_ of these relaxations model the way of\nmixing at call sites the most. These options are expected to make the check\nreport for more functions, and report longer mixable ranges.\n\n`QualifiersMix```Â¶\n\n    \n\nWhether to consider parameters of some _cvr-qualified_ `T` and a differently\n_cvr-qualified_ `T` (i.e. `T` and `const T`, `const T` and `volatile T`, etc.)\nmixable between one another. If false, the check will consider differently\nqualified types unmixable. True turns the warnings on. Defaults to false.\n\nThe following example produces a diagnostic only if QualifiersMix is enabled:\n\n    \n    \n    void *memcpy(const void *Destination, void *Source, std::size_t N) { /* ... */ }\n    \n\n`ModelImplicitConversions```Â¶\n\n    \n\nWhether to consider parameters of type `T` and `U` mixable if there exists an\nimplicit conversion from `T` to `U` and `U` to `T`. If false, the check will\nnot consider implicitly convertible types for mixability. True turns warnings\nfor implicit conversions on. Defaults to true.\n\nThe following examples produce a diagnostic only if ModelImplicitConversions\nis enabled:\n\n    \n    \n    void fun(int Int, double Double) { /* ... */ }\n    void compare(const char *CharBuf, std::string String) { /* ... */ }\n    \n\nNote\n\nChanging the qualifiers of an expressionâs type (e.g. from `int` to `const\nint`) is defined as an _implicit conversion_ in the C++ Standard. However, the\ncheck separates this decision-making on the mixability of differently\nqualified types based on whether QualifiersMix was enabled.\n\nFor example, the following code snippet will only produce a diagnostic if\n**both** QualifiersMix and ModelImplicitConversions are enabled:\n\n    \n    \n    void fun2(int Int, const double Double) { /* ... */ }\n    \n\n### Filtering optionsÂ¶\n\nFiltering options can be used to lessen the size of the diagnostics emitted by\nthe checker, whether the aim is to ignore certain constructs or dampen the\nnoisiness.\n\n`MinimumLength```Â¶\n\n    \n\nThe minimum length required from an adjacent parameter sequence to be\ndiagnosed. Defaults to 2. Might be any positive integer greater or equal to 2.\nIf 0 or 1 is given, the default value 2 will be used instead.\n\nFor example, if 3 is specified, the examples above will not be matched.\n\n`IgnoredParameterNames```Â¶\n\n    \n\nThe list of parameter **names** that should never be considered part of a\nswappable adjacent parameter sequence. The value is a ;-separated list of\nnames. To ignore unnamed parameters, add ââ to the list verbatim (not the\nempty string, but the two quotes, potentially escaped!). **This option is\ncase-sensitive!**\n\nBy default, the following parameter names, and their Uppercase-initial\nvariants are ignored: ââ (unnamed parameters), iterator, begin, end,\nfirst, last, lhs, rhs.\n\n`IgnoredParameterTypeSuffixes```Â¶\n\n    \n\nThe list of parameter **type name suffixes** that should never be considered\npart of a swappable adjacent parameter sequence. Parameters which type, as\nwritten in the source code, end with an element of this option will be\nignored. The value is a ;-separated list of names. **This option is case-\nsensitive!**\n\nBy default, the following, and their lowercase-initial variants are ignored:\nbool, It, Iterator, InputIt, ForwardIt, BidirIt, RandomIt, random_iterator,\nReverseIt, reverse_iterator, reverse_const_iterator, RandomIt,\nrandom_iterator, ReverseIt, reverse_iterator, reverse_const_iterator,\nConst_Iterator, ConstIterator, const_reverse_iterator, ConstReverseIterator.\nIn addition, _Bool (but not _bool) is also part of the default value.\n\n`SuppressParametersUsedTogether```Â¶\n\n    \n\nSuppresses diagnostics about parameters that are used together or in a similar\nfashion inside the functionâs body. Defaults to true. Specifying false will\nturn off the heuristics.\n\nCurrently, the following heuristics are implemented which will suppress the\nwarning about the parameter pair involved:\n\n  * The parameters are used in the same expression, e.g. `f(a, b)` or `a < b`.\n\n  * The parameters are further passed to the same function to the same parameter of that function, of the same overload. E.g. `f(a, 1)` and `f(b, 2)` to some `f(T, int)`.\n\nNote\n\nThe check does not perform path-sensitive analysis, and as such, âsame\nfunctionâ in this context means the same function declaration. If the same\nmember function of a type on two distinct instances are called with the\nparameters, it will still be regarded as âsame functionâ.\n\n  * The same member field is accessed, or member method is called of the two parameters, e.g. `a.foo()` and `b.foo()`.\n\n  * Separate `return` statements return either of the parameters on different code paths.\n\n`NamePrefixSuffixSilenceDissimilarityTreshold```Â¶\n\n    \n\nThe number of characters two parameter names might be different on _either_\nthe head or the tail end with the rest of the name the same so that the\nwarning about the two parameters are silenced. Defaults to 1. Might be any\npositive integer. If 0, the filtering heuristic based on the parametersâ\nnames is turned off.\n\nThis option can be used to silence warnings about parameters where the naming\nscheme indicates that the order of those parameters do not matter.\n\nFor example, the parameters `LHS` and `RHS` are 1-dissimilar suffixes of each\nother: `L` and `R` is the different character, while `HS` is the common\nsuffix. Similarly, parameters `text1, text2, text3` are 1-dissimilar prefixes\nof each other, with the numbers at the end being the dissimilar part. If the\nvalue is at least 1, such cases will not be reported.\n\n## LimitationsÂ¶\n\n**This check is designed to check function signatures!**\n\nThe check does not investigate functions that are generated by the compiler in\na context that is only determined from a call site. These cases include\nvariadic functions, functions in C code that do not have an argument list, and\nC++ template instantiations. Most of these cases, which are otherwise\nswappable from a callerâs standpoint, have no way of getting âfixedâ at\nthe definition point. In the case of C++ templates, only primary template\ndefinitions and explicit specializations are matched and analyzed.\n\nNone of the following cases produce a diagnostic:\n\n    \n    \n    int printf(const char *Format, ...) { /* ... */ }\n    int someOldCFunction() { /* ... */ }\n    \n    template <typename T, typename U>\n    int add(T X, U Y) { return X + Y };\n    \n    void theseAreNotWarnedAbout() {\n        printf(\"%d %d\\n\", 1, 2);   // Two ints passed, they could be swapped.\n        someOldCFunction(1, 2, 3); // Similarly, multiple ints passed.\n    \n        add(1, 2); // Instantiates 'add<int, int>', but that's not a user-defined function.\n    }\n    \n\nDue to the limitation above, parameters which type are further dependent upon\ntemplate instantiations to _prove_ that they mix with another parameterâs is\nnot diagnosed.\n\n    \n    \n    template <typename T>\n    struct Vector {\n      typedef T element_type;\n    };\n    \n    // Diagnosed: Explicit instantiation was done by the user, we can prove it\n    // is the same type.\n    void instantiated(int A, Vector<int>::element_type B) { /* ... */ }\n    \n    // Diagnosed: The two parameter types are exactly the same.\n    template <typename T>\n    void exact(typename Vector<T>::element_type A,\n               typename Vector<T>::element_type B) { /* ... */ }\n    \n    // Skipped: The two parameters are both 'T' but we cannot prove this\n    // without actually instantiating.\n    template <typename T>\n    void falseNegative(T A, typename Vector<T>::element_type B) { /* ... */ }\n    \n\nIn the context of _implicit conversions_ (when ModelImplicitConversions is\nenabled), the modelling performed by the check warns if the parameters are\nswappable and the swapped order matches implicit conversions. It does not\nmodel whether there exists an unrelated third type from which _both_\nparameters can be given in a function call. This means that in the following\nexample, even while `strs()` clearly carries the possibility to be called with\nswapped arguments (as long as the arguments are string literals), will not be\nwarned about.\n\n    \n    \n    struct String {\n        String(const char *Buf);\n    };\n    \n    struct StringView {\n        StringView(const char *Buf);\n        operator const char *() const;\n    };\n    \n    // Skipped: Directly swapping expressions of the two type cannot mix.\n    // (Note: StringView -> const char * -> String would be **two**\n    // user-defined conversions, which is disallowed by the language.)\n    void strs(String Str, StringView SV) { /* ... */ }\n    \n    // Diagnosed: StringView implicitly converts to and from a buffer.\n    void cStr(StringView SV, const char *Buf() { /* ... */ }",
                "disable": false
            },
            {
                "real_name": "bugprone-exception-escape",
                "display_name": "bugprone-exception-escape",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-exception-escapeÂ¶\n\nFinds functions which may throw an exception directly or indirectly, but they\nshould not. The functions which should not throw exceptions are the following:\n\n  * Destructors\n  * Move constructors\n  * Move assignment operators\n  * The `main()` functions\n  * `swap()` functions\n  * Functions marked with `throw()` or `noexcept`\n  * Other functions given as option\n\nA destructor throwing an exception may result in undefined behavior, resource\nleaks or unexpected termination of the program. Throwing move constructor or\nmove assignment also may result in undefined behavior or resource leak. The\n`swap()` operations expected to be non throwing most of the cases and they are\nalways possible to implement in a non throwing way. Non throwing `swap()`\noperations are also used to create move operations. A throwing `main()`\nfunction also results in unexpected termination.\n\nWARNING! This check may be expensive on large source files.\n\n## OptionsÂ¶\n\n`FunctionsThatShouldNotThrow```Â¶\n\n    \n\nComma separated list containing function names which should not throw. An\nexample value for this parameter can be `WinMain` which adds function\n`WinMain()` in the Windows API to the list of the functions which should not\nthrow. Default value is an empty string.\n\n`IgnoredExceptions```Â¶\n\n    \n\nComma separated list containing type names which are not counted as thrown\nexceptions in the check. Default value is an empty string.",
                "disable": false
            },
            {
                "real_name": "bugprone-fold-init-type",
                "display_name": "bugprone-fold-init-type",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-fold-init-typeÂ¶\n\nThe check flags type mismatches in\n[folds](https://en.wikipedia.org/wiki/Fold_\\(higher-order_function\\)) like\n`std::accumulate` that might result in loss of precision. `std::accumulate`\nfolds an input range into an initial value using the type of the latter, with\n`operator+` by default. This can cause loss of precision through:\n\n  * Truncation: The following code uses a floating point range and an int initial value, so truncation will happen at every application of `operator+` and the result will be 0, which might not be what the user expected.\n\n    \n    \n    auto a = {0.5f, 0.5f, 0.5f, 0.5f};\n    return std::accumulate(std::begin(a), std::end(a), 0);\n    \n\n  * Overflow: The following code also returns 0.\n\n    \n    \n    auto a = {65536LL * 65536 * 65536};\n    return std::accumulate(std::begin(a), std::end(a), 0);",
                "disable": false
            },
            {
                "real_name": "bugprone-forward-declaration-namespace",
                "display_name": "bugprone-forward-declaration-namespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-forward-declaration-namespaceÂ¶\n\nChecks if an unused forward declaration is in a wrong namespace.\n\nThe check inspects all unused forward declarations and checks if there is any\ndeclaration/definition with the same name existing, which could indicate that\nthe forward declaration is in a potentially wrong namespace.\n\n    \n    \n    namespace na { struct A; }\n    namespace nb { struct A {}; }\n    nb::A a;\n    // warning : no definition found for 'A', but a definition with the same name\n    // 'A' found in another namespace 'nb::'\n    \n\nThis check can only generate warnings, but it canât suggest a fix at this\npoint.",
                "disable": false
            },
            {
                "real_name": "bugprone-forwarding-reference-overload",
                "display_name": "bugprone-forwarding-reference-overload",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-forwarding-reference-overloadÂ¶\n\nThe check looks for perfect forwarding constructors that can hide copy or move\nconstructors. If a non const lvalue reference is passed to the constructor,\nthe forwarding reference parameter will be a better match than the const\nreference parameter of the copy constructor, so the perfect forwarding\nconstructor will be called, which can be confusing. For detailed description\nof this issue see: Scott Meyers, Effective Modern C++, Item 26.\n\nConsider the following example:\n\n    \n    \n    class Person {\n    public:\n      // C1: perfect forwarding ctor\n      template<typename T>\n      explicit Person(T&& n) {}\n    \n      // C2: perfect forwarding ctor with parameter default value\n      template<typename T>\n      explicit Person(T&& n, int x = 1) {}\n    \n      // C3: perfect forwarding ctor guarded with enable_if\n      template<typename T, typename X = enable_if_t<is_special<T>, void>>\n      explicit Person(T&& n) {}\n    \n      // C4: variadic perfect forwarding ctor guarded with enable_if\n      template<typename... A,\n        enable_if_t<is_constructible_v<tuple<string, int>, A&&...>, int> = 0>\n      explicit Person(A&&... a) {}\n    \n      // (possibly compiler generated) copy ctor\n      Person(const Person& rhs);\n    };\n    \n\nThe check warns for constructors C1 and C2, because those can hide copy and\nmove constructors. We suppress warnings if the copy and the move constructors\nare both disabled (deleted or private), because there is nothing the perfect\nforwarding constructor could hide in this case. We also suppress warnings for\nconstructors like C3 and C4 that are guarded with an `enable_if`, assuming the\nprogrammer was aware of the possible hiding.\n\n## BackgroundÂ¶\n\nFor deciding whether a constructor is guarded with enable_if, we consider the\ntypes of the constructor parameters, the default values of template type\nparameters and the types of non-type template parameters with a default\nliteral value. If any part of these types is `std::enable_if` or\n`std::enable_if_t`, we assume the constructor is guarded.",
                "disable": false
            },
            {
                "real_name": "bugprone-implicit-widening-of-multiplication-result",
                "display_name": "bugprone-implicit-widening-of-multiplication-result",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-implicit-widening-of-multiplication-resultÂ¶\n\nThe check diagnoses instances where a result of a multiplication is implicitly\nwidened, and suggests (with fix-it) to either silence the code by making\nwidening explicit, or to perform the multiplication in a wider type, to avoid\nthe widening afterwards.\n\nThis is mainly useful when operating on very large buffers. For example,\nconsider:\n\n    \n    \n    void zeroinit(char* base, unsigned width, unsigned height) {\n      for(unsigned row = 0; row != height; ++row) {\n        for(unsigned col = 0; col != width; ++col) {\n          char* ptr = base + row * width + col;\n          *ptr = 0;\n        }\n      }\n    }\n    \n\nThis is fine in general, but if `width * height` overflows, you end up\nwrapping back to the beginning of `base` instead of processing the entire\nrequested buffer.\n\nIndeed, this only matters for pretty large buffers (4GB+), but that can happen\nvery easily for example in image processing, where for that to happen you\nâonlyâ need a ~269MPix image.\n\n## OptionsÂ¶\n\n`UseCXXStaticCastsInCppSources```Â¶\n\n    \n\nWhen suggesting fix-its for C++ code, should C++-style `static_cast<>()`âs\nbe suggested, or C-style casts. Defaults to `true`.\n\n`UseCXXHeadersInCppSources```Â¶\n\n    \n\nWhen suggesting to include the appropriate header in C++ code, should\n`<cstddef>` header be suggested, or `<stddef.h>`. Defaults to `true`.\n\nExamples:\n\n    \n    \n    long mul(int a, int b) {\n      return a * b; // warning: performing an implicit widening conversion to type 'long' of a multiplication performed in type 'int'\n    }\n    \n    char* ptr_add(char *base, int a, int b) {\n      return base + a * b; // warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n    }\n    \n    char ptr_subscript(char *base, int a, int b) {\n      return base[a * b]; // warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-inaccurate-erase",
                "display_name": "bugprone-inaccurate-erase",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-inaccurate-eraseÂ¶\n\nChecks for inaccurate use of the `erase()` method.\n\nAlgorithms like `remove()` do not actually remove any element from the\ncontainer but return an iterator to the first redundant element at the end of\nthe container. These redundant elements must be removed using the `erase()`\nmethod. This check warns when not all of the elements will be removed due to\nusing an inappropriate overload.\n\nFor example, the following code erases only one element:\n\n    \n    \n    std::vector<int> xs;\n    ...\n    xs.erase(std::remove(xs.begin(), xs.end(), 10));\n    \n\nCall the two-argument overload of `erase()` to remove the subrange:\n\n    \n    \n    std::vector<int> xs;\n    ...\n    xs.erase(std::remove(xs.begin(), xs.end(), 10), xs.end());",
                "disable": false
            },
            {
                "real_name": "bugprone-incorrect-roundings",
                "display_name": "bugprone-incorrect-roundings",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-incorrect-roundingsÂ¶\n\nChecks the usage of patterns known to produce incorrect rounding. Programmers\noften use:\n\n    \n    \n    (int)(double_expression + 0.5)\n    \n\nto round the double expression to an integer. The problem with this:\n\n  1. It is unnecessarily slow.\n  2. It is incorrect. The number 0.499999975 (smallest representable float number below 0.5) rounds to 1.0. Even worse behavior for negative numbers where both -0.5f and -1.4f both round to 0.0.",
                "disable": false
            },
            {
                "real_name": "bugprone-infinite-loop",
                "display_name": "bugprone-infinite-loop",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-infinite-loopÂ¶\n\nFinds obvious infinite loops (loops where the condition variable is not\nchanged at all).\n\nFinding infinite loops is well-known to be impossible (halting problem).\nHowever, it is possible to detect some obvious infinite loops, for example, if\nthe loop condition is not changed. This check detects such loops. A loop is\nconsidered infinite if it does not have any loop exit statement (`break`,\n`continue`, `goto`, `return`, `throw` or a call to a function called as\n`[[noreturn]]`) and all of the following conditions hold for every variable in\nthe condition:\n\n  * It is a local variable.\n  * It has no reference or pointer aliases.\n  * It is not a structure or class member.\n\nFurthermore, the condition must not contain a function call to consider the\nloop infinite since functions may return different values for different calls.\n\nFor example, the following loop is considered infinite i is not changed in the\nbody:\n\n    \n    \n    int i = 0, j = 0;\n    while (i < 10) {\n      ++j;\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-integer-division",
                "display_name": "bugprone-integer-division",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-integer-divisionÂ¶\n\nFinds cases where integer division in a floating point context is likely to\ncause unintended loss of precision.\n\nNo reports are made if divisions are part of the following expressions:\n\n  * operands of operators expecting integral or bool types,\n  * call expressions of integral or bool types, and\n  * explicit cast expressions to integral or bool types,\n\nas these are interpreted as signs of deliberateness from the programmer.\n\nExamples:\n\n    \n    \n    float floatFunc(float);\n    int intFunc(int);\n    double d;\n    int i = 42;\n    \n    // Warn, floating-point values expected.\n    d = 32 * 8 / (2 + i);\n    d = 8 * floatFunc(1 + 7 / 2);\n    d = i / (1 << 4);\n    \n    // OK, no integer division.\n    d = 32 * 8.0 / (2 + i);\n    d = 8 * floatFunc(1 + 7.0 / 2);\n    d = (double)i / (1 << 4);\n    \n    // OK, there are signs of deliberateness.\n    d = 1 << (i / 2);\n    d = 9 + intFunc(6 * i / 32);\n    d = (int)(i / 32) - 8;",
                "disable": false
            },
            {
                "real_name": "bugprone-lambda-function-name",
                "display_name": "bugprone-lambda-function-name",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-lambda-function-nameÂ¶\n\nChecks for attempts to get the name of a function from within a lambda\nexpression. The name of a lambda is always something like `operator()`, which\nis almost never what was intended.\n\nExample:\n\n    \n    \n    void FancyFunction() {\n      [] { printf(\"Called from %s\\n\", __func__); }();\n      [] { printf(\"Now called from %s\\n\", __FUNCTION__); }();\n    }\n    \n\nOutput:\n\n    \n    \n    Called from operator()\n    Now called from operator()\n    \n\nLikely intended output:\n\n    \n    \n    Called from FancyFunction\n    Now called from FancyFunction",
                "disable": false
            },
            {
                "real_name": "bugprone-macro-parentheses",
                "display_name": "bugprone-macro-parentheses",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-macro-parenthesesÂ¶\n\nFinds macros that can have unexpected behavior due to missing parentheses.\n\nMacros are expanded by the preprocessor as-is. As a result, there can be\nunexpected behavior; operators may be evaluated in unexpected order and unary\noperators may become binary operators, etc.\n\nWhen the replacement list has an expression, it is recommended to surround it\nwith parentheses. This ensures that the macro result is evaluated completely\nbefore it is used.\n\nIt is also recommended to surround macro arguments in the replacement list\nwith parentheses. This ensures that the argument value is calculated properly.",
                "disable": false
            },
            {
                "real_name": "bugprone-macro-repeated-side-effects",
                "display_name": "bugprone-macro-repeated-side-effects",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-macro-repeated-side-effectsÂ¶\n\nChecks for repeated argument with side effects in macros.",
                "disable": false
            },
            {
                "real_name": "bugprone-misplaced-operator-in-strlen-in-alloc",
                "display_name": "bugprone-misplaced-operator-in-strlen-in-alloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-misplaced-operator-in-strlen-in-allocÂ¶\n\nFinds cases where `1` is added to the string in the argument to `strlen()`,\n`strnlen()`, `strnlen_s()`, `wcslen()`, `wcsnlen()`, and `wcsnlen_s()` instead\nof the result and the value is used as an argument to a memory allocation\nfunction (`malloc()`, `calloc()`, `realloc()`, `alloca()`) or the `new[]`\noperator in C++. The check detects error cases even if one of these functions\n(except the `new[]` operator) is called by a constant function pointer. Cases\nwhere `1` is added both to the parameter and the result of the `strlen()`-like\nfunction are ignored, as are cases where the whole addition is surrounded by\nextra parentheses.\n\nC example code:\n\n    \n    \n    void bad_malloc(char *str) {\n      char *c = (char*) malloc(strlen(str + 1));\n    }\n    \n\nThe suggested fix is to add `1` to the return value of `strlen()` and not to\nits argument. In the example above the fix would be\n\n    \n    \n    char *c = (char*) malloc(strlen(str) + 1);\n    \n\nC++ example code:\n\n    \n    \n    void bad_new(char *str) {\n      char *c = new char[strlen(str + 1)];\n    }\n    \n\nAs in the C code with the `malloc()` function, the suggested fix is to add `1`\nto the return value of `strlen()` and not to its argument. In the example\nabove the fix would be\n\n    \n    \n    char *c = new char[strlen(str) + 1];\n    \n\nExample for silencing the diagnostic:\n\n    \n    \n    void bad_malloc(char *str) {\n      char *c = (char*) malloc(strlen((str + 1)));\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-misplaced-pointer-arithmetic-in-alloc",
                "display_name": "bugprone-misplaced-pointer-arithmetic-in-alloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-misplaced-pointer-arithmetic-in-allocÂ¶\n\nFinds cases where an integer expression is added to or subtracted from the\nresult of a memory allocation function (`malloc()`, `calloc()`, `realloc()`,\n`alloca()`) instead of its argument. The check detects error cases even if one\nof these functions is called by a constant function pointer.\n\nExample code:\n\n    \n    \n    void bad_malloc(int n) {\n      char *p = (char*) malloc(n) + 10;\n    }\n    \n\nThe suggested fix is to add the integer expression to the argument of `malloc`\nand not to its result. In the example above the fix would be\n\n    \n    \n    char *p = (char*) malloc(n + 10);",
                "disable": false
            },
            {
                "real_name": "bugprone-misplaced-widening-cast",
                "display_name": "bugprone-misplaced-widening-cast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-misplaced-widening-castÂ¶\n\nThis check will warn when there is a cast of a calculation result to a bigger\ntype. If the intention of the cast is to avoid loss of precision then the cast\nis misplaced, and there can be loss of precision. Otherwise the cast is\nineffective.\n\nExample code:\n\n    \n    \n    long f(int x) {\n        return (long)(x * 1000);\n    }\n    \n\nThe result `x * 1000` is first calculated using `int` precision. If the result\nexceeds `int` precision there is loss of precision. Then the result is casted\nto `long`.\n\nIf there is no loss of precision then the cast can be removed or you can\nexplicitly cast to `int` instead.\n\nIf you want to avoid loss of precision then put the cast in a proper location,\nfor instance:\n\n    \n    \n    long f(int x) {\n        return (long)x * 1000;\n    }\n    \n\n## Implicit castsÂ¶\n\nForgetting to place the cast at all is at least as dangerous and at least as\ncommon as misplacing it. If `CheckImplicitCasts` is enabled the check also\ndetects these cases, for instance:\n\n    \n    \n    long f(int x) {\n        return x * 1000;\n    }\n    \n\n## Floating pointÂ¶\n\nCurrently warnings are only written for integer conversion. No warning is\nwritten for this code:\n\n    \n    \n    double f(float x) {\n        return (double)(x * 10.0f);\n    }\n    \n\n## OptionsÂ¶\n\n`CheckImplicitCasts```Â¶\n\n    \n\nIf true, enables detection of implicit casts. Default is false.",
                "disable": false
            },
            {
                "real_name": "bugprone-move-forwarding-reference",
                "display_name": "bugprone-move-forwarding-reference",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-move-forwarding-referenceÂ¶\n\nWarns if `std::move` is called on a forwarding reference, for example:\n\n    \n    \n    template <typename T>\n    void foo(T&& t) {\n      bar(std::move(t));\n    }\n    \n\n[Forwarding references](http://www.open-\nstd.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf) should typically be passed\nto `std::forward` instead of `std::move`, and this is the fix that will be\nsuggested.\n\n(A forwarding reference is an rvalue reference of a type that is a deduced\nfunction template argument.)\n\nIn this example, the suggested fix would be\n\n    \n    \n    bar(std::forward<T>(t));\n    \n\n## BackgroundÂ¶\n\nCode like the example above is sometimes written with the expectation that\n`T&&` will always end up being an rvalue reference, no matter what type is\ndeduced for `T`, and that it is therefore not possible to pass an lvalue to\n`foo()`. However, this is not true. Consider this example:\n\n    \n    \n    std::string s = \"Hello, world\";\n    foo(s);\n    \n\nThis code compiles and, after the call to `foo()`, `s` is left in an\nindeterminate state because it has been moved from. This may be surprising to\nthe caller of `foo()` because no `std::move` was used when calling `foo()`.\n\nThe reason for this behavior lies in the special rule for template argument\ndeduction on function templates like `foo()` â i.e. on function templates\nthat take an rvalue reference argument of a type that is a deduced function\ntemplate argument. (See section [temp.deduct.call]/3 in the C++11 standard.)\n\nIf `foo()` is called on an lvalue (as in the example above), then `T` is\ndeduced to be an lvalue reference. In the example, `T` is deduced to be\n`std::string &`. The type of the argument `t` therefore becomes `std::string&\n&&`; by the reference collapsing rules, this collapses to `std::string&`.\n\nThis means that the `foo(s)` call passes `s` as an lvalue reference, and\n`foo()` ends up moving `s` and thereby placing it into an indeterminate state.",
                "disable": false
            },
            {
                "real_name": "bugprone-multiple-statement-macro",
                "display_name": "bugprone-multiple-statement-macro",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-multiple-statement-macroÂ¶\n\nDetect multiple statement macros that are used in unbraced conditionals. Only\nthe first statement of the macro will be inside the conditional and the other\nones will be executed unconditionally.\n\nExample:\n\n    \n    \n    #define INCREMENT_TWO(x, y) (x)++; (y)++\n    if (do_increment)\n      INCREMENT_TWO(a, b);  // (b)++ will be executed unconditionally.",
                "disable": false
            },
            {
                "real_name": "bugprone-narrowing-conversions",
                "display_name": "bugprone-narrowing-conversions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-narrowing-conversionsÂ¶\n\nThe bugprone-narrowing-conversions check is an alias, please see\n[cppcoreguidelines-narrowing-conversions](../cppcoreguidelines/narrowing-\nconversions.html) for more information.",
                "disable": false
            },
            {
                "real_name": "bugprone-no-escape",
                "display_name": "bugprone-no-escape",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-no-escapeÂ¶\n\nFinds pointers with the `noescape` attribute that are captured by an\nasynchronously-executed block. The block arguments in `dispatch_async()` and\n`dispatch_after()` are guaranteed to escape, so it is an error if a pointer\nwith the `noescape` attribute is captured by one of these blocks.\n\nThe following is an example of an invalid use of the `noescape` attribute.\n\n>\n>     void foo(__attribute__((noescape)) int *p) {\n>       dispatch_async(queue, ^{\n>         *p = 123;\n>       });\n>     });\n>",
                "disable": false
            },
            {
                "real_name": "bugprone-not-null-terminated-result",
                "display_name": "bugprone-not-null-terminated-result",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-not-null-terminated-resultÂ¶\n\nFinds function calls where it is possible to cause a not null-terminated\nresult. Usually the proper length of a string is `strlen(src) + 1` or equal\nlength of this expression, because the null terminator needs an extra space.\nWithout the null terminator it can result in undefined behavior when the\nstring is read.\n\nThe following and their respective `wchar_t` based functions are checked:\n\n`memcpy`, `memcpy_s`, `memchr`, `memmove`, `memmove_s`, `strerror_s`,\n`strncmp`, `strxfrm`\n\nThe following is a real-world example where the programmer forgot to increase\nthe passed third argument, which is `size_t length`. That is why the length of\nthe allocated memory is not enough to hold the null terminator.\n\n    \n    \n    static char *stringCpy(const std::string &str) {\n      char *result = reinterpret_cast<char *>(malloc(str.size()));\n      memcpy(result, str.data(), str.size());\n      return result;\n    }\n    \n\nIn addition to issuing warnings, fix-it rewrites all the necessary code. It\nalso tries to adjust the capacity of the destination array:\n\n    \n    \n    static char *stringCpy(const std::string &str) {\n      char *result = reinterpret_cast<char *>(malloc(str.size() + 1));\n      strcpy(result, str.data());\n      return result;\n    }\n    \n\nNote: It cannot guarantee to rewrite every of the path-sensitive memory\nallocations.\n\n## Transformation rules of âmemcpy()âÂ¶\n\nIt is possible to rewrite the `memcpy()` and `memcpy_s()` calls as the\nfollowing four functions: `strcpy()`, `strncpy()`, `strcpy_s()`,\n`strncpy_s()`, where the latter two are the safer versions of the former two.\nIt rewrites the `wchar_t` based memory handler functions respectively.\n\n### Rewrite based on the destination arrayÂ¶\n\n  * If copy to the destination array cannot overflow [1] the new function should be the older copy function (ending with `cpy`), because it is more efficient than the safe version.\n  * If copy to the destination array can overflow [1] and `WantToUseSafeFunctions` is set to true and it is possible to obtain the capacity of the destination array then the new function could be the safe version (ending with `cpy_s`).\n  * If the new function is could be safe version and C++ files are analyzed and the destination array is plain `char`/`wchar_t` without `un/signed` then the length of the destination array can be omitted.\n  * If the new function is could be safe version and the destination array is `un/signed` it needs to be casted to plain `char *`/`wchar_t *`.\n\n[1] It is possible to overflow:\n\n    \n\n  * If the capacity of the destination array is unknown.\n  * If the given length is equal to the destination arrayâs capacity.\n\n### Rewrite based on the length of the source stringÂ¶\n\n  * If the given length is `strlen(source)` or equal length of this expression then the new function should be the older copy function (ending with `cpy`), as it is more efficient than the safe version (ending with `cpy_s`).\n  * Otherwise we assume that the programmer wanted to copy âNâ characters, so the new function is `ncpy`-like which copies âNâ characters.\n\n## Transformations with âstrlen()â or equal length of this expressionÂ¶\n\nIt transforms the `wchar_t` based memory and string handler functions\nrespectively (where only `strerror_s` does not have `wchar_t` based alias).\n\n### Memory handler functionsÂ¶\n\n`memcpy` Please visit the Transformation rules of âmemcpy()â section.\n\n`memchr` Usually there is a C-style cast and it is needed to be removed,\nbecause the new function `strchr`âs return type is correct. The given length\nis going to be removed.\n\n`memmove` If safe functions are available the new function is `memmove_s`,\nwhich has a new second argument which is the length of the destination array,\nit is adjusted, and the length of the source string is incremented by one. If\nsafe functions are not available the given length is incremented by one.\n\n`memmove_s` The given length is incremented by one.\n\n### String handler functionsÂ¶\n\n`strerror_s` The given length is incremented by one.\n\n`strncmp` If the third argument is the first or the second argumentâs\n`length + 1` it has to be truncated without the `+ 1` operation.\n\n`strxfrm` The given length is incremented by one.\n\n## OptionsÂ¶\n\n`WantToUseSafeFunctions```Â¶\n\n    \n\nThe value true specifies that the target environment is considered to\nimplement â_sâ suffixed memory and string handler functions which are\nsafer than older versions (e.g. âmemcpy_s()â). The default value is true.",
                "disable": false
            },
            {
                "real_name": "bugprone-parent-virtual-call",
                "display_name": "bugprone-parent-virtual-call",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-parent-virtual-callÂ¶\n\nDetects and fixes calls to grand-â¦parent virtual methods instead of calls to\noverridden parentâs virtual methods.\n\n    \n    \n    struct A {\n      int virtual foo() {...}\n    };\n    \n    struct B: public A {\n      int foo() override {...}\n    };\n    \n    struct C: public B {\n      int foo() override { A::foo(); }\n    //                     ^^^^^^^^\n    // warning: qualified name A::foo refers to a member overridden in subclass; did you mean 'B'?  [bugprone-parent-virtual-call]\n    };",
                "disable": false
            },
            {
                "real_name": "bugprone-posix-return",
                "display_name": "bugprone-posix-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-posix-returnÂ¶\n\nChecks if any calls to `pthread_*` or `posix_*` functions (except\n`posix_openpt`) expect negative return values. These functions return either\n`0` on success or an `errno` on failure, which is positive only.\n\nExample buggy usage looks like:\n\n    \n    \n    if (posix_fadvise(...) < 0) {\n    \n\nThis will never happen as the return value is always non-negative. A simple\nfix could be:\n\n    \n    \n    if (posix_fadvise(...) > 0) {",
                "disable": false
            },
            {
                "real_name": "bugprone-redundant-branch-condition",
                "display_name": "bugprone-redundant-branch-condition",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-redundant-branch-conditionÂ¶\n\nFinds condition variables in nested `if` statements that were also checked in\nthe outer `if` statement and were not changed.\n\nSimple example:\n\n    \n    \n    bool onFire = isBurning();\n    if (onFire) {\n      if (onFire)\n        scream();\n    }\n    \n\nHere onFire is checked both in the outer `if` and the inner `if` statement\nwithout a possible change between the two checks. The check warns for this\ncode and suggests removal of the second checking of variable onFire.\n\nThe checker also detects redundant condition checks if the condition variable\nis an operand of a logical âandâ (`&&`) or a logical âorâ (`||`)\noperator:\n\n    \n    \n    bool onFire = isBurning();\n    if (onFire) {\n      if (onFire && peopleInTheBuilding > 0)\n        scream();\n    }\n    \n    \n    \n    bool onFire = isBurning();\n    if (onFire) {\n      if (onFire || isCollapsing())\n        scream();\n    }\n    \n\nIn the first case (logical âandâ) the suggested fix is to remove the\nredundant condition variable and keep the other side of the `&&`. In the\nsecond case (logical âorâ) the whole `if` is removed similarly to the\nsimple case on the top.\n\nThe condition of the outer `if` statement may also be a logical âandâ\n(`&&`) expression:\n\n    \n    \n    bool onFire = isBurning();\n    if (onFire && fireFighters < 10) {\n      if (someOtherCondition()) {\n        if (onFire)\n          scream();\n      }\n    }\n    \n\nThe error is also detected if both the outer statement is a logical âandâ\n(`&&`) and the inner statement is a logical âandâ (`&&`) or âorâ\n(`||`). The inner `if` statement does not have to be a direct descendant of\nthe outer one.\n\nNo error is detected if the condition variable may have been changed between\nthe two checks:\n\n    \n    \n    bool onFire = isBurning();\n    if (onFire) {\n      tryToExtinguish(onFire);\n      if (onFire && peopleInTheBuilding > 0)\n        scream();\n    }\n    \n\nEvery possible change is considered, thus if the condition variable is not a\nlocal variable of the function, it is a volatile or it has an alias (pointer\nor reference) then no warning is issued.\n\n## Known limitationsÂ¶\n\nThe `else` branch is not checked currently for negated condition variable:\n\n    \n    \n    bool onFire = isBurning();\n    if (onFire) {\n      scream();\n    } else {\n      if (!onFire) {\n        continueWork();\n      }\n    }\n    \n\nThe checker currently only detects redundant checking of single condition\nvariables. More complex expressions are not checked:\n\n    \n    \n    if (peopleInTheBuilding == 1) {\n      if (peopleInTheBuilding == 1) {\n        doSomething();\n      }\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-reserved-identifier",
                "display_name": "bugprone-reserved-identifier",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-reserved-identifierÂ¶\n\ncert-dcl37-c and cert-dcl51-cpp redirect here as an alias for this check.\n\nChecks for usages of identifiers reserved for use by the implementation.\n\nThe C and C++ standards both reserve the following names for such use:\n\n  * identifiers that begin with an underscore followed by an uppercase letter;\n  * identifiers in the global namespace that begin with an underscore.\n\nThe C standard additionally reserves names beginning with a double underscore,\nwhile the C++ standard strengthens this to reserve names with a double\nunderscore occurring anywhere.\n\nViolating the naming rules above results in undefined behavior.\n\n    \n    \n    namespace NS {\n      void __f(); // name is not allowed in user code\n      using _Int = int; // same with this\n      #define cool__macro // also this\n    }\n    int _g(); // disallowed in global namespace only\n    \n\nThe check can also be inverted, i.e. it can be configured to flag any\nidentifier that is _not_ a reserved identifier. This mode is for use by e.g.\nstandard library implementors, to ensure they donât infringe on the user\nnamespace.\n\nThis check does not (yet) check for other reserved names, e.g. macro names\nidentical to language keywords, and names specifically reserved by language\nstandards, e.g. C++ âzombie namesâ and C future library directions.\n\nThis check corresponds to CERT C Coding Standard rule [DCL37-C. Do not declare\nor define a reserved\nidentifier](https://wiki.sei.cmu.edu/confluence/display/c/DCL37-C.+Do+not+declare+or+define+a+reserved+identifier)\nas well as its C++ counterpart, [DCL51-CPP. Do not declare or define a\nreserved\nidentifier](https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL51-CPP.+Do+not+declare+or+define+a+reserved+identifier).\n\n## OptionsÂ¶\n\n`Invert```Â¶\n\n    \n\nIf true, inverts the check, i.e. flags names that are not reserved. Default is\nfalse.\n\n`AllowedIdentifiers```Â¶\n\n    \n\nSemicolon-separated list of names that the check ignores. Default is an empty\nlist.",
                "disable": false
            },
            {
                "real_name": "bugprone-shared-ptr-array-mismatch",
                "display_name": "bugprone-shared-ptr-array-mismatch",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-shared-ptr-array-mismatchÂ¶\n\nFinds initializations of C++ shared pointers to non-array type that are\ninitialized with an array.\n\nIf a shared pointer `std::shared_ptr<T>` is initialized with a new-expression\n`new T[]` the memory is not deallocated correctly. The pointer uses plain\n`delete` in this case to deallocate the target memory. Instead a `delete[]`\ncall is needed. A `std::shared_ptr<T[]>` calls the correct delete operator.\n\nThe check offers replacement of `shared_ptr<T>` to `shared_ptr<T[]>` if it is\nused at a single variable declaration (one variable in one statement).\n\nExample:\n\n    \n    \n    std::shared_ptr<Foo> x(new Foo[10]); // -> std::shared_ptr<Foo[]> x(new Foo[10]);\n    //                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n    std::shared_ptr<Foo> x1(new Foo), x2(new Foo[10]); // no replacement\n    //                                   ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n    \n    std::shared_ptr<Foo> x3(new Foo[10], [](const Foo *ptr) { delete[] ptr; }); // no warning\n    \n    struct S {\n      std::shared_ptr<Foo> x(new Foo[10]); // no replacement in this case\n      //                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n    };\n    \n\nThis check partially covers the CERT C++ Coding Standard rule [MEM51-CPP.\nProperly deallocate dynamically allocated\nresources](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM51-CPP.+Properly+deallocate+dynamically+allocated+resources)\nHowever, only the `std::shared_ptr` case is detected by this check.",
                "disable": false
            },
            {
                "real_name": "bugprone-signal-handler",
                "display_name": "bugprone-signal-handler",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-signal-handlerÂ¶\n\nFinds functions registered as signal handlers that call non asynchronous-safe\nfunctions. Any function that cannot be determined to be an asynchronous-safe\nfunction call is assumed to be non-asynchronous-safe by the checker, including\nuser functions for which only the declaration is visible. User function calls\nwith visible definition are checked recursively. The check handles only C\ncode. Only the function names are considered and the fact that the function is\na system-call, but no other restrictions on the arguments passed to the\nfunctions (the `signal` call is allowed without restrictions).\n\nThis check corresponds to the CERT C Coding Standard rule [SIG30-C. Call only\nasynchronous-safe functions within signal\nhandlers](https://www.securecoding.cert.org/confluence/display/c/SIG30-C.+Call+only+asynchronous-\nsafe+functions+within+signal+handlers) and has an alias name `cert-sig30-c`.\n\n`AsyncSafeFunctionSet```Â¶\n\n    \n\nSelects which set of functions is considered as asynchronous-safe (and\ntherefore allowed in signal handlers). Value `minimal` selects a minimal set\nthat is defined in the CERT SIG30-C rule and includes functions `abort()`,\n`_Exit()`, `quick_exit()` and `signal()`. Value `POSIX` selects a larger set\nof functions that is listed in POSIX.1-2017 (see [this\nlink](https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03)\nfor more information). The function `quick_exit` is not included in the shown\nlist. It is assumable that the reason is that the list was not updated for\nC11. The checker includes `quick_exit` in the set of safe functions. Functions\nregistered as exit handlers are not checked.\n\nDefault is `POSIX`.",
                "disable": false
            },
            {
                "real_name": "bugprone-signed-char-misuse",
                "display_name": "bugprone-signed-char-misuse",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-signed-char-misuseÂ¶\n\ncert-str34-c redirects here as an alias for this check. For the CERT alias,\nthe DiagnoseSignedUnsignedCharComparisons option is set to false.\n\nFinds those `signed char` -> integer conversions which might indicate a\nprogramming error. The basic problem with the `signed char`, that it might\nstore the non-ASCII characters as negative values. This behavior can cause a\nmisunderstanding of the written code both when an explicit and when an\nimplicit conversion happens.\n\nWhen the code contains an explicit `signed char` -> integer conversion, the\nhuman programmer probably expects that the converted value matches with the\ncharacter code (a value from [0..255]), however, the actual value is in\n[-128..127] interval. To avoid this kind of misinterpretation, the desired way\nof converting from a `signed char` to an integer value is converting to\n`unsigned char` first, which stores all the characters in the positive\n[0..255] interval which matches the known character codes.\n\nIn case of implicit conversion, the programmer might not actually be aware\nthat a conversion happened and char value is used as an integer. There are\nsome use cases when this unawareness might lead to a functionally imperfect\ncode. For example, checking the equality of a `signed char` and an `unsigned\nchar` variable is something we should avoid in C++ code. During this\ncomparison, the two variables are converted to integers which have different\nvalue ranges. For `signed char`, the non-ASCII characters are stored as a\nvalue in [-128..-1] interval, while the same characters are stored in the\n[128..255] interval for an `unsigned char`.\n\nIt depends on the actual platform whether plain `char` is handled as `signed\nchar` by default and so it is caught by this check or not. To change the\ndefault behavior you can use `-funsigned-char` and `-fsigned-char` compilation\noptions.\n\nCurrently, this check warns in the following cases: \\- `signed char` is\nassigned to an integer variable \\- `signed char` and `unsigned char` are\ncompared with equality/inequality operator \\- `signed char` is converted to an\ninteger in the array subscript\n\nSee also: [STR34-C. Cast characters to unsigned char before converting to\nlarger integer\nsizes](https://wiki.sei.cmu.edu/confluence/display/c/STR34-C.+Cast+characters+to+unsigned+char+before+converting+to+larger+integer+sizes)\n\nA good example from the CERT description when a `char` variable is used to\nread from a file that might contain non-ASCII characters. The problem comes up\nwhen the code uses the `-1` integer value as EOF, while the 255 character code\nis also stored as `-1` in twoâs complement form of char type. See a simple\nexample of this below. This code stops not only when it reaches the end of the\nfile, but also when it gets a character with the 255 code.\n\n    \n    \n    #define EOF (-1)\n    \n    int read(void) {\n      char CChar;\n      int IChar = EOF;\n    \n      if (readChar(CChar)) {\n        IChar = CChar;\n      }\n      return IChar;\n    }\n    \n\nA proper way to fix the code above is converting the `char` variable to an\n`unsigned char` value first.\n\n    \n    \n    #define EOF (-1)\n    \n    int read(void) {\n      char CChar;\n      int IChar = EOF;\n    \n      if (readChar(CChar)) {\n        IChar = static_cast<unsigned char>(CChar);\n      }\n      return IChar;\n    }\n    \n\nAnother use case is checking the equality of two `char` variables with\ndifferent signedness. Inside the non-ASCII value range this comparison between\na `signed char` and an `unsigned char` always returns `false`.\n\n    \n    \n    bool compare(signed char SChar, unsigned char USChar) {\n      if (SChar == USChar)\n        return true;\n      return false;\n    }\n    \n\nThe easiest way to fix this kind of comparison is casting one of the\narguments, so both arguments will have the same type.\n\n    \n    \n    bool compare(signed char SChar, unsigned char USChar) {\n      if (static_cast<unsigned char>(SChar) == USChar)\n        return true;\n      return false;\n    }\n    \n\n`CharTypdefsToIgnore```Â¶\n\n    \n\nA semicolon-separated list of typedef names. In this list, we can list\ntypedefs for `char` or `signed char`, which will be ignored by the check. This\nis useful when a typedef introduces an integer alias like `sal_Int8` or\n`int8_t`. In this case, human misinterpretation is not an issue.\n\n`DiagnoseSignedUnsignedCharComparisons```Â¶\n\n    \n\nWhen true, the check will warn on `signed char`/`unsigned char` comparisons,\notherwise these comparisons are ignored. By default, this option is set to\ntrue.",
                "disable": false
            },
            {
                "real_name": "bugprone-sizeof-container",
                "display_name": "bugprone-sizeof-container",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-sizeof-containerÂ¶\n\nThe check finds usages of `sizeof` on expressions of STL container types. Most\nlikely the user wanted to use `.size()` instead.\n\nAll class/struct types declared in namespace `std::` having a const `size()`\nmethod are considered containers, with the exception of `std::bitset` and\n`std::array`.\n\nExamples:\n\n    \n    \n    std::string s;\n    int a = 47 + sizeof(s); // warning: sizeof() doesn't return the size of the container. Did you mean .size()?\n    \n    int b = sizeof(std::string); // no warning, probably intended.\n    \n    std::string array_of_strings[10];\n    int c = sizeof(array_of_strings) / sizeof(array_of_strings[0]); // no warning, definitely intended.\n    \n    std::array<int, 3> std_array;\n    int d = sizeof(std_array); // no warning, probably intended.",
                "disable": false
            },
            {
                "real_name": "bugprone-sizeof-expression",
                "display_name": "bugprone-sizeof-expression",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-sizeof-expressionÂ¶\n\nThe check finds usages of `sizeof` expressions which are most likely errors.\n\nThe `sizeof` operator yields the size (in bytes) of its operand, which may be\nan expression or the parenthesized name of a type. Misuse of this operator may\nbe leading to errors and possible software vulnerabilities.\n\n## Suspicious usage of âsizeof(K)âÂ¶\n\nA common mistake is to query the `sizeof` of an integer literal. This is\nequivalent to query the size of its type (probably `int`). The intent of the\nprogrammer was probably to simply get the integer and not its size.\n\n    \n    \n    #define BUFLEN 42\n    char buf[BUFLEN];\n    memset(buf, 0, sizeof(BUFLEN));  // sizeof(42) ==> sizeof(int)\n    \n\n## Suspicious usage of âsizeof(expr)âÂ¶\n\nIn cases, where there is an enum or integer to represent a type, a common\nmistake is to query the `sizeof` on the integer or enum that represents the\ntype that should be used by `sizeof`. This results in the size of the integer\nand not of the type the integer represents:\n\n    \n    \n    enum data_type {\n      FLOAT_TYPE,\n      DOUBLE_TYPE\n    };\n    \n    struct data {\n      data_type type;\n      void* buffer;\n      data_type get_type() {\n        return type;\n      }\n    };\n    \n    void f(data d, int numElements) {\n      // should be sizeof(float) or sizeof(double), depending on d.get_type()\n      int numBytes = numElements * sizeof(d.get_type());\n      ...\n    }\n    \n\n## Suspicious usage of âsizeof(this)âÂ¶\n\nThe `this` keyword is evaluated to a pointer to an object of a given type. The\nexpression `sizeof(this)` is returning the size of a pointer. The programmer\nmost likely wanted the size of the object and not the size of the pointer.\n\n    \n    \n    class Point {\n      [...]\n      size_t size() { return sizeof(this); }  // should probably be sizeof(*this)\n      [...]\n    };\n    \n\n## Suspicious usage of âsizeof(char*)âÂ¶\n\nThere is a subtle difference between declaring a string literal with `char* A\n= \"\"` and `char A[] = \"\"`. The first case has the type `char*` instead of the\naggregate type `char[]`. Using `sizeof` on an object declared with `char*`\ntype is returning the size of a pointer instead of the number of characters\n(bytes) in the string literal.\n\n    \n    \n    const char* kMessage = \"Hello World!\";      // const char kMessage[] = \"...\";\n    void getMessage(char* buf) {\n      memcpy(buf, kMessage, sizeof(kMessage));  // sizeof(char*)\n    }\n    \n\n## Suspicious usage of âsizeof(A*)âÂ¶\n\nA common mistake is to compute the size of a pointer instead of its pointee.\nThese cases may occur because of explicit cast or implicit conversion.\n\n    \n    \n    int A[10];\n    memset(A, 0, sizeof(A + 0));\n    \n    struct Point point;\n    memset(point, 0, sizeof(&point));\n    \n\n## Suspicious usage of âsizeof(â¦)/sizeof(â¦)âÂ¶\n\nDividing `sizeof` expressions is typically used to retrieve the number of\nelements of an aggregate. This check warns on incompatible or suspicious\ncases.\n\nIn the following example, the entity has 10-bytes and is incompatible with the\ntype `int` which has 4 bytes.\n\n    \n    \n    char buf[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };  // sizeof(buf) => 10\n    void getMessage(char* dst) {\n      memcpy(dst, buf, sizeof(buf) / sizeof(int));  // sizeof(int) => 4  [incompatible sizes]\n    }\n    \n\nIn the following example, the expression `sizeof(Values)` is returning the\nsize of `char*`. One can easily be fooled by its declaration, but in parameter\ndeclaration the size â10â is ignored and the function is receiving a\n`char*`.\n\n    \n    \n    char OrderedValues[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    return CompareArray(char Values[10]) {\n      return memcmp(OrderedValues, Values, sizeof(Values)) == 0;  // sizeof(Values) ==> sizeof(char*) [implicit cast to char*]\n    }\n    \n\n## Suspicious âsizeofâ by âsizeofâ expressionÂ¶\n\nMultiplying `sizeof` expressions typically makes no sense and is probably a\nlogic error. In the following example, the programmer used `*` instead of `/`.\n\n    \n    \n    const char kMessage[] = \"Hello World!\";\n    void getMessage(char* buf) {\n      memcpy(buf, kMessage, sizeof(kMessage) * sizeof(char));  //  sizeof(kMessage) / sizeof(char)\n    }\n    \n\nThis check may trigger on code using the arraysize macro. The following code\nis working correctly but should be simplified by using only the `sizeof`\noperator.\n\n    \n    \n    extern Object objects[100];\n    void InitializeObjects() {\n      memset(objects, 0, arraysize(objects) * sizeof(Object));  // sizeof(objects)\n    }\n    \n\n## Suspicious usage of âsizeof(sizeof(â¦))âÂ¶\n\nGetting the `sizeof` of a `sizeof` makes no sense and is typically an error\nhidden through macros.\n\n    \n    \n    #define INT_SZ sizeof(int)\n    int buf[] = { 42 };\n    void getInt(int* dst) {\n      memcpy(dst, buf, sizeof(INT_SZ));  // sizeof(sizeof(int)) is suspicious.\n    }\n    \n\n## OptionsÂ¶\n\n`WarnOnSizeOfConstant```Â¶\n\n    \n\nWhen true, the check will warn on an expression like `sizeof(CONSTANT)`.\nDefault is true.\n\n`WarnOnSizeOfIntegerExpression```Â¶\n\n    \n\nWhen true, the check will warn on an expression like `sizeof(expr)` where the\nexpression results in an integer. Default is false.\n\n`WarnOnSizeOfThis```Â¶\n\n    \n\nWhen true, the check will warn on an expression like `sizeof(this)`. Default\nis true.\n\n`WarnOnSizeOfCompareToConstant```Â¶\n\n    \n\nWhen true, the check will warn on an expression like `sizeof(expr) <= k` for a\nsuspicious constant k while k is 0 or greater than 0x8000. Default is true.",
                "disable": false
            },
            {
                "real_name": "bugprone-spuriously-wake-up-functions",
                "display_name": "bugprone-spuriously-wake-up-functions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-spuriously-wake-up-functionsÂ¶\n\nFinds `cnd_wait`, `cnd_timedwait`, `wait`, `wait_for`, or `wait_until`\nfunction calls when the function is not invoked from a loop that checks\nwhether a condition predicate holds or the function has a condition parameter.\n\nThis check corresponds to the CERT C++ Coding Standard rule [CON54-CPP. Wrap\nfunctions that can spuriously wake up in a\nloop](https://wiki.sei.cmu.edu/confluence/display/cplusplus/CON54-CPP.+Wrap+functions+that+can+spuriously+wake+up+in+a+loop).\nand CERT C Coding Standard rule [CON36-C. Wrap functions that can spuriously\nwake up in a\nloop](https://wiki.sei.cmu.edu/confluence/display/c/CON36-C.+Wrap+functions+that+can+spuriously+wake+up+in+a+loop).",
                "disable": false
            },
            {
                "real_name": "bugprone-string-constructor",
                "display_name": "bugprone-string-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-string-constructorÂ¶\n\nFinds string constructors that are suspicious and probably errors.\n\nA common mistake is to swap parameters to the âfillâ string-constructor.\n\nExamples:\n\n    \n    \n    std::string str('x', 50); // should be str(50, 'x')\n    \n\nCalling the string-literal constructor with a length bigger than the literal\nis suspicious and adds extra random characters to the string.\n\nExamples:\n\n    \n    \n    std::string(\"test\", 200);   // Will include random characters after \"test\".\n    std::string_view(\"test\", 200);\n    \n\nCreating an empty string from constructors with parameters is considered\nsuspicious. The programmer should use the empty constructor instead.\n\nExamples:\n\n    \n    \n    std::string(\"test\", 0);   // Creation of an empty string.\n    std::string_view(\"test\", 0);\n    \n\n## OptionsÂ¶\n\n`WarnOnLargeLength```Â¶\n\n    \n\nWhen true, the check will warn on a string with a length greater than\n`LargeLengthThreshold`. Default is true.\n\n`LargeLengthThreshold```Â¶\n\n    \n\nAn integer specifying the large length threshold. Default is 0x800000.\n\n`StringNames```Â¶\n\n    \n\nDefault is ::std::basic_string;::std::basic_string_view.\n\nSemicolon-delimited list of class names to apply this check to. By default\n::std::basic_string applies to `std::string` and `std::wstring`. Set to e.g.\n::std::basic_string;llvm::StringRef;QString to perform this check on custom\nclasses.",
                "disable": false
            },
            {
                "real_name": "bugprone-string-integer-assignment",
                "display_name": "bugprone-string-integer-assignment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-string-integer-assignmentÂ¶\n\nThe check finds assignments of an integer to `std::basic_string<CharT>`\n(`std::string`, `std::wstring`, etc.). The source of the problem is the\nfollowing assignment operator of `std::basic_string<CharT>`:\n\n    \n    \n    basic_string& operator=( CharT ch );\n    \n\nNumeric types can be implicitly casted to character types.\n\n    \n    \n    std::string s;\n    int x = 5965;\n    s = 6;\n    s = x;\n    \n\nUse the appropriate conversion functions or character literals.\n\n    \n    \n    std::string s;\n    int x = 5965;\n    s = '6';\n    s = std::to_string(x);\n    \n\nIn order to suppress false positives, use an explicit cast.\n\n    \n    \n    std::string s;\n    s = static_cast<char>(6);",
                "disable": false
            },
            {
                "real_name": "bugprone-string-literal-with-embedded-nul",
                "display_name": "bugprone-string-literal-with-embedded-nul",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-string-literal-with-embedded-nulÂ¶\n\nFinds occurrences of string literal with embedded NUL character and validates\ntheir usage.\n\n## Invalid escapingÂ¶\n\nSpecial characters can be escaped within a string literal by using their\nhexadecimal encoding like `\\x42`. A common mistake is to escape them like this\n`\\0x42` where the `\\0` stands for the NUL character.\n\n    \n    \n    const char* Example[] = \"Invalid character: \\0x12 should be \\x12\";\n    const char* Bytes[] = \"\\x03\\0x02\\0x01\\0x00\\0xFF\\0xFF\\0xFF\";\n    \n\n## Truncated literalÂ¶\n\nString-like classes can manipulate strings with embedded NUL as they are\nkeeping track of the bytes and the length. This is not the case for a `char*`\n(NUL-terminated) string.\n\nA common mistake is to pass a string-literal with embedded NUL to a string\nconstructor expecting a NUL-terminated string. The bytes after the first NUL\ncharacter are truncated.\n\n    \n    \n    std::string str(\"abc\\0def\");  // \"def\" is truncated\n    str += \"\\0\";                  // This statement is doing nothing\n    if (str == \"\\0abc\") return;   // This expression is always true",
                "disable": false
            },
            {
                "real_name": "bugprone-stringview-nullptr",
                "display_name": "bugprone-stringview-nullptr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-stringview-nullptrÂ¶\n\nChecks for various ways that the `const CharT*` constructor of\n`std::basic_string_view` can be passed a null argument and replaces them with\nthe default constructor in most cases. For the comparison operators, braced\ninitializer list does not compile so instead a call to `.empty()` or the empty\nstring literal are used, where appropriate.\n\nThis prevents code from invoking behavior which is unconditionally undefined.\nThe single-argument `const CharT*` constructor does not check for the null\ncase before dereferencing its input. The standard is slated to add an\nexplicitly-deleted overload to catch some of these cases: wg21.link/p2166\n\nTo catch the additional cases of `NULL` (which expands to `__null`) and `0`,\nfirst run the `modernize-use-nullptr` check to convert the callers to\n`nullptr`.\n\n    \n    \n    std::string_view sv = nullptr;\n    \n    sv = nullptr;\n    \n    bool is_empty = sv == nullptr;\n    bool isnt_empty = sv != nullptr;\n    \n    accepts_sv(nullptr);\n    \n    accepts_sv({{}});  // A\n    \n    accepts_sv({nullptr, 0});  // B\n    \n\nis translated intoâ¦\n\n    \n    \n    std::string_view sv = {};\n    \n    sv = {};\n    \n    bool is_empty = sv.empty();\n    bool isnt_empty = !sv.empty();\n    \n    accepts_sv(\"\");\n    \n    accepts_sv(\"\");  // A\n    \n    accepts_sv({nullptr, 0});  // B\n    \n\nNote\n\nThe source pattern with trailing comment âAâ selects the `(const CharT*)`\nconstructor overload and then value-initializes the pointer, causing a null\ndereference. It happens to not include the `nullptr` literal, but it is still\nwithin the scope of this ClangTidy check.\n\nNote\n\nThe source pattern with trailing comment âBâ selects the `(const CharT*,\nsize_type)` constructor which is perfectly valid, since the length argument is\n`0`. It is not changed by this ClangTidy check.",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-enum-usage",
                "display_name": "bugprone-suspicious-enum-usage",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-enum-usageÂ¶\n\nThe checker detects various cases when an enum is probably misused (as a\nbitmask ).\n\n  1. When âADDâ or âbitwise ORâ is used between two enum which come from different types and these types value ranges are not disjoint.\n\nThe following cases will be investigated only using\n[`StrictMode`](../performance/inefficient-string-concatenation.html#cmdoption-\narg-strictmode). We regard the enum as a (suspicious) bitmask if the three\nconditions below are true at the same time:\n\n  * at most half of the elements of the enum are non pow-of-2 numbers (because of short enumerations)\n  * there is another non pow-of-2 number than the enum constant representing all choices (the result âbitwise ORâ operation of all enum elements)\n  * enum type variable/enumconstant is used as an argument of a + or âbitwise OR â operator\n\nSo whenever the non pow-of-2 element is used as a bitmask element we diagnose\na misuse and give a warning.\n\n  2. Investigating the right hand side of += and |= operator.\n  3. Check only the enum value side of a | and + operator if one of them is not enum val.\n  4. Check both side of | or + operator where the enum values are from the same enum type.\n\nExamples:\n\n    \n    \n    enum { A, B, C };\n    enum { D, E, F = 5 };\n    enum { G = 10, H = 11, I = 12 };\n    \n    unsigned flag;\n    flag =\n        A |\n        H; // OK, disjoint value intervals in the enum types ->probably good use.\n    flag = B | F; // Warning, have common values so they are probably misused.\n    \n    // Case 2:\n    enum Bitmask {\n      A = 0,\n      B = 1,\n      C = 2,\n      D = 4,\n      E = 8,\n      F = 16,\n      G = 31 // OK, real bitmask.\n    };\n    \n    enum Almostbitmask {\n      AA = 0,\n      BB = 1,\n      CC = 2,\n      DD = 4,\n      EE = 8,\n      FF = 16,\n      GG // Problem, forgot to initialize.\n    };\n    \n    unsigned flag = 0;\n    flag |= E; // OK.\n    flag |=\n        EE; // Warning at the decl, and note that it was used here as a bitmask.\n    \n\n## OptionsÂ¶\n\n`StrictMode```Â¶\n\n    \n\nDefault value: 0. When non-null the suspicious bitmask usage will be\ninvestigated additionally to the different enum usage check.",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-include",
                "display_name": "bugprone-suspicious-include",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-includeÂ¶\n\nThe check detects various cases when an include refers to what appears to be\nan implementation file, which often leads to hard-to-track-down ODR\nviolations.\n\nExamples:\n\n    \n    \n    #include \"Dinosaur.hpp\"     // OK, .hpp files tend not to have definitions.\n    #include \"Pterodactyl.h\"    // OK, .h files tend not to have definitions.\n    #include \"Velociraptor.cpp\" // Warning, filename is suspicious.\n    #include_next <stdio.c>     // Warning, filename is suspicious.\n    \n\n## OptionsÂ¶\n\n`HeaderFileExtensions```Â¶\n\n    \n\nDefault value: `\";h;hh;hpp;hxx\"` A semicolon-separated list of filename\nextensions of header files (the filename extensions should not contain a\nâ.â prefix). For extension-less header files, use an empty string or leave\nan empty string between â;â if there are other filename extensions.\n\n`ImplementationFileExtensions```Â¶\n\n    \n\nDefault value: `\"c;cc;cpp;cxx\"` Likewise, a semicolon-separated list of\nfilename extensions of implementation files.",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-memory-comparison",
                "display_name": "bugprone-suspicious-memory-comparison",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-memory-comparisonÂ¶\n\nFinds potentially incorrect calls to `memcmp()` based on properties of the\narguments. The following cases are covered:\n\n**Case 1: Non-standard-layout type**\n\nComparing the object representations of non-standard-layout objects may not\nproperly compare the value representations.\n\n**Case 2: Types with no unique object representation**\n\nObjects with the same value may not have the same object representation. This\nmay be caused by padding or floating-point types.\n\nSee also: [EXP42-C. Do not compare padding\ndata](https://wiki.sei.cmu.edu/confluence/display/c/EXP42-C.+Do+not+compare+padding+data)\nand [FLP37-C. Do not use object representations to compare floating-point\nvalues](https://wiki.sei.cmu.edu/confluence/display/c/FLP37-C.+Do+not+use+object+representations+to+compare+floating-\npoint+values)\n\nThis check is also related to and partially overlaps the CERT C++ Coding\nStandard rules [OOP57-CPP. Prefer special member functions and overloaded\noperators to C Standard Library\nfunctions](https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP57-CPP.+Prefer+special+member+functions+and+overloaded+operators+to+C+Standard+Library+functions)\nand [EXP62-CPP. Do not access the bits of an object representation that are\nnot part of the objectâs value\nrepresentation](https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP62-CPP.+Do+not+access+the+bits+of+an+object+representation+that+are+not+part+of+the+object%27s+value+representation)",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-memset-usage",
                "display_name": "bugprone-suspicious-memset-usage",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-memset-usageÂ¶\n\nThis check finds `memset()` calls with potential mistakes in their arguments.\nConsidering the function as `void* memset(void* destination, int fill_value,\nsize_t byte_count)`, the following cases are covered:\n\n**Case 1: Fill value is a character ``â0â``**\n\nFilling up a memory area with ASCII code 48 characters is not customary,\npossibly integer zeroes were intended instead. The check offers a replacement\nof `'0'` with `0`. Memsetting character pointers with `'0'` is allowed.\n\n**Case 2: Fill value is truncated**\n\nMemset converts `fill_value` to `unsigned char` before using it. If\n`fill_value` is out of unsigned character range, it gets truncated and memory\nwill not contain the desired pattern.\n\n**Case 3: Byte count is zero**\n\nCalling memset with a literal zero in its `byte_count` argument is likely to\nbe unintended and swapped with `fill_value`. The check offers to swap these\ntwo arguments.\n\nCorresponding cpplint.py check name: `runtime/memset`.\n\nExamples:\n\n    \n    \n    void foo() {\n      int i[5] = {1, 2, 3, 4, 5};\n      int *ip = i;\n      char c = '1';\n      char *cp = &c;\n      int v = 0;\n    \n      // Case 1\n      memset(ip, '0', 1); // suspicious\n      memset(cp, '0', 1); // OK\n    \n      // Case 2\n      memset(ip, 0xabcd, 1); // fill value gets truncated\n      memset(ip, 0x00, 1);   // OK\n    \n      // Case 3\n      memset(ip, sizeof(int), v); // zero length, potentially swapped\n      memset(ip, 0, 1);           // OK\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-missing-comma",
                "display_name": "bugprone-suspicious-missing-comma",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-missing-commaÂ¶\n\nString literals placed side-by-side are concatenated at translation phase 6\n(after the preprocessor). This feature is used to represent long string\nliteral on multiple lines.\n\nFor instance, the following declarations are equivalent:\n\n    \n    \n    const char* A[] = \"This is a test\";\n    const char* B[] = \"This\" \" is a \"    \"test\";\n    \n\nA common mistake done by programmers is to forget a comma between two string\nliterals in an array initializer list.\n\n    \n    \n    const char* Test[] = {\n      \"line 1\",\n      \"line 2\"     // Missing comma!\n      \"line 3\",\n      \"line 4\",\n      \"line 5\"\n    };\n    \n\nThe array contains the string âline 2line3â at offset 1 (i.e. Test[1]).\nClang wonât generate warnings at compile time.\n\nThis check may warn incorrectly on cases like:\n\n    \n    \n    const char* SupportedFormat[] = {\n      \"Error %s\",\n      \"Code \" PRIu64,   // May warn here.\n      \"Warning %s\",\n    };\n    \n\n## OptionsÂ¶\n\n`SizeThreshold```Â¶\n\n    \n\nAn unsigned integer specifying the minimum size of a string literal to be\nconsidered by the check. Default is `5U`.\n\n`RatioThreshold```Â¶\n\n    \n\nA string specifying the maximum threshold ratio [0, 1.0] of suspicious string\nliterals to be considered. Default is `\".2\"`.\n\n`MaxConcatenatedTokens```Â¶\n\n    \n\nAn unsigned integer specifying the maximum number of concatenated tokens.\nDefault is `5U`.",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-semicolon",
                "display_name": "bugprone-suspicious-semicolon",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-semicolonÂ¶\n\nFinds most instances of stray semicolons that unexpectedly alter the meaning\nof the code. More specifically, it looks for `if`, `while`, `for` and `for-\nrange` statements whose body is a single semicolon, and then analyzes the\ncontext of the code (e.g. indentation) in an attempt to determine whether that\nis intentional.\n\n    \n    \n    if (x < y);\n    {\n      x++;\n    }\n    \n\nHere the body of the `if` statement consists of only the semicolon at the end\nof the first line, and x will be incremented regardless of the condition.\n\n    \n    \n    while ((line = readLine(file)) != NULL);\n      processLine(line);\n    \n\nAs a result of this code, processLine() will only be called once, when the\n`while` loop with the empty body exits with line == NULL. The indentation of\nthe code indicates the intention of the programmer.\n\n    \n    \n    if (x >= y);\n    x -= y;\n    \n\nWhile the indentation does not imply any nesting, there is simply no valid\nreason to have an if statement with an empty body (but it can make sense for a\nloop). So this check issues a warning for the code above.\n\nTo solve the issue remove the stray semicolon or in case the empty body is\nintentional, reflect this using code indentation or put the semicolon in a new\nline. For example:\n\n    \n    \n    while (readWhitespace());\n      Token t = readNextToken();\n    \n\nHere the second line is indented in a way that suggests that it is meant to be\nthe body of the while loop - whose body is in fact empty, because of the\nsemicolon at the end of the first line.\n\nEither remove the indentation from the second line:\n\n    \n    \n    while (readWhitespace());\n    Token t = readNextToken();\n    \n\nâ¦ or move the semicolon from the end of the first line to a new line:\n\n    \n    \n    while (readWhitespace())\n      ;\n    \n      Token t = readNextToken();\n    \n\nIn this case the check will assume that you know what you are doing, and will\nnot raise a warning.",
                "disable": false
            },
            {
                "real_name": "bugprone-suspicious-string-compare",
                "display_name": "bugprone-suspicious-string-compare",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-suspicious-string-compareÂ¶\n\nFind suspicious usage of runtime string comparison functions. This check is\nvalid in C and C++.\n\nChecks for calls with implicit comparator and proposed to explicitly add it.\n\n    \n    \n    if (strcmp(...))       // Implicitly compare to zero\n    if (!strcmp(...))      // Won't warn\n    if (strcmp(...) != 0)  // Won't warn\n    \n\nChecks that compare function results (i.e., `strcmp`) are compared to valid\nconstant. The resulting value is\n\n    \n    \n    <  0    when lower than,\n    >  0    when greater than,\n    == 0    when equals.\n    \n\nA common mistake is to compare the result to 1 or -1.\n\n    \n    \n    if (strcmp(...) == -1)  // Incorrect usage of the returned value.\n    \n\nAdditionally, the check warns if the results value is implicitly cast to a\n_suspicious_ non-integer type. Itâs happening when the returned value is\nused in a wrong context.\n\n    \n    \n    if (strcmp(...) < 0.)  // Incorrect usage of the returned value.\n    \n\n## OptionsÂ¶\n\n`WarnOnImplicitComparison```Â¶\n\n    \n\nWhen true, the check will warn on implicit comparison. true by default.\n\n`WarnOnLogicalNotComparison```Â¶\n\n    \n\nWhen true, the check will warn on logical not comparison. false by default.\n\n`StringCompareLikeFunctions```Â¶\n\n    \n\nA string specifying the comma-separated names of the extra string comparison\nfunctions. Default is an empty string. The check will detect the following\nstring comparison functions: __builtin_memcmp, __builtin_strcasecmp,\n__builtin_strcmp, __builtin_strncasecmp, __builtin_strncmp, _mbscmp,\n_mbscmp_l, _mbsicmp, _mbsicmp_l, _mbsnbcmp, _mbsnbcmp_l, _mbsnbicmp,\n_mbsnbicmp_l, _mbsncmp, _mbsncmp_l, _mbsnicmp, _mbsnicmp_l, _memicmp,\n_memicmp_l, _stricmp, _stricmp_l, _strnicmp, _strnicmp_l, _wcsicmp,\n_wcsicmp_l, _wcsnicmp, _wcsnicmp_l, lstrcmp, lstrcmpi, memcmp, memicmp,\nstrcasecmp, strcmp, strcmpi, stricmp, strncasecmp, strncmp, strnicmp,\nwcscasecmp, wcscmp, wcsicmp, wcsncmp, wcsnicmp, wmemcmp.",
                "disable": false
            },
            {
                "real_name": "bugprone-swapped-arguments",
                "display_name": "bugprone-swapped-arguments",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-swapped-argumentsÂ¶\n\nFinds potentially swapped arguments by looking at implicit conversions.",
                "disable": false
            },
            {
                "real_name": "bugprone-terminating-continue",
                "display_name": "bugprone-terminating-continue",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-terminating-continueÂ¶\n\nDetects `do while` loops with a condition always evaluating to false that have\na `continue` statement, as this `continue` terminates the loop effectively.\n\n    \n    \n    void f() {\n    do {\n      // some code\n      continue; // terminating continue\n      // some other code\n    } while(false);",
                "disable": false
            },
            {
                "real_name": "bugprone-throw-keyword-missing",
                "display_name": "bugprone-throw-keyword-missing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-throw-keyword-missingÂ¶\n\nWarns about a potentially missing `throw` keyword. If a temporary object is\ncreated, but the objectâs type derives from (or is the same as) a class that\nhas âEXCEPTIONâ, âExceptionâ or âexceptionâ in its name, we can\nassume that the programmerâs intention was to throw that object.\n\nExample:\n\n    \n    \n    void f(int i) {\n      if (i < 0) {\n        // Exception is created but is not thrown.\n        std::runtime_error(\"Unexpected argument\");\n      }\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-too-small-loop-variable",
                "display_name": "bugprone-too-small-loop-variable",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-too-small-loop-variableÂ¶\n\nDetects those `for` loops that have a loop variable with a âtoo smallâ\ntype which means this type canât represent all values which are part of the\niteration range.\n\n    \n    \n    int main() {\n      long size = 294967296l;\n      for (short i = 0; i < size; ++i) {}\n    }\n    \n\nThis `for` loop is an infinite loop because the `short` type canât represent\nall values in the `[0..size]` interval.\n\nIn a real use case size means a containerâs size which depends on the user\ninput.\n\n    \n    \n    int doSomething(const std::vector& items) {\n      for (short i = 0; i < items.size(); ++i) {}\n    }\n    \n\nThis algorithm works for a small amount of objects, but will lead to freeze\nfor a larger user input.\n\n`MagnitudeBitsUpperLimit```Â¶\n\n    \n\nUpper limit for the magnitude bits of the loop variable. If itâs set the\ncheck filters out those catches in which the loop variableâs type has more\nmagnitude bits as the specified upper limit. The default value is 16. For\nexample, if the user sets this option to 31 (bits), then a 32-bit `unsigned\nint` is ignored by the check, however a 32-bit `int` is not (A 32-bit `signed\nint` has 31 magnitude bits).\n\n    \n    \n    int main() {\n      long size = 294967296l;\n      for (unsigned i = 0; i < size; ++i) {} // no warning with MagnitudeBitsUpperLimit = 31 on a system where unsigned is 32-bit\n      for (int i = 0; i < size; ++i) {} // warning with MagnitudeBitsUpperLimit = 31 on a system where int is 32-bit\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-unchecked-optional-access",
                "display_name": "bugprone-unchecked-optional-access",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-unchecked-optional-accessÂ¶\n\n_Note_ : This check uses a flow-sensitive static analysis to produce its\nresults. Therefore, it may be more resource intensive (RAM, CPU) than the\naverage clang-tidy check.\n\nThis check identifies unsafe accesses to values contained in\n`std::optional<T>`, `absl::optional<T>`, or `base::Optional<T>` objects. Below\nwe will refer to all these types collectively as `optional<T>`.\n\nAn access to the value of an `optional<T>` occurs when one of its `value`,\n`operator*`, or `operator->` member functions is invoked. To align with common\nmisconceptions, the check considers these member functions as equivalent, even\nthough there are subtle differences related to exceptions versus undefined\nbehavior. See go/optional-style-recommendations for more information on that\ntopic.\n\nAn access to the value of an `optional<T>` is considered safe if and only if\ncode in the local scope (for example, a function body) ensures that the\n`optional<T>` has a value in all possible execution paths that can reach the\naccess. That should happen either through an explicit check, using the\n`optional<T>::has_value` member function, or by constructing the `optional<T>`\nin a way that shows that it unambiguously holds a value (e.g using\n`std::make_optional` which always returns a populated `std::optional<T>`).\n\nBelow we list some examples, starting with unsafe optional access patterns,\nfollowed by safe access patterns.\n\n## Unsafe access patternsÂ¶\n\n### Access the value without checking if it existsÂ¶\n\nThe check flags accesses to the value that are not locally guarded by\nexistence check:\n\n    \n    \n    void f(std::optional<int> opt) {\n      use(*opt); // unsafe: it is unclear whether `opt` has a value.\n    }\n    \n\n### Access the value in the wrong branchÂ¶\n\nThe check is aware of the state of an optional object in different branches of\nthe code. For example:\n\n    \n    \n    void f(std::optional<int> opt) {\n      if (opt.has_value()) {\n      } else {\n        use(opt.value()); // unsafe: it is clear that `opt` does *not* have a value.\n      }\n    }\n    \n\n### Assume a function result to be stableÂ¶\n\nThe check is aware that function results might not be stable. That is,\nconsecutive calls to the same function might return different values. For\nexample:\n\n    \n    \n    void f(Foo foo) {\n      if (foo.opt().has_value()) {\n        use(*foo.opt()); // unsafe: it is unclear whether `foo.opt()` has a value.\n      }\n    }\n    \n\n### Rely on invariants of uncommon APIsÂ¶\n\nThe check is unaware of invariants of uncommon APIs. For example:\n\n    \n    \n    void f(Foo foo) {\n      if (foo.HasProperty(\"bar\")) {\n        use(*foo.GetProperty(\"bar\")); // unsafe: it is unclear whether `foo.GetProperty(\"bar\")` has a value.\n      }\n    }\n    \n\n### Check if a value exists, then pass the optional to another functionÂ¶\n\nThe check relies on local reasoning. The check and value access must both\nhappen in the same function. An access is considered unsafe even if the caller\nof the function performing the access ensures that the optional has a value.\nFor example:\n\n    \n    \n    void g(std::optional<int> opt) {\n      use(*opt); // unsafe: it is unclear whether `opt` has a value.\n    }\n    \n    void f(std::optional<int> opt) {\n      if (opt.has_value()) {\n        g(opt);\n      }\n    }\n    \n\n## Safe access patternsÂ¶\n\n### Check if a value exists, then access the valueÂ¶\n\nThe check recognizes all straightforward ways for checking if a value exists\nand accessing the value contained in an optional object. For example:\n\n    \n    \n    void f(std::optional<int> opt) {\n      if (opt.has_value()) {\n        use(*opt);\n      }\n    }\n    \n\n### Check if a value exists, then access the value from a copyÂ¶\n\nThe criteria that the check uses is semantic, not syntactic. It recognizes\nwhen a copy of the optional object being accessed is known to have a value.\nFor example:\n\n    \n    \n    void f(std::optional<int> opt1) {\n      if (opt1.has_value()) {\n        std::optional<int> opt2 = opt1;\n        use(*opt2);\n      }\n    }\n    \n\n### Ensure that a value exists using common macrosÂ¶\n\nThe check is aware of common macros like `CHECK`, `DCHECK`, and `ASSERT_THAT`.\nThose can be used to ensure that an optional object has a value. For example:\n\n    \n    \n    void f(std::optional<int> opt) {\n      DCHECK(opt.has_value());\n      use(*opt);\n    }\n    \n\n### Ensure that a value exists, then access the value in a correlated branchÂ¶\n\nThe check is aware of correlated branches in the code and can figure out when\nan optional object is ensured to have a value on all execution paths that lead\nto an access. For example:\n\n    \n    \n    void f(std::optional<int> opt) {\n      bool safe = false;\n      if (opt.has_value() && SomeOtherCondition()) {\n        safe = true;\n      }\n      // ... more code...\n      if (safe) {\n        use(*opt);\n      }\n    }\n    \n\n## Stabilize function resultsÂ¶\n\nSince function results are not assumed to be stable across calls, it is best\nto store the result of the function call in a local variable and use that\nvariable to access the value. For example:\n\n    \n    \n    void f(Foo foo) {\n      if (const auto& foo_opt = foo.opt(); foo_opt.has_value()) {\n        use(*foo_opt);\n      }\n    }\n    \n\n## Do not rely on uncommon-API invariantsÂ¶\n\nWhen uncommon APIs guarantee that an optional has contents, do not rely on it\nâ instead, check explicitly that the optional object has a value. For\nexample:\n\n    \n    \n    void f(Foo foo) {\n      if (const auto& property = foo.GetProperty(\"bar\")) {\n        use(*property);\n      }\n    }\n    \n\ninstead of the HasProperty, GetProperty pairing we saw above.\n\n## Do not rely on caller-performed checksÂ¶\n\nIf you know that all of a functionâs callers have checked that an optional\nargument has a value, either change the function to take the value directly or\ncheck the optional again in the local scope of the callee. For example:\n\n    \n    \n    void g(int val) {\n      use(val);\n    }\n    \n    void f(std::optional<int> opt) {\n      if (opt.has_value()) {\n        g(*opt);\n      }\n    }\n    \n\nand\n\n    \n    \n    struct S {\n      std::optional<int> opt;\n      int x;\n    };\n    \n    void g(const S &s) {\n      if (s.opt.has_value() && s.x > 10) {\n        use(*s.opt);\n    }\n    \n    void f(S s) {\n      if (s.opt.has_value()) {\n        g(s);\n      }\n    }\n    \n\n## Additional notesÂ¶\n\n### Aliases created via `using` declarationsÂ¶\n\nThe check is aware of aliases of optional types that are created via `using`\ndeclarations. For example:\n\n    \n    \n    using OptionalInt = std::optional<int>;\n    \n    void f(OptionalInt opt) {\n      use(opt.value()); // unsafe: it is unclear whether `opt` has a value.\n    }\n    \n\n### LambdasÂ¶\n\nThe check does not currently report unsafe optional accesses in lambdas. A\nfuture version will expand the scope to lambdas, following the rules outlined\nabove. It is best to follow the same principles when using optionals in\nlambdas.",
                "disable": false
            },
            {
                "real_name": "bugprone-undefined-memory-manipulation",
                "display_name": "bugprone-undefined-memory-manipulation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-undefined-memory-manipulationÂ¶\n\nFinds calls of memory manipulation functions `memset()`, `memcpy()` and\n`memmove()` on not TriviallyCopyable objects resulting in undefined behavior.",
                "disable": false
            },
            {
                "real_name": "bugprone-undelegated-constructor",
                "display_name": "bugprone-undelegated-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-undelegated-constructorÂ¶\n\nFinds creation of temporary objects in constructors that look like a function\ncall to another constructor of the same class.\n\nThe user most likely meant to use a delegating constructor or base class\ninitializer.",
                "disable": false
            },
            {
                "real_name": "bugprone-unhandled-exception-at-new",
                "display_name": "bugprone-unhandled-exception-at-new",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-unhandled-exception-at-newÂ¶\n\nFinds calls to `new` with missing exception handler for `std::bad_alloc`.\n\nCalls to `new` may throw exceptions of type `std::bad_alloc` that should be\nhandled. Alternatively, the nonthrowing form of `new` can be used. The check\nverifies that the exception is handled in the function that calls `new`.\n\nIf a nonthrowing version is used or the exception is allowed to propagate out\nof the function no warning is generated.\n\nThe exception handler is checked if it catches a `std::bad_alloc` or\n`std::exception` exception type, or all exceptions (catch-all). The check\nassumes that any user-defined `operator new` is either `noexcept` or may throw\nan exception of type `std::bad_alloc` (or one derived from it). Other\nexception class types are not taken into account.\n\n    \n    \n    int *f() noexcept {\n      int *p = new int[1000]; // warning: missing exception handler for allocation failure at 'new'\n      // ...\n      return p;\n    }\n    \n    \n    \n    int *f1() { // not 'noexcept'\n      int *p = new int[1000]; // no warning: exception can be handled outside\n                              // of this function\n      // ...\n      return p;\n    }\n    \n    int *f2() noexcept {\n      try {\n        int *p = new int[1000]; // no warning: exception is handled\n        // ...\n        return p;\n      } catch (std::bad_alloc &) {\n        // ...\n      }\n      // ...\n    }\n    \n    int *f3() noexcept {\n      int *p = new (std::nothrow) int[1000]; // no warning: \"nothrow\" is used\n      // ...\n      return p;\n    }",
                "disable": false
            },
            {
                "real_name": "bugprone-unhandled-self-assignment",
                "display_name": "bugprone-unhandled-self-assignment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-unhandled-self-assignmentÂ¶\n\ncert-oop54-cpp redirects here as an alias for this check. For the CERT alias,\nthe WarnOnlyIfThisHasSuspiciousField option is set to false.\n\nFinds user-defined copy assignment operators which do not protect the code\nagainst self-assignment either by checking self-assignment explicitly or using\nthe copy-and-swap or the copy-and-move method.\n\nBy default, this check searches only those classes which have any pointer or C\narray field to avoid false positives. In case of a pointer or a C array,\nitâs likely that self-copy assignment breaks the object if the copy\nassignment operator was not written with care.\n\nSee also: [OOP54-CPP. Gracefully handle self-copy\nassignment](https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP54-CPP.+Gracefully+handle+self-\ncopy+assignment)\n\nA copy assignment operator must prevent that self-copy assignment ruins the\nobject state. A typical use case is when the class has a pointer field and the\ncopy assignment operator first releases the pointed object and then tries to\nassign it:\n\n    \n    \n    class T {\n    int* p;\n    \n    public:\n      T(const T &rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}\n      ~T() { delete p; }\n    \n      // ...\n    \n      T& operator=(const T &rhs) {\n        delete p;\n        p = new int(*rhs.p);\n        return *this;\n      }\n    };\n    \n\nThere are two common C++ patterns to avoid this problem. The first is the\nself-assignment check:\n\n    \n    \n    class T {\n    int* p;\n    \n    public:\n      T(const T &rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}\n      ~T() { delete p; }\n    \n      // ...\n    \n      T& operator=(const T &rhs) {\n        if(this == &rhs)\n          return *this;\n    \n        delete p;\n        p = new int(*rhs.p);\n        return *this;\n      }\n    };\n    \n\nThe second one is the copy-and-swap method when we create a temporary copy\n(using the copy constructor) and then swap this temporary object with `this`:\n\n    \n    \n    class T {\n    int* p;\n    \n    public:\n      T(const T &rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}\n      ~T() { delete p; }\n    \n      // ...\n    \n      void swap(T &rhs) {\n        using std::swap;\n        swap(p, rhs.p);\n      }\n    \n      T& operator=(const T &rhs) {\n        T(rhs).swap(*this);\n        return *this;\n      }\n    };\n    \n\nThere is a third pattern which is less common. Letâs call it the copy-and-\nmove method when we create a temporary copy (using the copy constructor) and\nthen move this temporary object into `this` (needs a move assignment\noperator):\n\n    \n    \n    class T {\n    int* p;\n    \n    public:\n      T(const T &rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}\n      ~T() { delete p; }\n    \n      // ...\n    \n      T& operator=(const T &rhs) {\n        T t = rhs;\n        *this = std::move(t);\n        return *this;\n      }\n    \n      T& operator=(T &&rhs) {\n        p = rhs.p;\n        rhs.p = nullptr;\n        return *this;\n      }\n    };\n    \n\n`WarnOnlyIfThisHasSuspiciousField```Â¶\n\n    \n\nWhen true, the check will warn only if the container class of the copy\nassignment operator has any suspicious fields (pointer or C array). This\noption is set to true by default.",
                "disable": false
            },
            {
                "real_name": "bugprone-unused-raii",
                "display_name": "bugprone-unused-raii",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-unused-raiiÂ¶\n\nFinds temporaries that look like RAII objects.\n\nThe canonical example for this is a scoped lock.\n\n    \n    \n    {\n      scoped_lock(&global_mutex);\n      critical_section();\n    }\n    \n\nThe destructor of the scoped_lock is called before the `critical_section` is\nentered, leaving it unprotected.\n\nWe apply a number of heuristics to reduce the false positive count of this\ncheck:\n\n  * Ignore code expanded from macros. Testing frameworks make heavy use of this.\n  * Ignore types with trivial destructors. They are very unlikely to be RAII objects and thereâs no difference when they are deleted.\n  * Ignore objects at the end of a compound statement (doesnât change behavior).\n  * Ignore objects returned from a call.",
                "disable": false
            },
            {
                "real_name": "bugprone-unused-return-value",
                "display_name": "bugprone-unused-return-value",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-unused-return-valueÂ¶\n\nWarns on unused function return values. The checked functions can be\nconfigured.\n\n## OptionsÂ¶\n\n`CheckedFunctions```Â¶\n\n    \n\nSemicolon-separated list of functions to check. The function is checked if the\nname and scope matches, with any arguments. By default the following functions\nare checked: `std::async, std::launder, std::remove, std::remove_if,\nstd::unique, std::unique_ptr::release, std::basic_string::empty,\nstd::vector::empty, std::back_inserter, std::distance, std::find,\nstd::find_if, std::inserter, std::lower_bound, std::make_pair,\nstd::map::count, std::map::find, std::map::lower_bound,\nstd::multimap::equal_range, std::multimap::upper_bound, std::set::count,\nstd::set::find, std::setfill, std::setprecision, std::setw, std::upper_bound,\nstd::vector::at, bsearch, ferror, feof, isalnum, isalpha, isblank, iscntrl,\nisdigit, isgraph, islower, isprint, ispunct, isspace, isupper, iswalnum,\niswprint, iswspace, isxdigit, memchr, memcmp, strcmp, strcoll, strncmp,\nstrpbrk, strrchr, strspn, strstr, wcscmp, access, bind, connect, difftime,\ndlsym, fnmatch, getaddrinfo, getopt, htonl, htons, iconv_open, inet_addr,\nisascii, isatty, mmap, newlocale, openat, pathconf, pthread_equal,\npthread_getspecific, pthread_mutex_trylock, readdir, readlink, recvmsg,\nregexec, scandir, semget, setjmp, shm_open, shmget, sigismember, strcasecmp,\nstrsignal, ttyname`\n\n  * `std::async()`. Not using the return value makes the call synchronous.\n  * `std::launder()`. Not using the return value usually means that the function interface was misunderstood by the programmer. Only the returned pointer is âlaunderedâ, not the argument.\n  * `std::remove()`, `std::remove_if()` and `std::unique()`. The returned iterator indicates the boundary between elements to keep and elements to be removed. Not using the return value means that the information about which elements to remove is lost.\n  * `std::unique_ptr::release()`. Not using the return value can lead to resource leaks if the same pointer isnât stored anywhere else. Often, ignoring the `release()` return value indicates that the programmer confused the function with `reset()`.\n  * `std::basic_string::empty()` and `std::vector::empty()`. Not using the return value often indicates that the programmer confused the function with `clear()`.\n\n[cert-err33-c](../cert/err33-c.html) is an alias of this check that checks a\nfixed and large set of standard library functions.",
                "disable": false
            },
            {
                "real_name": "bugprone-use-after-move",
                "display_name": "bugprone-use-after-move",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-use-after-moveÂ¶\n\nWarns if an object is used after it has been moved, for example:\n\n    \n    \n    std::string str = \"Hello, world!\\n\";\n    std::vector<std::string> messages;\n    messages.emplace_back(std::move(str));\n    std::cout << str;\n    \n\nThe last line will trigger a warning that `str` is used after it has been\nmoved.\n\nThe check does not trigger a warning if the object is reinitialized after the\nmove and before the use. For example, no warning will be output for this code:\n\n    \n    \n    messages.emplace_back(std::move(str));\n    str = \"Greetings, stranger!\\n\";\n    std::cout << str;\n    \n\nSubsections below explain more precisely what exactly the check considers to\nbe a move, use, and reinitialization.\n\nThe check takes control flow into account. A warning is only emitted if the\nuse can be reached from the move. This means that the following code does not\nproduce a warning:\n\n    \n    \n    if (condition) {\n      messages.emplace_back(std::move(str));\n    } else {\n      std::cout << str;\n    }\n    \n\nOn the other hand, the following code does produce a warning:\n\n    \n    \n    for (int i = 0; i < 10; ++i) {\n      std::cout << str;\n      messages.emplace_back(std::move(str));\n    }\n    \n\n(The use-after-move happens on the second iteration of the loop.)\n\nIn some cases, the check may not be able to detect that two branches are\nmutually exclusive. For example (assuming that `i` is an int):\n\n    \n    \n    if (i == 1) {\n      messages.emplace_back(std::move(str));\n    }\n    if (i == 2) {\n      std::cout << str;\n    }\n    \n\nIn this case, the check will erroneously produce a warning, even though it is\nnot possible for both the move and the use to be executed. More formally, the\nanalysis is [flow-sensitive but not path-\nsensitive](https://en.wikipedia.org/wiki/Data-flow_analysis#Sensitivities).\n\n## Silencing erroneous warningsÂ¶\n\nAn erroneous warning can be silenced by reinitializing the object after the\nmove:\n\n    \n    \n    if (i == 1) {\n      messages.emplace_back(std::move(str));\n      str = \"\";\n    }\n    if (i == 2) {\n      std::cout << str;\n    }\n    \n\nIf you want to avoid the overhead of actually reinitializing the object, you\ncan create a dummy function that causes the check to assume the object was\nreinitialized:\n\n    \n    \n    template <class T>\n    void IS_INITIALIZED(T&) {}\n    \n\nYou can use this as follows:\n\n    \n    \n    if (i == 1) {\n      messages.emplace_back(std::move(str));\n    }\n    if (i == 2) {\n      IS_INITIALIZED(str);\n      std::cout << str;\n    }\n    \n\nThe check will not output a warning in this case because passing the object to\na function as a non-const pointer or reference counts as a reinitialization\n(see section Reinitialization below).\n\n## Unsequenced moves, uses, and reinitializationsÂ¶\n\nIn many cases, C++ does not make any guarantees about the order in which sub-\nexpressions of a statement are evaluated. This means that in code like the\nfollowing, it is not guaranteed whether the use will happen before or after\nthe move:\n\n    \n    \n    void f(int i, std::vector<int> v);\n    std::vector<int> v = { 1, 2, 3 };\n    f(v[1], std::move(v));\n    \n\nIn this kind of situation, the check will note that the use and move are\nunsequenced.\n\nThe check will also take sequencing rules into account when reinitializations\noccur in the same statement as moves or uses. A reinitialization is only\nconsidered to reinitialize a variable if it is guaranteed to be evaluated\nafter the move and before the use.\n\n## MoveÂ¶\n\nThe check currently only considers calls of `std::move` on local variables or\nfunction parameters. It does not check moves of member variables or global\nvariables.\n\nAny call of `std::move` on a variable is considered to cause a move of that\nvariable, even if the result of `std::move` is not passed to an rvalue\nreference parameter.\n\nThis means that the check will flag a use-after-move even on a type that does\nnot define a move constructor or move assignment operator. This is\nintentional. Developers may use `std::move` on such a type in the expectation\nthat the type will add move semantics in the future. If such a `std::move` has\nthe potential to cause a use-after-move, we want to warn about it even if the\ntype does not implement move semantics yet.\n\nFurthermore, if the result of `std::move` _is_ passed to an rvalue reference\nparameter, this will always be considered to cause a move, even if the\nfunction that consumes this parameter does not move from it, or if it does so\nonly conditionally. For example, in the following situation, the check will\nassume that a move always takes place:\n\n    \n    \n    std::vector<std::string> messages;\n    void f(std::string &&str) {\n      // Only remember the message if it isn't empty.\n      if (!str.empty()) {\n        messages.emplace_back(std::move(str));\n      }\n    }\n    std::string str = \"\";\n    f(std::move(str));\n    \n\nThe check will assume that the last line causes a move, even though, in this\nparticular case, it does not. Again, this is intentional.\n\nThere is one special case: A call to `std::move` inside a `try_emplace` call\nis conservatively assumed not to move. This is to avoid spurious warnings, as\nthe check has no way to reason about the `bool` returned by `try_emplace`.\n\nWhen analyzing the order in which moves, uses and reinitializations happen\n(see section Unsequenced moves, uses, and reinitializations), the move is\nassumed to occur in whichever function the result of the `std::move` is passed\nto.\n\n## UseÂ¶\n\nAny occurrence of the moved variable that is not a reinitialization (see\nbelow) is considered to be a use.\n\nAn exception to this are objects of type `std::unique_ptr`, `std::shared_ptr`\nand `std::weak_ptr`, which have defined move behavior (objects of these\nclasses are guaranteed to be empty after they have been moved from).\nTherefore, an object of these classes will only be considered to be used if it\nis dereferenced, i.e. if `operator*`, `operator->` or `operator[]` (in the\ncase of `std::unique_ptr<T []>`) is called on it.\n\nIf multiple uses occur after a move, only the first of these is flagged.\n\n## ReinitializationÂ¶\n\nThe check considers a variable to be reinitialized in the following cases:\n\n>   * The variable occurs on the left-hand side of an assignment.\n>   * The variable is passed to a function as a non-const pointer or non-const\n> lvalue reference. (It is assumed that the variable may be an out-parameter\n> for the function.)\n>   * `clear()` or `assign()` is called on the variable and the variable is of\n> one of the standard container types `basic_string`, `vector`, `deque`,\n> `forward_list`, `list`, `set`, `map`, `multiset`, `multimap`,\n> `unordered_set`, `unordered_map`, `unordered_multiset`,\n> `unordered_multimap`.\n>   * `reset()` is called on the variable and the variable is of type\n> `std::unique_ptr`, `std::shared_ptr` or `std::weak_ptr`.\n>   * A member function marked with the `[[clang::reinitializes]]` attribute\n> is called on the variable.\n>\n\nIf the variable in question is a struct and an individual member variable of\nthat struct is written to, the check does not consider this to be a\nreinitialization â even if, eventually, all member variables of the struct\nare written to. For example:\n\n    \n    \n    struct S {\n      std::string str;\n      int i;\n    };\n    S s = { \"Hello, world!\\n\", 42 };\n    S s_other = std::move(s);\n    s.str = \"Lorem ipsum\";\n    s.i = 99;\n    \n\nThe check will not consider `s` to be reinitialized after the last line;\ninstead, the line that assigns to `s.str` will be flagged as a use-after-move.\nThis is intentional as this pattern of reinitializing a struct is error-prone.\nFor example, if an additional member variable is added to `S`, it is easy to\nforget to add the reinitialization for this additional member. Instead, it is\nsafer to assign to the entire struct in one go, and this will also avoid the\nuse-after-move warning.",
                "disable": false
            },
            {
                "real_name": "bugprone-virtual-near-miss",
                "display_name": "bugprone-virtual-near-miss",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# bugprone-virtual-near-missÂ¶\n\nWarn if a function is a near miss (i.e. the name is very similar and the\nfunction signature is the same) to a virtual function from a base class.\n\nExample:\n\n    \n    \n    struct Base {\n      virtual void func();\n    };\n    \n    struct Derived : Base {\n      virtual void funk();\n      // warning: 'Derived::funk' has a similar name and the same signature as virtual method 'Base::func'; did you mean to override it?\n    };",
                "disable": false
            },
            {
                "real_name": "cert-con36-c",
                "display_name": "cert-con36-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-con36-cÂ¶\n\nThe cert-con36-c check is an alias, please see [bugprone-spuriously-wake-up-\nfunctions](../bugprone/spuriously-wake-up-functions.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cert-con54-cpp",
                "display_name": "cert-con54-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-con54-cppÂ¶\n\nThe cert-con54-cpp check is an alias, please see [bugprone-spuriously-wake-up-\nfunctions](../bugprone/spuriously-wake-up-functions.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cert-dcl03-c",
                "display_name": "cert-dcl03-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl03-cÂ¶\n\nThe cert-dcl03-c check is an alias, please see [misc-static-\nassert](../misc/static-assert.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-dcl16-c",
                "display_name": "cert-dcl16-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl16-cÂ¶\n\nThe cert-dcl16-c check is an alias, please see [readability-uppercase-literal-\nsuffix](../readability/uppercase-literal-suffix.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-dcl21-cpp",
                "display_name": "cert-dcl21-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl21-cppÂ¶\n\nThis check flags postfix `operator++` and `operator--` declarations if the\nreturn type is not a const object. This also warns if the return type is a\nreference type.\n\nThe object returned by a postfix increment or decrement operator is supposed\nto be a snapshot of the objectâs value prior to modification. With such an\nimplementation, any modifications made to the resulting object from calling\noperator++(int) would be modifying a temporary object. Thus, such an\nimplementation of a postfix increment or decrement operator should instead\nreturn a const object, prohibiting accidental mutation of a temporary object.\nSimilarly, it is unexpected for the postfix operator to return a reference to\nits previous state, and any subsequent modifications would be operating on a\nstale object.\n\nThis check corresponds to the CERT C++ Coding Standard recommendation\nDCL21-CPP. Overloaded postfix increment and decrement operators should return\na const object. However, all of the CERT recommendations have been removed\nfrom public view, and so their justification for the behavior of this check\nrequires an account on their wiki to view.",
                "disable": false
            },
            {
                "real_name": "cert-dcl37-c",
                "display_name": "cert-dcl37-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl37-cÂ¶\n\nThe cert-dcl37-c check is an alias, please see [bugprone-reserved-\nidentifier](../bugprone/reserved-identifier.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-dcl50-cpp",
                "display_name": "cert-dcl50-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl50-cppÂ¶\n\nThis check flags all function definitions (but not declarations) of C-style\nvariadic functions.\n\nThis check corresponds to the CERT C++ Coding Standard rule [DCL50-CPP. Do not\ndefine a C-style variadic\nfunction](https://www.securecoding.cert.org/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function).",
                "disable": false
            },
            {
                "real_name": "cert-dcl51-cpp",
                "display_name": "cert-dcl51-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl51-cppÂ¶\n\nThe cert-dcl51-cpp check is an alias, please see [bugprone-reserved-\nidentifier](../bugprone/reserved-identifier.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-dcl54-cpp",
                "display_name": "cert-dcl54-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl54-cppÂ¶\n\nThe cert-dcl54-cpp check is an alias, please see [misc-new-delete-\noverloads](../misc/new-delete-overloads.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-dcl58-cpp",
                "display_name": "cert-dcl58-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl58-cppÂ¶\n\nModification of the `std` or `posix` namespace can result in undefined\nbehavior. This check warns for such modifications. The `std` (or `posix`)\nnamespace is allowed to be extended with (class or function) template\nspecializations that depend on an user-defined type (a type that is not\ndefined in the standard system headers).\n\nThe check detects the following (user provided) declarations in namespace\n`std` or `posix`:\n\n  * Anything that is not a template specialization.\n  * Explicit specializations of any standard library function template or class template, if it does not have any user-defined type as template argument.\n  * Explicit specializations of any member function of a standard library class template.\n  * Explicit specializations of any member function template of a standard library class or class template.\n  * Explicit or partial specialization of any member class template of a standard library class or class template.\n\nExamples:\n\n    \n    \n    namespace std {\n      int x; // warning: modification of 'std' namespace can result in undefined behavior [cert-dcl58-cpp]\n    }\n    \n    namespace posix::a { // warning: modification of 'posix' namespace can result in undefined behavior\n    }\n    \n    template <>\n    struct ::std::hash<long> { // warning: modification of 'std' namespace can result in undefined behavior\n      unsigned long operator()(const long &K) const {\n        return K;\n      }\n    };\n    \n    struct MyData { long data; };\n    \n    template <>\n    struct ::std::hash<MyData> { // no warning: specialization with user-defined type\n      unsigned long operator()(const MyData &K) const {\n        return K.data;\n      }\n    };\n    \n    namespace std {\n      template <>\n      void swap<bool>(bool &a, bool &b); // warning: modification of 'std' namespace can result in undefined behavior\n    \n      template <>\n      bool less<void>::operator()<MyData &&, MyData &&>(MyData &&, MyData &&) const { // warning: modification of 'std' namespace can result in undefined behavior\n        return true;\n      }\n    }\n    \n\nThis check corresponds to the CERT C++ Coding Standard rule [DCL58-CPP. Do not\nmodify the standard\nnamespaces](https://www.securecoding.cert.org/confluence/display/cplusplus/DCL58-CPP.+Do+not+modify+the+standard+namespaces).",
                "disable": false
            },
            {
                "real_name": "cert-dcl59-cpp",
                "display_name": "cert-dcl59-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-dcl59-cppÂ¶\n\nThe cert-dcl59-cpp check is an alias, please see [google-build-\nnamespaces](../google/build-namespaces.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-env33-c",
                "display_name": "cert-env33-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-env33-cÂ¶\n\nThis check flags calls to `system()`, `popen()`, and `_popen()`, which execute\na command processor. It does not flag calls to `system()` with a null pointer\nargument, as such a call checks for the presence of a command processor but\ndoes not actually attempt to execute a command.\n\nThis check corresponds to the CERT C Coding Standard rule [ENV33-C. Do not\ncall\nsystem()](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=2130132).",
                "disable": false
            },
            {
                "real_name": "cert-err09-cpp",
                "display_name": "cert-err09-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err09-cppÂ¶\n\nThe cert-err09-cpp check is an alias, please see [misc-throw-by-value-catch-\nby-reference](../misc/throw-by-value-catch-by-reference.html) for more\ninformation.\n\nThis check corresponds to the CERT C++ Coding Standard recommendation\nERR09-CPP. Throw anonymous temporaries. However, all of the CERT\nrecommendations have been removed from public view, and so their justification\nfor the behavior of this check requires an account on their wiki to view.",
                "disable": false
            },
            {
                "real_name": "cert-err33-c",
                "display_name": "cert-err33-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err33-cÂ¶\n\nWarns on unused function return values. Many of the standard library functions\nreturn a value that indicates if the call was successful. Ignoring the\nreturned value can cause unexpected behavior if an error has occurred. The\nfollowing functions are checked:\n\n  * aligned_alloc()\n  * asctime_s()\n  * at_quick_exit()\n  * atexit()\n  * bsearch()\n  * bsearch_s()\n  * btowc()\n  * c16rtomb()\n  * c32rtomb()\n  * calloc()\n  * clock()\n  * cnd_broadcast()\n  * cnd_init()\n  * cnd_signal()\n  * cnd_timedwait()\n  * cnd_wait()\n  * ctime_s()\n  * fclose()\n  * fflush()\n  * fgetc()\n  * fgetpos()\n  * fgets()\n  * fgetwc()\n  * fopen()\n  * fopen_s()\n  * fprintf()\n  * fprintf_s()\n  * fputc()\n  * fputs()\n  * fputwc()\n  * fputws()\n  * fread()\n  * freopen()\n  * freopen_s()\n  * fscanf()\n  * fscanf_s()\n  * fseek()\n  * fsetpos()\n  * ftell()\n  * fwprintf()\n  * fwprintf_s()\n  * fwrite()\n  * fwscanf()\n  * fwscanf_s()\n  * getc()\n  * getchar()\n  * getenv()\n  * getenv_s()\n  * gets_s()\n  * getwc()\n  * getwchar()\n  * gmtime()\n  * gmtime_s()\n  * localtime()\n  * localtime_s()\n  * malloc()\n  * mbrtoc16()\n  * mbrtoc32()\n  * mbsrtowcs()\n  * mbsrtowcs_s()\n  * mbstowcs()\n  * mbstowcs_s()\n  * memchr()\n  * mktime()\n  * mtx_init()\n  * mtx_lock()\n  * mtx_timedlock()\n  * mtx_trylock()\n  * mtx_unlock()\n  * printf_s()\n  * putc()\n  * putwc()\n  * raise()\n  * realloc()\n  * remove()\n  * rename()\n  * setlocale()\n  * setvbuf()\n  * scanf()\n  * scanf_s()\n  * signal()\n  * snprintf()\n  * snprintf_s()\n  * sprintf()\n  * sprintf_s()\n  * sscanf()\n  * sscanf_s()\n  * strchr()\n  * strerror_s()\n  * strftime()\n  * strpbrk()\n  * strrchr()\n  * strstr()\n  * strtod()\n  * strtof()\n  * strtoimax()\n  * strtok()\n  * strtok_s()\n  * strtol()\n  * strtold()\n  * strtoll()\n  * strtoumax()\n  * strtoul()\n  * strtoull()\n  * strxfrm()\n  * swprintf()\n  * swprintf_s()\n  * swscanf()\n  * swscanf_s()\n  * thrd_create()\n  * thrd_detach()\n  * thrd_join()\n  * thrd_sleep()\n  * time()\n  * timespec_get()\n  * tmpfile()\n  * tmpfile_s()\n  * tmpnam()\n  * tmpnam_s()\n  * tss_create()\n  * tss_get()\n  * tss_set()\n  * ungetc()\n  * ungetwc()\n  * vfprintf()\n  * vfprintf_s()\n  * vfscanf()\n  * vfscanf_s()\n  * vfwprintf()\n  * vfwprintf_s()\n  * vfwscanf()\n  * vfwscanf_s()\n  * vprintf_s()\n  * vscanf()\n  * vscanf_s()\n  * vsnprintf()\n  * vsnprintf_s()\n  * vsprintf()\n  * vsprintf_s()\n  * vsscanf()\n  * vsscanf_s()\n  * vswprintf()\n  * vswprintf_s()\n  * vswscanf()\n  * vswscanf_s()\n  * vwprintf_s()\n  * vwscanf()\n  * vwscanf_s()\n  * wcrtomb()\n  * wcschr()\n  * wcsftime()\n  * wcspbrk()\n  * wcsrchr()\n  * wcsrtombs()\n  * wcsrtombs_s()\n  * wcsstr()\n  * wcstod()\n  * wcstof()\n  * wcstoimax()\n  * wcstok()\n  * wcstok_s()\n  * wcstol()\n  * wcstold()\n  * wcstoll()\n  * wcstombs()\n  * wcstombs_s()\n  * wcstoumax()\n  * wcstoul()\n  * wcstoull()\n  * wcsxfrm()\n  * wctob()\n  * wctrans()\n  * wctype()\n  * wmemchr()\n  * wprintf_s()\n  * wscanf()\n  * wscanf_s()\n\nThis check is an alias of check [bugprone-unused-return-\nvalue](../bugprone/unused-return-value.html) with a fixed set of functions.\n\nThe check corresponds to a part of CERT C Coding Standard rule [ERR33-C.\nDetect and handle standard library\nerrors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors).\nThe list of checked functions is taken from the rule, with following\nexception:\n\n  * The check can not differentiate if a function is called with `NULL` argument. Therefore the following functions are not checked: `mblen`, `mbrlen`, `mbrtowc`, `mbtowc`, `wctomb`, `wctomb_s`",
                "disable": false
            },
            {
                "real_name": "cert-err34-c",
                "display_name": "cert-err34-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err34-cÂ¶\n\nThis check flags calls to string-to-number conversion functions that do not\nverify the validity of the conversion, such as `atoi()` or `scanf()`. It does\nnot flag calls to `strtol()`, or other, related conversion functions that do\nperform better error checking.\n\n    \n    \n    #include <stdlib.h>\n    \n    void func(const char *buff) {\n      int si;\n    \n      if (buff) {\n        si = atoi(buff); /* 'atoi' used to convert a string to an integer, but function will\n                             not report conversion errors; consider using 'strtol' instead. */\n      } else {\n        /* Handle error */\n      }\n    }\n    \n\nThis check corresponds to the CERT C Coding Standard rule [ERR34-C. Detect\nerrors when converting a string to a\nnumber](https://www.securecoding.cert.org/confluence/display/c/ERR34-C.+Detect+errors+when+converting+a+string+to+a+number).",
                "disable": false
            },
            {
                "real_name": "cert-err52-cpp",
                "display_name": "cert-err52-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err52-cppÂ¶\n\nThis check flags all call expressions involving `setjmp()` and `longjmp()`.\n\nThis check corresponds to the CERT C++ Coding Standard rule [ERR52-CPP. Do not\nuse setjmp() or\nlongjmp()](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=1834).",
                "disable": false
            },
            {
                "real_name": "cert-err58-cpp",
                "display_name": "cert-err58-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err58-cppÂ¶\n\nThis check flags all `static` or `thread_local` variable declarations where\nthe initializer for the object may throw an exception.\n\nThis check corresponds to the CERT C++ Coding Standard rule [ERR58-CPP. Handle\nall exceptions thrown before main() begins\nexecuting](https://www.securecoding.cert.org/confluence/display/cplusplus/ERR58-CPP.+Handle+all+exceptions+thrown+before+main%28%29+begins+executing).",
                "disable": false
            },
            {
                "real_name": "cert-err60-cpp",
                "display_name": "cert-err60-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err60-cppÂ¶\n\nThis check flags all throw expressions where the exception object is not\nnothrow copy constructible.\n\nThis check corresponds to the CERT C++ Coding Standard rule [ERR60-CPP.\nException objects must be nothrow copy\nconstructible](https://www.securecoding.cert.org/confluence/display/cplusplus/ERR60-CPP.+Exception+objects+must+be+nothrow+copy+constructible).",
                "disable": false
            },
            {
                "real_name": "cert-err61-cpp",
                "display_name": "cert-err61-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-err61-cppÂ¶\n\nThe cert-err61-cpp check is an alias, please see [misc-throw-by-value-catch-\nby-reference](../misc/throw-by-value-catch-by-reference.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cert-exp42-c",
                "display_name": "cert-exp42-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-exp42-cÂ¶\n\nThe cert-exp42-c check is an alias, please see [bugprone-suspicious-memory-\ncomparison](../bugprone/suspicious-memory-comparison.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cert-fio38-c",
                "display_name": "cert-fio38-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-fio38-cÂ¶\n\nThe cert-fio38-c check is an alias, please see [misc-non-copyable-\nobjects](../misc/non-copyable-objects.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-flp30-c",
                "display_name": "cert-flp30-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-flp30-cÂ¶\n\nThis check flags `for` loops where the induction expression has a floating-\npoint type.\n\nThis check corresponds to the CERT C Coding Standard rule [FLP30-C. Do not use\nfloating-point variables as loop\ncounters](https://www.securecoding.cert.org/confluence/display/c/FLP30-C.+Do+not+use+floating-\npoint+variables+as+loop+counters).",
                "disable": false
            },
            {
                "real_name": "cert-flp37-c",
                "display_name": "cert-flp37-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-flp37-cÂ¶\n\nThe cert-flp37-c check is an alias, please see [bugprone-suspicious-memory-\ncomparison](../bugprone/suspicious-memory-comparison.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cert-mem57-cpp",
                "display_name": "cert-mem57-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-mem57-cppÂ¶\n\nThis check flags uses of default `operator new` where the type has extended\nalignment (an alignment greater than the fundamental alignment). (The default\n`operator new` is guaranteed to provide the correct alignment if the requested\nalignment is less or equal to the fundamental alignment). Only cases are\ndetected (by design) where the `operator new` is not user-defined and is not a\nplacement new (the reason is that in these cases we assume that the user\nprovided the correct memory allocation).\n\nThis check corresponds to the CERT C++ Coding Standard rule [MEM57-CPP. Avoid\nusing default operator new for over-aligned\ntypes](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM57-CPP.+Avoid+using+default+operator+new+for+over-\naligned+types).",
                "disable": false
            },
            {
                "real_name": "cert-msc30-c",
                "display_name": "cert-msc30-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-msc30-cÂ¶\n\nThe cert-msc30-c check is an alias, please see [cert-\nmsc50-cpp](../cert/msc50-cpp.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-msc32-c",
                "display_name": "cert-msc32-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-msc32-cÂ¶\n\nThe cert-msc32-c check is an alias, please see [cert-\nmsc51-cpp](../cert/msc51-cpp.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-msc50-cpp",
                "display_name": "cert-msc50-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-msc50-cppÂ¶\n\nPseudorandom number generators use mathematical algorithms to produce a\nsequence of numbers with good statistical properties, but the numbers produced\nare not genuinely random. The `std::rand()` function takes a seed (number),\nruns a mathematical operation on it and returns the result. By manipulating\nthe seed the result can be predictable. This check warns for the usage of\n`std::rand()`.",
                "disable": false
            },
            {
                "real_name": "cert-msc51-cpp",
                "display_name": "cert-msc51-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-msc51-cppÂ¶\n\nThis check flags all pseudo-random number engines, engine adaptor\ninstantiations and `srand()` when initialized or seeded with default argument,\nconstant expression or any user-configurable type. Pseudo-random number\nengines seeded with a predictable value may cause vulnerabilities e.g. in\nsecurity protocols. This is a CERT security rule, see [MSC51-CPP. Ensure your\nrandom number generator is properly\nseeded](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC51-CPP.+Ensure+your+random+number+generator+is+properly+seeded)\nand [MSC32-C. Properly seed pseudorandom number\ngenerators](https://wiki.sei.cmu.edu/confluence/display/c/MSC32-C.+Properly+seed+pseudorandom+number+generators).\n\nExamples:\n\n    \n    \n    void foo() {\n      std::mt19937 engine1; // Diagnose, always generate the same sequence\n      std::mt19937 engine2(1); // Diagnose\n      engine1.seed(); // Diagnose\n      engine2.seed(1); // Diagnose\n    \n      std::time_t t;\n      engine1.seed(std::time(&t)); // Diagnose, system time might be controlled by user\n    \n      int x = atoi(argv[1]);\n      std::mt19937 engine3(x);  // Will not warn\n    }\n    \n\n## OptionsÂ¶\n\n`DisallowedSeedTypes```Â¶\n\n    \n\nA comma-separated list of the type names which are disallowed. Default values\nare `time_t`, `std::time_t`.",
                "disable": false
            },
            {
                "real_name": "cert-oop11-cpp",
                "display_name": "cert-oop11-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-oop11-cppÂ¶\n\nThe cert-oop11-cpp check is an alias, please see [performance-move-\nconstructor-init](../performance/move-constructor-init.html) for more\ninformation.\n\nThis check corresponds to the CERT C++ Coding Standard recommendation\nOOP11-CPP. Do not copy-initialize members or base classes from a move\nconstructor. However, all of the CERT recommendations have been removed from\npublic view, and so their justification for the behavior of this check\nrequires an account on their wiki to view.",
                "disable": false
            },
            {
                "real_name": "cert-oop54-cpp",
                "display_name": "cert-oop54-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-oop54-cppÂ¶\n\nThe cert-oop54-cpp check is an alias, please see [bugprone-unhandled-self-\nassignment](../bugprone/unhandled-self-assignment.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-oop57-cpp",
                "display_name": "cert-oop57-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-oop57-cppÂ¶\n\n> Flags use of the C standard library functions `memset`, `memcpy` and\n> `memcmp` and similar derivatives on non-trivial types.\n\n## OptionsÂ¶\n\n`MemSetNames```Â¶\n\n    \n\nSpecify extra functions to flag that act similarly to `memset`. Specify names\nin a semicolon delimited list. Default is an empty string. The check will\ndetect the following functions: memset, std::memset.\n\n`MemCpyNames```Â¶\n\n    \n\nSpecify extra functions to flag that act similarly to `memcpy`. Specify names\nin a semicolon delimited list. Default is an empty string. The check will\ndetect the following functions: std::memcpy, memcpy, std::memmove, memmove,\nstd::strcpy, strcpy, memccpy, stpncpy, strncpy.\n\n`MemCmpNames```Â¶\n\n    \n\nSpecify extra functions to flag that act similarly to `memcmp`. Specify names\nin a semicolon delimited list. Default is an empty string. The check will\ndetect the following functions: std::memcmp, memcmp, std::strcmp, strcmp,\nstrncmp.\n\nThis check corresponds to the CERT C++ Coding Standard rule [OOP57-CPP. Prefer\nspecial member functions and overloaded operators to C Standard Library\nfunctions](https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP57-CPP.+Prefer+special+member+functions+and+overloaded+operators+to+C+Standard+Library+functions).",
                "disable": false
            },
            {
                "real_name": "cert-oop58-cpp",
                "display_name": "cert-oop58-cpp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-oop58-cppÂ¶\n\nFinds assignments to the copied object and its direct or indirect members in\ncopy constructors and copy assignment operators.\n\nThis check corresponds to the CERT C Coding Standard rule [OOP58-CPP. Copy\noperations must not mutate the source\nobject](https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP58-CPP.+Copy+operations+must+not+mutate+the+source+object).",
                "disable": false
            },
            {
                "real_name": "cert-pos44-c",
                "display_name": "cert-pos44-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-pos44-cÂ¶\n\nThe cert-pos44-c check is an alias, please see [bugprone-bad-signal-to-kill-\nthread](../bugprone/bad-signal-to-kill-thread.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-pos47-c",
                "display_name": "cert-pos47-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-pos47-cÂ¶\n\nThe cert-pos47-c check is an alias, please see [concurrency-thread-canceltype-\nasynchronous](../concurrency/thread-canceltype-asynchronous.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cert-sig30-c",
                "display_name": "cert-sig30-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-sig30-cÂ¶\n\nThe cert-sig30-c check is an alias, please see [bugprone-signal-\nhandler](../bugprone/signal-handler.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cert-str34-c",
                "display_name": "cert-str34-c",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cert-str34-cÂ¶\n\nThe cert-str34-c check is an alias, please see [bugprone-signed-char-\nmisuse](../bugprone/signed-char-misuse.html) for more information.",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.CallAndMessage",
                "display_name": "clang-analyzer-core.CallAndMessage",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.CallAndMessage",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.DivideZero",
                "display_name": "clang-analyzer-core.DivideZero",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.DivideZero",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.DynamicTypePropagation",
                "display_name": "clang-analyzer-core.DynamicTypePropagation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.DynamicTypePropagation",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.NonNullParamChecker",
                "display_name": "clang-analyzer-core.NonNullParamChecker",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.NonNullParamChecker",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.NullDereference",
                "display_name": "clang-analyzer-core.NullDereference",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.NullDereference",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.StackAddressEscape",
                "display_name": "clang-analyzer-core.StackAddressEscape",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.StackAddressEscape",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.UndefinedBinaryOperatorResult",
                "display_name": "clang-analyzer-core.UndefinedBinaryOperatorResult",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.UndefinedBinaryOperatorResult",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.uninitialized.ArraySubscript",
                "display_name": "clang-analyzer-core.uninitialized.ArraySubscript",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.uninitialized.ArraySubscript",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.uninitialized.Assign",
                "display_name": "clang-analyzer-core.uninitialized.Assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.uninitialized.Assign",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.uninitialized.Branch",
                "display_name": "clang-analyzer-core.uninitialized.Branch",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.uninitialized.Branch",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.uninitialized.CapturedBlockVariable",
                "display_name": "clang-analyzer-core.uninitialized.CapturedBlockVariable",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.uninitialized.CapturedBlockVariable",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.uninitialized.UndefReturn",
                "display_name": "clang-analyzer-core.uninitialized.UndefReturn",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.uninitialized.UndefReturn",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-core.VLASize",
                "display_name": "clang-analyzer-core.VLASize",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-core.VLASize",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-cplusplus.InnerPointer",
                "display_name": "clang-analyzer-cplusplus.InnerPointer",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-cplusplus.InnerPointer",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-cplusplus.Move",
                "display_name": "clang-analyzer-cplusplus.Move",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-cplusplus.Move",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-cplusplus.NewDelete",
                "display_name": "clang-analyzer-cplusplus.NewDelete",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-cplusplus.NewDelete",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-cplusplus.NewDeleteLeaks",
                "display_name": "clang-analyzer-cplusplus.NewDeleteLeaks",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-cplusplus.NewDeleteLeaks",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-deadcode.DeadStores",
                "display_name": "clang-analyzer-deadcode.DeadStores",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-deadcode.DeadStores",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-nullability.NullableDereferenced",
                "display_name": "clang-analyzer-nullability.NullableDereferenced",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-nullability.NullableDereferenced",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-nullability.NullablePassedToNonnull",
                "display_name": "clang-analyzer-nullability.NullablePassedToNonnull",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-nullability.NullablePassedToNonnull",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-nullability.NullableReturnedFromNonnull",
                "display_name": "clang-analyzer-nullability.NullableReturnedFromNonnull",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-nullability.NullableReturnedFromNonnull",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-nullability.NullPassedToNonnull",
                "display_name": "clang-analyzer-nullability.NullPassedToNonnull",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-nullability.NullPassedToNonnull",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-nullability.NullReturnedFromNonnull",
                "display_name": "clang-analyzer-nullability.NullReturnedFromNonnull",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-nullability.NullReturnedFromNonnull",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.cplusplus.UninitializedObject",
                "display_name": "clang-analyzer-optin.cplusplus.UninitializedObject",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.cplusplus.UninitializedObject",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.cplusplus.VirtualCall",
                "display_name": "clang-analyzer-optin.cplusplus.VirtualCall",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.cplusplus.VirtualCall",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.mpi.MPI-Checker",
                "display_name": "clang-analyzer-optin.mpi.MPI-Checker",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.mpi.MPI-Checker",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.osx.OSObjectCStyleCast",
                "display_name": "clang-analyzer-optin.osx.OSObjectCStyleCast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.osx.OSObjectCStyleCast",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.performance.GCDAntipattern",
                "display_name": "clang-analyzer-optin.performance.GCDAntipattern",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.performance.GCDAntipattern",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.performance.Padding",
                "display_name": "clang-analyzer-optin.performance.Padding",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.performance.Padding",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-optin.portability.UnixAPI",
                "display_name": "clang-analyzer-optin.portability.UnixAPI",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-optin.portability.UnixAPI",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.API",
                "display_name": "clang-analyzer-osx.API",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.API",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.AtSync",
                "display_name": "clang-analyzer-osx.cocoa.AtSync",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.AtSync",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.AutoreleaseWrite",
                "display_name": "clang-analyzer-osx.cocoa.AutoreleaseWrite",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.AutoreleaseWrite",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.ClassRelease",
                "display_name": "clang-analyzer-osx.cocoa.ClassRelease",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.ClassRelease",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.Dealloc",
                "display_name": "clang-analyzer-osx.cocoa.Dealloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.Dealloc",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.IncompatibleMethodTypes",
                "display_name": "clang-analyzer-osx.cocoa.IncompatibleMethodTypes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.IncompatibleMethodTypes",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.Loops",
                "display_name": "clang-analyzer-osx.cocoa.Loops",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.Loops",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.MissingSuperCall",
                "display_name": "clang-analyzer-osx.cocoa.MissingSuperCall",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.MissingSuperCall",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.NilArg",
                "display_name": "clang-analyzer-osx.cocoa.NilArg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.NilArg",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.NonNilReturnValue",
                "display_name": "clang-analyzer-osx.cocoa.NonNilReturnValue",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.NonNilReturnValue",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.NSAutoreleasePool",
                "display_name": "clang-analyzer-osx.cocoa.NSAutoreleasePool",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.NSAutoreleasePool",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.NSError",
                "display_name": "clang-analyzer-osx.cocoa.NSError",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.NSError",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.ObjCGenerics",
                "display_name": "clang-analyzer-osx.cocoa.ObjCGenerics",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.ObjCGenerics",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.RetainCount",
                "display_name": "clang-analyzer-osx.cocoa.RetainCount",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.RetainCount",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak",
                "display_name": "clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.SelfInit",
                "display_name": "clang-analyzer-osx.cocoa.SelfInit",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.SelfInit",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.SuperDealloc",
                "display_name": "clang-analyzer-osx.cocoa.SuperDealloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.SuperDealloc",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.UnusedIvars",
                "display_name": "clang-analyzer-osx.cocoa.UnusedIvars",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.UnusedIvars",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.cocoa.VariadicMethodTypes",
                "display_name": "clang-analyzer-osx.cocoa.VariadicMethodTypes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.cocoa.VariadicMethodTypes",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.coreFoundation.CFError",
                "display_name": "clang-analyzer-osx.coreFoundation.CFError",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.coreFoundation.CFError",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.coreFoundation.CFNumber",
                "display_name": "clang-analyzer-osx.coreFoundation.CFNumber",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.coreFoundation.CFNumber",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.coreFoundation.CFRetainRelease",
                "display_name": "clang-analyzer-osx.coreFoundation.CFRetainRelease",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.coreFoundation.CFRetainRelease",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.coreFoundation.containers.OutOfBounds",
                "display_name": "clang-analyzer-osx.coreFoundation.containers.OutOfBounds",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.coreFoundation.containers.OutOfBounds",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.coreFoundation.containers.PointerSizedValues",
                "display_name": "clang-analyzer-osx.coreFoundation.containers.PointerSizedValues",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.coreFoundation.containers.PointerSizedValues",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.MIG",
                "display_name": "clang-analyzer-osx.MIG",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.MIG",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.NumberObjectConversion",
                "display_name": "clang-analyzer-osx.NumberObjectConversion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.NumberObjectConversion",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.ObjCProperty",
                "display_name": "clang-analyzer-osx.ObjCProperty",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.ObjCProperty",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.OSObjectRetainCount",
                "display_name": "clang-analyzer-osx.OSObjectRetainCount",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.OSObjectRetainCount",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-osx.SecKeychainAPI",
                "display_name": "clang-analyzer-osx.SecKeychainAPI",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-osx.SecKeychainAPI",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.FloatLoopCounter",
                "display_name": "clang-analyzer-security.FloatLoopCounter",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.FloatLoopCounter",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.bcmp",
                "display_name": "clang-analyzer-security.insecureAPI.bcmp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.bcmp",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.bcopy",
                "display_name": "clang-analyzer-security.insecureAPI.bcopy",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.bcopy",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.bzero",
                "display_name": "clang-analyzer-security.insecureAPI.bzero",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.bzero",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.getpw",
                "display_name": "clang-analyzer-security.insecureAPI.getpw",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.getpw",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.gets",
                "display_name": "clang-analyzer-security.insecureAPI.gets",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.gets",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.mkstemp",
                "display_name": "clang-analyzer-security.insecureAPI.mkstemp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.mkstemp",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.mktemp",
                "display_name": "clang-analyzer-security.insecureAPI.mktemp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.mktemp",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.rand",
                "display_name": "clang-analyzer-security.insecureAPI.rand",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.rand",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.strcpy",
                "display_name": "clang-analyzer-security.insecureAPI.strcpy",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.strcpy",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.UncheckedReturn",
                "display_name": "clang-analyzer-security.insecureAPI.UncheckedReturn",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.UncheckedReturn",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-security.insecureAPI.vfork",
                "display_name": "clang-analyzer-security.insecureAPI.vfork",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-security.insecureAPI.vfork",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.API",
                "display_name": "clang-analyzer-unix.API",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.API",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.cstring.BadSizeArg",
                "display_name": "clang-analyzer-unix.cstring.BadSizeArg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.cstring.BadSizeArg",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.cstring.NullArg",
                "display_name": "clang-analyzer-unix.cstring.NullArg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.cstring.NullArg",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.Malloc",
                "display_name": "clang-analyzer-unix.Malloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.Malloc",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.MallocSizeof",
                "display_name": "clang-analyzer-unix.MallocSizeof",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.MallocSizeof",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.MismatchedDeallocator",
                "display_name": "clang-analyzer-unix.MismatchedDeallocator",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.MismatchedDeallocator",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-unix.Vfork",
                "display_name": "clang-analyzer-unix.Vfork",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-unix.Vfork",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-valist.CopyToSelf",
                "display_name": "clang-analyzer-valist.CopyToSelf",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-valist.CopyToSelf",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-valist.Uninitialized",
                "display_name": "clang-analyzer-valist.Uninitialized",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-valist.Uninitialized",
                "disable": false
            },
            {
                "real_name": "clang-analyzer-valist.Unterminated",
                "display_name": "clang-analyzer-valist.Unterminated",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "clang-analyzer-valist.Unterminated",
                "disable": false
            },
            {
                "real_name": "concurrency-mt-unsafe",
                "display_name": "concurrency-mt-unsafe",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# concurrency-mt-unsafeÂ¶\n\nChecks for some thread-unsafe functions against a black list of known-to-be-\nunsafe functions. Usually they access static variables without synchronization\n(e.g. gmtime(3)) or utilize signals in a racy way. The set of functions to\ncheck is specified with the FunctionSet option.\n\nNote that using some thread-unsafe functions may be still valid in concurrent\nprogramming if only a single thread is used (e.g. setenv(3)), however, some\nfunctions may track a state in global variables which would be clobbered by\nsubsequent (non-parallel, but concurrent) calls to a related function. E.g.\nthe following code suffers from unprotected accesses to a global state:\n\n    \n    \n    // getnetent(3) maintains global state with DB connection, etc.\n    // If a concurrent green thread calls getnetent(3), the global state is corrupted.\n    netent = getnetent();\n    yield();\n    netent = getnetent();\n    \n\nExamples:\n\n    \n    \n    tm = gmtime(timep); // uses a global buffer\n    \n    sleep(1); // implementation may use SIGALRM\n    \n\n`FunctionSet```Â¶\n\n    \n\nSpecifies which functions in libc should be considered thread-safe, possible\nvalues are posix, glibc, or any.\n\nposix means POSIX defined thread-unsafe functions. POSIX.1-2001 in â2.9.1\nThread-Safetyâ defines that all functions specified in the standard are\nthread-safe except a predefined list of thread-unsafe functions.\n\nGlibc defines some of them as thread-safe (e.g. dirname(3)), but adds non-\nPOSIX thread-unsafe ones (e.g. getopt_long(3)). Glibcâs list is compiled\nfrom GNU web documentation with a search for MT-Safe tag:\n<https://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-\nConcepts.html>\n\nIf you want to identify thread-unsafe API for at least one libc or unsure\nwhich libc will be used, use any (default).",
                "disable": false
            },
            {
                "real_name": "concurrency-thread-canceltype-asynchronous",
                "display_name": "concurrency-thread-canceltype-asynchronous",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# concurrency-thread-canceltype-asynchronousÂ¶\n\nFinds `pthread_setcanceltype` function calls where a threadâs cancellation\ntype is set to asynchronous. Asynchronous cancellation type\n(`PTHREAD_CANCEL_ASYNCHRONOUS`) is generally unsafe, use type\n`PTHREAD_CANCEL_DEFERRED` instead which is the default. Even with deferred\ncancellation, a cancellation point in an asynchronous signal handler may still\nbe acted upon and the effect is as if it was an asynchronous cancellation.\n\nThis check corresponds to the CERT C Coding Standard rule [POS47-C. Do not use\nthreads that can be canceled\nasynchronously](https://wiki.sei.cmu.edu/confluence/display/c/POS47-C.+Do+not+use+threads+that+can+be+canceled+asynchronously).",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-avoid-c-arrays",
                "display_name": "cppcoreguidelines-avoid-c-arrays",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-avoid-c-arraysÂ¶\n\nThe cppcoreguidelines-avoid-c-arrays check is an alias, please see [modernize-\navoid-c-arrays](../modernize/avoid-c-arrays.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-avoid-goto",
                "display_name": "cppcoreguidelines-avoid-goto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-avoid-gotoÂ¶\n\nThe usage of `goto` for control flow is error prone and should be replaced\nwith looping constructs. Only forward jumps in nested loops are accepted.\n\nThis check implements\n[ES.76](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es76-avoid-\ngoto) from the CppCoreGuidelines and [6.3.1 from High Integrity\nC++](http://www.codingstandard.com/rule/6-3-1-ensure-that-the-labels-for-a-\njump-statement-or-a-switch-condition-appear-later-in-the-same-or-an-enclosing-\nblock/).\n\nFor more information on why to avoid programming with `goto` you can read the\nfamous paper [A Case against the GO TO\nStatement.](https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF).\n\nThe check diagnoses `goto` for backward jumps in every language mode. These\nshould be replaced with C/C++ looping constructs.\n\n    \n    \n    // Bad, handwritten for loop.\n    int i = 0;\n    // Jump label for the loop\n    loop_start:\n    do_some_operation();\n    \n    if (i < 100) {\n      ++i;\n      goto loop_start;\n    }\n    \n    // Better\n    for(int i = 0; i < 100; ++i)\n      do_some_operation();\n    \n\nModern C++ needs `goto` only to jump out of nested loops.\n\n    \n    \n    for(int i = 0; i < 100; ++i) {\n      for(int j = 0; j < 100; ++j) {\n        if (i * j > 500)\n          goto early_exit;\n      }\n    }\n    \n    early_exit:\n    some_operation();\n    \n\nAll other uses of `goto` are diagnosed in C++.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-avoid-magic-numbers",
                "display_name": "cppcoreguidelines-avoid-magic-numbers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-avoid-magic-numbersÂ¶\n\nThe cppcoreguidelines-avoid-magic-numbers check is an alias, please see\n[readability-magic-numbers](../readability/magic-numbers.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-avoid-non-const-global-variables",
                "display_name": "cppcoreguidelines-avoid-non-const-global-variables",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-avoid-non-const-global-variablesÂ¶\n\nFinds non-const global variables as described in [I.2 of C++ Core\nGuidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-\nglobal) . As [R.6 of C++ Core\nGuidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rr-\nglobal) is a duplicate of rule I.2 it also covers that rule.\n\n    \n    \n    char a;  // Warns!\n    const char b =  0;\n    \n    namespace some_namespace\n    {\n        char c;  // Warns!\n        const char d = 0;\n    }\n    \n    char * c_ptr1 = &some_namespace::c;  // Warns!\n    char *const c_const_ptr = &some_namespace::c;  // Warns!\n    char & c_reference = some_namespace::c;  // Warns!\n    \n    class Foo  // No Warnings inside Foo, only namespace scope is covered\n    {\n    public:\n        char e = 0;\n        const char f = 0;\n    protected:\n        char g = 0;\n    private:\n        char h = 0;\n    };\n    \n\nVariables: `a`, `c`, `c_ptr1`, `c_ptr2`, `c_const_ptr` and `c_reference`, will\nall generate warnings since they are either: a globally accessible variable\nand non-const, a pointer or reference providing global access to non-const\ndata or both.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-c-copy-assignment-signature",
                "display_name": "cppcoreguidelines-c-copy-assignment-signature",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-c-copy-assignment-signatureÂ¶\n\nThe cppcoreguidelines-c-copy-assignment-signature check is an alias, please\nsee [misc-unconventional-assign-operator](../misc/unconventional-assign-\noperator.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-explicit-virtual-functions",
                "display_name": "cppcoreguidelines-explicit-virtual-functions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-explicit-virtual-functionsÂ¶\n\nThe cppcoreguidelines-explicit-virtual-functions check is an alias, please see\n[modernize-use-override](../modernize/use-override.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-init-variables",
                "display_name": "cppcoreguidelines-init-variables",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-init-variablesÂ¶\n\nChecks whether there are local variables that are declared without an initial\nvalue. These may lead to unexpected behavior if there is a code path that\nreads the variable before assigning to it.\n\nOnly integers, booleans, floats, doubles and pointers are checked. The fix\noption initializes all detected values with the value of zero. An exception is\nfloat and double types, which are initialized to NaN.\n\nAs an example a function that looks like this:\n\n    \n    \n    void function() {\n      int x;\n      char *txt;\n      double d;\n    \n      // Rest of the function.\n    }\n    \n\nWould be rewritten to look like this:\n\n    \n    \n    #include <math.h>\n    \n    void function() {\n      int x = 0;\n      char *txt = nullptr;\n      double d = NAN;\n    \n      // Rest of the function.\n    }\n    \n\nIt warns for the uninitialized enum case, but without a FixIt:\n\n    \n    \n    enum A {A1, A2, A3};\n    enum A_c : char { A_c1, A_c2, A_c3 };\n    enum class B { B1, B2, B3 };\n    enum class B_i : int { B_i1, B_i2, B_i3 };\n    void function() {\n      A a;     // Warning: variable 'a' is not initialized\n      A_c a_c; // Warning: variable 'a_c' is not initialized\n      B b;     // Warning: variable 'b' is not initialized\n      B_i b_i; // Warning: variable 'b_i' is not initialized\n    }\n    \n\n## OptionsÂ¶\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`MathHeader```Â¶\n\n    \n\nA string specifying the header to include to get the definition of NAN.\nDefault is <math.h>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-interfaces-global-init",
                "display_name": "cppcoreguidelines-interfaces-global-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-interfaces-global-initÂ¶\n\nThis check flags initializers of globals that access extern objects, and\ntherefore can lead to order-of-initialization problems.\n\nThis rule is part of the âInterfacesâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-\nglobal-init>\n\nNote that currently this does not flag calls to non-constexpr functions, and\ntherefore globals could still be accessed from functions themselves.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-macro-to-enum",
                "display_name": "cppcoreguidelines-macro-to-enum",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-macro-to-enumÂ¶\n\nThe cppcoreguidelines-macro-to-enum check is an alias, please see [modernize-\nmacro-to-enum](../modernize/macro-to-enum.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-macro-usage",
                "display_name": "cppcoreguidelines-macro-usage",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-macro-usageÂ¶\n\nFinds macro usage that is considered problematic because better language\nconstructs exist for the task.\n\nThe relevant sections in the C++ Core Guidelines are\n[ES.31](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es31-dont-\nuse-macros-for-constants-or-functions), and\n[ES.32](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es32-use-\nall_caps-for-all-macro-names).\n\nExamples:\n\n    \n    \n    #define C 0\n    #define F1(x, y) ((a) > (b) ? (a) : (b))\n    #define F2(...) (__VA_ARGS__)\n    #define COMMA ,\n    #define NORETURN [[noreturn]]\n    #define DEPRECATED attribute((deprecated))\n    #if LIB_EXPORTS\n    #define DLLEXPORTS __declspec(dllexport)\n    #else\n    #define DLLEXPORTS __declspec(dllimport)\n    #endif\n    \n\nresults in the following warnings:\n\n    \n    \n    4 warnings generated.\n    test.cpp:1:9: warning: macro 'C' used to declare a constant; consider using a 'constexpr' constant [cppcoreguidelines-macro-usage]\n    #define C 0\n            ^\n    test.cpp:2:9: warning: function-like macro 'F1' used; consider a 'constexpr' template function [cppcoreguidelines-macro-usage]\n    #define F1(x, y) ((a) > (b) ? (a) : (b))\n            ^\n    test.cpp:3:9: warning: variadic macro 'F2' used; consider using a 'constexpr' variadic template function [cppcoreguidelines-macro-usage]\n    #define F2(...) (__VA_ARGS__)\n            ^\n    \n\n## OptionsÂ¶\n\n`AllowedRegexp```Â¶\n\n    \n\nA regular expression to filter allowed macros. For example\nDEBUG*|LIBTORRENT*|TORRENT*|UNI* could be applied to filter libtorrent.\nDefault value is ^DEBUG_*.\n\n`CheckCapsOnly```Â¶\n\n    \n\nBoolean flag to warn on all macros except those with CAPS_ONLY names. This\noption is intended to ease introduction of this check into older code bases.\nDefault value is false.\n\n`IgnoreCommandLineMacros```Â¶\n\n    \n\nBoolean flag to toggle ignoring command-line-defined macros. Default value is\ntrue.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-narrowing-conversions",
                "display_name": "cppcoreguidelines-narrowing-conversions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-narrowing-conversionsÂ¶\n\nChecks for silent narrowing conversions, e.g: `int i = 0; i += 0.1;`. While\nthe issue is obvious in this former example, it might not be so in the\nfollowing: `void MyClass::f(double d) { int_member_ += d; }`.\n\nThis rule is part of the âExpressions and statementsâ profile of the C++\nCore Guidelines, corresponding to rule ES.46. See\n\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es46-avoid-\nlossy-narrowing-truncating-arithmetic-conversions>.\n\nWe enforce only part of the guideline, more specifically, we flag narrowing\nconversions from:\n\n    \n\n  * an integer to a narrower integer (e.g. `char` to `unsigned char`) if WarnOnIntegerNarrowingConversion Option is set,\n  * an integer to a narrower floating-point (e.g. `uint64_t` to `float`) if WarnOnIntegerToFloatingPointNarrowingConversion Option is set,\n  * a floating-point to an integer (e.g. `double` to `int`),\n  * a floating-point to a narrower floating-point (e.g. `double` to `float`) if WarnOnFloatingPointNarrowingConversion Option is set.\n\nThis check will flag:\n\n    \n\n  * All narrowing conversions that are not marked by an explicit cast (c-style or `static_cast`). For example: `int i = 0; i += 0.1;`, `void f(int); f(0.1);`,\n  * All applications of binary operators with a narrowing conversions. For example: `int i; i+= 0.1;`.\n\n## OptionsÂ¶\n\n`WarnOnIntegerNarrowingConversion```Â¶\n\n    \n\nWhen true, the check will warn on narrowing integer conversion (e.g. `int` to\n`size_t`). true by default.\n\n`WarnOnIntegerToFloatingPointNarrowingConversion```Â¶\n\n    \n\nWhen true, the check will warn on narrowing integer to floating-point\nconversion (e.g. `size_t` to `double`). true by default.\n\n`WarnOnFloatingPointNarrowingConversion```Â¶\n\n    \n\nWhen true, the check will warn on narrowing floating point conversion (e.g.\n`double` to `float`). true by default.\n\n`WarnWithinTemplateInstantiation```Â¶\n\n    \n\nWhen true, the check will warn on narrowing conversions within template\ninstantiations. false by default.\n\n`WarnOnEquivalentBitWidth```Â¶\n\n    \n\nWhen true, the check will warn on narrowing conversions that arise from\ncasting between types of equivalent bit width. (e.g. int n = uint(0); or long\nlong n = double(0);) true by default.\n\n`IgnoreConversionFromTypes```Â¶\n\n    \n\nNarrowing conversions from any type in this semicolon-separated list will be\nignored. This may be useful to weed out commonly occurring, but less commonly\nproblematic assignments such as int n = std::vector<char>().size(); or int n =\nstd::difference(it1, it2);. The default list is empty, but one suggested list\nfor a legacy codebase would be size_t;ptrdiff_t;size_type;difference_type.\n\n`PedanticMode```Â¶\n\n    \n\nWhen true, the check will warn on assigning a floating point constant to an\ninteger value even if the floating point value is exactly representable in the\ndestination type (e.g. `int i = 1.0;`). false by default.\n\n## FAQÂ¶\n\n>   * What does ânarrowing conversion from âintâ to âfloatââ mean?\n>\n\nAn IEEE754 Floating Point number can represent all integer values in the range\n[-2^PrecisionBits, 2^PrecisionBits] where PrecisionBits is the number of bits\nin the mantissa.\n\nFor `float` this would be [-2^23, 2^23], where `int` can represent values in\nthe range [-2^31, 2^31-1].\n\n>   * What does âimplementation-definedâ mean?\n>\n\nYou may have encountered messages like ânarrowing conversion from\nâunsigned intâ to signed type âintâ is implementation-definedâ. The\nC/C++ standard does not mandate twoâs complement for signed integers, and so\nthe compiler is free to define what the semantics are for converting an\nunsigned integer to signed integer. Clangâs implementation uses the twoâs\ncomplement format.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-no-malloc",
                "display_name": "cppcoreguidelines-no-malloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-no-mallocÂ¶\n\nThis check handles C-Style memory management using `malloc()`, `realloc()`,\n`calloc()` and `free()`. It warns about its use and tries to suggest the use\nof an appropriate RAII object. Furthermore, it can be configured to check\nagainst a user-specified list of functions that are used for memory management\n(e.g. `posix_memalign()`). See [C++ Core\nGuidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rr-\nmallocfree).\n\nThere is no attempt made to provide fix-it hints, since manual resource\nmanagement isnât easily transformed automatically into RAII.\n\n    \n    \n    // Warns each of the following lines.\n    // Containers like std::vector or std::string should be used.\n    char* some_string = (char*) malloc(sizeof(char) * 20);\n    char* some_string = (char*) realloc(sizeof(char) * 30);\n    free(some_string);\n    \n    int* int_array = (int*) calloc(30, sizeof(int));\n    \n    // Rather use a smartpointer or stack variable.\n    struct some_struct* s = (struct some_struct*) malloc(sizeof(struct some_struct));\n    \n\n## OptionsÂ¶\n\n`Allocations```Â¶\n\n    \n\nSemicolon-separated list of fully qualified names of memory allocation\nfunctions. Defaults to `::malloc;::calloc`.\n\n`Deallocations```Â¶\n\n    \n\nSemicolon-separated list of fully qualified names of memory allocation\nfunctions. Defaults to `::free`.\n\n`Reallocations```Â¶\n\n    \n\nSemicolon-separated list of fully qualified names of memory allocation\nfunctions. Defaults to `::realloc`.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-non-private-member-variables-in-classes",
                "display_name": "cppcoreguidelines-non-private-member-variables-in-classes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-non-private-member-variables-in-classesÂ¶\n\nThe cppcoreguidelines-non-private-member-variables-in-classes check is an\nalias, please see [misc-non-private-member-variables-in-classes](../misc/non-\nprivate-member-variables-in-classes.html) for more information.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-owning-memory",
                "display_name": "cppcoreguidelines-owning-memory",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-owning-memoryÂ¶\n\nThis check implements the type-based semantics of `gsl::owner<T*>`, which\nallows static analysis on code, that uses raw pointers to handle resources\nlike dynamic memory, but wonât introduce RAII concepts.\n\nThe relevant sections in the [C++ Core\nGuidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)\nare I.11, C.33, R.3 and GSL.Views The definition of a `gsl::owner<T*>` is\nstraight forward\n\n    \n    \n    namespace gsl { template <typename T> owner = T; }\n    \n\nIt is therefore simple to introduce the owner even without using an\nimplementation of the [Guideline Support\nLibrary](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#gsl-\nguideline-support-library).\n\nAll checks are purely type based and not (yet) flow sensitive.\n\nThe following examples will demonstrate the correct and incorrect\ninitializations of owners, assignment is handled the same way. Note that both\n`new` and `malloc()`-like resource functions are considered to produce\nresources.\n\n    \n    \n    // Creating an owner with factory functions is checked.\n    gsl::owner<int*> function_that_returns_owner() { return gsl::owner<int*>(new int(42)); }\n    \n    // Dynamic memory must be assigned to an owner\n    int* Something = new int(42); // BAD, will be caught\n    gsl::owner<int*> Owner = new int(42); // Good\n    gsl::owner<int*> Owner = new int[42]; // Good as well\n    \n    // Returned owner must be assigned to an owner\n    int* Something = function_that_returns_owner(); // Bad, factory function\n    gsl::owner<int*> Owner = function_that_returns_owner(); // Good, result lands in owner\n    \n    // Something not a resource or owner should not be assigned to owners\n    int Stack = 42;\n    gsl::owner<int*> Owned = &Stack; // Bad, not a resource assigned\n    \n\nIn the case of dynamic memory as resource, only `gsl::owner<T*>` variables are\nallowed to be deleted.\n\n    \n    \n    // Example Bad, non-owner as resource handle, will be caught.\n    int* NonOwner = new int(42); // First warning here, since new must land in an owner\n    delete NonOwner; // Second warning here, since only owners are allowed to be deleted\n    \n    // Example Good, Ownership correctly stated\n    gsl::owner<int*> Owner = new int(42); // Good\n    delete Owner; // Good as well, statically enforced, that only owners get deleted\n    \n\nThe check will furthermore ensure, that functions, that expect a\n`gsl::owner<T*>` as argument get called with either a `gsl::owner<T*>` or a\nnewly created resource.\n\n    \n    \n    void expects_owner(gsl::owner<int*> o) { delete o; }\n    \n    // Bad Code\n    int NonOwner = 42;\n    expects_owner(&NonOwner); // Bad, will get caught\n    \n    // Good Code\n    gsl::owner<int*> Owner = new int(42);\n    expects_owner(Owner); // Good\n    expects_owner(new int(42)); // Good as well, recognized created resource\n    \n    // Port legacy code for better resource-safety\n    gsl::owner<FILE*> File = fopen(\"my_file.txt\", \"rw+\");\n    FILE* BadFile = fopen(\"another_file.txt\", \"w\"); // Bad, warned\n    \n    // ... use the file\n    \n    fclose(File); // Ok, File is annotated as 'owner<>'\n    fclose(BadFile); // BadFile is not an 'owner<>', will be warned\n    \n\n## OptionsÂ¶\n\n`LegacyResourceProducers```Â¶\n\n    \n\nSemicolon-separated list of fully qualified names of legacy functions that\ncreate resources but cannot introduce `gsl::owner<>`. Defaults to\n`::malloc;::aligned_alloc;::realloc;::calloc;::fopen;::freopen;::tmpfile`.\n\n`LegacyResourceConsumers```Â¶\n\n    \n\nSemicolon-separated list of fully qualified names of legacy functions\nexpecting resource owners as pointer arguments but cannot introduce\n`gsl::owner<>`. Defaults to `::free;::realloc;::freopen;::fclose`.\n\n## LimitationsÂ¶\n\nUsing `gsl::owner<T*>` in a typedef or alias is not handled correctly.\n\n    \n    \n    using heap_int = gsl::owner<int*>;\n    heap_int allocated = new int(42); // False positive!\n    \n\nThe `gsl::owner<T*>` is declared as a templated type alias. In template\nfunctions and classes, like in the example below, the information of the type\naliases gets lost. Therefore using `gsl::owner<T*>` in a heavy templated code\nbase might lead to false positives.\n\nKnown code constructs that do not get diagnosed correctly are:\n\n  * `std::exchange`\n  * `std::vector<gsl::owner<T*>>`\n\n    \n    \n    // This template function works as expected. Type information doesn't get lost.\n    template <typename T>\n    void delete_owner(gsl::owner<T*> owned_object) {\n      delete owned_object; // Everything alright\n    }\n    \n    gsl::owner<int*> function_that_returns_owner() { return gsl::owner<int*>(new int(42)); }\n    \n    // Type deduction does not work for auto variables.\n    // This is caught by the check and will be noted accordingly.\n    auto OwnedObject = function_that_returns_owner(); // Type of OwnedObject will be int*\n    \n    // Problematic function template that looses the typeinformation on owner\n    template <typename T>\n    void bad_template_function(T some_object) {\n      // This line will trigger the warning, that a non-owner is assigned to an owner\n      gsl::owner<T*> new_owner = some_object;\n    }\n    \n    // Calling the function with an owner still yields a false positive.\n    bad_template_function(gsl::owner<int*>(new int(42)));\n    \n    \n    // The same issue occurs with templated classes like the following.\n    template <typename T>\n    class OwnedValue {\n    public:\n      const T getValue() const { return _val; }\n    private:\n      T _val;\n    };\n    \n    // Code, that yields a false positive.\n    OwnedValue<gsl::owner<int*>> Owner(new int(42)); // Type deduction yield T -> int *\n    // False positive, getValue returns int* and not gsl::owner<int*>\n    gsl::owner<int*> OwnedInt = Owner.getValue();\n    \n\nAnother limitation of the current implementation is only the type based\nchecking. Suppose you have code like the following:\n\n    \n    \n    // Two owners with assigned resources\n    gsl::owner<int*> Owner1 = new int(42);\n    gsl::owner<int*> Owner2 = new int(42);\n    \n    Owner2 = Owner1; // Conceptual Leak of initial resource of Owner2!\n    Owner1 = nullptr;\n    \n\nThe semantic of a `gsl::owner<T*>` is mostly like a `std::unique_ptr<T>`,\ntherefore assignment of two `gsl::owner<T*>` is considered a move, which\nrequires that the resource `Owner2` must have been released before the\nassignment. This kind of condition could be caught in later improvements of\nthis check with flowsensitive analysis. Currently, the Clang Static Analyzer\ncatches this bug for dynamic memory, but not for general types of resources.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-prefer-member-initializer",
                "display_name": "cppcoreguidelines-prefer-member-initializer",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-prefer-member-initializerÂ¶\n\nFinds member initializations in the constructor body which can be converted\ninto member initializers of the constructor instead. This not only improves\nthe readability of the code but also positively affects its performance.\nClass-member assignments inside a control statement or following the first\ncontrol statement are ignored.\n\nThis check implements\n[C.49](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c49-prefer-\ninitialization-to-assignment-in-constructors) from the CppCoreGuidelines.\n\nIf the language version is C++ 11 or above, the constructor is the default\nconstructor of the class, the field is not a bitfield (only in case of earlier\nlanguage version than C++ 20), furthermore the assigned value is a literal,\nnegated literal or `enum` constant then the preferred place of the\ninitialization is at the class member declaration.\n\nThis latter rule is\n[C.48](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c48-prefer-\nin-class-initializers-to-member-initializers-in-constructors-for-constant-\ninitializers) from CppCoreGuidelines.\n\nPlease note, that this check does not enforce this latter rule for\ninitializations already implemented as member initializers. For that purpose\nsee check [modernize-use-default-member-init](../modernize/use-default-member-\ninit.html).\n\n## Example 1Â¶\n\n    \n    \n    class C {\n      int n;\n      int m;\n    public:\n      C() {\n        n = 1; // Literal in default constructor\n        if (dice())\n          return;\n        m = 1;\n      }\n    };\n    \n\nHere `n` can be initialized using a default member initializer, unlike `m`, as\n`m`âs initialization follows a control statement (`if`):\n\n    \n    \n    class C {\n      int n{1};\n      int m;\n    public:\n      C() {\n        if (dice())\n          return;\n        m = 1;\n      }\n    \n\n## Example 2Â¶\n\n    \n    \n    class C {\n      int n;\n      int m;\n    public:\n      C(int nn, int mm) {\n        n = nn; // Neither default constructor nor literal\n        if (dice())\n          return;\n        m = mm;\n      }\n    };\n    \n\nHere `n` can be initialized in the constructor initialization list, unlike\n`m`, as `m`âs initialization follows a control statement (`if`):\n\n    \n    \n    C(int nn, int mm) : n(nn) {\n      if (dice())\n        return;\n      m = mm;\n    }\n    \n\n`UseAssignment```Â¶\n\n    \n\nIf this option is set to true (default is false), the check will initialize\nmembers with an assignment. In this case the fix of the first example looks\nlike this:\n\n    \n    \n    class C {\n      int n = 1;\n      int m;\n    public:\n      C() {\n        if (dice())\n          return;\n        m = 1;\n      }\n    };",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-bounds-array-to-pointer-decay",
                "display_name": "cppcoreguidelines-pro-bounds-array-to-pointer-decay",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-bounds-array-to-pointer-decayÂ¶\n\nThis check flags all array to pointer decays.\n\nPointers should not be used as arrays. `span<T>` is a bounds-checked, safe\nalternative to using pointers to access arrays.\n\nThis rule is part of the âBounds safetyâ profile of the C++ Core\nGuidelines, see\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\nbounds-decay>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-bounds-constant-array-index",
                "display_name": "cppcoreguidelines-pro-bounds-constant-array-index",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-bounds-constant-array-indexÂ¶\n\nThis check flags all array subscript expressions on static arrays and\n`std::arrays` that either do not have a constant integer expression index or\nare out of bounds (for `std::array`). For out-of-bounds checking of static\narrays, see the -Warray-bounds Clang diagnostic.\n\nThis rule is part of the âBounds safetyâ profile of the C++ Core\nGuidelines, see\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\nbounds-arrayindex>.\n\nOptionally, this check can generate fixes using `gsl::at` for indexing.\n\n## OptionsÂ¶\n\n`GslHeader```Â¶\n\n    \n\nThe check can generate fixes after this option has been set to the name of the\ninclude file that contains `gsl::at()`, e.g. âgsl/gsl.hâ.\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-bounds-pointer-arithmetic",
                "display_name": "cppcoreguidelines-pro-bounds-pointer-arithmetic",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-bounds-pointer-arithmeticÂ¶\n\nThis check flags all usage of pointer arithmetic, because it could lead to an\ninvalid pointer. Subtraction of two pointers is not flagged by this check.\n\nPointers should only refer to single objects, and pointer arithmetic is\nfragile and easy to get wrong. `span<T>` is a bounds-checked, safe type for\naccessing arrays of data.\n\nThis rule is part of the âBounds safetyâ profile of the C++ Core\nGuidelines, see\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\nbounds-arithmetic>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-const-cast",
                "display_name": "cppcoreguidelines-pro-type-const-cast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-const-castÂ¶\n\nThis check flags all uses of `const_cast` in C++ code.\n\nModifying a variable that was declared const is undefined behavior, even with\n`const_cast`.\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-constcast>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-cstyle-cast",
                "display_name": "cppcoreguidelines-pro-type-cstyle-cast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-cstyle-castÂ¶\n\nThis check flags all use of C-style casts that perform a `static_cast`\ndowncast, `const_cast`, or `reinterpret_cast`.\n\nUse of these casts can violate type safety and cause the program to access a\nvariable that is actually of type X to be accessed as if it were of an\nunrelated type Z. Note that a C-style `(T)expression` cast means to perform\nthe first of the following that is possible: a `const_cast`, a `static_cast`,\na `static_cast` followed by a `const_cast`, a `reinterpret_cast`, or a\n`reinterpret_cast` followed by a `const_cast`. This rule bans `(T)expression`\nonly when used to perform an unsafe cast.\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-cstylecast>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-member-init",
                "display_name": "cppcoreguidelines-pro-type-member-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-member-initÂ¶\n\nThe check flags user-defined constructor definitions that do not initialize\nall fields that would be left in an undefined state by default construction,\ne.g. builtins, pointers and record types without user-provided default\nconstructors containing at least one such type. If these fields arenât\ninitialized, the constructor will leave some of the memory in an undefined\nstate.\n\nFor C++11 it suggests fixes to add in-class field initializers. For older\nversions it inserts the field initializers into the constructor initializer\nlist. It will also initialize any direct base classes that need to be zeroed\nin the constructor initializer list.\n\nThe check takes assignment of fields in the constructor body into account but\ngenerates false positives for fields initialized in methods invoked in the\nconstructor body.\n\nThe check also flags variables with automatic storage duration that have\nrecord types without a user-provided constructor and are not initialized. The\nsuggested fix is to zero initialize the variable via `{}` for C++11 and beyond\nor `= {}` for older language versions.\n\n## OptionsÂ¶\n\n`IgnoreArrays```Â¶\n\n    \n\nIf set to true, the check will not warn about array members that are not zero-\ninitialized during construction. For performance critical code, it may be\nimportant to not initialize fixed-size array members. Default is false.\n\n`UseAssignment```Â¶\n\n    \n\nIf set to true, the check will provide fix-its with literal initializers (\n`int i = 0;` ) instead of curly braces ( `int i{};` ).\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\ncorresponding to rule Type.6. See\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-memberinit>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-reinterpret-cast",
                "display_name": "cppcoreguidelines-pro-type-reinterpret-cast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-reinterpret-castÂ¶\n\nThis check flags all uses of `reinterpret_cast` in C++ code.\n\nUse of these casts can violate type safety and cause the program to access a\nvariable that is actually of type `X` to be accessed as if it were of an\nunrelated type `Z`.\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-reinterpretcast>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-static-cast-downcast",
                "display_name": "cppcoreguidelines-pro-type-static-cast-downcast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-static-cast-downcastÂ¶\n\nThis check flags all usages of `static_cast`, where a base class is casted to\na derived class. In those cases, a fix-it is provided to convert the cast to a\n`dynamic_cast`.\n\nUse of these casts can violate type safety and cause the program to access a\nvariable that is actually of type `X` to be accessed as if it were of an\nunrelated type `Z`.\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-downcast>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-union-access",
                "display_name": "cppcoreguidelines-pro-type-union-access",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-union-accessÂ¶\n\nThis check flags all access to members of unions. Passing unions as a whole is\nnot flagged.\n\nReading from a union member assumes that member was the last one written, and\nwriting to a union member assumes another member with a nontrivial destructor\nhad its destructor called. This is fragile because it cannot generally be\nenforced to be safe in the language and so relies on programmer discipline to\nget it right.\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-unions>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-pro-type-vararg",
                "display_name": "cppcoreguidelines-pro-type-vararg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-pro-type-varargÂ¶\n\nThis check flags all calls to c-style vararg functions and all use of\n`va_arg`.\n\nTo allow for SFINAE use of vararg functions, a call is not flagged if a\nliteral 0 is passed as the only vararg argument.\n\nPassing to varargs assumes the correct type will be read. This is fragile\nbecause it cannot generally be enforced to be safe in the language and so\nrelies on programmer discipline to get it right.\n\nThis rule is part of the âType safetyâ profile of the C++ Core Guidelines,\nsee\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-\ntype-varargs>.",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-slicing",
                "display_name": "cppcoreguidelines-slicing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-slicingÂ¶\n\nFlags slicing of member variables or vtable. Slicing happens when copying a\nderived object into a base object: the members of the derived object (both\nmember variables and virtual member functions) will be discarded. This can be\nmisleading especially for member function slicing, for example:\n\n    \n    \n    struct B { int a; virtual int f(); };\n    struct D : B { int b; int f() override; };\n    \n    void use(B b) {  // Missing reference, intended?\n      b.f();  // Calls B::f.\n    }\n    \n    D d;\n    use(d);  // Slice.\n    \n\nSee the relevant C++ Core Guidelines sections for details:\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es63-dont-\nslice>\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c145-access-\npolymorphic-objects-through-pointers-and-references>",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-special-member-functions",
                "display_name": "cppcoreguidelines-special-member-functions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-special-member-functionsÂ¶\n\nThe check finds classes where some but not all of the special member functions\nare defined.\n\nBy default the compiler defines a copy constructor, copy assignment operator,\nmove constructor, move assignment operator and destructor. The default can be\nsuppressed by explicit user-definitions. The relationship between which\nfunctions will be suppressed by definitions of other functions is complicated\nand it is advised that all five are defaulted or explicitly defined.\n\nNote that defining a function with `= delete` is considered to be a\ndefinition.\n\nThis rule is part of the âConstructors, assignments, and destructorsâ\nprofile of the C++ Core Guidelines, corresponding to rule C.21. See\n\n<https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c21-if-\nyou-define-or-delete-any-default-operation-define-or-delete-them-all>.\n\n## OptionsÂ¶\n\n`AllowSoleDefaultDtor```Â¶\n\n    \n\nWhen set to true (default is false), this check doesnât flag classes with a\nsole, explicitly defaulted destructor. An example for such a class is:\n\n    \n    \n    struct A {\n      virtual ~A() = default;\n    };\n    \n\n`AllowMissingMoveFunctions```Â¶\n\n    \n\nWhen set to true (default is false), this check doesnât flag classes which\ndefine no move operations at all. It still flags classes which define only one\nof either move constructor or move assignment operator. With this option\nenabled, the following class wonât be flagged:\n\n    \n    \n    struct A {\n      A(const A&);\n      A& operator=(const A&);\n      ~A();\n    };\n    \n\n`AllowMissingMoveFunctionsWhenCopyIsDeleted```Â¶\n\n    \n\nWhen set to true (default is false), this check doesnât flag classes which\ndefine deleted copy operations but donât define move operations. This flag\nis related to Google C++ Style Guide\n<https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types>.\nWith this option enabled, the following class wonât be flagged:\n\n    \n    \n    struct A {\n      A(const A&) = delete;\n      A& operator=(const A&) = delete;\n      ~A();\n    };",
                "disable": false
            },
            {
                "real_name": "cppcoreguidelines-virtual-class-destructor",
                "display_name": "cppcoreguidelines-virtual-class-destructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# cppcoreguidelines-virtual-class-destructorÂ¶\n\nFinds virtual classes whose destructor is neither public and virtual nor\nprotected and non-virtual. A virtual classâs destructor should be specified\nin one of these ways to prevent undefined behavior.\n\nThis check implements\n[C.35](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-\nvirtual) from the CppCoreGuidelines.\n\nNote that this check will diagnose a class with a virtual method regardless of\nwhether the class is used as a base class or not.\n\nFixes are available for user-declared and implicit destructors that are either\npublic and non-virtual or protected and virtual. No fixes are offered for\nprivate destructors. There, the decision whether to make them private and\nvirtual or protected and non-virtual depends on the use case and is thus left\nto the user.\n\n## ExampleÂ¶\n\nFor example, the following classes/structs get flagged by the check since they\nviolate guideline **C.35** :\n\n    \n    \n    struct Foo {        // NOK, protected destructor should not be virtual\n      virtual void f();\n    protected:\n      virtual ~Foo(){}\n    };\n    \n    class Bar {         // NOK, public destructor should be virtual\n      virtual void f();\n    public:\n      ~Bar(){}\n    };\n    \n\nThis would be rewritten to look like this:\n\n    \n    \n    struct Foo {        // OK, destructor is not virtual anymore\n      virtual void f();\n    protected:\n      ~Foo(){}\n    };\n    \n    class Bar {         // OK, destructor is now virtual\n      virtual void f();\n    public:\n      virtual ~Bar(){}\n    };",
                "disable": false
            },
            {
                "real_name": "darwin-avoid-spinlock",
                "display_name": "darwin-avoid-spinlock",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# darwin-avoid-spinlockÂ¶\n\nFinds usages of `OSSpinlock`, which is deprecated due to potential livelock\nproblems.\n\nThis check will detect following function invocations:\n\n  * `OSSpinlockLock`\n  * `OSSpinlockTry`\n  * `OSSpinlockUnlock`\n\nThe corresponding information about the problem of `OSSpinlock`:\n<https://blog.postmates.com/why-spinlocks-are-bad-on-ios-b69fc5221058>",
                "disable": false
            },
            {
                "real_name": "darwin-dispatch-once-nonstatic",
                "display_name": "darwin-dispatch-once-nonstatic",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# darwin-dispatch-once-nonstaticÂ¶\n\nFinds declarations of `dispatch_once_t` variables without static or global\nstorage. The behavior of using `dispatch_once_t` predicates with automatic or\ndynamic storage is undefined by libdispatch, and should be avoided.\n\nIt is a common pattern to have functions initialize internal static or global\ndata once when the function runs, but programmers have been known to miss the\nstatic on the `dispatch_once_t` predicate, leading to an uninitialized flag\nvalue at the mercy of the stack.\n\nProgrammers have also been known to make `dispatch_once_t` variables be\nmembers of structs or classes, with the intent to lazily perform some\nexpensive struct or class member initialization only once; however, this\nviolates the libdispatch requirements.\n\nSee the discussion section of [Appleâs dispatch_once\ndocumentation](https://developer.apple.com/documentation/dispatch/1447169-dispatch_once)\nfor more information.",
                "disable": false
            },
            {
                "real_name": "fuchsia-default-arguments-calls",
                "display_name": "fuchsia-default-arguments-calls",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-default-arguments-callsÂ¶\n\nWarns if a function or method is called with default arguments.\n\nFor example, given the declaration:\n\n    \n    \n    int foo(int value = 5) { return value; }\n    \n\nA function call expression that uses a default argument will be diagnosed.\nCalling it without defaults will not cause a warning:\n\n    \n    \n    foo();  // warning\n    foo(0); // no warning\n    \n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "fuchsia-default-arguments-declarations",
                "display_name": "fuchsia-default-arguments-declarations",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-default-arguments-declarationsÂ¶\n\nWarns if a function or method is declared with default parameters.\n\nFor example, the declaration:\n\n    \n    \n    int foo(int value = 5) { return value; }\n    \n\nwill cause a warning.\n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "fuchsia-header-anon-namespaces",
                "display_name": "fuchsia-header-anon-namespaces",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-header-anon-namespacesÂ¶\n\nThe fuchsia-header-anon-namespaces check is an alias, please see [google-\nbuild-namespace](../google/build-namespaces.html) for more information.",
                "disable": false
            },
            {
                "real_name": "fuchsia-multiple-inheritance",
                "display_name": "fuchsia-multiple-inheritance",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-multiple-inheritanceÂ¶\n\nWarns if a class inherits from multiple classes that are not pure virtual.\n\nFor example, declaring a class that inherits from multiple concrete classes is\ndisallowed:\n\n    \n    \n    class Base_A {\n    public:\n      virtual int foo() { return 0; }\n    };\n    \n    class Base_B {\n    public:\n      virtual int bar() { return 0; }\n    };\n    \n    // Warning\n    class Bad_Child1 : public Base_A, Base_B {};\n    \n\nA class that inherits from a pure virtual is allowed:\n\n    \n    \n    class Interface_A {\n    public:\n      virtual int foo() = 0;\n    };\n    \n    class Interface_B {\n    public:\n      virtual int bar() = 0;\n    };\n    \n    // No warning\n    class Good_Child1 : public Interface_A, Interface_B {\n      virtual int foo() override { return 0; }\n      virtual int bar() override { return 0; }\n    };\n    \n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "fuchsia-overloaded-operator",
                "display_name": "fuchsia-overloaded-operator",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-overloaded-operatorÂ¶\n\nWarns if an operator is overloaded, except for the assignment (copy and move)\noperators.\n\nFor example:\n\n    \n    \n    int operator+(int);     // Warning\n    \n    B &operator=(const B &Other);  // No warning\n    B &operator=(B &&Other) // No warning\n    \n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "fuchsia-statically-constructed-objects",
                "display_name": "fuchsia-statically-constructed-objects",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-statically-constructed-objectsÂ¶\n\nWarns if global, non-trivial objects with static storage are constructed,\nunless the object is statically initialized with a `constexpr` constructor or\nhas no explicit constructor.\n\nFor example:\n\n    \n    \n    class A {};\n    \n    class B {\n    public:\n      B(int Val) : Val(Val) {}\n    private:\n      int Val;\n    };\n    \n    class C {\n    public:\n      C(int Val) : Val(Val) {}\n      constexpr C() : Val(0) {}\n    \n    private:\n      int Val;\n    };\n    \n    static A a;         // No warning, as there is no explicit constructor\n    static C c(0);      // No warning, as constructor is constexpr\n    \n    static B b(0);      // Warning, as constructor is not constexpr\n    static C c2(0, 1);  // Warning, as constructor is not constexpr\n    \n    static int i;       // No warning, as it is trivial\n    \n    extern int get_i();\n    static C(get_i())   // Warning, as the constructor is dynamically initialized\n    \n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "fuchsia-trailing-return",
                "display_name": "fuchsia-trailing-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-trailing-returnÂ¶\n\nFunctions that have trailing returns are disallowed, except for those using\n`decltype` specifiers and lambda with otherwise unutterable return types.\n\nFor example:\n\n    \n    \n    // No warning\n    int add_one(const int arg) { return arg; }\n    \n    // Warning\n    auto get_add_one() -> int (*)(const int) {\n      return add_one;\n    }\n    \n\nExceptions are made for lambdas and `decltype` specifiers:\n\n    \n    \n    // No warning\n    auto lambda = [](double x, double y) -> double {return x + y;};\n    \n    // No warning\n    template <typename T1, typename T2>\n    auto fn(const T1 &lhs, const T2 &rhs) -> decltype(lhs + rhs) {\n      return lhs + rhs;\n    }\n    \n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "fuchsia-virtual-inheritance",
                "display_name": "fuchsia-virtual-inheritance",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# fuchsia-virtual-inheritanceÂ¶\n\nWarns if classes are defined with virtual inheritance.\n\nFor example, classes should not be defined with virtual inheritance:\n\n    \n    \n    class B : public virtual A {};   // warning\n    \n\nSee the features disallowed in Fuchsia at\n<https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md>",
                "disable": false
            },
            {
                "real_name": "google-build-explicit-make-pair",
                "display_name": "google-build-explicit-make-pair",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-build-explicit-make-pairÂ¶\n\nCheck that `make_pair`âs template arguments are deduced.\n\nG++ 4.6 in C++11 mode fails badly if `make_pair`âs template arguments are\nspecified explicitly, and such use isnât intended in any case.\n\nCorresponding cpplint.py check name: build/explicit_make_pair.",
                "disable": false
            },
            {
                "real_name": "google-build-namespaces",
                "display_name": "google-build-namespaces",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-build-namespacesÂ¶\n\ncert-dcl59-cpp redirects here as an alias for this check. fuchsia-header-anon-\nnamespaces redirects here as an alias for this check.\n\nFinds anonymous namespaces in headers.\n\n<https://google.github.io/styleguide/cppguide.html#Namespaces>\n\nCorresponding cpplint.py check name: build/namespaces.\n\n## OptionsÂ¶\n\n`HeaderFileExtensions```Â¶\n\n    \n\nA comma-separated list of filename extensions of header files (the filename\nextensions should not include â.â prefix). Default is âh,hh,hpp,hxxâ.\nFor header files without an extension, use an empty string (if there are no\nother desired extensions) or leave an empty element in the list. E.g.,\nâh,hh,hpp,hxx,â (note the trailing comma).",
                "disable": false
            },
            {
                "real_name": "google-build-using-namespace",
                "display_name": "google-build-using-namespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-build-using-namespaceÂ¶\n\nFinds `using namespace` directives.\n\nThe check implements the following rule of the [Google C++ Style\nGuide](https://google.github.io/styleguide/cppguide.html#Namespaces):\n\n> You may not use a using-directive to make all names from a namespace\n> available.\n    \n    \n    // Forbidden -- This pollutes the namespace.\n    using namespace foo;\n    \n\nCorresponding cpplint.py check name: build/namespaces.",
                "disable": false
            },
            {
                "real_name": "google-default-arguments",
                "display_name": "google-default-arguments",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-default-argumentsÂ¶\n\nChecks that default arguments are not given for virtual methods.\n\nSee <https://google.github.io/styleguide/cppguide.html#Default_Arguments>",
                "disable": false
            },
            {
                "real_name": "google-explicit-constructor",
                "display_name": "google-explicit-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-explicit-constructorÂ¶\n\nChecks that constructors callable with a single argument and conversion\noperators are marked explicit to avoid the risk of unintentional implicit\nconversions.\n\nConsider this example:\n\n    \n    \n    struct S {\n      int x;\n      operator bool() const { return true; }\n    };\n    \n    bool f() {\n      S a{1};\n      S b{2};\n      return a == b;\n    }\n    \n\nThe function will return `true`, since the objects are implicitly converted to\n`bool` before comparison, which is unlikely to be the intent.\n\nThe check will suggest inserting `explicit` before the constructor or\nconversion operator declaration. However, copy and move constructors should\nnot be explicit, as well as constructors taking a single `initializer_list`\nargument.\n\nThis code:\n\n    \n    \n    struct S {\n      S(int a);\n      explicit S(const S&);\n      operator bool() const;\n      ...\n    \n\nwill become\n\n    \n    \n    struct S {\n      explicit S(int a);\n      S(const S&);\n      explicit operator bool() const;\n      ...\n    \n\nSee <https://google.github.io/styleguide/cppguide.html#Explicit_Constructors>",
                "disable": false
            },
            {
                "real_name": "google-global-names-in-headers",
                "display_name": "google-global-names-in-headers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-global-names-in-headersÂ¶\n\nFlag global namespace pollution in header files. Right now it only triggers on\n`using` declarations and directives.\n\nThe relevant style guide section is\n<https://google.github.io/styleguide/cppguide.html#Namespaces>.\n\n## OptionsÂ¶\n\n`HeaderFileExtensions```Â¶\n\n    \n\nA comma-separated list of filename extensions of header files (the filename\nextensions should not contain â.â prefix). Default is âhâ. For header\nfiles without an extension, use an empty string (if there are no other desired\nextensions) or leave an empty element in the list. E.g., âh,hh,hpp,hxx,â\n(note the trailing comma).",
                "disable": false
            },
            {
                "real_name": "google-objc-avoid-nsobject-new",
                "display_name": "google-objc-avoid-nsobject-new",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-objc-avoid-nsobject-newÂ¶\n\nFinds calls to `+new` or overrides of it, which are prohibited by the Google\nObjective-C style guide.\n\nThe Google Objective-C style guide forbids calling `+new` or overriding it in\nclass implementations, preferring `+alloc` and `-init` methods to instantiate\nobjects.\n\nAn example:\n\n    \n    \n    NSDate *now = [NSDate new];\n    Foo *bar = [Foo new];\n    \n\nInstead, code should use `+alloc`/`-init` or class factory methods.\n\n    \n    \n    NSDate *now = [NSDate date];\n    Foo *bar = [[Foo alloc] init];\n    \n\nThis check corresponds to the Google Objective-C Style Guide rule [Do Not Use\n+new](https://google.github.io/styleguide/objcguide.html#do-not-use-new).",
                "disable": false
            },
            {
                "real_name": "google-objc-avoid-throwing-exception",
                "display_name": "google-objc-avoid-throwing-exception",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-objc-avoid-throwing-exceptionÂ¶\n\nFinds uses of throwing exceptions usages in Objective-C files.\n\nFor the same reason as the Google C++ style guide, we prefer not throwing\nexceptions from Objective-C code.\n\nThe corresponding C++ style guide rule:\n<https://google.github.io/styleguide/cppguide.html#Exceptions>\n\nInstead, prefer passing in `NSError **` and return `BOOL` to indicate success\nor failure.\n\nA counterexample:\n\n    \n    \n    - (void)readFile {\n      if ([self isError]) {\n        @throw [NSException exceptionWithName:...];\n      }\n    }\n    \n\nInstead, returning an error via `NSError **` is preferred:\n\n    \n    \n    - (BOOL)readFileWithError:(NSError **)error {\n      if ([self isError]) {\n        *error = [NSError errorWithDomain:...];\n        return NO;\n      }\n      return YES;\n    }\n    \n\nThe corresponding style guide rule:\n<https://google.github.io/styleguide/objcguide.html#avoid-throwing-exceptions>",
                "disable": false
            },
            {
                "real_name": "google-objc-function-naming",
                "display_name": "google-objc-function-naming",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-objc-function-namingÂ¶\n\nFinds function declarations in Objective-C files that do not follow the\npattern described in the Google Objective-C Style Guide.\n\nThe corresponding style guide rule can be found here:\n<https://google.github.io/styleguide/objcguide.html#function-names>\n\nAll function names should be in Pascal case. Functions whose storage class is\nnot static should have an appropriate prefix.\n\nThe following code sample does not follow this pattern:\n\n    \n    \n    static bool is_positive(int i) { return i > 0; }\n    bool IsNegative(int i) { return i < 0; }\n    \n\nThe sample above might be corrected to the following code:\n\n    \n    \n    static bool IsPositive(int i) { return i > 0; }\n    bool *ABCIsNegative(int i) { return i < 0; }",
                "disable": false
            },
            {
                "real_name": "google-objc-global-variable-declaration",
                "display_name": "google-objc-global-variable-declaration",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-objc-global-variable-declarationÂ¶\n\nFinds global variable declarations in Objective-C files that do not follow the\npattern of variable names in Googleâs Objective-C Style Guide.\n\nThe corresponding style guide rule:\n<https://google.github.io/styleguide/objcguide.html#variable-names>\n\nAll the global variables should follow the pattern of `g[A-Z].*` (variables)\nor `k[A-Z].*` (constants). The check will suggest a variable name that follows\nthe pattern if it can be inferred from the original name.\n\nFor code:\n\n    \n    \n    static NSString* myString = @\"hello\";\n    \n\nThe fix will be:\n\n    \n    \n    static NSString* gMyString = @\"hello\";\n    \n\nAnother example of constant:\n\n    \n    \n    static NSString* const myConstString = @\"hello\";\n    \n\nThe fix will be:\n\n    \n    \n    static NSString* const kMyConstString = @\"hello\";\n    \n\nHowever for code that prefixed with non-alphabetical characters like:\n\n    \n    \n    static NSString* __anotherString = @\"world\";\n    \n\nThe check will give a warning message but will not be able to suggest a fix.\nThe user needs to fix it on their own.",
                "disable": false
            },
            {
                "real_name": "google-readability-avoid-underscore-in-googletest-name",
                "display_name": "google-readability-avoid-underscore-in-googletest-name",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-readability-avoid-underscore-in-googletest-nameÂ¶\n\nChecks whether there are underscores in googletest test and test case names in\ntest macros:\n\n  * `TEST`\n  * `TEST_F`\n  * `TEST_P`\n  * `TYPED_TEST`\n  * `TYPED_TEST_P`\n\nThe `FRIEND_TEST` macro is not included.\n\nFor example:\n\n    \n    \n    TEST(TestCaseName, Illegal_TestName) {}\n    TEST(Illegal_TestCaseName, TestName) {}\n    \n\nwould trigger the check. [Underscores are not\nallowed](https://github.com/google/googletest/blob/master/googletest/docs/faq.md#why-\nshould-test-suite-names-and-test-names-not-contain-underscore) in test names\nnor test case names.\n\nThe `DISABLED_` prefix, which may be used to [disable individual\ntests](https://github.com/google/googletest/blob/master/googletest/docs/faq.md#why-\nshould-test-suite-names-and-test-names-not-contain-underscore), is ignored\nwhen checking test names, but the rest of the rest of the test name is still\nchecked.\n\nThis check does not propose any fixes.",
                "disable": false
            },
            {
                "real_name": "google-readability-braces-around-statements",
                "display_name": "google-readability-braces-around-statements",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-readability-braces-around-statementsÂ¶\n\nThe google-readability-braces-around-statements check is an alias, please see\n[readability-braces-around-statements](../readability/braces-around-\nstatements.html) for more information.",
                "disable": false
            },
            {
                "real_name": "google-readability-casting",
                "display_name": "google-readability-casting",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-readability-castingÂ¶\n\nFinds usages of C-style casts.\n\n<https://google.github.io/styleguide/cppguide.html#Casting>\n\nCorresponding cpplint.py check name: readability/casting.\n\nThis check is similar to `-Wold-style-cast`, but it suggests automated fixes\nin some cases. The reported locations should not be different from the ones\ngenerated by `-Wold-style-cast`.",
                "disable": false
            },
            {
                "real_name": "google-readability-function-size",
                "display_name": "google-readability-function-size",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-readability-function-sizeÂ¶\n\nThe google-readability-function-size check is an alias, please see\n[readability-function-size](../readability/function-size.html) for more\ninformation.",
                "disable": false
            },
            {
                "real_name": "google-readability-namespace-comments",
                "display_name": "google-readability-namespace-comments",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-readability-namespace-commentsÂ¶\n\nThe google-readability-namespace-comments check is an alias, please see [llvm-\nnamespace-comment](../llvm/namespace-comment.html) for more information.",
                "disable": false
            },
            {
                "real_name": "google-readability-todo",
                "display_name": "google-readability-todo",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-readability-todoÂ¶\n\nFinds TODO comments without a username or bug number.\n\nThe relevant style guide section is\n<https://google.github.io/styleguide/cppguide.html#TODO_Comments>.\n\nCorresponding cpplint.py check: readability/todo",
                "disable": false
            },
            {
                "real_name": "google-runtime-int",
                "display_name": "google-runtime-int",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-runtime-intÂ¶\n\nFinds uses of `short`, `long` and `long long` and suggest replacing them with\n`u?intXX(_t)?`.\n\nThe corresponding style guide rule:\n<https://google.github.io/styleguide/cppguide.html#Integer_Types>.\n\nCorresponding cpplint.py check: runtime/int.\n\n## OptionsÂ¶\n\n`UnsignedTypePrefix```Â¶\n\n    \n\nA string specifying the unsigned type prefix. Default is uint.\n\n`SignedTypePrefix```Â¶\n\n    \n\nA string specifying the signed type prefix. Default is int.\n\n`TypeSuffix```Â¶\n\n    \n\nA string specifying the type suffix. Default is an empty string.",
                "disable": false
            },
            {
                "real_name": "google-runtime-operator",
                "display_name": "google-runtime-operator",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-runtime-operatorÂ¶\n\nFinds overloads of unary `operator &`.\n\n<https://google.github.io/styleguide/cppguide.html#Operator_Overloading>\n\nCorresponding cpplint.py check name: runtime/operator.",
                "disable": false
            },
            {
                "real_name": "google-upgrade-googletest-case",
                "display_name": "google-upgrade-googletest-case",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# google-upgrade-googletest-caseÂ¶\n\nFinds uses of deprecated Google Test version 1.9 APIs with names containing\n`case` and replaces them with equivalent APIs with `suite`.\n\nAll names containing `case` are being replaced to be consistent with the\nmeanings of âtest caseâ and âtest suiteâ as used by the International\nSoftware Testing Qualifications Board and ISO 29119.\n\nThe new names are a part of Google Test version 1.9 (release pending). It is\nrecommended that users update their dependency to version 1.9 and then use\nthis check to remove deprecated names.\n\nThe affected APIs are:\n\n  * Member functions of `testing::Test`, `testing::TestInfo`, `testing::TestEventListener`, `testing::UnitTest`, and any type inheriting from these types\n  * The macros `TYPED_TEST_CASE`, `TYPED_TEST_CASE_P`, `REGISTER_TYPED_TEST_CASE_P`, and `INSTANTIATE_TYPED_TEST_CASE_P`\n  * The type alias `testing::TestCase`\n\nExamples of fixes created by this check:\n\n    \n    \n    class FooTest : public testing::Test {\n    public:\n      static void SetUpTestCase();\n      static void TearDownTestCase();\n    };\n    \n    TYPED_TEST_CASE(BarTest, BarTypes);\n    \n\nbecomes\n\n    \n    \n    class FooTest : public testing::Test {\n    public:\n      static void SetUpTestSuite();\n      static void TearDownTestSuite();\n    };\n    \n    TYPED_TEST_SUITE(BarTest, BarTypes);\n    \n\nFor better consistency of user code, the check renames both virtual and non-\nvirtual member functions with matching names in derived types. The check tries\nto provide only a warning when a fix cannot be made safely, as is the case\nwith some template and macro uses.",
                "disable": false
            },
            {
                "real_name": "hicpp-avoid-c-arrays",
                "display_name": "hicpp-avoid-c-arrays",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-avoid-c-arraysÂ¶\n\nThe hicpp-avoid-c-arrays check is an alias, please see [modernize-avoid-c-\narrays](../modernize/avoid-c-arrays.html) for more information.",
                "disable": false
            },
            {
                "real_name": "hicpp-avoid-goto",
                "display_name": "hicpp-avoid-goto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-avoid-gotoÂ¶\n\nThe hicpp-avoid-goto check is an alias to [cppcoreguidelines-avoid-\ngoto](../cppcoreguidelines/avoid-goto.html). Rule [6.3.1 High Integrity\nC++](http://www.codingstandard.com/rule/6-3-1-ensure-that-the-labels-for-a-\njump-statement-or-a-switch-condition-appear-later-in-the-same-or-an-enclosing-\nblock/) requires that `goto` only skips parts of a block and is not used for\nother reasons.\n\nBoth coding guidelines implement the same exception to the usage of `goto`.",
                "disable": false
            },
            {
                "real_name": "hicpp-braces-around-statements",
                "display_name": "hicpp-braces-around-statements",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-braces-around-statementsÂ¶\n\nThe hicpp-braces-around-statements check is an alias, please see [readability-\nbraces-around-statements](../readability/braces-around-statements.html) for\nmore information. It enforces the [rule\n6.1.1](http://www.codingstandard.com/rule/6-1-1-enclose-the-body-of-a-\nselection-or-an-iteration-statement-in-a-compound-statement/).",
                "disable": false
            },
            {
                "real_name": "hicpp-deprecated-headers",
                "display_name": "hicpp-deprecated-headers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-deprecated-headersÂ¶\n\nThe hicpp-deprecated-headers check is an alias, please see [modernize-\ndeprecated-headers](../modernize/deprecated-headers.html) for more\ninformation. It enforces the [rule\n1.3.3](http://www.codingstandard.com/rule/1-3-3-do-not-use-the-c-standard-\nlibrary-h-headers/).",
                "disable": false
            },
            {
                "real_name": "hicpp-exception-baseclass",
                "display_name": "hicpp-exception-baseclass",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-exception-baseclassÂ¶\n\nEnsure that every value that in a `throw` expression is an instance of\n`std::exception`.\n\nThis enforces [rule 15.1](http://www.codingstandard.com/section/15-1-throwing-\nan-exception/) of the High Integrity C++ Coding Standard.\n\n    \n    \n    class custom_exception {};\n    \n    void throwing() noexcept(false) {\n      // Problematic throw expressions.\n      throw int(42);\n      throw custom_exception();\n    }\n    \n    class mathematical_error : public std::exception {};\n    \n    void throwing2() noexcept(false) {\n      // These kind of throws are ok.\n      throw mathematical_error();\n      throw std::runtime_error();\n      throw std::exception();\n    }",
                "disable": false
            },
            {
                "real_name": "hicpp-explicit-conversions",
                "display_name": "hicpp-explicit-conversions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-explicit-conversionsÂ¶\n\nThis check is an alias for [google-explicit-constructor](../google/explicit-\nconstructor.html). Used to enforce parts of [rule\n5.4.1](http://www.codingstandard.com/rule/5-4-1-only-use-casting-forms-\nstatic_cast-excl-void-dynamic_cast-or-explicit-constructor-call/). This check\nwill enforce that constructors and conversion operators are marked explicit.\nOther forms of casting checks are implemented in other places. The following\nchecks can be used to check for more forms of casting:\n\n  * [cppcoreguidelines-pro-type-static-cast-downcast](../cppcoreguidelines/pro-type-static-cast-downcast.html)\n  * [cppcoreguidelines-pro-type-reinterpret-cast](../cppcoreguidelines/pro-type-reinterpret-cast.html)\n  * [cppcoreguidelines-pro-type-const-cast](../cppcoreguidelines/pro-type-const-cast.html)\n  * [cppcoreguidelines-pro-type-cstyle-cast](../cppcoreguidelines/pro-type-cstyle-cast.html)",
                "disable": false
            },
            {
                "real_name": "hicpp-function-size",
                "display_name": "hicpp-function-size",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-function-sizeÂ¶\n\nThis check is an alias for [readability-function-\nsize](../readability/function-size.html). Useful to enforce multiple sections\non function complexity.\n\n  * [rule 8.2.2](http://www.codingstandard.com/rule/8-2-2-do-not-declare-functions-with-an-excessive-number-of-parameters/)\n  * [rule 8.3.1](http://www.codingstandard.com/rule/8-3-1-do-not-write-functions-with-an-excessive-mccabe-cyclomatic-complexity/)\n  * [rule 8.3.2](http://www.codingstandard.com/rule/8-3-2-do-not-write-functions-with-a-high-static-program-path-count/)",
                "disable": false
            },
            {
                "real_name": "hicpp-invalid-access-moved",
                "display_name": "hicpp-invalid-access-moved",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-invalid-access-movedÂ¶\n\nThis check is an alias for [bugprone-use-after-move](../bugprone/use-after-\nmove.html).\n\nImplements parts of the [rule\n8.4.1](http://www.codingstandard.com/rule/8-4-1-do-not-access-an-invalid-\nobject-or-an-object-with-indeterminate-value/) to check if moved-from objects\nare accessed.",
                "disable": false
            },
            {
                "real_name": "hicpp-member-init",
                "display_name": "hicpp-member-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-member-initÂ¶\n\nThis check is an alias for [cppcoreguidelines-pro-type-member-\ninit](../cppcoreguidelines/pro-type-member-init.html). Implements the check\nfor [rule 12.4.2](http://www.codingstandard.com/rule/12-4-2-ensure-that-a-\nconstructor-initializes-explicitly-all-base-classes-and-non-static-data-\nmembers/) to initialize class members in the right order.",
                "disable": false
            },
            {
                "real_name": "hicpp-move-const-arg",
                "display_name": "hicpp-move-const-arg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-move-const-argÂ¶\n\nThe hicpp-move-const-arg check is an alias, please see [performance-move-\nconst-arg](../performance/move-const-arg.html) for more information. It\nenforces the [rule 17.3.1](http://www.codingstandard.com/rule/17-3-1-do-not-\nuse-stdmove-on-objects-declared-with-const-or-const-type/).",
                "disable": false
            },
            {
                "real_name": "hicpp-multiway-paths-covered",
                "display_name": "hicpp-multiway-paths-covered",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-multiway-paths-coveredÂ¶\n\nThis check discovers situations where code paths are not fully-covered. It\nfurthermore suggests using `if` instead of `switch` if the code will be more\nclear. The [rule 6.1.2](http://www.codingstandard.com/rule/6-1-2-explicitly-\ncover-all-paths-through-multi-way-selection-statements/) and [rule\n6.1.4](http://www.codingstandard.com/rule/6-1-4-ensure-that-a-switch-\nstatement-has-at-least-two-case-labels-distinct-from-the-default-label/) of\nthe High Integrity C++ Coding Standard are enforced.\n\n`if-else if` chains that miss a final `else` branch might lead to unexpected\nprogram execution and be the result of a logical error. If the missing `else`\nbranch is intended you can leave it empty with a clarifying comment. This\nwarning can be noisy on some code bases, so it is disabled by default.\n\n    \n    \n    void f1() {\n      int i = determineTheNumber();\n    \n       if(i > 0) {\n         // Some Calculation\n       } else if (i < 0) {\n         // Precondition violated or something else.\n       }\n       // ...\n    }\n    \n\nSimilar arguments hold for `switch` statements which do not cover all possible\ncode paths.\n\n    \n    \n    // The missing default branch might be a logical error. It can be kept empty\n    // if there is nothing to do, making it explicit.\n    void f2(int i) {\n      switch (i) {\n      case 0: // something\n        break;\n      case 1: // something else\n        break;\n      }\n      // All other numbers?\n    }\n    \n    // Violates this rule as well, but already emits a compiler warning (-Wswitch).\n    enum Color { Red, Green, Blue, Yellow };\n    void f3(enum Color c) {\n      switch (c) {\n      case Red: // We can't drive for now.\n        break;\n      case Green:  // We are allowed to drive.\n        break;\n      }\n      // Other cases missing\n    }\n    \n\nThe [rule 6.1.4](http://www.codingstandard.com/rule/6-1-4-ensure-that-a-\nswitch-statement-has-at-least-two-case-labels-distinct-from-the-default-\nlabel/) requires every `switch` statement to have at least two `case` labels\nother than a default label. Otherwise, the `switch` could be better expressed\nwith an `if` statement. Degenerated `switch` statements without any labels are\ncaught as well.\n\n    \n    \n    // Degenerated switch that could be better written as `if`\n    int i = 42;\n    switch(i) {\n      case 1: // do something here\n      default: // do something else here\n    }\n    \n    // Should rather be the following:\n    if (i == 1) {\n      // do something here\n    }\n    else {\n      // do something here\n    }\n    \n    \n    \n    // A completely degenerated switch will be diagnosed.\n    int i = 42;\n    switch(i) {}\n    \n\n## OptionsÂ¶\n\n`WarnOnMissingElse```Â¶\n\n    \n\nBoolean flag that activates a warning for missing `else` branches. Default is\nfalse.",
                "disable": false
            },
            {
                "real_name": "hicpp-named-parameter",
                "display_name": "hicpp-named-parameter",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-named-parameterÂ¶\n\nThis check is an alias for [readability-named-parameter](../readability/named-\nparameter.html).\n\nImplements [rule 8.2.1](http://www.codingstandard.com/rule/8-2-1-make-\nparameter-names-absent-or-identical-in-all-declarations/).",
                "disable": false
            },
            {
                "real_name": "hicpp-new-delete-operators",
                "display_name": "hicpp-new-delete-operators",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-new-delete-operatorsÂ¶\n\nThis check is an alias for [misc-new-delete-overloads](../misc/new-delete-\noverloads.html). Implements [rule\n12.3.1](http://www.codingstandard.com/section/12-3-free-store/) to ensure the\nnew and delete operators have the correct signature.",
                "disable": false
            },
            {
                "real_name": "hicpp-no-array-decay",
                "display_name": "hicpp-no-array-decay",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-no-array-decayÂ¶\n\nThe hicpp-no-array-decay check is an alias, please see [cppcoreguidelines-pro-\nbounds-array-to-pointer-decay](../cppcoreguidelines/pro-bounds-array-to-\npointer-decay.html) for more information. It enforces the [rule\n4.1.1](http://www.codingstandard.com/section/4-1-array-to-pointer-\nconversion/).",
                "disable": false
            },
            {
                "real_name": "hicpp-no-assembler",
                "display_name": "hicpp-no-assembler",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-no-assemblerÂ¶\n\nCheck for assembler statements. No fix is offered.\n\nInline assembler is forbidden by the [High Integrity C++ Coding\nStandard](http://www.codingstandard.com/section/7-5-the-asm-declaration/) as\nit restricts the portability of code.",
                "disable": false
            },
            {
                "real_name": "hicpp-no-malloc",
                "display_name": "hicpp-no-malloc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-no-mallocÂ¶\n\nThe hicpp-no-malloc check is an alias, please see [cppcoreguidelines-no-\nmalloc](../cppcoreguidelines/no-malloc.html) for more information. It enforces\nthe [rule 5.3.2](http://www.codingstandard.com/rule/5-3-2-allocate-memory-\nusing-new-and-release-it-using-delete/).",
                "disable": false
            },
            {
                "real_name": "hicpp-noexcept-move",
                "display_name": "hicpp-noexcept-move",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-noexcept-moveÂ¶\n\nThis check is an alias for [performance-noexcept-move-\nconstructor](../performance/noexcept-move-constructor.html). Checks [rule\n12.5.4](http://www.codingstandard.com/rule/12-5-4-declare-noexcept-the-move-\nconstructor-and-move-assignment-operator) to mark move assignment and move\nconstruction noexcept.",
                "disable": false
            },
            {
                "real_name": "hicpp-signed-bitwise",
                "display_name": "hicpp-signed-bitwise",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-signed-bitwiseÂ¶\n\nFinds uses of bitwise operations on signed integer types, which may lead to\nundefined or implementation defined behavior.\n\nThe according rule is defined in the [High Integrity C++ Standard, Section\n5.6.1](http://www.codingstandard.com/section/5-6-shift-operators/).\n\n## OptionsÂ¶\n\n`IgnorePositiveIntegerLiterals```Â¶\n\n    \n\nIf this option is set to true, the check will not warn on bitwise operations\nwith positive integer literals, e.g. ~0, 2 << 1, etc. Default value is false.",
                "disable": false
            },
            {
                "real_name": "hicpp-special-member-functions",
                "display_name": "hicpp-special-member-functions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-special-member-functionsÂ¶\n\nThis check is an alias for [cppcoreguidelines-special-member-\nfunctions](../cppcoreguidelines/special-member-functions.html). Checks that\nspecial member functions have the correct signature, according to [rule\n12.5.7](http://www.codingstandard.com/rule/12-5-7-declare-assignment-\noperators-with-the-ref-qualifier/).",
                "disable": false
            },
            {
                "real_name": "hicpp-static-assert",
                "display_name": "hicpp-static-assert",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-static-assertÂ¶\n\nThe hicpp-static-assert check is an alias, please see [misc-static-\nassert](../misc/static-assert.html) for more information. It enforces the\n[rule 7.1.10](http://www.codingstandard.com/rule/6-1-1-enclose-the-body-of-a-\nselection-or-an-iteration-statement-in-a-compound-statement/).",
                "disable": false
            },
            {
                "real_name": "hicpp-undelegated-constructor",
                "display_name": "hicpp-undelegated-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-undelegated-constructorÂ¶\n\nThis check is an alias for [bugprone-undelegated-\nconstructor](../bugprone/undelegated-constructor.html). Partially implements\n[rule 12.4.5](http://www.codingstandard.com/rule/12-4-5-use-delegating-\nconstructors-to-reduce-code-duplication/) to find misplaced constructor calls\ninside a constructor.\n\n    \n    \n    struct Ctor {\n      Ctor();\n      Ctor(int);\n      Ctor(int, int);\n      Ctor(Ctor *i) {\n        // All Ctor() calls result in a temporary object\n        Ctor(); // did you intend to call a delegated constructor?\n        Ctor(0); // did you intend to call a delegated constructor?\n        Ctor(1, 2); // did you intend to call a delegated constructor?\n        foo();\n      }\n    };",
                "disable": false
            },
            {
                "real_name": "hicpp-uppercase-literal-suffix",
                "display_name": "hicpp-uppercase-literal-suffix",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-uppercase-literal-suffixÂ¶\n\nThe hicpp-uppercase-literal-suffix check is an alias, please see [readability-\nuppercase-literal-suffix](../readability/uppercase-literal-suffix.html) for\nmore information.",
                "disable": false
            },
            {
                "real_name": "hicpp-use-auto",
                "display_name": "hicpp-use-auto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-autoÂ¶\n\nThe hicpp-use-auto check is an alias, please see [modernize-use-\nauto](../modernize/use-auto.html) for more information. It enforces the [rule\n7.1.8](http://www.codingstandard.com/rule/7-1-8-use-auto-id-expr-when-\ndeclaring-a-variable-to-have-the-same-type-as-its-initializer-function-call/).",
                "disable": false
            },
            {
                "real_name": "hicpp-use-emplace",
                "display_name": "hicpp-use-emplace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-emplaceÂ¶\n\nThe hicpp-use-emplace check is an alias, please see [modernize-use-\nemplace](../modernize/use-emplace.html) for more information. It enforces the\n[rule 17.4.2](http://www.codingstandard.com/rule/17-4-2-use-api-calls-that-\nconstruct-objects-in-place/).",
                "disable": false
            },
            {
                "real_name": "hicpp-use-equals-default",
                "display_name": "hicpp-use-equals-default",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-equals-defaultÂ¶\n\nThis check is an alias for [modernize-use-equals-default](../modernize/use-\nequals-default.html). Implements [rule\n12.5.1](http://www.codingstandard.com/rule/12-5-1-define-explicitly-default-\nor-delete-implicit-special-member-functions-of-concrete-classes/) to\nexplicitly default special member functions.",
                "disable": false
            },
            {
                "real_name": "hicpp-use-equals-delete",
                "display_name": "hicpp-use-equals-delete",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-equals-deleteÂ¶\n\nThis check is an alias for [modernize-use-equals-delete](../modernize/use-\nequals-delete.html). Implements [rule\n12.5.1](http://www.codingstandard.com/rule/12-5-1-define-explicitly-default-\nor-delete-implicit-special-member-functions-of-concrete-classes/) to\nexplicitly default or delete special member functions.",
                "disable": false
            },
            {
                "real_name": "hicpp-use-noexcept",
                "display_name": "hicpp-use-noexcept",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-noexceptÂ¶\n\nThe hicpp-use-noexcept check is an alias, please see [modernize-use-\nnoexcept](../modernize/use-noexcept.html) for more information. It enforces\nthe [rule 1.3.5](http://www.codingstandard.com/rule/1-3-5-do-not-use-throw-\nexception-specifications/).",
                "disable": false
            },
            {
                "real_name": "hicpp-use-nullptr",
                "display_name": "hicpp-use-nullptr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-nullptrÂ¶\n\nThe hicpp-use-nullptr check is an alias, please see [modernize-use-\nnullptr](../modernize/use-nullptr.html) for more information. It enforces the\n[rule 2.5.3](http://www.codingstandard.com/rule/2-5-3-use-nullptr-for-the-\nnull-pointer-constant/).",
                "disable": false
            },
            {
                "real_name": "hicpp-use-override",
                "display_name": "hicpp-use-override",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-use-overrideÂ¶\n\nThis check is an alias for [modernize-use-override](../modernize/use-\noverride.html). Implements [rule\n10.2.1](http://www.codingstandard.com/section/10-2-virtual-functions/) to\ndeclare a virtual function override when overriding.",
                "disable": false
            },
            {
                "real_name": "hicpp-vararg",
                "display_name": "hicpp-vararg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# hicpp-varargÂ¶\n\nThe hicpp-vararg check is an alias, please see [cppcoreguidelines-pro-type-\nvararg](../cppcoreguidelines/pro-type-vararg.html) for more information. It\nenforces the [rule\n14.1.1](http://www.codingstandard.com/section/14-1-template-declarations/).",
                "disable": false
            },
            {
                "real_name": "linuxkernel-must-use-errs",
                "display_name": "linuxkernel-must-use-errs",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# linuxkernel-must-use-errsÂ¶\n\nChecks Linux kernel code to see if it uses the results from the functions in\n`linux/err.h`. Also checks to see if code uses the results from functions that\ndirectly return a value from one of these error functions.\n\nThis is important in the Linux kernel because `ERR_PTR`, `PTR_ERR`, `IS_ERR`,\n`IS_ERR_OR_NULL`, `ERR_CAST`, and `PTR_ERR_OR_ZERO` return values must be\nchecked, since positive pointers and negative error codes are being used in\nthe same context. These functions are marked with\n`__attribute__((warn_unused_result))`, but some kernel versions do not have\nthis warning enabled for clang.\n\nExamples:\n\n    \n    \n    /* Trivial unused call to an ERR function */\n    PTR_ERR_OR_ZERO(some_function_call());\n    \n    /* A function that returns ERR_PTR. */\n    void *fn() { ERR_PTR(-EINVAL); }\n    \n    /* An invalid use of fn. */\n    fn();",
                "disable": false
            },
            {
                "real_name": "llvm-else-after-return",
                "display_name": "llvm-else-after-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-else-after-returnÂ¶\n\nThe llvm-else-after-return check is an alias, please see [readability-else-\nafter-return](../readability/else-after-return.html) for more information.",
                "disable": false
            },
            {
                "real_name": "llvm-header-guard",
                "display_name": "llvm-header-guard",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-header-guardÂ¶\n\nFinds and fixes header guards that do not adhere to LLVM style.\n\n## OptionsÂ¶\n\n`HeaderFileExtensions```Â¶\n\n    \n\nA comma-separated list of filename extensions of header files (the filename\nextensions should not include â.â prefix). Default is âh,hh,hpp,hxxâ.\nFor header files without an extension, use an empty string (if there are no\nother desired extensions) or leave an empty element in the list. E.g.,\nâh,hh,hpp,hxx,â (note the trailing comma).",
                "disable": false
            },
            {
                "real_name": "llvm-include-order",
                "display_name": "llvm-include-order",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-include-orderÂ¶\n\nChecks the correct order of `#includes`.\n\nSee <https://llvm.org/docs/CodingStandards.html#include-style>",
                "disable": false
            },
            {
                "real_name": "llvm-namespace-comment",
                "display_name": "llvm-namespace-comment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-namespace-commentÂ¶\n\ngoogle-readability-namespace-comments redirects here as an alias for this\ncheck.\n\nChecks that long namespaces have a closing comment.\n\n<https://llvm.org/docs/CodingStandards.html#namespace-indentation>\n\n<https://google.github.io/styleguide/cppguide.html#Namespaces>\n\n    \n    \n    namespace n1 {\n    void f();\n    }\n    \n    // becomes\n    \n    namespace n1 {\n    void f();\n    }  // namespace n1\n    \n\n## OptionsÂ¶\n\n`ShortNamespaceLines```Â¶\n\n    \n\nRequires the closing brace of the namespace definition to be followed by a\nclosing comment if the body of the namespace has more than ShortNamespaceLines\nlines of code. The value is an unsigned integer that defaults to 1U.\n\n`SpacesBeforeComments```Â¶\n\n    \n\nAn unsigned integer specifying the number of spaces before the comment closing\na namespace definition. Default is 1U.",
                "disable": false
            },
            {
                "real_name": "llvm-prefer-isa-or-dyn-cast-in-conditionals",
                "display_name": "llvm-prefer-isa-or-dyn-cast-in-conditionals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-prefer-isa-or-dyn-cast-in-conditionalsÂ¶\n\nLooks at conditionals and finds and replaces cases of `cast<>`, which will\nassert rather than return a null pointer, and `dyn_cast<>` where the return\nvalue is not captured. Additionally, finds and replaces cases that match the\npattern `var && isa<X>(var)`, where `var` is evaluated twice.\n\n    \n    \n    // Finds these:\n    if (auto x = cast<X>(y)) {}\n    // is replaced by:\n    if (auto x = dyn_cast<X>(y)) {}\n    \n    if (cast<X>(y)) {}\n    // is replaced by:\n    if (isa<X>(y)) {}\n    \n    if (dyn_cast<X>(y)) {}\n    // is replaced by:\n    if (isa<X>(y)) {}\n    \n    if (var && isa<T>(var)) {}\n    // is replaced by:\n    if (isa_and_nonnull<T>(var.foo())) {}\n    \n    // Other cases are ignored, e.g.:\n    if (auto f = cast<Z>(y)->foo()) {}\n    if (cast<Z>(y)->foo()) {}\n    if (X.cast(y)) {}",
                "disable": false
            },
            {
                "real_name": "llvm-prefer-register-over-unsigned",
                "display_name": "llvm-prefer-register-over-unsigned",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-prefer-register-over-unsignedÂ¶\n\nFinds historical use of `unsigned` to hold vregs and physregs and rewrites\nthem to use `Register`.\n\nCurrently this works by finding all variables of unsigned integer type whose\ninitializer begins with an implicit cast from `Register` to `unsigned`.\n\n    \n    \n    void example(MachineOperand &MO) {\n      unsigned Reg = MO.getReg();\n      ...\n    }\n    \n\nbecomes:\n\n    \n    \n    void example(MachineOperand &MO) {\n      Register Reg = MO.getReg();\n      ...\n    }",
                "disable": false
            },
            {
                "real_name": "llvm-qualified-auto",
                "display_name": "llvm-qualified-auto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-qualified-autoÂ¶\n\nThe llvm-qualified-auto check is an alias, please see [readability-qualified-\nauto](../readability/qualified-auto.html) for more information.",
                "disable": false
            },
            {
                "real_name": "llvm-twine-local",
                "display_name": "llvm-twine-local",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvm-twine-localÂ¶\n\nLooks for local `Twine` variables which are prone to use after frees and\nshould be generally avoided.\n\n    \n    \n    static Twine Moo = Twine(\"bark\") + \"bah\";\n    \n    // becomes\n    \n    static std::string Moo = (Twine(\"bark\") + \"bah\").str();",
                "disable": false
            },
            {
                "real_name": "llvmlibc-callee-namespace",
                "display_name": "llvmlibc-callee-namespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvmlibc-callee-namespaceÂ¶\n\nChecks all calls resolve to functions within `__llvm_libc` namespace.\n\n    \n    \n    namespace __llvm_libc {\n    \n    // Allow calls with the fully qualified name.\n    __llvm_libc::strlen(\"hello\");\n    \n    // Allow calls to compiler provided functions.\n    (void)__builtin_abs(-1);\n    \n    // Bare calls are allowed as long as they resolve to the correct namespace.\n    strlen(\"world\");\n    \n    // Disallow calling into functions in the global namespace.\n    ::strlen(\"!\");\n    \n    } // namespace __llvm_libc",
                "disable": false
            },
            {
                "real_name": "llvmlibc-implementation-in-namespace",
                "display_name": "llvmlibc-implementation-in-namespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvmlibc-implementation-in-namespaceÂ¶\n\nChecks that all declarations in the llvm-libc implementation are within the\ncorrect namespace.\n\n    \n    \n    // Correct: implementation inside the correct namespace.\n    namespace __llvm_libc {\n        void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char *src) {}\n        // Namespaces within __llvm_libc namespace are allowed.\n        namespace inner{\n            int localVar = 0;\n        }\n        // Functions with C linkage are allowed.\n        extern \"C\" void str_fuzz(){}\n    }\n    \n    // Incorrect: implementation not in a namespace.\n    void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char *src) {}\n    \n    // Incorrect: outer most namespace is not correct.\n    namespace something_else {\n        void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char *src) {}\n    }",
                "disable": false
            },
            {
                "real_name": "llvmlibc-restrict-system-libc-headers",
                "display_name": "llvmlibc-restrict-system-libc-headers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# llvmlibc-restrict-system-libc-headersÂ¶\n\nFinds includes of system libc headers not provided by the compiler within\nllvm-libc implementations.\n\n    \n    \n    #include <stdio.h>            // Not allowed because it is part of system libc.\n    #include <stddef.h>           // Allowed because it is provided by the compiler.\n    #include \"internal/stdio.h\"   // Allowed because it is NOT part of system libc.\n    \n\nThis check is necessary because accidentally including system libc headers can\nlead to subtle and hard to detect bugs. For example consider a system libc\nwhose `dirent` struct has slightly different field ordering than llvm-libc.\nWhile this will compile successfully, this can cause issues during runtime\nbecause they are ABI incompatible.\n\n## OptionsÂ¶\n\n`Includes```Â¶\n\n    \n\nA string containing a comma separated glob list of allowed include filenames.\nSimilar to the -checks glob list for running clang-tidy itself, the two\nwildcard characters are * and -, to include and exclude globs, respectively.\nThe default is -*, which disallows all includes.\n\nThis can be used to allow known safe includes such as Linux development\nheaders. See [portability-restrict-system-includes](../portability/restrict-\nsystem-includes.html) for more details.",
                "disable": false
            },
            {
                "real_name": "misc-confusable-identifiers",
                "display_name": "misc-confusable-identifiers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-confusable-identifiersÂ¶\n\nWarn about confusable identifiers, i.e. identifiers that are visually close to\neach other, but use different Unicode characters. This detects a potential\nattack described in\n[CVE-2021-42574](https://www.cve.org/CVERecord?id=CVE-2021-42574).\n\nExample:\n\n    \n    \n    int fo; // Initial character is U+0066 (LATIN SMALL LETTER F).\n    int ðo; // Initial character is U+1234 (SUPER COOL AWESOME UPPERCASE NOT LATIN F) not U+0066 (LATIN SMALL LETTER F).",
                "disable": false
            },
            {
                "real_name": "misc-const-correctness",
                "display_name": "misc-const-correctness",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-const-correctnessÂ¶\n\nThis check implements detection of local variables which could be declared as\n`const`, but are not. Declaring variables as `const` is required or\nrecommended by many coding guidelines, such as: [CppCoreGuidelines\nES.25](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es25-declare-\nan-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on) and\n[AUTOSAR C++14 Rule A7-1-1 (6.7.1\nSpecifiers)](https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-03/AUTOSAR_RS_CPP14Guidelines.pdf).\n\nPlease note that this analysis is type-based only. Variables that are not\nmodified but used to create a non-const handle that might escape the scope are\nnot diagnosed as potential `const`.\n\n    \n    \n    // Declare a variable, which is not ``const`` ...\n    int i = 42;\n    // but use it as read-only. This means that `i` can be declared ``const``.\n    int result = i * i;\n    \n\nThe check can analyzes values, pointers and references but not (yet) pointees:\n\n    \n    \n    // Normal values like built-ins or objects.\n    int potential_const_int = 42; // 'const int potential_const_int = 42' suggestion.\n    int copy_of_value = potential_const_int;\n    \n    MyClass could_be_const; // 'const MyClass could_be_const' suggestion;\n    could_be_const.const_qualified_method();\n    \n    // References can be declared const as well.\n    int &reference_value = potential_const_int; // 'const int &reference_value' suggestion.\n    int another_copy = reference_value;\n    \n    // The similar semantics of pointers are not (yet) analyzed.\n    int *pointer_variable = &potential_const_int; // Not 'const int *pointer_variable' suggestion.\n    int last_copy = *pointer_variable;\n    \n\nThe automatic code transformation is only applied to variables that are\ndeclared in single declarations. You may want to prepare your code base with\n[readability-isolate-declaration](../readability/isolate-declaration.html)\nfirst.\n\nNote that there is the check [cppcoreguidelines-avoid-non-const-global-\nvariables](cppcoreguidelines-avoid-non-const-global-variables.html) to enforce\n`const` correctness on all globals.\n\n## Known LimitationsÂ¶\n\nThe check will not analyze templated variables or variables that are\ninstantiation dependent. Different instantiations can result in different\n`const` correctness properties and in general it is not possible to find all\ninstantiations of a template. It might be used differently in an independent\ntranslation unit.\n\nPointees can not be analyzed for constness yet. The following code is shows\nthis limitation.\n\n    \n    \n    // Declare a variable that will not be modified.\n    int constant_value = 42;\n    \n    // Declare a pointer to that variable, that does not modify either, but misses 'const'.\n    // Could be 'const int *pointer_to_constant = &constant_value;'\n    int *pointer_to_constant = &constant_value;\n    \n    // Usage:\n    int result = 520 * 120 * (*pointer_to_constant);\n    \n\nThis limitation affects the capability to add `const` to methods which is not\npossible, too.\n\n## OptionsÂ¶\n\n`AnalyzeValues`` (default = 1)`Â¶\n\n    \n\nEnable or disable the analysis of ordinary value variables, like `int i = 42;`\n\n`AnalyzeReferences`` (default = 1)`Â¶\n\n    \n\nEnable or disable the analysis of reference variables, like `int &ref = i;`\n\n`WarnPointersAsValues`` (default = 0)`Â¶\n\n    \n\nThis option enables the suggestion for `const` of the pointer itself. Pointer\nvalues have two possibilities to be `const`, the pointer and the value\npointing to.\n\n    \n    \n    const int value = 42;\n    const int * const pointer_variable = &value;\n    \n    // The following operations are forbidden for `pointer_variable`.\n    // *pointer_variable = 44;\n    // pointer_variable = nullptr;\n    \n\n`TransformValues`` (default = 1)`Â¶\n\n    \n\nProvides fixit-hints for value types that automatically adds `const` if its a\nsingle declaration.\n\n    \n    \n    // Emits a hint for 'value' to become 'const int value = 42;'.\n    int value = 42;\n    // Result is modified later in its life-time. No diagnostic and fixit hint will be emitted.\n    int result = value * 3;\n    result -= 10;\n    \n\n`TransformReferences`` (default = 1)`Â¶\n\n    \n\nProvides fixit-hints for reference types that automatically adds `const` if\nits a single declaration.\n\n    \n    \n    // This variable could still be a constant. But because there is a non-const reference to\n    // it, it can not be transformed (yet).\n    int value = 42;\n    // The reference 'ref_value' is not modified and can be made 'const int &ref_value = value;'\n    int &ref_value = value;\n    \n    // Result is modified later in its life-time. No diagnostic and fixit hint will be emitted.\n    int result = ref_value * 3;\n    result -= 10;\n    \n\n`TransformPointersAsValues`` (default = 0)`Â¶\n\n    \n\nProvides fixit-hints for pointers if their pointee is not changed. This does\nnot analyze if the value-pointed-to is unchanged!\n\nRequires âWarnPointersAsValuesâ to be 1.\n\n    \n    \n    int value = 42;\n    // Emits a hint that 'ptr_value' may become 'int *const ptr_value = &value' because its pointee\n    // is not changed.\n    int *ptr_value = &value;\n    \n    int result = 100 * (*ptr_value);\n    // This modification of the pointee is still allowed and not analyzed/diagnosed.\n    *ptr_value = 0;\n    \n    // The following pointer may not become a 'int *const'.\n    int *changing_pointee = &value;\n    changing_pointee = &result;",
                "disable": false
            },
            {
                "real_name": "misc-definitions-in-headers",
                "display_name": "misc-definitions-in-headers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-definitions-in-headersÂ¶\n\nFinds non-extern non-inline function and variable definitions in header files,\nwhich can lead to potential ODR violations in case these headers are included\nfrom multiple translation units.\n\n    \n    \n    // Foo.h\n    int a = 1; // Warning: variable definition.\n    extern int d; // OK: extern variable.\n    \n    namespace N {\n      int e = 2; // Warning: variable definition.\n    }\n    \n    // Warning: variable definition.\n    const char* str = \"foo\";\n    \n    // OK: internal linkage variable definitions are ignored for now.\n    // Although these might also cause ODR violations, we can be less certain and\n    // should try to keep the false-positive rate down.\n    static int b = 1;\n    const int c = 1;\n    const char* const str2 = \"foo\";\n    constexpr int k = 1;\n    \n    // Warning: function definition.\n    int g() {\n      return 1;\n    }\n    \n    // OK: inline function definition is allowed to be defined multiple times.\n    inline int e() {\n      return 1;\n    }\n    \n    class A {\n    public:\n      int f1() { return 1; } // OK: implicitly inline member function definition is allowed.\n      int f2();\n    \n      static int d;\n    };\n    \n    // Warning: not an inline member function definition.\n    int A::f2() { return 1; }\n    \n    // OK: class static data member declaration is allowed.\n    int A::d = 1;\n    \n    // OK: function template is allowed.\n    template<typename T>\n    T f3() {\n      T a = 1;\n      return a;\n    }\n    \n    // Warning: full specialization of a function template is not allowed.\n    template <>\n    int f3() {\n      int a = 1;\n      return a;\n    }\n    \n    template <typename T>\n    struct B {\n      void f1();\n    };\n    \n    // OK: member function definition of a class template is allowed.\n    template <typename T>\n    void B<T>::f1() {}\n    \n    class CE {\n      constexpr static int i = 5; // OK: inline variable definition.\n    };\n    \n    inline int i = 5; // OK: inline variable definition.\n    \n    constexpr int f10() { return 0; } // OK: constexpr function implies inline.\n    \n    // OK: C++14 variable templates are inline.\n    template <class T>\n    constexpr T pi = T(3.1415926L);\n    \n\n## OptionsÂ¶\n\n`HeaderFileExtensions```Â¶\n\n    \n\nA comma-separated list of filename extensions of header files (the filename\nextensions should not include â.â prefix). Default is âh,hh,hpp,hxxâ.\nFor header files without an extension, use an empty string (if there are no\nother desired extensions) or leave an empty element in the list. E.g.,\nâh,hh,hpp,hxx,â (note the trailing comma).\n\n`UseHeaderFileExtension```Â¶\n\n    \n\nWhen true, the check will use the file extension to distinguish header files.\nDefault is true.",
                "disable": false
            },
            {
                "real_name": "misc-misleading-bidirectional",
                "display_name": "misc-misleading-bidirectional",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-misleading-bidirectionalÂ¶\n\nWarn about unterminated bidirectional unicode sequence, detecting potential\nattack as described in the [Trojan Source](https://www.trojansource.codes)\nattack.\n\nExample:\n\n    \n    \n    #include <iostream>\n    \n    int main() {\n        bool isAdmin = false;\n        /*â® } â¦if (isAdmin)â© â¦ begin admins only */\n            std::cout << \"You are an admin.\\n\";\n        /* end admins only â® { â¦*/\n        return 0;\n    }",
                "disable": false
            },
            {
                "real_name": "misc-misleading-identifier",
                "display_name": "misc-misleading-identifier",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-misleading-identifierÂ¶\n\nFinds identifiers that contain Unicode characters with right-to-left\ndirection, which can be confusing as they may change the understanding of a\nwhole statement line, as described in [Trojan\nSource](https://trojansource.codes).\n\nAn example of such misleading code follows:\n\n    \n    \n    #include <stdio.h>\n    \n    short int × = (short int)0;\n    short int × = (short int)12345;\n    \n    int main() {\n      int × = ×; // a local variable, set to zero?\n      printf(\"× is %d\\n\", ×);\n      printf(\"× is %d\\n\", ×);\n    }",
                "disable": false
            },
            {
                "real_name": "misc-misplaced-const",
                "display_name": "misc-misplaced-const",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-misplaced-constÂ¶\n\nThis check diagnoses when a `const` qualifier is applied to a `typedef`/\n`using` to a pointer type rather than to the pointee, because such constructs\nare often misleading to developers because the `const` applies to the pointer\nrather than the pointee.\n\nFor instance, in the following code, the resulting type is `int * const`\nrather than `const int *`:\n\n    \n    \n    typedef int *int_ptr;\n    void f(const int_ptr ptr) {\n      *ptr = 0; // potentially quite unexpectedly the int can be modified here\n      ptr = 0; // does not compile\n    }\n    \n\nThe check does not diagnose when the underlying `typedef`/`using` type is a\npointer to a `const` type or a function pointer type. This is because the\n`const` qualifier is less likely to be mistaken because it would be redundant\n(or disallowed) on the underlying pointee type.",
                "disable": false
            },
            {
                "real_name": "misc-new-delete-overloads",
                "display_name": "misc-new-delete-overloads",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-new-delete-overloadsÂ¶\n\ncert-dcl54-cpp redirects here as an alias for this check.\n\nThe check flags overloaded operator `new()` and operator `delete()` functions\nthat do not have a corresponding free store function defined within the same\nscope. For instance, the check will flag a class implementation of a non-\nplacement operator `new()` when the class does not also define a non-placement\noperator `delete()` function as well.\n\nThe check does not flag implicitly-defined operators, deleted or private\noperators, or placement operators.\n\nThis check corresponds to CERT C++ Coding Standard rule [DCL54-CPP. Overload\nallocation and deallocation functions as a pair in the same\nscope](https://www.securecoding.cert.org/confluence/display/cplusplus/DCL54-CPP.+Overload+allocation+and+deallocation+functions+as+a+pair+in+the+same+scope).",
                "disable": false
            },
            {
                "real_name": "misc-no-recursion",
                "display_name": "misc-no-recursion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-no-recursionÂ¶\n\nFinds strongly connected functions (by analyzing the call graph for SCCâs\n(Strongly Connected Components) that are loops), diagnoses each function in\nthe cycle, and displays one example of a possible call graph loop (recursion).\n\nReferences:\n\n  * CERT C++ Coding Standard rule [DCL56-CPP. Avoid cycles during initialization of static objects](https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL56-CPP.+Avoid+cycles+during+initialization+of+static+objects).\n  * JPL Institutional Coding Standard for the C Programming Language (JPL DOCID D-60411) rule 2.4 Do not use direct or indirect recursion.\n  * OpenCL Specification, Version 1.2 rule [6.9 Restrictions: i. Recursion is not supported.](https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf).\n\nLimitations:\n\n  * The check does not handle calls done through function pointers\n  * The check does not handle C++ destructors",
                "disable": false
            },
            {
                "real_name": "misc-non-copyable-objects",
                "display_name": "misc-non-copyable-objects",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-non-copyable-objectsÂ¶\n\ncert-fio38-c redirects here as an alias for this check.\n\nThe check flags dereferences and non-pointer declarations of objects that are\nnot meant to be passed by value, such as C FILE objects or POSIX\n`pthread_mutex_t` objects.\n\nThis check corresponds to CERT C++ Coding Standard rule [FIO38-C. Do not copy\na FILE\nobject](https://www.securecoding.cert.org/confluence/display/c/FIO38-C.+Do+not+copy+a+FILE+object).",
                "disable": false
            },
            {
                "real_name": "misc-non-private-member-variables-in-classes",
                "display_name": "misc-non-private-member-variables-in-classes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-non-private-member-variables-in-classesÂ¶\n\ncppcoreguidelines-non-private-member-variables-in-classes redirects here as an\nalias for this check.\n\nFinds classes that contain non-static data members in addition to user-\ndeclared non-static member functions and diagnose all data members declared\nwith a non-`public` access specifier. The data members should be declared as\n`private` and accessed through member functions instead of exposed to derived\nclasses or class consumers.\n\n## OptionsÂ¶\n\n`IgnoreClassesWithAllMemberVariablesBeingPublic```Â¶\n\n    \n\nAllows to completely ignore classes if **all** the member variables in that\nclass a declared with a `public` access specifier.\n\n`IgnorePublicMemberVariables```Â¶\n\n    \n\nAllows to ignore (not diagnose) **all** the member variables declared with a\n`public` access specifier.",
                "disable": false
            },
            {
                "real_name": "misc-redundant-expression",
                "display_name": "misc-redundant-expression",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-redundant-expressionÂ¶\n\nDetect redundant expressions which are typically errors due to copy-paste.\n\nDepending on the operator expressions may be\n\n  * redundant,\n  * always `true`,\n  * always `false`,\n  * always a constant (zero or one).\n\nExamples:\n\n    \n    \n    ((x+1) | (x+1))             // (x+1) is redundant\n    (p->x == p->x)              // always true\n    (p->x < p->x)               // always false\n    (speed - speed + 1 == 12)   // speed - speed is always zero",
                "disable": false
            },
            {
                "real_name": "misc-static-assert",
                "display_name": "misc-static-assert",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-static-assertÂ¶\n\ncert-dcl03-c redirects here as an alias for this check.\n\nReplaces `assert()` with `static_assert()` if the condition is evaluable at\ncompile time.\n\nThe condition of `static_assert()` is evaluated at compile time which is safer\nand more efficient.",
                "disable": false
            },
            {
                "real_name": "misc-throw-by-value-catch-by-reference",
                "display_name": "misc-throw-by-value-catch-by-reference",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-throw-by-value-catch-by-referenceÂ¶\n\ncert-err09-cpp redirects here as an alias for this check. cert-err61-cpp\nredirects here as an alias for this check.\n\nFinds violations of the rule âThrow by value, catch by referenceâ\npresented for example in âC++ Coding Standardsâ by H. Sutter and A.\nAlexandrescu, as well as the CERT C++ Coding Standard rule [ERR61-CPP. Catch\nexceptions by lvalue\nreference](https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR61-CPP.+Catch+exceptions+by+lvalue+reference).\n\nExceptions:\n\n    \n\n  * Throwing string literals will not be flagged despite being a pointer. They are not susceptible to slicing and the usage of string literals is idiomatic.\n  * Catching character pointers (`char`, `wchar_t`, unicode character types) will not be flagged to allow catching string literals.\n  * Moved named values will not be flagged as not throwing an anonymous temporary. In this case we can be sure that the user knows that the object canât be accessed outside catch blocks handling the error.\n  * Throwing function parameters will not be flagged as not throwing an anonymous temporary. This allows helper functions for throwing.\n  * Re-throwing caught exception variables will not be flagged as not throwing an anonymous temporary. Although this can usually be done by just writing `throw;` it happens often enough in real code.\n\n## OptionsÂ¶\n\n`CheckThrowTemporaries```Â¶\n\n    \n\nTriggers detection of violations of the CERT recommendation ERR09-CPP. Throw\nanonymous temporaries. Default is true.\n\n`WarnOnLargeObject```Â¶\n\n    \n\nAlso warns for any large, trivial object caught by value. Catching a large\nobject by value is not dangerous but affects the performance negatively. The\nmaximum size of an object allowed to be caught without warning can be set\nusing the MaxSize option. Default is false.\n\n`MaxSize```Â¶\n\n    \n\nDetermines the maximum size of an object allowed to be caught without warning.\nOnly applicable if `WarnOnLargeObject` is set to true. If the option is set by\nthe user to std::numeric_limits<uint64_t>::max() then it reverts to the\ndefault value. Default is the size of size_t.",
                "disable": false
            },
            {
                "real_name": "misc-unconventional-assign-operator",
                "display_name": "misc-unconventional-assign-operator",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-unconventional-assign-operatorÂ¶\n\nFinds declarations of assign operators with the wrong return and/or argument\ntypes and definitions with good return type but wrong `return` statements.\n\n>   * The return type must be `Class&`.\n>   * The assignment may be from the class type by value, const lvalue\n> reference, non-const rvalue reference, or from a completely different type\n> (e.g. `int`).\n>   * Private and deleted operators are ignored.\n>   * The operator must always return `*this`.\n>",
                "disable": false
            },
            {
                "real_name": "misc-uniqueptr-reset-release",
                "display_name": "misc-uniqueptr-reset-release",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-uniqueptr-reset-releaseÂ¶\n\nFind and replace `unique_ptr::reset(release())` with `std::move()`.\n\nExample:\n\n    \n    \n    std::unique_ptr<Foo> x, y;\n    x.reset(y.release()); -> x = std::move(y);\n    \n\nIf `y` is already rvalue, `std::move()` is not added. `x` and `y` can also be\n`std::unique_ptr<Foo>*`.\n\n## OptionsÂ¶\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.",
                "disable": false
            },
            {
                "real_name": "misc-unused-alias-decls",
                "display_name": "misc-unused-alias-decls",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-unused-alias-declsÂ¶\n\nFinds unused namespace alias declarations.\n\n    \n    \n    namespace my_namespace {\n    class C {};\n    }\n    namespace unused_alias = ::my_namespace;",
                "disable": false
            },
            {
                "real_name": "misc-unused-parameters",
                "display_name": "misc-unused-parameters",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-unused-parametersÂ¶\n\nFinds unused function parameters. Unused parameters may signify a bug in the\ncode (e.g. when a different parameter is used instead). The suggested fixes\neither comment parameter name out or remove the parameter completely, if all\ncallers of the function are in the same translation unit and can be updated.\n\nThe check is similar to the `-Wunused-parameter` compiler diagnostic and can\nbe used to prepare a codebase to enabling of that diagnostic. By default the\ncheck is more permissive (see [`StrictMode`](../performance/inefficient-\nstring-concatenation.html#cmdoption-arg-strictmode)).\n\n    \n    \n    void a(int i) { /*some code that doesn't use `i`*/ }\n    \n    // becomes\n    \n    void a(int  /*i*/) { /*some code that doesn't use `i`*/ }\n    \n    \n    \n    static void staticFunctionA(int i);\n    static void staticFunctionA(int i) { /*some code that doesn't use `i`*/ }\n    \n    // becomes\n    \n    static void staticFunctionA()\n    static void staticFunctionA() { /*some code that doesn't use `i`*/ }\n    \n\n## OptionsÂ¶\n\n`StrictMode```Â¶\n\n    \n\nWhen false (default value), the check will ignore trivially unused parameters,\ni.e. when the corresponding function has an empty body (and in case of\nconstructors - no constructor initializers). When the function body is empty,\nan unused parameter is unlikely to be unnoticed by a human reader, and\nthereâs basically no place for a bug to hide.",
                "disable": false
            },
            {
                "real_name": "misc-unused-using-decls",
                "display_name": "misc-unused-using-decls",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# misc-unused-using-declsÂ¶\n\nFinds unused `using` declarations.\n\nExample:\n\n    \n    \n    namespace n { class C; }\n    using n::C;  // Never actually used.",
                "disable": false
            },
            {
                "real_name": "modernize-avoid-bind",
                "display_name": "modernize-avoid-bind",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-avoid-bindÂ¶\n\nThe check finds uses of `std::bind` and `boost::bind` and replaces them with\nlambdas. Lambdas will use value-capture unless reference capture is explicitly\nrequested with `std::ref` or `boost::ref`.\n\nIt supports arbitrary callables including member functions, function objects,\nand free functions, and all variations thereof. Anything that you can pass to\nthe first argument of `bind` should be diagnosable. Currently, the only known\ncase where a fix-it is unsupported is when the same placeholder is specified\nmultiple times in the parameter list.\n\nGiven:\n\n    \n    \n    int add(int x, int y) { return x + y; }\n    \n\nThen:\n\n    \n    \n    void f() {\n      int x = 2;\n      auto clj = std::bind(add, x, _1);\n    }\n    \n\nis replaced by:\n\n    \n    \n    void f() {\n      int x = 2;\n      auto clj = [=](auto && arg1) { return add(x, arg1); };\n    }\n    \n\n`std::bind` can be hard to read and can result in larger object files and\nbinaries due to type information that will not be produced by equivalent\nlambdas.\n\n## OptionsÂ¶\n\n`PermissiveParameterList```Â¶\n\n    \n\nIf the option is set to true, the check will append `auto&&...` to the end of\nevery placeholder parameter list. Without this, it is possible for a fix-it to\nperform an incorrect transformation in the case where the result of the `bind`\nis used in the context of a type erased functor such as `std::function` which\nallows mismatched arguments. For example:\n\n    \n    \n    int add(int x, int y) { return x + y; }\n    int foo() {\n      std::function<int(int,int)> ignore_args = std::bind(add, 2, 2);\n      return ignore_args(3, 3);\n    }\n    \n\nis valid code, and returns 4. The actual values passed to `ignore_args` are\nsimply ignored. Without `PermissiveParameterList`, this would be transformed\ninto\n\n    \n    \n    int add(int x, int y) { return x + y; }\n    int foo() {\n      std::function<int(int,int)> ignore_args = [] { return add(2, 2); }\n      return ignore_args(3, 3);\n    }\n    \n\nwhich will _not_ compile, since the lambda does not contain an `operator()`\nthat accepts 2 arguments. With permissive parameter list, it instead generates\n\n    \n    \n    int add(int x, int y) { return x + y; }\n    int foo() {\n      std::function<int(int,int)> ignore_args = [](auto&&...) { return add(2, 2); }\n      return ignore_args(3, 3);\n    }\n    \n\nwhich is correct.\n\nThis check requires using C++14 or higher to run.",
                "disable": false
            },
            {
                "real_name": "modernize-avoid-c-arrays",
                "display_name": "modernize-avoid-c-arrays",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-avoid-c-arraysÂ¶\n\ncppcoreguidelines-avoid-c-arrays redirects here as an alias for this check.\n\nhicpp-avoid-c-arrays redirects here as an alias for this check.\n\nFinds C-style array types and recommend to use `std::array<>` /\n`std::vector<>`. All types of C arrays are diagnosed.\n\nHowever, fix-it are potentially dangerous in header files and are therefore\nnot emitted right now.\n\n    \n    \n    int a[] = {1, 2}; // warning: do not declare C-style arrays, use std::array<> instead\n    \n    int b[1]; // warning: do not declare C-style arrays, use std::array<> instead\n    \n    void foo() {\n      int c[b[0]]; // warning: do not declare C VLA arrays, use std::vector<> instead\n    }\n    \n    template <typename T, int Size>\n    class array {\n      T d[Size]; // warning: do not declare C-style arrays, use std::array<> instead\n    \n      int e[1]; // warning: do not declare C-style arrays, use std::array<> instead\n    };\n    \n    array<int[4], 2> d; // warning: do not declare C-style arrays, use std::array<> instead\n    \n    using k = int[4]; // warning: do not declare C-style arrays, use std::array<> instead\n    \n\nHowever, the `extern \"C\"` code is ignored, since it is common to share such\nheaders between C code, and C++ code.\n\n    \n    \n    // Some header\n    extern \"C\" {\n    \n    int f[] = {1, 2}; // not diagnosed\n    \n    int j[1]; // not diagnosed\n    \n    inline void bar() {\n      {\n        int j[j[0]]; // not diagnosed\n      }\n    }\n    \n    }\n    \n\nSimilarly, the `main()` function is ignored. Its second and third parameters\ncan be either `char* argv[]` or `char** argv`, but cannot be `std::array<>`.",
                "disable": false
            },
            {
                "real_name": "modernize-concat-nested-namespaces",
                "display_name": "modernize-concat-nested-namespaces",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-concat-nested-namespacesÂ¶\n\nChecks for use of nested namespaces such as `namespace a { namespace b { ... }\n}` and suggests changing to the more concise syntax introduced in C++17:\n`namespace a::b { ... }`. Inline namespaces are not modified.\n\nFor example:\n\n    \n    \n    namespace n1 {\n    namespace n2 {\n    void t();\n    }\n    }\n    \n    namespace n3 {\n    namespace n4 {\n    namespace n5 {\n    void t();\n    }\n    }\n    namespace n6 {\n    namespace n7 {\n    void t();\n    }\n    }\n    }\n    \n\nWill be modified to:\n\n    \n    \n    namespace n1::n2 {\n    void t();\n    }\n    \n    namespace n3 {\n    namespace n4::n5 {\n    void t();\n    }\n    namespace n6::n7 {\n    void t();\n    }\n    }",
                "disable": false
            },
            {
                "real_name": "modernize-deprecated-headers",
                "display_name": "modernize-deprecated-headers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-deprecated-headersÂ¶\n\nSome headers from C library were deprecated in C++ and are no longer welcome\nin C++ codebases. Some have no effect in C++. For more details refer to the\nC++ 14 Standard [depr.c.headers] section.\n\nThis check replaces C standard library headers with their C++ alternatives and\nremoves redundant ones.\n\n    \n    \n    // C++ source file...\n    #include <assert.h>\n    #include <stdbool.h>\n    \n    // becomes\n    \n    #include <cassert>\n    // No 'stdbool.h' here.\n    \n\nImportant note: the Standard doesnât guarantee that the C++ headers declare\nall the same functions in the global namespace. The check in its current form\ncan break the code that uses library symbols from the global namespace.\n\n  * <assert.h>\n  * <complex.h>\n  * <ctype.h>\n  * <errno.h>\n  * <fenv.h> // deprecated since C++11\n  * <float.h>\n  * <inttypes.h>\n  * <limits.h>\n  * <locale.h>\n  * <math.h>\n  * <setjmp.h>\n  * <signal.h>\n  * <stdarg.h>\n  * <stddef.h>\n  * <stdint.h>\n  * <stdio.h>\n  * <stdlib.h>\n  * <string.h>\n  * <tgmath.h> // deprecated since C++11\n  * <time.h>\n  * <uchar.h> // deprecated since C++11\n  * <wchar.h>\n  * <wctype.h>\n\nIf the specified standard is older than C++11 the check will only replace\nheaders deprecated before C++11, otherwise â every header that appeared in\nthe previous list.\n\nThese headers donât have effect in C++:\n\n  * <iso646.h>\n  * <stdalign.h>\n  * <stdbool.h>\n\nThe checker ignores include directives within extern âCâ { â¦ } blocks,\nsince a library might want to expose some API for C and C++ libraries.\n\n    \n    \n    // C++ source file...\n    extern \"C\" {\n    #include <assert.h>  // Left intact.\n    #include <stdbool.h> // Left intact.\n    }\n    \n\n## OptionsÂ¶\n\n`CheckHeaderFile```Â¶\n\n    \n\nclang-tidy cannot know if the header file included by the currently analyzed\nC++ source file is not included by any other C source files. Hence, to omit\nfalse-positives and wrong fixit-hints, we ignore emitting reports into header\nfiles. One can set this option to true if they know that the header files in\nthe project are only used by C++ source file. Default is false.",
                "disable": false
            },
            {
                "real_name": "modernize-deprecated-ios-base-aliases",
                "display_name": "modernize-deprecated-ios-base-aliases",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-deprecated-ios-base-aliasesÂ¶\n\nDetects usage of the deprecated member types of `std::ios_base` and replaces\nthose that have a non-deprecated equivalent.\n\nDeprecated member type | Replacement  \n---|---  \n`std::ios_base::io_state` | `std::ios_base::iostate`  \n`std::ios_base::open_mode` | `std::ios_base::openmode`  \n`std::ios_base::seek_dir` | `std::ios_base::seekdir`  \n`std::ios_base::streamoff` |  \n`std::ios_base::streampos` |",
                "disable": false
            },
            {
                "real_name": "modernize-loop-convert",
                "display_name": "modernize-loop-convert",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-loop-convertÂ¶\n\nThis check converts `for(...; ...; ...)` loops to use the new range-based\nloops in C++11.\n\nThree kinds of loops can be converted:\n\n  * Loops over statically allocated arrays.\n  * Loops over containers, using iterators.\n  * Loops over array-like containers, using `operator[]` and `at()`.\n\n## MinConfidence optionÂ¶\n\n### riskyÂ¶\n\nIn loops where the container expression is more complex than just a reference\nto a declared expression (a variable, function, enum, etc.), and some part of\nit appears elsewhere in the loop, we lower our confidence in the\ntransformation due to the increased risk of changing semantics.\nTransformations for these loops are marked as risky, and thus will only be\nconverted if the minimum required confidence level is set to risky.\n\n    \n    \n    int arr[10][20];\n    int l = 5;\n    \n    for (int j = 0; j < 20; ++j)\n      int k = arr[l][j] + l; // using l outside arr[l] is considered risky\n    \n    for (int i = 0; i < obj.getVector().size(); ++i)\n      obj.foo(10); // using 'obj' is considered risky\n    \n\nSee Range-based loops evaluate end() only once for an example of an incorrect\ntransformation when the minimum required confidence level is set to risky.\n\n### reasonable (Default)Â¶\n\nIf a loop calls `.end()` or `.size()` after each iteration, the transformation\nfor that loop is marked as reasonable, and thus will be converted if the\nrequired confidence level is set to reasonable (default) or lower.\n\n    \n    \n    // using size() is considered reasonable\n    for (int i = 0; i < container.size(); ++i)\n      cout << container[i];\n    \n\n### safeÂ¶\n\nAny other loops that do not match the above criteria to be marked as risky or\nreasonable are marked safe, and thus will be converted if the required\nconfidence level is set to safe or lower.\n\n    \n    \n    int arr[] = {1,2,3};\n    \n    for (int i = 0; i < 3; ++i)\n      cout << arr[i];\n    \n\n## ExampleÂ¶\n\nOriginal:\n\n    \n    \n    const int N = 5;\n    int arr[] = {1,2,3,4,5};\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    \n    // safe conversion\n    for (int i = 0; i < N; ++i)\n      cout << arr[i];\n    \n    // reasonable conversion\n    for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)\n      cout << *it;\n    \n    // reasonable conversion\n    for (int i = 0; i < v.size(); ++i)\n      cout << v[i];\n    \n\nAfter applying the check with minimum confidence level set to reasonable\n(default):\n\n    \n    \n    const int N = 5;\n    int arr[] = {1,2,3,4,5};\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    \n    // safe conversion\n    for (auto & elem : arr)\n      cout << elem;\n    \n    // reasonable conversion\n    for (auto & elem : v)\n      cout << elem;\n    \n    // reasonable conversion\n    for (auto & elem : v)\n      cout << elem;\n    \n\n## Reverse Iterator SupportÂ¶\n\nThe converter is also capable of transforming iterator loops which use\n`rbegin` and `rend` for looping backwards over a container. Out of the box\nthis will automatically happen in C++20 mode using the `ranges` library,\nhowever the check can be configured to work without C++20 by specifying a\nfunction to reverse a range and optionally the header file where that function\nlives.\n\n`UseCxx20ReverseRanges```Â¶\n\n    \n\nWhen set to true convert loops when in C++20 or later mode using\n`std::ranges::reverse_view`. Default value is `true`.\n\n`MakeReverseRangeFunction```Â¶\n\n    \n\nSpecify the function used to reverse an iterator pair, the function should\naccept a class with `rbegin` and `rend` methods and return a class with\n`begin` and `end` methods that call the `rbegin` and `rend` methods\nrespectively. Common examples are `ranges::reverse_view` and `llvm::reverse`.\nDefault value is an empty string.\n\n`MakeReverseRangeHeader```Â¶\n\n    \n\nSpecifies the header file where `MakeReverseRangeFunction` is declared. For\nthe previous examples this option would be set to `range/v3/view/reverse.hpp`\nand `llvm/ADT/STLExtras.h` respectively. If this is an empty string and\n`MakeReverseRangeFunction` is set, the check will proceed on the assumption\nthat the function is already available in the translation unit. This can be\nwrapped in angle brackets to signify to add the include as a system include.\nDefault value is an empty string.\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n## LimitationsÂ¶\n\nThere are certain situations where the tool may erroneously perform\ntransformations that remove information and change semantics. Users of the\ntool should be aware of the behavior and limitations of the check outlined by\nthe cases below.\n\n### Comments inside loop headersÂ¶\n\nComments inside the original loop header are ignored and deleted when\ntransformed.\n\n    \n    \n    for (int i = 0; i < N; /* This will be deleted */ ++i) { }\n    \n\n### Range-based loops evaluate end() only onceÂ¶\n\nThe C++11 range-based for loop calls `.end()` only once during the\ninitialization of the loop. If in the original loop `.end()` is called after\neach iteration the semantics of the transformed loop may differ.\n\n    \n    \n    // The following is semantically equivalent to the C++11 range-based for loop,\n    // therefore the semantics of the header will not change.\n    for (iterator it = container.begin(), e = container.end(); it != e; ++it) { }\n    \n    // Instead of calling .end() after each iteration, this loop will be\n    // transformed to call .end() only once during the initialization of the loop,\n    // which may affect semantics.\n    for (iterator it = container.begin(); it != container.end(); ++it) { }\n    \n\nAs explained above, calling member functions of the container in the body of\nthe loop is considered risky. If the called member function modifies the\ncontainer the semantics of the converted loop will differ due to `.end()`\nbeing called only once.\n\n    \n    \n    bool flag = false;\n    for (vector<T>::iterator it = vec.begin(); it != vec.end(); ++it) {\n      // Add a copy of the first element to the end of the vector.\n      if (!flag) {\n        // This line makes this transformation 'risky'.\n        vec.push_back(*it);\n        flag = true;\n      }\n      cout << *it;\n    }\n    \n\nThe original code above prints out the contents of the container including the\nnewly added element while the converted loop, shown below, will only print the\noriginal contents and not the newly added element.\n\n    \n    \n    bool flag = false;\n    for (auto & elem : vec) {\n      // Add a copy of the first element to the end of the vector.\n      if (!flag) {\n        // This line makes this transformation 'risky'\n        vec.push_back(elem);\n        flag = true;\n      }\n      cout << elem;\n    }\n    \n\nSemantics will also be affected if `.end()` has side effects. For example, in\nthe case where calls to `.end()` are logged the semantics will change in the\ntransformed loop if `.end()` was originally called after each iteration.\n\n    \n    \n    iterator end() {\n      num_of_end_calls++;\n      return container.end();\n    }\n    \n\n### Overloaded operator->() with side effectsÂ¶\n\nSimilarly, if `operator->()` was overloaded to have side effects, such as\nlogging, the semantics will change. If the iteratorâs `operator->()` was\nused in the original loop it will be replaced with `<container\nelement>.<member>` instead due to the implicit dereference as part of the\nrange-based for loop. Therefore any side effect of the overloaded\n`operator->()` will no longer be performed.\n\n    \n    \n    for (iterator it = c.begin(); it != c.end(); ++it) {\n      it->func(); // Using operator->()\n    }\n    // Will be transformed to:\n    for (auto & elem : c) {\n      elem.func(); // No longer using operator->()\n    }\n    \n\n### Pointers and references to containersÂ¶\n\nWhile most of the checkâs risk analysis is dedicated to determining whether\nthe iterator or container was modified within the loop, it is possible to\ncircumvent the analysis by accessing and modifying the container through a\npointer or reference.\n\nIf the container were directly used instead of using the pointer or reference\nthe following transformation would have only been applied at the risky level\nsince calling a member function of the container is considered risky. The\ncheck cannot identify expressions associated with the container that are\ndifferent than the one used in the loop header, therefore the transformation\nbelow ends up being performed at the safe level.\n\n    \n    \n    vector<int> vec;\n    \n    vector<int> *ptr = &vec;\n    vector<int> &ref = vec;\n    \n    for (vector<int>::iterator it = vec.begin(), e = vec.end(); it != e; ++it) {\n      if (!flag) {\n        // Accessing and modifying the container is considered risky, but the risk\n        // level is not raised here.\n        ptr->push_back(*it);\n        ref.push_back(*it);\n        flag = true;\n      }\n    }\n    \n\n### OpenMPÂ¶\n\nAs range-based for loops are only available since OpenMP 5, this check should\nnot be used on code with a compatibility requirement of OpenMP prior to\nversion 5. It is **intentional** that this check does not make any attempts to\nexclude incorrect diagnostics on OpenMP for loops prior to OpenMP 5.\n\nTo prevent this check to be applied (and to break) OpenMP for loops but still\nbe applied to non-OpenMP for loops the usage of `NOLINT` (see [Suppressing\nUndesired Diagnostics](../../index.html#clang-tidy-nolint)) on the specific\nfor loops is recommended.",
                "disable": false
            },
            {
                "real_name": "modernize-macro-to-enum",
                "display_name": "modernize-macro-to-enum",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-macro-to-enumÂ¶\n\nReplaces groups of adjacent macros with an unscoped anonymous enum. Using an\nunscoped anonymous enum ensures that everywhere the macro token was used\npreviously, the enumerator name may be safely used.\n\nThis check can be used to enforce the C++ core guideline [Enum.1: Prefer\nenumerations over\nmacros](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#enum1-prefer-\nenumerations-over-macros), within the constraints outlined below.\n\nPotential macros for replacement must meet the following constraints:\n\n  * Macros must expand only to integral literal tokens or expressions of literal tokens. The expression may contain any of the unary operators `-`, `+`, `~` or `!`, any of the binary operators `,`, `-`, `+`, `*`, `/`, `%`, `&`, `|`, `^`, `<`, `>`, `<=`, `>=`, `==`, `!=`, `||`, `&&`, `<<`, `>>` or `<=>`, the ternary operator `?:` and its [GNU extension](https://gcc.gnu.org/onlinedocs/gcc/Conditionals.html). Parenthesized expressions are also recognized. This recognizes most valid expressions. In particular, expressions with the `sizeof` operator are not recognized.\n  * Macros must be defined on sequential source file lines, or with only comment lines in between macro definitions.\n  * Macros must all be defined in the same source file.\n  * Macros must not be defined within a conditional compilation block. (Conditional include guards are exempt from this constraint.)\n  * Macros must not be defined adjacent to other preprocessor directives.\n  * Macros must not be used in any conditional preprocessing directive.\n  * Macros must not be used as arguments to other macros.\n  * Macros must not be undefined.\n  * Macros must be defined at the top-level, not inside any declaration or definition.\n\nEach cluster of macros meeting the above constraints is presumed to be a set\nof values suitable for replacement by an anonymous enum. From there, a\ndeveloper can give the anonymous enum a name and continue refactoring to a\nscoped enum if desired. Comments on the same line as a macro definition or\nbetween subsequent macro definitions are preserved in the output. No\nformatting is assumed in the provided replacements, although clang-tidy can\noptionally format all fixes.\n\nWarning\n\nInitializing expressions are assumed to be valid initializers for an enum. C\nrequires that enum values fit into an `int`, but this may not be the case for\nsome accepted constant expressions. For instance `1 << 40` will not fit into\nan `int` when the size of an `int` is 32 bits.\n\nExamples:\n\n    \n    \n    #define RED   0xFF0000\n    #define GREEN 0x00FF00\n    #define BLUE  0x0000FF\n    \n    #define TM_NONE (-1) // No method selected.\n    #define TM_ONE 1    // Use tailored method one.\n    #define TM_TWO 2    // Use tailored method two.  Method two\n                        // is preferable to method one.\n    #define TM_THREE 3  // Use tailored method three.\n    \n\nbecomes\n\n    \n    \n    enum {\n    RED = 0xFF0000,\n    GREEN = 0x00FF00,\n    BLUE = 0x0000FF\n    };\n    \n    enum {\n    TM_NONE = (-1), // No method selected.\n    TM_ONE = 1,    // Use tailored method one.\n    TM_TWO = 2,    // Use tailored method two.  Method two\n                        // is preferable to method one.\n    TM_THREE = 3  // Use tailored method three.\n    };",
                "disable": false
            },
            {
                "real_name": "modernize-make-shared",
                "display_name": "modernize-make-shared",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-make-sharedÂ¶\n\nThis check finds the creation of `std::shared_ptr` objects by explicitly\ncalling the constructor and a `new` expression, and replaces it with a call to\n`std::make_shared`.\n\n    \n    \n    auto my_ptr = std::shared_ptr<MyPair>(new MyPair(1, 2));\n    \n    // becomes\n    \n    auto my_ptr = std::make_shared<MyPair>(1, 2);\n    \n\nThis check also finds calls to `std::shared_ptr::reset()` with a `new`\nexpression, and replaces it with a call to `std::make_shared`.\n\n    \n    \n    my_ptr.reset(new MyPair(1, 2));\n    \n    // becomes\n    \n    my_ptr = std::make_shared<MyPair>(1, 2);\n    \n\n## OptionsÂ¶\n\n`MakeSmartPtrFunction```Â¶\n\n    \n\nA string specifying the name of make-shared-ptr function. Default is\nstd::make_shared.\n\n`MakeSmartPtrFunctionHeader```Â¶\n\n    \n\nA string specifying the corresponding header of make-shared-ptr function.\nDefault is memory.\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will not give warnings inside macros. Default is\ntrue.\n\n`IgnoreDefaultInitialization```Â¶\n\n    \n\nIf set to non-zero, the check does not suggest edits that will transform\ndefault initialization into value initialization, as this can cause\nperformance regressions. Default is 1.",
                "disable": false
            },
            {
                "real_name": "modernize-make-unique",
                "display_name": "modernize-make-unique",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-make-uniqueÂ¶\n\nThis check finds the creation of `std::unique_ptr` objects by explicitly\ncalling the constructor and a `new` expression, and replaces it with a call to\n`std::make_unique`, introduced in C++14.\n\n    \n    \n    auto my_ptr = std::unique_ptr<MyPair>(new MyPair(1, 2));\n    \n    // becomes\n    \n    auto my_ptr = std::make_unique<MyPair>(1, 2);\n    \n\nThis check also finds calls to `std::unique_ptr::reset()` with a `new`\nexpression, and replaces it with a call to `std::make_unique`.\n\n    \n    \n    my_ptr.reset(new MyPair(1, 2));\n    \n    // becomes\n    \n    my_ptr = std::make_unique<MyPair>(1, 2);\n    \n\n## OptionsÂ¶\n\n`MakeSmartPtrFunction```Â¶\n\n    \n\nA string specifying the name of make-unique-ptr function. Default is\nstd::make_unique.\n\n`MakeSmartPtrFunctionHeader```Â¶\n\n    \n\nA string specifying the corresponding header of make-unique-ptr function.\nDefault is <memory>.\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will not give warnings inside macros. Default is\ntrue.\n\n`IgnoreDefaultInitialization```Â¶\n\n    \n\nIf set to non-zero, the check does not suggest edits that will transform\ndefault initialization into value initialization, as this can cause\nperformance regressions. Default is 1.",
                "disable": false
            },
            {
                "real_name": "modernize-pass-by-value",
                "display_name": "modernize-pass-by-value",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-pass-by-valueÂ¶\n\nWith move semantics added to the language and the standard library updated\nwith move constructors added for many types it is now interesting to take an\nargument directly by value, instead of by const-reference, and then copy. This\ncheck allows the compiler to take care of choosing the best way to construct\nthe copy.\n\nThe transformation is usually beneficial when the calling code passes an\n_rvalue_ and assumes the move construction is a cheap operation. This short\nexample illustrates how the construction of the value happens:\n\n    \n    \n    void foo(std::string s);\n    std::string get_str();\n    \n    void f(const std::string &str) {\n      foo(str);       // lvalue  -> copy construction\n      foo(get_str()); // prvalue -> move construction\n    }\n    \n\nNote\n\nCurrently, only constructors are transformed to make use of pass-by-value.\nContributions that handle other situations are welcome!\n\n## Pass-by-value in constructorsÂ¶\n\nReplaces the uses of const-references constructor parameters that are copied\ninto class fields. The parameter is then moved with std::move().\n\nSince `std::move()` is a library function declared in <utility> it may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\n    \n    \n     #include <string>\n    \n     class Foo {\n     public:\n    -  Foo(const std::string &Copied, const std::string &ReadOnly)\n    -    : Copied(Copied), ReadOnly(ReadOnly)\n    +  Foo(std::string Copied, const std::string &ReadOnly)\n    +    : Copied(std::move(Copied)), ReadOnly(ReadOnly)\n       {}\n    \n     private:\n       std::string Copied;\n       const std::string &ReadOnly;\n     };\n    \n     std::string get_cwd();\n    \n     void f(const std::string &Path) {\n       // The parameter corresponding to 'get_cwd()' is move-constructed. By\n       // using pass-by-value in the Foo constructor we managed to avoid a\n       // copy-construction.\n       Foo foo(get_cwd(), Path);\n     }\n    \n\nIf the parameter is used more than once no transformation is performed since\nmoved objects have an undefined state. It means the following code will be\nleft untouched:\n\n    \n    \n    #include <string>\n    \n    void pass(const std::string &S);\n    \n    struct Foo {\n      Foo(const std::string &S) : Str(S) {\n        pass(S);\n      }\n    \n      std::string Str;\n    };\n    \n\n### Known limitationsÂ¶\n\nA situation where the generated code can be wrong is when the object\nreferenced is modified before the assignment in the init-list through a\nâhiddenâ reference.\n\nExample:\n\n    \n    \n     std::string s(\"foo\");\n    \n     struct Base {\n       Base() {\n         s = \"bar\";\n       }\n     };\n    \n     struct Derived : Base {\n    -  Derived(const std::string &S) : Field(S)\n    +  Derived(std::string S) : Field(std::move(S))\n       { }\n    \n       std::string Field;\n     };\n    \n     void f() {\n    -  Derived d(s); // d.Field holds \"bar\"\n    +  Derived d(s); // d.Field holds \"foo\"\n     }\n    \n\n### Note about delayed template parsingÂ¶\n\nWhen delayed template parsing is enabled, constructors part of templated\ncontexts; templated constructors, constructors in class templates,\nconstructors of inner classes of template classes, etc., are not transformed.\nDelayed template parsing is enabled by default on Windows as a Microsoft\nextension: [Clang Compiler Userâs Manual - Microsoft\nextensions](https://clang.llvm.org/docs/UsersManual.html#microsoft-\nextensions).\n\nDelayed template parsing can be enabled using the -fdelayed-template-parsing\nflag and disabled using -fno-delayed-template-parsing.\n\nExample:\n\n    \n    \n      template <typename T> class C {\n        std::string S;\n    \n      public:\n    =  // using -fdelayed-template-parsing (default on Windows)\n    =  C(const std::string &S) : S(S) {}\n    \n    +  // using -fno-delayed-template-parsing (default on non-Windows systems)\n    +  C(std::string S) : S(std::move(S)) {}\n      };\n    \n\nSee also\n\nFor more information about the pass-by-value idiom, read: [Want Speed? Pass by\nValue](https://web.archive.org/web/20140205194657/http://cpp-\nnext.com/archive/2009/08/want-speed-pass-by-value/).\n\n## OptionsÂ¶\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`ValuesOnly```Â¶\n\n    \n\nWhen true, the check only warns about copied parameters that are already\npassed by value. Default is false.",
                "disable": false
            },
            {
                "real_name": "modernize-raw-string-literal",
                "display_name": "modernize-raw-string-literal",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-raw-string-literalÂ¶\n\nThis check selectively replaces string literals containing escaped characters\nwith raw string literals.\n\nExample:\n\n    \n    \n    const char *const Quotes{\"embedded \\\"quotes\\\"\"};\n    const char *const Paragraph{\"Line one.\\nLine two.\\nLine three.\\n\"};\n    const char *const SingleLine{\"Single line.\\n\"};\n    const char *const TrailingSpace{\"Look here -> \\n\"};\n    const char *const Tab{\"One\\tTwo\\n\"};\n    const char *const Bell{\"Hello!\\a  And welcome!\"};\n    const char *const Path{\"C:\\\\Program Files\\\\Vendor\\\\Application.exe\"};\n    const char *const RegEx{\"\\\\w\\\\([a-z]\\\\)\"};\n    \n\nbecomes\n\n    \n    \n    const char *const Quotes{R\"(embedded \"quotes\")\"};\n    const char *const Paragraph{\"Line one.\\nLine two.\\nLine three.\\n\"};\n    const char *const SingleLine{\"Single line.\\n\"};\n    const char *const TrailingSpace{\"Look here -> \\n\"};\n    const char *const Tab{\"One\\tTwo\\n\"};\n    const char *const Bell{\"Hello!\\a  And welcome!\"};\n    const char *const Path{R\"(C:\\Program Files\\Vendor\\Application.exe)\"};\n    const char *const RegEx{R\"(\\w\\([a-z]\\))\"};\n    \n\nThe presence of any of the following escapes can cause the string to be\nconverted to a raw string literal: `\\\\`, `\\'`, `\\\"`, `\\?`, and octal or\nhexadecimal escapes for printable ASCII characters.\n\nA string literal containing only escaped newlines is a common way of writing\nlines of text output. Introducing physical newlines with raw string literals\nin this case is likely to impede readability. These string literals are left\nunchanged.\n\nAn escaped horizontal tab, form feed, or vertical tab prevents the string\nliteral from being converted. The presence of a horizontal tab, form feed or\nvertical tab in source code is not visually obvious.",
                "disable": false
            },
            {
                "real_name": "modernize-redundant-void-arg",
                "display_name": "modernize-redundant-void-arg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-redundant-void-argÂ¶\n\nFind and remove redundant `void` argument lists.\n\nExamples:\n\n     Initial code | Code with applied fixes  \n---|---  \n`int f(void);` | `int f();`  \n`int (*f(void))(void);` | `int (*f())();`  \n`typedef int (*f_t(void))(void);` | `typedef int (*f_t())();`  \n`void (C::*p)(void);` | `void (C::*p)();`  \n`C::C(void) {}` | `C::C() {}`  \n`C::~C(void) {}` | `C::~C() {}`",
                "disable": false
            },
            {
                "real_name": "modernize-replace-auto-ptr",
                "display_name": "modernize-replace-auto-ptr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-replace-auto-ptrÂ¶\n\nThis check replaces the uses of the deprecated class `std::auto_ptr` by\n`std::unique_ptr` (introduced in C++11). The transfer of ownership, done by\nthe copy-constructor and the assignment operator, is changed to match\n`std::unique_ptr` usage by using explicit calls to `std::move()`.\n\nMigration example:\n\n    \n    \n    -void take_ownership_fn(std::auto_ptr<int> int_ptr);\n    +void take_ownership_fn(std::unique_ptr<int> int_ptr);\n    \n     void f(int x) {\n    -  std::auto_ptr<int> a(new int(x));\n    -  std::auto_ptr<int> b;\n    +  std::unique_ptr<int> a(new int(x));\n    +  std::unique_ptr<int> b;\n    \n    -  b = a;\n    -  take_ownership_fn(b);\n    +  b = std::move(a);\n    +  take_ownership_fn(std::move(b));\n     }\n    \n\nSince `std::move()` is a library function declared in `<utility>` it may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\n## Known LimitationsÂ¶\n\n  * If headers modification is not activated or if a header is not allowed to be changed this check will produce broken code (compilation error), where the headersâ code will stay unchanged while the code using them will be changed.\n  * Client code that declares a reference to an `std::auto_ptr` coming from code that canât be migrated (such as a header coming from a 3rd party library) will produce a compilation error after migration. This is because the type of the reference will be changed to `std::unique_ptr` but the type returned by the library wonât change, binding a reference to `std::unique_ptr` from an `std::auto_ptr`. This pattern doesnât make much sense and usually `std::auto_ptr` are stored by value (otherwise what is the point in using them instead of a reference or a pointer?).\n\n    \n    \n     // <3rd-party header...>\n     std::auto_ptr<int> get_value();\n     const std::auto_ptr<int> & get_ref();\n    \n     // <calling code (with migration)...>\n    -std::auto_ptr<int> a(get_value());\n    +std::unique_ptr<int> a(get_value()); // ok, unique_ptr constructed from auto_ptr\n    \n    -const std::auto_ptr<int> & p = get_ptr();\n    +const std::unique_ptr<int> & p = get_ptr(); // won't compile\n    \n\n  * Non-instantiated templates arenât modified.\n\n    \n    \n    template <typename X>\n    void f() {\n        std::auto_ptr<X> p;\n    }\n    \n    // only 'f<int>()' (or similar) will trigger the replacement.\n    \n\n## OptionsÂ¶\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.",
                "disable": false
            },
            {
                "real_name": "modernize-replace-disallow-copy-and-assign-macro",
                "display_name": "modernize-replace-disallow-copy-and-assign-macro",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-replace-disallow-copy-and-assign-macroÂ¶\n\nFinds macro expansions of `DISALLOW_COPY_AND_ASSIGN(Type)` and replaces them\nwith a deleted copy constructor and a deleted assignment operator.\n\nBefore the `delete` keyword was introduced in C++11 it was common practice to\ndeclare a copy constructor and an assignment operator as private members. This\neffectively makes them unusable to the public API of a class.\n\nWith the advent of the `delete` keyword in C++11 we can abandon the `private`\naccess of the copy constructor and the assignment operator and delete the\nmethods entirely.\n\nWhen running this check on a code like this:\n\n    \n    \n    class Foo {\n    private:\n      DISALLOW_COPY_AND_ASSIGN(Foo);\n    };\n    \n\nIt will be transformed to this:\n\n    \n    \n    class Foo {\n    private:\n      Foo(const Foo &) = delete;\n      const Foo &operator=(const Foo &) = delete;\n    };\n    \n\n## Known LimitationsÂ¶\n\n  * Notice that the migration example above leaves the `private` access specification untouched. You might want to run the check [modernize-use-equals-delete](use-equals-delete.html) to get warnings for deleted functions in private sections.\n\n## OptionsÂ¶\n\n`MacroName```Â¶\n\n    \n\nA string specifying the macro name whose expansion will be replaced. Default\nis DISALLOW_COPY_AND_ASSIGN.\n\nSee: <https://en.cppreference.com/w/cpp/language/function#Deleted_functions>",
                "disable": false
            },
            {
                "real_name": "modernize-replace-random-shuffle",
                "display_name": "modernize-replace-random-shuffle",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-replace-random-shuffleÂ¶\n\nThis check will find occurrences of `std::random_shuffle` and replace it with\n`std::shuffle`. In C++17 `std::random_shuffle` will no longer be available and\nthus we need to replace it.\n\nBelow are two examples of what kind of occurrences will be found and two\nexamples of what it will be replaced with.\n\n    \n    \n    std::vector<int> v;\n    \n    // First example\n    std::random_shuffle(vec.begin(), vec.end());\n    \n    // Second example\n    std::random_shuffle(vec.begin(), vec.end(), randomFunc);\n    \n\nBoth of these examples will be replaced with:\n\n    \n    \n    std::shuffle(vec.begin(), vec.end(), std::mt19937(std::random_device()()));\n    \n\nThe second example will also receive a warning that `randomFunc` is no longer\nsupported in the same way as before so if the user wants the same\nfunctionality, the user will need to change the implementation of the\n`randomFunc`.\n\nOne thing to be aware of here is that `std::random_device` is quite expensive\nto initialize. So if you are using the code in a performance critical place,\nyou probably want to initialize it elsewhere. Another thing is that the\nseeding quality of the suggested fix is quite poor: `std::mt19937` has an\ninternal state of 624 32-bit integers, but is only seeded with a single\ninteger. So if you require higher quality randomness, you should consider\nseeding better, for example:\n\n    \n    \n    std::shuffle(v.begin(), v.end(), []() {\n      std::mt19937::result_type seeds[std::mt19937::state_size];\n      std::random_device device;\n      std::uniform_int_distribution<typename std::mt19937::result_type> dist;\n      std::generate(std::begin(seeds), std::end(seeds), [&] { return dist(device); });\n      std::seed_seq seq(std::begin(seeds), std::end(seeds));\n      return std::mt19937(seq);\n    }());",
                "disable": false
            },
            {
                "real_name": "modernize-return-braced-init-list",
                "display_name": "modernize-return-braced-init-list",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-return-braced-init-listÂ¶\n\nReplaces explicit calls to the constructor in a return with a braced\ninitializer list. This way the return type is not needlessly duplicated in the\nfunction definition and the return statement.\n\n    \n    \n    Foo bar() {\n      Baz baz;\n      return Foo(baz);\n    }\n    \n    // transforms to:\n    \n    Foo bar() {\n      Baz baz;\n      return {baz};\n    }",
                "disable": false
            },
            {
                "real_name": "modernize-shrink-to-fit",
                "display_name": "modernize-shrink-to-fit",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-shrink-to-fitÂ¶\n\nReplace copy and swap tricks on shrinkable containers with the\n`shrink_to_fit()` method call.\n\nThe `shrink_to_fit()` method is more readable and more effective than the copy\nand swap trick to reduce the capacity of a shrinkable container. Note that,\nthe `shrink_to_fit()` method is only available in C++11 and up.",
                "disable": false
            },
            {
                "real_name": "modernize-unary-static-assert",
                "display_name": "modernize-unary-static-assert",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-unary-static-assertÂ¶\n\nThe check diagnoses any `static_assert` declaration with an empty string\nliteral and provides a fix-it to replace the declaration with a single-\nargument `static_assert` declaration.\n\nThe check is only applicable for C++17 and later code.\n\nThe following code:\n\n    \n    \n    void f_textless(int a) {\n      static_assert(sizeof(a) <= 10, \"\");\n    }\n    \n\nis replaced by:\n\n    \n    \n    void f_textless(int a) {\n      static_assert(sizeof(a) <= 10);\n    }",
                "disable": false
            },
            {
                "real_name": "modernize-use-auto",
                "display_name": "modernize-use-auto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-autoÂ¶\n\nThis check is responsible for using the `auto` type specifier for variable\ndeclarations to _improve code readability and maintainability_. For example:\n\n    \n    \n    std::vector<int>::iterator I = my_container.begin();\n    \n    // transforms to:\n    \n    auto I = my_container.begin();\n    \n\nThe `auto` type specifier will only be introduced in situations where the\nvariable type matches the type of the initializer expression. In other words\n`auto` should deduce the same type that was originally spelled in the source.\nHowever, not every situation should be transformed:\n\n    \n    \n    int val = 42;\n    InfoStruct &I = SomeObject.getInfo();\n    \n    // Should not become:\n    \n    auto val = 42;\n    auto &I = SomeObject.getInfo();\n    \n\nIn this example using `auto` for builtins doesnât improve readability. In\nother situations it makes the code less self-documenting impairing readability\nand maintainability. As a result, `auto` is used only introduced in specific\nsituations described below.\n\n## IteratorsÂ¶\n\nIterator type specifiers tend to be long and used frequently, especially in\nloop constructs. Since the functions generating iterators have a common\nformat, the type specifier can be replaced without obscuring the meaning of\ncode while improving readability and maintainability.\n\n    \n    \n    for (std::vector<int>::iterator I = my_container.begin(),\n                                    E = my_container.end();\n         I != E; ++I) {\n    }\n    \n    // becomes\n    \n    for (auto I = my_container.begin(), E = my_container.end(); I != E; ++I) {\n    }\n    \n\nThe check will only replace iterator type-specifiers when all of the following\nconditions are satisfied:\n\n  * The iterator is for one of the standard containers in `std` namespace:\n    * `array`\n    * `deque`\n    * `forward_list`\n    * `list`\n    * `vector`\n    * `map`\n    * `multimap`\n    * `set`\n    * `multiset`\n    * `unordered_map`\n    * `unordered_multimap`\n    * `unordered_set`\n    * `unordered_multiset`\n    * `queue`\n    * `priority_queue`\n    * `stack`\n  * The iterator is one of the possible iterator types for standard containers:\n    * `iterator`\n    * `reverse_iterator`\n    * `const_iterator`\n    * `const_reverse_iterator`\n  * In addition to using iterator types directly, typedefs or other ways of referring to those types are also allowed. However, implementation-specific types for which a type like `std::vector<int>::iterator` is itself a typedef will not be transformed. Consider the following examples:\n\n    \n    \n    // The following direct uses of iterator types will be transformed.\n    std::vector<int>::iterator I = MyVec.begin();\n    {\n      using namespace std;\n      list<int>::iterator I = MyList.begin();\n    }\n    \n    // The type specifier for J would transform to auto since it's a typedef\n    // to a standard iterator type.\n    typedef std::map<int, std::string>::const_iterator map_iterator;\n    map_iterator J = MyMap.begin();\n    \n    // The following implementation-specific iterator type for which\n    // std::vector<int>::iterator could be a typedef would not be transformed.\n    __gnu_cxx::__normal_iterator<int*, std::vector> K = MyVec.begin();\n    \n\n  * The initializer for the variable being declared is not a braced initializer list. Otherwise, use of `auto` would cause the type of the variable to be deduced as `std::initializer_list`.\n\n## New expressionsÂ¶\n\nFrequently, when a pointer is declared and initialized with `new`, the pointee\ntype is written twice: in the declaration type and in the `new` expression. In\nthis case, the declaration type can be replaced with `auto` improving\nreadability and maintainability.\n\n    \n    \n    TypeName *my_pointer = new TypeName(my_param);\n    \n    // becomes\n    \n    auto *my_pointer = new TypeName(my_param);\n    \n\nThe check will also replace the declaration type in multiple declarations, if\nthe following conditions are satisfied:\n\n  * All declared variables have the same type (i.e. all of them are pointers to the same type).\n  * All declared variables are initialized with a `new` expression.\n  * The types of all the new expressions are the same than the pointee of the declaration type.\n\n    \n    \n    TypeName *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;\n    \n    // becomes\n    \n    auto *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;\n    \n\n## Cast expressionsÂ¶\n\nFrequently, when a variable is declared and initialized with a cast, the\nvariable type is written twice: in the declaration type and in the cast\nexpression. In this case, the declaration type can be replaced with `auto`\nimproving readability and maintainability.\n\n    \n    \n    TypeName *my_pointer = static_cast<TypeName>(my_param);\n    \n    // becomes\n    \n    auto *my_pointer = static_cast<TypeName>(my_param);\n    \n\nThe check handles `static_cast`, `dynamic_cast`, `const_cast`,\n`reinterpret_cast`, functional casts, C-style casts and function templates\nthat behave as casts, such as `llvm::dyn_cast`, `boost::lexical_cast` and\n`gsl::narrow_cast`. Calls to function templates are considered to behave as\ncasts if the first template argument is explicit and is a type, and the\nfunction returns that type, or a pointer or reference to it.\n\n## Known LimitationsÂ¶\n\n  * If the initializer is an explicit conversion constructor, the check will not replace the type specifier even though it would be safe to do so.\n  * User-defined iterators are not handled at this time.\n\n## OptionsÂ¶\n\n`MinTypeNameLength```Â¶\n\n    \n\nIf the option is set to non-zero (default 5), the check will ignore type names\nhaving a length less than the option value. The option affects expressions\nonly, not iterators. Spaces between multi-lexeme type names (`long int`) are\nconsidered as one. If the `RemoveStars` option (see below) is set to true,\nthen `*s` in the type are also counted as a part of the type name.\n\n    \n    \n    // MinTypeNameLength = 0, RemoveStars=0\n    \n    int a = static_cast<int>(foo());            // ---> auto a = ...\n    // length(bool *) = 4\n    bool *b = new bool;                         // ---> auto *b = ...\n    unsigned c = static_cast<unsigned>(foo());  // ---> auto c = ...\n    \n    // MinTypeNameLength = 5, RemoveStars=0\n    \n    int a = static_cast<int>(foo());                 // ---> int  a = ...\n    bool b = static_cast<bool>(foo());               // ---> bool b = ...\n    bool *pb = static_cast<bool*>(foo());            // ---> bool *pb = ...\n    unsigned c = static_cast<unsigned>(foo());       // ---> auto c = ...\n    // length(long <on-or-more-spaces> int) = 8\n    long int d = static_cast<long int>(foo());       // ---> auto d = ...\n    \n    // MinTypeNameLength = 5, RemoveStars=1\n    \n    int a = static_cast<int>(foo());                 // ---> int  a = ...\n    // length(int * * ) = 5\n    int **pa = static_cast<int**>(foo());            // ---> auto pa = ...\n    bool b = static_cast<bool>(foo());               // ---> bool b = ...\n    bool *pb = static_cast<bool*>(foo());            // ---> auto pb = ...\n    unsigned c = static_cast<unsigned>(foo());       // ---> auto c = ...\n    long int d = static_cast<long int>(foo());       // ---> auto d = ...\n    \n\n`RemoveStars```Â¶\n\n    \n\nIf the option is set to true (default is false), the check will remove stars\nfrom the non-typedef pointer types when replacing type names with `auto`.\nOtherwise, the check will leave stars. For example:\n\n    \n    \n    TypeName *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;\n    \n    // RemoveStars = 0\n    \n    auto *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;\n    \n    // RemoveStars = 1\n    \n    auto my_first_pointer = new TypeName, my_second_pointer = new TypeName;",
                "disable": false
            },
            {
                "real_name": "modernize-use-bool-literals",
                "display_name": "modernize-use-bool-literals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-bool-literalsÂ¶\n\nFinds integer literals which are cast to `bool`.\n\n    \n    \n    bool p = 1;\n    bool f = static_cast<bool>(1);\n    std::ios_base::sync_with_stdio(0);\n    bool x = p ? 1 : 0;\n    \n    // transforms to\n    \n    bool p = true;\n    bool f = true;\n    std::ios_base::sync_with_stdio(false);\n    bool x = p ? true : false;\n    \n\n## OptionsÂ¶\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will not give warnings inside macros. Default is\ntrue.",
                "disable": false
            },
            {
                "real_name": "modernize-use-default-member-init",
                "display_name": "modernize-use-default-member-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-default-member-initÂ¶\n\nThis check converts constructorsâ member initializers into the new default\nmember initializers in C++11. Other member initializers that match the default\nmember initializer are removed. This can reduce repeated code or allow use of\nâ= defaultâ.\n\n    \n    \n    struct A {\n      A() : i(5), j(10.0) {}\n      A(int i) : i(i), j(10.0) {}\n      int i;\n      double j;\n    };\n    \n    // becomes\n    \n    struct A {\n      A() {}\n      A(int i) : i(i) {}\n      int i{5};\n      double j{10.0};\n    };\n    \n\nNote\n\nOnly converts member initializers for built-in types, enums, and pointers. The\nreadability-redundant-member-init check will remove redundant member\ninitializers for classes.\n\n## OptionsÂ¶\n\n`UseAssignment```Â¶\n\n    \n\nIf this option is set to true (default is false), the check will initialize\nmembers with an assignment. For example:\n\n    \n    \n    struct A {\n      A() {}\n      A(int i) : i(i) {}\n      int i = 5;\n      double j = 10.0;\n    };\n    \n\n`IgnoreMacros```Â¶\n\n    \n\nIf this option is set to true (default is true), the check will not warn about\nmembers declared inside macros.",
                "disable": false
            },
            {
                "real_name": "modernize-use-emplace",
                "display_name": "modernize-use-emplace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-emplaceÂ¶\n\nThe check flags insertions to an STL-style container done by calling the\n`push_back` method with an explicitly-constructed temporary of the container\nelement type. In this case, the corresponding `emplace_back` method results in\nless verbose and potentially more efficient code. Right now the check\ndoesnât support `push_front` and `insert`. It also doesnât support\n`insert` functions for associative containers because replacing `insert` with\n`emplace` may result in [speed\nregression](https://htmlpreview.github.io/?https://github.com/HowardHinnant/papers/blob/master/insert_vs_emplace.html),\nbut it might get support with some addition flag in the future.\n\nBy default only `std::vector`, `std::deque`, `std::list` are considered. This\nlist can be modified using the `ContainersWithPushBack` option.\n\nThis check also reports when an `emplace`-like method is improperly used, for\nexample using `emplace_back` while also calling a constructor. This creates a\ntemporary that requires at best a move and at worst a copy. Almost all\n`emplace`-like functions in the STL are covered by this, with `try_emplace` on\n`std::map` and `std::unordered_map` being the exception as it behaves slightly\ndifferently than all the others. More containers can be added with the\n`EmplacyFunctions` option, so long as the container defines a `value_type`\ntype, and the `emplace`-like functions construct a `value_type` object.\n\nBefore:\n\n    \n    \n    std::vector<MyClass> v;\n    v.push_back(MyClass(21, 37));\n    v.emplace_back(MyClass(21, 37));\n    \n    std::vector<std::pair<int, int>> w;\n    \n    w.push_back(std::pair<int, int>(21, 37));\n    w.push_back(std::make_pair(21L, 37L));\n    w.emplace_back(std::make_pair(21L, 37L));\n    \n\nAfter:\n\n    \n    \n    std::vector<MyClass> v;\n    v.emplace_back(21, 37);\n    v.emplace_back(21, 37);\n    \n    std::vector<std::pair<int, int>> w;\n    w.emplace_back(21, 37);\n    w.emplace_back(21L, 37L);\n    w.emplace_back(21L, 37L);\n    \n\nBy default, the check is able to remove unnecessary `std::make_pair` and\n`std::make_tuple` calls from `push_back` calls on containers of `std::pair`\nand `std::tuple`. Custom tuple-like types can be modified by the `TupleTypes`\noption; custom make functions can be modified by the `TupleMakeFunctions`\noption.\n\nThe other situation is when we pass arguments that will be converted to a type\ninside a container.\n\nBefore:\n\n    \n    \n    std::vector<boost::optional<std::string> > v;\n    v.push_back(\"abc\");\n    \n\nAfter:\n\n    \n    \n    std::vector<boost::optional<std::string> > v;\n    v.emplace_back(\"abc\");\n    \n\nIn some cases the transformation would be valid, but the code wouldnât be\nexception safe. In this case the calls of `push_back` wonât be replaced.\n\n    \n    \n    std::vector<std::unique_ptr<int>> v;\n    v.push_back(std::unique_ptr<int>(new int(0)));\n    auto *ptr = new int(1);\n    v.push_back(std::unique_ptr<int>(ptr));\n    \n\nThis is because replacing it with `emplace_back` could cause a leak of this\npointer if `emplace_back` would throw exception before emplacement (e.g. not\nenough memory to add a new element).\n\nFor more info read item 42 - âConsider emplacement instead of insertion.â\nof Scott Meyers âEffective Modern C++â.\n\nThe default smart pointers that are considered are `std::unique_ptr`,\n`std::shared_ptr`, `std::auto_ptr`. To specify other smart pointers or other\nclasses use the `SmartPointers` option.\n\nCheck also doesnât fire if any argument of the constructor call would be:\n\n>   * a bit-field (bit-fields canât bind to rvalue/universal reference)\n>   * a `new` expression (to avoid leak)\n>   * if the argument would be converted via derived-to-base cast.\n>\n\nThis check requires C++11 or higher to run.\n\n## OptionsÂ¶\n\n`ContainersWithPushBack```Â¶\n\n    \n\nSemicolon-separated list of class names of custom containers that support\n`push_back`.\n\n`IgnoreImplicitConstructors```Â¶\n\n    \n\nWhen true, the check will ignore implicitly constructed arguments of\n`push_back`, e.g.\n\n    \n    \n    std::vector<std::string> v;\n    v.push_back(\"a\"); // Ignored when IgnoreImplicitConstructors is `true`.\n    \n\nDefault is false.\n\n`SmartPointers```Â¶\n\n    \n\nSemicolon-separated list of class names of custom smart pointers.\n\n`TupleTypes```Â¶\n\n    \n\nSemicolon-separated list of `std::tuple`-like class names.\n\n`TupleMakeFunctions```Â¶\n\n    \n\nSemicolon-separated list of `std::make_tuple`-like function names. Those\nfunction calls will be removed from `push_back` calls and turned into\n`emplace_back`.\n\n`EmplacyFunctions```Â¶\n\n    \n\nSemicolon-separated list of containers without their template parameters and\nsome `emplace`-like method of the container. Example: `vector::emplace_back`.\nThose methods will be checked for improper use and the check will report when\na temporary is unnecessarily created.\n\n### ExampleÂ¶\n\n    \n    \n    std::vector<MyTuple<int, bool, char>> x;\n    x.push_back(MakeMyTuple(1, false, 'x'));\n    x.emplace_back(MakeMyTuple(1, false, 'x'));\n    \n\ntransforms to:\n\n    \n    \n    std::vector<MyTuple<int, bool, char>> x;\n    x.emplace_back(1, false, 'x');\n    x.emplace_back(1, false, 'x');\n    \n\nwhen `TupleTypes` is set to `MyTuple`, `TupleMakeFunctions` is set to\n`MakeMyTuple`, and `EmplacyFunctions` is set to `vector::emplace_back`.",
                "disable": false
            },
            {
                "real_name": "modernize-use-equals-default",
                "display_name": "modernize-use-equals-default",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-equals-defaultÂ¶\n\nThis check replaces default bodies of special member functions with `=\ndefault;`. The explicitly defaulted function declarations enable more\nopportunities in optimization, because the compiler might treat explicitly\ndefaulted functions as trivial.\n\n    \n    \n    struct A {\n      A() {}\n      ~A();\n    };\n    A::~A() {}\n    \n    // becomes\n    \n    struct A {\n      A() = default;\n      ~A();\n    };\n    A::~A() = default;\n    \n\nNote\n\nMove-constructor and move-assignment operator are not supported yet.\n\n## OptionsÂ¶\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will not give warnings inside macros. Default is\ntrue.",
                "disable": false
            },
            {
                "real_name": "modernize-use-equals-delete",
                "display_name": "modernize-use-equals-delete",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-equals-deleteÂ¶\n\nThis check marks unimplemented private special member functions with `=\ndelete`. To avoid false-positives, this check only applies in a translation\nunit that has all other member functions implemented.\n\n    \n    \n    struct A {\n    private:\n      A(const A&);\n      A& operator=(const A&);\n    };\n    \n    // becomes\n    \n    struct A {\n    private:\n      A(const A&) = delete;\n      A& operator=(const A&) = delete;\n    };\n    \n\n`IgnoreMacros```Â¶\n\n    \n\nIf this option is set to true (default is true), the check will not warn about\nfunctions declared inside macros.",
                "disable": false
            },
            {
                "real_name": "modernize-use-nodiscard",
                "display_name": "modernize-use-nodiscard",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-nodiscardÂ¶\n\nAdds `[[nodiscard]]` attributes (introduced in C++17) to member functions in\norder to highlight at compile time which return values should not be ignored.\n\nMember functions need to satisfy the following conditions to be considered by\nthis check:\n\n>   * no `[[nodiscard]]`, `[[noreturn]]`,\n> `__attribute__((warn_unused_result))`, `[[clang::warn_unused_result]]` nor\n> `[[gcc::warn_unused_result]]` attribute,\n>   * non-void return type,\n>   * non-template return types,\n>   * const member function,\n>   * non-variadic functions,\n>   * no non-const reference parameters,\n>   * no pointer parameters,\n>   * no template parameters,\n>   * no template function parameters,\n>   * not be a member of a class with mutable member variables,\n>   * no Lambdas,\n>   * no conversion functions.\n>\n\nSuch functions have no means of altering any state or passing values other\nthan via the return type. Unless the member functions are altering state via\nsome external call (e.g. I/O).\n\n## ExampleÂ¶\n\n    \n    \n    bool empty() const;\n    bool empty(int i) const;\n    \n\ntransforms to:\n\n    \n    \n    [[nodiscard]] bool empty() const;\n    [[nodiscard]] bool empty(int i) const;\n    \n\n## OptionsÂ¶\n\n`ReplacementString```Â¶\n\n    \n\nSpecifies a macro to use instead of `[[nodiscard]]`. This is useful when\nmaintaining source code that needs to compile with a pre-C++17 compiler.\n\n### ExampleÂ¶\n\n    \n    \n    bool empty() const;\n    bool empty(int i) const;\n    \n\ntransforms to:\n\n    \n    \n    NO_DISCARD bool empty() const;\n    NO_DISCARD bool empty(int i) const;\n    \n\nif the [`ReplacementString`](use-noexcept.html#cmdoption-arg-\nreplacementstring) option is set to NO_DISCARD.\n\nNote\n\nIf the [`ReplacementString`](use-noexcept.html#cmdoption-arg-\nreplacementstring) is not a C++ attribute, but instead a macro, then that\nmacro must be defined in scope or the fix-it will not be applied.\n\nNote\n\nFor alternative `__attribute__` syntax options to mark functions as\n`[[nodiscard]]` in non-c++17 source code. See\n<https://clang.llvm.org/docs/AttributeReference.html#nodiscard-warn-unused-\nresult>",
                "disable": false
            },
            {
                "real_name": "modernize-use-noexcept",
                "display_name": "modernize-use-noexcept",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-noexceptÂ¶\n\nThis check replaces deprecated dynamic exception specifications with the\nappropriate noexcept specification (introduced in C++11). By default this\ncheck will replace `throw()` with `noexcept`, and `throw(<exception>[,...])`\nor `throw(...)` with `noexcept(false)`.\n\n## ExampleÂ¶\n\n    \n    \n    void foo() throw();\n    void bar() throw(int) {}\n    \n\ntransforms to:\n\n    \n    \n    void foo() noexcept;\n    void bar() noexcept(false) {}\n    \n\n## OptionsÂ¶\n\n`ReplacementString```Â¶\n\n    \n\nUsers can use `ReplacementString` to specify a macro to use instead of\n`noexcept`. This is useful when maintaining source code that uses custom\nexception specification marking other than `noexcept`. Fix-it hints will only\nbe generated for non-throwing specifications.\n\n### ExampleÂ¶\n\n    \n    \n    void bar() throw(int);\n    void foo() throw();\n    \n\ntransforms to:\n\n    \n    \n    void bar() throw(int);  // No fix-it generated.\n    void foo() NOEXCEPT;\n    \n\nif the `ReplacementString` option is set to NOEXCEPT.\n\n`UseNoexceptFalse```Â¶\n\n    \n\nEnabled by default, disabling will generate fix-it hints that remove throwing\ndynamic exception specs, e.g., `throw(<something>)`, completely without\nproviding a replacement text, except for destructors and delete operators that\nare `noexcept(true)` by default.\n\n### ExampleÂ¶\n\n    \n    \n    void foo() throw(int) {}\n    \n    struct bar {\n      void foobar() throw(int);\n      void operator delete(void *ptr) throw(int);\n      void operator delete[](void *ptr) throw(int);\n      ~bar() throw(int);\n    }\n    \n\ntransforms to:\n\n    \n    \n    void foo() {}\n    \n    struct bar {\n      void foobar();\n      void operator delete(void *ptr) noexcept(false);\n      void operator delete[](void *ptr) noexcept(false);\n      ~bar() noexcept(false);\n    }\n    \n\nif the `UseNoexceptFalse` option is set to false.",
                "disable": false
            },
            {
                "real_name": "modernize-use-nullptr",
                "display_name": "modernize-use-nullptr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-nullptrÂ¶\n\nThe check converts the usage of null pointer constants (e.g. `NULL`, `0`) to\nuse the new C++11 `nullptr` keyword.\n\n## ExampleÂ¶\n\n    \n    \n    void assignment() {\n      char *a = NULL;\n      char *b = 0;\n      char c = 0;\n    }\n    \n    int *ret_ptr() {\n      return 0;\n    }\n    \n\ntransforms to:\n\n    \n    \n    void assignment() {\n      char *a = nullptr;\n      char *b = nullptr;\n      char c = 0;\n    }\n    \n    int *ret_ptr() {\n      return nullptr;\n    }\n    \n\n## OptionsÂ¶\n\n`NullMacros```Â¶\n\n    \n\nComma-separated list of macro names that will be transformed along with\n`NULL`. By default this check will only replace the `NULL` macro and will skip\nany similar user-defined macros.\n\n### ExampleÂ¶\n\n    \n    \n    #define MY_NULL (void*)0\n    void assignment() {\n      void *p = MY_NULL;\n    }\n    \n\ntransforms to:\n\n    \n    \n    #define MY_NULL NULL\n    void assignment() {\n      int *p = nullptr;\n    }\n    \n\nif the `NullMacros` option is set to `MY_NULL`.",
                "disable": false
            },
            {
                "real_name": "modernize-use-override",
                "display_name": "modernize-use-override",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-overrideÂ¶\n\nAdds `override` (introduced in C++11) to overridden virtual functions and\nremoves `virtual` from those functions as it is not required.\n\n`virtual` on non base class implementations was used to help indicate to the\nuser that a function was virtual. C++ compilers did not use the presence of\nthis to signify an overridden function.\n\nIn C++ 11 `override` and `final` keywords were introduced to allow overridden\nfunctions to be marked appropriately. Their presence allows compilers to\nverify that an overridden function correctly overrides a base class\nimplementation.\n\nThis can be useful as compilers can generate a compile time error when:\n\n>   * The base class implementation function signature changes.\n>   * The user has not created the override with the correct signature.\n>\n\n## OptionsÂ¶\n\n`IgnoreDestructors```Â¶\n\n    \n\nIf set to true, this check will not diagnose destructors. Default is false.\n\n`AllowOverrideAndFinal```Â¶\n\n    \n\nIf set to true, this check will not diagnose `override` as redundant with\n`final`. This is useful when code will be compiled by a compiler with\nwarning/error checking flags requiring `override` explicitly on overridden\nmembers, such as `gcc -Wsuggest-override`/`gcc -Werror=suggest-override`.\nDefault is false.\n\n`OverrideSpelling```Â¶\n\n    \n\nSpecifies a macro to use instead of `override`. This is useful when\nmaintaining source code that also needs to compile with a pre-C++11 compiler.\n\n`FinalSpelling```Â¶\n\n    \n\nSpecifies a macro to use instead of `final`. This is useful when maintaining\nsource code that also needs to compile with a pre-C++11 compiler.\n\nNote\n\nFor more information on the use of `override` see\n<https://en.cppreference.com/w/cpp/language/override>",
                "disable": false
            },
            {
                "real_name": "modernize-use-trailing-return-type",
                "display_name": "modernize-use-trailing-return-type",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-trailing-return-typeÂ¶\n\nRewrites function signatures to use a trailing return type (introduced in\nC++11). This transformation is purely stylistic. The return type before the\nfunction name is replaced by `auto` and inserted after the function parameter\nlist (and qualifiers).\n\n## ExampleÂ¶\n\n    \n    \n    int f1();\n    inline int f2(int arg) noexcept;\n    virtual float f3() const && = delete;\n    \n\ntransforms to:\n\n    \n    \n    auto f1() -> int;\n    inline auto f2(int arg) -> int noexcept;\n    virtual auto f3() const && -> float = delete;\n    \n\n## Known LimitationsÂ¶\n\nThe following categories of return types cannot be rewritten currently:\n\n  * function pointers\n  * member function pointers\n  * member pointers\n\nUnqualified names in the return type might erroneously refer to different\nentities after the rewrite. Preventing such errors requires a full lookup of\nall unqualified names present in the return type in the scope of the trailing\nreturn type location. This location includes e.g. function parameter names and\nmembers of the enclosing class (including all inherited classes). Such a\nlookup is currently not implemented.\n\nGiven the following piece of code\n\n    \n    \n    struct S { long long value; };\n    S f(unsigned S) { return {S * 2}; }\n    class CC {\n      int S;\n      struct S m();\n    };\n    S CC::m() { return {0}; }\n    \n\na careless rewrite would produce the following output:\n\n    \n    \n    struct S { long long value; };\n    auto f(unsigned S) -> S { return {S * 2}; } // error\n    class CC {\n      int S;\n      auto m() -> struct S;\n    };\n    auto CC::m() -> S { return {0}; } // error\n    \n\nThis code fails to compile because the S in the context of f refers to the\nequally named function parameter. Similarly, the S in the context of m refers\nto the equally named class member. The check can currently only detect and\navoid a clash with a function parameter name.",
                "disable": false
            },
            {
                "real_name": "modernize-use-transparent-functors",
                "display_name": "modernize-use-transparent-functors",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-transparent-functorsÂ¶\n\nPrefer transparent functors to non-transparent ones. When using transparent\nfunctors, the type does not need to be repeated. The code is easier to read,\nmaintain and less prone to errors. It is not possible to introduce unwanted\nconversions.\n\n    \n    \n    // Non-transparent functor\n    std::map<int, std::string, std::greater<int>> s;\n    \n    // Transparent functor.\n    std::map<int, std::string, std::greater<>> s;\n    \n    // Non-transparent functor\n    using MyFunctor = std::less<MyType>;\n    \n\nIt is not always a safe transformation though. The following case will be\nuntouched to preserve the semantics.\n\n    \n    \n    // Non-transparent functor\n    std::map<const char *, std::string, std::greater<std::string>> s;\n    \n\n## OptionsÂ¶\n\n`SafeMode```Â¶\n\n    \n\nIf the option is set to true, the check will not diagnose cases where using a\ntransparent functor cannot be guaranteed to produce identical results as the\noriginal code. The default value for this option is false.\n\nThis check requires using C++14 or higher to run.",
                "disable": false
            },
            {
                "real_name": "modernize-use-uncaught-exceptions",
                "display_name": "modernize-use-uncaught-exceptions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-uncaught-exceptionsÂ¶\n\nThis check will warn on calls to `std::uncaught_exception` and replace them\nwith calls to `std::uncaught_exceptions`, since `std::uncaught_exception` was\ndeprecated in C++17.\n\nBelow are a few examples of what kind of occurrences will be found and what\nthey will be replaced with.\n\n    \n    \n    #define MACRO1 std::uncaught_exception\n    #define MACRO2 std::uncaught_exception\n    \n    int uncaught_exception() {\n      return 0;\n    }\n    \n    int main() {\n      int res;\n    \n      res = uncaught_exception();\n      // No warning, since it is not the deprecated function from namespace std\n    \n      res = MACRO2();\n      // Warning, but will not be replaced\n    \n      res = std::uncaught_exception();\n      // Warning and replaced\n    \n      using std::uncaught_exception;\n      // Warning and replaced\n    \n      res = uncaught_exception();\n      // Warning and replaced\n    }\n    \n\nAfter applying the fixes the code will look like the following:\n\n    \n    \n    #define MACRO1 std::uncaught_exception\n    #define MACRO2 std::uncaught_exception\n    \n    int uncaught_exception() {\n      return 0;\n    }\n    \n    int main() {\n      int res;\n    \n      res = uncaught_exception();\n    \n      res = MACRO2();\n    \n      res = std::uncaught_exceptions();\n    \n      using std::uncaught_exceptions;\n    \n      res = uncaught_exceptions();\n    }",
                "disable": false
            },
            {
                "real_name": "modernize-use-using",
                "display_name": "modernize-use-using",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# modernize-use-usingÂ¶\n\nThe check converts the usage of `typedef` with `using` keyword.\n\nBefore:\n\n    \n    \n    typedef int variable;\n    \n    class Class{};\n    typedef void (Class::* MyPtrType)() const;\n    \n    typedef struct { int a; } R_t, *R_p;\n    \n\nAfter:\n\n    \n    \n    using variable = int;\n    \n    class Class{};\n    using MyPtrType = void (Class::*)() const;\n    \n    using R_t = struct { int a; };\n    using R_p = R_t*;\n    \n\nThis check requires using C++11 or higher to run.\n\n## OptionsÂ¶\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will not give warnings inside macros. Default is\ntrue.",
                "disable": false
            },
            {
                "real_name": "mpi-buffer-deref",
                "display_name": "mpi-buffer-deref",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# mpi-buffer-derefÂ¶\n\nThis check verifies if a buffer passed to an MPI (Message Passing Interface)\nfunction is sufficiently dereferenced. Buffers should be passed as a single\npointer or array. As MPI function signatures specify `void *` for their buffer\ntypes, insufficiently dereferenced buffers can be passed, like for example as\ndouble pointers or multidimensional arrays, without a compiler warning\nemitted.\n\nExamples:\n\n    \n    \n    // A double pointer is passed to the MPI function.\n    char *buf;\n    MPI_Send(&buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);\n    \n    // A multidimensional array is passed to the MPI function.\n    short buf[1][1];\n    MPI_Send(buf, 1, MPI_SHORT, 0, 0, MPI_COMM_WORLD);\n    \n    // A pointer to an array is passed to the MPI function.\n    short *buf[1];\n    MPI_Send(buf, 1, MPI_SHORT, 0, 0, MPI_COMM_WORLD);",
                "disable": false
            },
            {
                "real_name": "mpi-type-mismatch",
                "display_name": "mpi-type-mismatch",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# mpi-type-mismatchÂ¶\n\nThis check verifies if buffer type and MPI (Message Passing Interface)\ndatatype pairs match for used MPI functions. All MPI datatypes defined by the\nMPI standard (3.1) are verified by this check. User defined typedefs, custom\nMPI datatypes and null pointer constants are skipped, in the course of\nverification.\n\nExample:\n\n    \n    \n    // In this case, the buffer type matches MPI datatype.\n    char buf;\n    MPI_Send(&buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);\n    \n    // In the following case, the buffer type does not match MPI datatype.\n    int buf;\n    MPI_Send(&buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);",
                "disable": false
            },
            {
                "real_name": "objc-assert-equals",
                "display_name": "objc-assert-equals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-assert-equalsÂ¶\n\nFinds improper usages of XCTAssertEqual and XCTAssertNotEqual and replaces\nthem with XCTAssertEqualObjects or XCTAssertNotEqualObjects.\n\nThis makes tests less fragile, as many improperly rely on pointer equality for\nstrings that have equal values. This assumption is not guarantted by the\nlanguage.",
                "disable": false
            },
            {
                "real_name": "objc-avoid-nserror-init",
                "display_name": "objc-avoid-nserror-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-avoid-nserror-initÂ¶\n\nFinds improper initialization of `NSError` objects.\n\nAccording to Apple developer document, we should always use factory method\n`errorWithDomain:code:userInfo:` to create new NSError objects instead of\n`[NSError alloc] init]`. Otherwise it will lead to a warning message during\nruntime.\n\nThe corresponding information about `NSError` creation:\n<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/CreateCustomizeNSError/CreateCustomizeNSError.html>",
                "disable": false
            },
            {
                "real_name": "objc-dealloc-in-category",
                "display_name": "objc-dealloc-in-category",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-dealloc-in-categoryÂ¶\n\nFinds implementations of `-dealloc` in Objective-C categories. The category\nimplementation will override any `-dealloc` in the class implementation,\npotentially causing issues.\n\nClasses implement `-dealloc` to perform important actions to deallocate an\nobject. If a category on the class implements `-dealloc`, it will override the\nclassâs implementation and unexpected deallocation behavior may occur.",
                "disable": false
            },
            {
                "real_name": "objc-forbidden-subclassing",
                "display_name": "objc-forbidden-subclassing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-forbidden-subclassingÂ¶\n\nFinds Objective-C classes which are subclasses of classes which are not\ndesigned to be subclassed.\n\nBy default, includes a list of Objective-C classes which are publicly\ndocumented as not supporting subclassing.\n\nNote\n\nInstead of using this check, for code under your control, you should add\n`__attribute__((objc_subclassing_restricted))` before your `@interface`\ndeclarations to ensure the compiler prevents others from subclassing your\nObjective-C classes. See\n<https://clang.llvm.org/docs/AttributeReference.html#objc-subclassing-\nrestricted>\n\n## OptionsÂ¶\n\n`ForbiddenSuperClassNames```Â¶\n\n    \n\nSemicolon-separated list of names of Objective-C classes which do not support\nsubclassing.\n\nDefaults to\nABNewPersonViewController;ABPeoplePickerNavigationController;ABPersonViewController;ABUnknownPersonViewController;NSHashTable;NSMapTable;NSPointerArray;NSPointerFunctions;NSTimer;UIActionSheet;UIAlertView;UIImagePickerController;UITextInputMode;UIWebView.",
                "disable": false
            },
            {
                "real_name": "objc-missing-hash",
                "display_name": "objc-missing-hash",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-missing-hashÂ¶\n\nFinds Objective-C implementations that implement `-isEqual:` without also\nappropriately implementing `-hash`.\n\nApple documentation highlights that objects that are equal must have the same\nhash value:\n<https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418795-isequal?language=objc>\n\nNote that the check only verifies the presence of `-hash` in scenarios where\nits omission could result in unexpected behavior. The verification of the\nimplementation of `-hash` is the responsibility of the developer, e.g.,\nthrough the addition of unit tests to verify the implementation.",
                "disable": false
            },
            {
                "real_name": "objc-nsdate-formatter",
                "display_name": "objc-nsdate-formatter",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-nsdate-formatterÂ¶\n\nWhen `NSDateFormatter` is used to convert an `NSDate` type to a `String` type,\nthe user can specify a custom format string. Certain format specifiers are\nundesirable despite being legal. See\n<http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns> for\nall legal date patterns.\n\nThis checker reports as warnings the following string patterns in a date\nformat specifier:\n\n  1. yyyy + ww : Calendar year specified with week of a week year (unless YYYY is also specified).\n\n    * **Example 1:** Input Date: 29 December 2014 ; Format String: yyyy-ww;\n\nOutput string: 2014-01 (Wrong because itâs not the first week of 2014)\n\n    * **Example 2:** Input Date: 29 December 2014 ; Format String: dd-MM-yyyy (ww-YYYY);\n\nOutput string: 29-12-2014 (01-2015) (This is correct)\n\n  2. F without ee/EE : Numeric day of week in a month without actual day.\n\n    * **Example:** Input Date: 29 December 2014 ; Format String: F-MM;\n\nOutput string: 5-12 (Wrong because it reads as _5th ___ of Dec_ in English)\n\n  3. F without MM : Numeric day of week in a month without month.\n\n    * **Example:** Input Date: 29 December 2014 ; Format String: F-EE\n\nOutput string: 5-Mon (Wrong because it reads as _5th Mon of ____ in English)\n\n  4. WW without MM : Week of the month without the month.\n\n    * **Example:** Input Date: 29 December 2014 ; Format String: WW-yyyy\n\nOutput string: 05-2014 (Wrong because it reads as _5th Week of ____ in\nEnglish)\n\n  5. YYYY + QQ : Week year specified with quarter of normal year (unless yyyy is also specified).\n\n    * **Example 1:** Input Date: 29 December 2014 ; Format String: YYYY-QQ\n\nOutput string: 2015-04 (Wrong because itâs not the 4th quarter of 2015)\n\n    * **Example 2:** Input Date: 29 December 2014 ; Format String: ww-YYYY (QQ-yyyy)\n\nOutput string: 01-2015 (04-2014) (This is correct)\n\n  6. YYYY + MM : Week year specified with Month of a calendar year (unless yyyy is also specified).\n\n    * **Example 1:** Input Date: 29 December 2014 ; Format String: YYYY-MM\n\nOutput string: 2015-12 (Wrong because itâs not the 12th month of 2015)\n\n    * **Example 2:** Input Date: 29 December 2014 ; Format String: ww-YYYY (MM-yyyy)\n\nOutput string: 01-2015 (12-2014) (This is correct)\n\n  7. YYYY + DD : Week year with day of a calendar year (unless yyyy is also specified).\n\n    * **Example 1:** Input Date: 29 December 2014 ; Format String: YYYY-DD\n\nOutput string: 2015-363 (Wrong because itâs not the 363rd day of 2015)\n\n    * **Example 2:** Input Date: 29 December 2014 ; Format String: ww-YYYY (DD-yyyy)\n\nOutput string: 01-2015 (363-2014) (This is correct)\n\n  8. YYYY + WW : Week year with week of a calendar year (unless yyyy is also specified).\n\n    * **Example 1:** Input Date: 29 December 2014 ; Format String: YYYY-WW\n\nOutput string: 2015-05 (Wrong because itâs not the 5th week of 2015)\n\n    * **Example 2:** Input Date: 29 December 2014 ; Format String: ww-YYYY (WW-MM-yyyy)\n\nOutput string: 01-2015 (05-12-2014) (This is correct)\n\n  9. YYYY + F : Week year with day of week in a calendar month (unless yyyy is also specified).\n\n    * **Example 1:** Input Date: 29 December 2014 ; Format String: YYYY-ww-F-EE\n\nOutput string: 2015-01-5-Mon (Wrong because itâs not the 5th Monday of\nJanuary in 2015)\n\n    * **Example 2:** Input Date: 29 December 2014 ; Format String: ww-YYYY (F-EE-MM-yyyy)\n\nOutput string: 01-2015 (5-Mon-12-2014) (This is correct)",
                "disable": false
            },
            {
                "real_name": "objc-nsinvocation-argument-lifetime",
                "display_name": "objc-nsinvocation-argument-lifetime",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-nsinvocation-argument-lifetimeÂ¶\n\nFinds calls to `NSInvocation` methods under ARC that donât have proper\nargument object lifetimes. When passing Objective-C objects as parameters to\nthe `NSInvocation` methods `getArgument:atIndex:` and `getReturnValue:`, the\nvalues are copied by value into the argument pointer, which leads to incorrect\nreleasing behavior if the object pointers are not declared\n`__unsafe_unretained`.\n\nFor code:\n\n    \n    \n    id arg;\n    [invocation getArgument:&arg atIndex:2];\n    \n    __strong id returnValue;\n    [invocation getReturnValue:&returnValue];\n    \n\nThe fix will be:\n\n    \n    \n    __unsafe_unretained id arg;\n    [invocation getArgument:&arg atIndex:2];\n    \n    __unsafe_unretained id returnValue;\n    [invocation getReturnValue:&returnValue];\n    \n\nThe check will warn on being passed instance variable references that have\nlifetimes other than `__unsafe_unretained`, but does not propose a fix:\n\n    \n    \n    // \"id _returnValue\" is declaration of instance variable of class.\n    [invocation getReturnValue:&self->_returnValue];",
                "disable": false
            },
            {
                "real_name": "objc-property-declaration",
                "display_name": "objc-property-declaration",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-property-declarationÂ¶\n\nFinds property declarations in Objective-C files that do not follow the\npattern of property names in Appleâs programming guide. The property name\nshould be in the format of Lower Camel Case.\n\nFor code:\n\n    \n    \n    @property(nonatomic, assign) int LowerCamelCase;\n    \n\nThe fix will be:\n\n    \n    \n    @property(nonatomic, assign) int lowerCamelCase;\n    \n\nThe check will only fix âCamelCaseâ to âcamelCaseâ. In some other\ncases we will only provide warning messages since the property name could be\ncomplicated. Users will need to come up with a proper name by their own.\n\nThis check also accepts special acronyms as prefixes or suffixes. Such\nprefixes or suffixes will suppress the Lower Camel Case check according to the\nguide:\n<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-1002931-BBCFHEAB>\n\nFor a full list of well-known acronyms:\n<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE>\n\nThe corresponding style rule:\n<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-1001757>\n\nThe check will also accept property declared in category with a prefix of\nlowercase letters followed by a â_â to avoid naming conflict. For example:\n\n    \n    \n    @property(nonatomic, assign) int abc_lowerCamelCase;\n    \n\nThe corresponding style rule:\n<https://developer.apple.com/library/content/qa/qa1908/_index.html>",
                "disable": false
            },
            {
                "real_name": "objc-super-self",
                "display_name": "objc-super-self",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "oc"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# objc-super-selfÂ¶\n\nFinds invocations of `-self` on super instances in initializers of subclasses\nof `NSObject` and recommends calling a superclass initializer instead.\n\nInvoking `-self` on super instances in initializers is a common programmer\nerror when the programmerâs original intent is to call a superclass\ninitializer. Failing to call a superclass initializer breaks initializer\nchaining and can result in invalid object initialization.",
                "disable": false
            },
            {
                "real_name": "openmp-exception-escape",
                "display_name": "openmp-exception-escape",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# openmp-exception-escapeÂ¶\n\nAnalyzes OpenMP Structured Blocks and checks that no exception escapes out of\nthe Structured Block it was thrown in.\n\nAs per the OpenMP specification, a structured block is an executable\nstatement, possibly compound, with a single entry at the top and a single exit\nat the bottom. Which means, `throw` may not be used to âexitâ out of the\nstructured block. If an exception is not caught in the same structured block\nit was thrown in, the behavior is undefined.\n\nFIXME: this check does not model SEH, `setjmp`/`longjmp`.\n\nWARNING! This check may be expensive on large source files.\n\n## OptionsÂ¶\n\n`IgnoredExceptions```Â¶\n\n    \n\nComma-separated list containing type names which are not counted as thrown\nexceptions in the check. Default value is an empty string.",
                "disable": false
            },
            {
                "real_name": "openmp-use-default-none",
                "display_name": "openmp-use-default-none",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# openmp-use-default-noneÂ¶\n\nFinds OpenMP directives that are allowed to contain a `default` clause, but\neither donât specify it or the clause is specified but with the kind other\nthan `none`, and suggests to use the `default(none)` clause.\n\nUsing `default(none)` clause forces developers to explicitly specify data\nsharing attributes for the variables referenced in the construct, thus making\nit obvious which variables are referenced, and what is their data sharing\nattribute, thus increasing readability and possibly making errors easier to\nspot.\n\n## ExampleÂ¶\n\n    \n    \n    // ``for`` directive cannot have ``default`` clause, no diagnostics.\n    void n0(const int a) {\n    #pragma omp for\n      for (int b = 0; b < a; b++)\n        ;\n    }\n    \n    // ``parallel`` directive.\n    \n    // ``parallel`` directive can have ``default`` clause, but said clause is not\n    // specified, diagnosed.\n    void p0_0() {\n    #pragma omp parallel\n      ;\n      // WARNING: OpenMP directive ``parallel`` does not specify ``default``\n      //          clause. Consider specifying ``default(none)`` clause.\n    }\n    \n    // ``parallel`` directive can have ``default`` clause, and said clause is\n    // specified, with ``none`` kind, all good.\n    void p0_1() {\n    #pragma omp parallel default(none)\n      ;\n    }\n    \n    // ``parallel`` directive can have ``default`` clause, and said clause is\n    // specified, but with ``shared`` kind, which is not ``none``, diagnose.\n    void p0_2() {\n    #pragma omp parallel default(shared)\n      ;\n      // WARNING: OpenMP directive ``parallel`` specifies ``default(shared)``\n      //          clause. Consider using ``default(none)`` clause instead.\n    }\n    \n    // ``parallel`` directive can have ``default`` clause, and said clause is\n    // specified, but with ``firstprivate`` kind, which is not ``none``, diagnose.\n    void p0_3() {\n    #pragma omp parallel default(firstprivate)\n      ;\n      // WARNING: OpenMP directive ``parallel`` specifies ``default(firstprivate)``\n      //          clause. Consider using ``default(none)`` clause instead.\n    }",
                "disable": false
            },
            {
                "real_name": "performance-faster-string-find",
                "display_name": "performance-faster-string-find",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-faster-string-findÂ¶\n\nOptimize calls to `std::string::find()` and friends when the needle passed is\na single character string literal. The character literal overload is more\nefficient.\n\nExamples:\n\n    \n    \n    str.find(\"A\");\n    \n    // becomes\n    \n    str.find('A');\n    \n\n## OptionsÂ¶\n\n`StringLikeClasses```Â¶\n\n    \n\nSemicolon-separated list of names of string-like classes. By default only\n`::std::basic_string` and `::std::basic_string_view` are considered. The check\nwill only consider member functions named `find`, `rfind`, `find_first_of`,\n`find_first_not_of`, `find_last_of`, or `find_last_not_of` within these\nclasses.",
                "disable": false
            },
            {
                "real_name": "performance-for-range-copy",
                "display_name": "performance-for-range-copy",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-for-range-copyÂ¶\n\nFinds C++11 for ranges where the loop variable is copied in each iteration but\nit would suffice to obtain it by const reference.\n\nThe check is only applied to loop variables of types that are expensive to\ncopy which means they are not trivially copyable or have a non-trivial copy\nconstructor or destructor.\n\nTo ensure that it is safe to replace the copy with a const reference the\nfollowing heuristic is employed:\n\n  1. The loop variable is const qualified.\n  2. The loop variable is not const, but only const methods or operators are invoked on it, or it is used as const reference or value argument in constructors or function calls.\n\n## OptionsÂ¶\n\n`WarnOnAllAutoCopies```Â¶\n\n    \n\nWhen true, warns on any use of auto as the type of the range-based for loop\nvariable. Default is false.\n\n`AllowedTypes```Â¶\n\n    \n\nA semicolon-separated list of names of types allowed to be copied in each\niteration. Regular expressions are accepted, e.g. [Rr]ef(erence)?$ matches\nevery type with suffix Ref, ref, Reference and reference. The default is\nempty. If a name in the list contains the sequence :: it is matched against\nthe qualified typename (i.e. namespace::Type, otherwise it is matched against\nonly the type name (i.e. Type).",
                "disable": false
            },
            {
                "real_name": "performance-implicit-conversion-in-loop",
                "display_name": "performance-implicit-conversion-in-loop",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-implicit-conversion-in-loopÂ¶\n\nThis warning appears in a range-based loop with a loop variable of const ref\ntype where the type of the variable does not match the one returned by the\niterator. This means that an implicit conversion happens, which can for\nexample result in expensive deep copies.\n\nExample:\n\n    \n    \n    map<int, vector<string>> my_map;\n    for (const pair<int, vector<string>>& p : my_map) {}\n    // The iterator type is in fact pair<const int, vector<string>>, which means\n    // that the compiler added a conversion, resulting in a copy of the vectors.\n    \n\nThe easiest solution is usually to use `const auto&` instead of writing the\ntype manually.",
                "disable": false
            },
            {
                "real_name": "performance-inefficient-algorithm",
                "display_name": "performance-inefficient-algorithm",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-inefficient-algorithmÂ¶\n\nWarns on inefficient use of STL algorithms on associative containers.\n\nAssociative containers implement some of the algorithms as methods which\nshould be preferred to the algorithms in the algorithm header. The methods can\ntake advantage of the order of the elements.\n\n    \n    \n    std::set<int> s;\n    auto it = std::find(s.begin(), s.end(), 43);\n    \n    // becomes\n    \n    auto it = s.find(43);\n    \n    \n    \n    std::set<int> s;\n    auto c = std::count(s.begin(), s.end(), 43);\n    \n    // becomes\n    \n    auto c = s.count(43);",
                "disable": false
            },
            {
                "real_name": "performance-inefficient-string-concatenation",
                "display_name": "performance-inefficient-string-concatenation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-inefficient-string-concatenationÂ¶\n\nThis check warns about the performance overhead arising from concatenating\nstrings using the `operator+`, for instance:\n\n    \n    \n    std::string a(\"Foo\"), b(\"Bar\");\n    a = a + b;\n    \n\nInstead of this structure you should use `operator+=` or `std::string`âs\n(`std::basic_string`) class member function `append()`. For instance:\n\n    \n    \n    std::string a(\"Foo\"), b(\"Baz\");\n    for (int i = 0; i < 20000; ++i) {\n        a = a + \"Bar\" + b;\n    }\n    \n\nCould be rewritten in a greatly more efficient way like:\n\n    \n    \n    std::string a(\"Foo\"), b(\"Baz\");\n    for (int i = 0; i < 20000; ++i) {\n        a.append(\"Bar\").append(b);\n    }\n    \n\nAnd this can be rewritten too:\n\n    \n    \n    void f(const std::string&) {}\n    std::string a(\"Foo\"), b(\"Baz\");\n    void g() {\n        f(a + \"Bar\" + b);\n    }\n    \n\nIn a slightly more efficient way like:\n\n    \n    \n    void f(const std::string&) {}\n    std::string a(\"Foo\"), b(\"Baz\");\n    void g() {\n        f(std::string(a).append(\"Bar\").append(b));\n    }\n    \n\n## OptionsÂ¶\n\n`StrictMode```Â¶\n\n    \n\nWhen false, the check will only check the string usage in `while`, `for` and\n`for-range` statements. Default is false.",
                "disable": false
            },
            {
                "real_name": "performance-inefficient-vector-operation",
                "display_name": "performance-inefficient-vector-operation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-inefficient-vector-operationÂ¶\n\nFinds possible inefficient `std::vector` operations (e.g. `push_back`,\n`emplace_back`) that may cause unnecessary memory reallocations.\n\nIt can also find calls that add element to protobuf repeated field in a loop\nwithout calling Reserve() before the loop. Calling Reserve() first can avoid\nunnecessary memory reallocations.\n\nCurrently, the check only detects following kinds of loops with a single\nstatement body:\n\n  * Counter-based for loops start with 0:\n\n    \n    \n    std::vector<int> v;\n    for (int i = 0; i < n; ++i) {\n      v.push_back(n);\n      // This will trigger the warning since the push_back may cause multiple\n      // memory reallocations in v. This can be avoid by inserting a 'reserve(n)'\n      // statement before the for statement.\n    }\n    \n    SomeProto p;\n    for (int i = 0; i < n; ++i) {\n      p.add_xxx(n);\n      // This will trigger the warning since the add_xxx may cause multiple memory\n      // reallocations. This can be avoid by inserting a\n      // 'p.mutable_xxx().Reserve(n)' statement before the for statement.\n    }\n    \n\n  * For-range loops like `for (range-declaration : range_expression)`, the type of `range_expression` can be `std::vector`, `std::array`, `std::deque`, `std::set`, `std::unordered_set`, `std::map`, `std::unordered_set`:\n\n    \n    \n    std::vector<int> data;\n    std::vector<int> v;\n    \n    for (auto element : data) {\n      v.push_back(element);\n      // This will trigger the warning since the 'push_back' may cause multiple\n      // memory reallocations in v. This can be avoid by inserting a\n      // 'reserve(data.size())' statement before the for statement.\n    }\n    \n\n## OptionsÂ¶\n\n`VectorLikeClasses```Â¶\n\n    \n\nSemicolon-separated list of names of vector-like classes. By default only\n`::std::vector` is considered.\n\n`EnableProto```Â¶\n\n    \n\nWhen true, the check will also warn on inefficient operations for proto\nrepeated fields. Otherwise, the check only warns on inefficient vector\noperations. Default is false.",
                "disable": false
            },
            {
                "real_name": "performance-move-const-arg",
                "display_name": "performance-move-const-arg",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-move-const-argÂ¶\n\nThe check warns\n\n  * if `std::move()` is called with a constant argument,\n  * if `std::move()` is called with an argument of a trivially-copyable type,\n  * if the result of `std::move()` is passed as a const reference argument.\n\nIn all three cases, the check will suggest a fix that removes the\n`std::move()`.\n\nHere are examples of each of the three cases:\n\n    \n    \n    const string s;\n    return std::move(s);  // Warning: std::move of the const variable has no effect\n    \n    int x;\n    return std::move(x);  // Warning: std::move of the variable of a trivially-copyable type has no effect\n    \n    void f(const string &s);\n    string s;\n    f(std::move(s));  // Warning: passing result of std::move as a const reference argument; no move will actually happen\n    \n\n## OptionsÂ¶\n\n`CheckTriviallyCopyableMove```Â¶\n\n    \n\nIf true, enables detection of trivially copyable types that do not have a move\nconstructor. Default is true.\n\n`CheckMoveToConstRef```Â¶\n\n    \n\nIf true, enables detection of std::move() passed as a const reference\nargument. Default is true.",
                "disable": false
            },
            {
                "real_name": "performance-move-constructor-init",
                "display_name": "performance-move-constructor-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-move-constructor-initÂ¶\n\nâcert-oop11-cppâ redirects here as an alias for this check.\n\nThe check flags user-defined move constructors that have a ctor-initializer\ninitializing a member or base class through a copy constructor instead of a\nmove constructor.",
                "disable": false
            },
            {
                "real_name": "performance-no-automatic-move",
                "display_name": "performance-no-automatic-move",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-no-automatic-moveÂ¶\n\nFinds local variables that cannot be automatically moved due to constness.\n\nUnder [certain\nconditions](https://en.cppreference.com/w/cpp/language/return#automatic_move_from_local_variables_and_parameters),\nlocal values are automatically moved out when returning from a function. A\ncommon mistake is to declare local `lvalue` variables `const`, which prevents\nthe move.\n\nExample [[1]](https://godbolt.org/z/x7SYYA):\n\n    \n    \n    StatusOr<std::vector<int>> Cool() {\n      std::vector<int> obj = ...;\n      return obj;  // calls StatusOr::StatusOr(std::vector<int>&&)\n    }\n    \n    StatusOr<std::vector<int>> NotCool() {\n      const std::vector<int> obj = ...;\n      return obj;  // calls `StatusOr::StatusOr(const std::vector<int>&)`\n    }\n    \n\nThe former version (`Cool`) should be preferred over the latter (`Uncool`) as\nit will avoid allocations and potentially large memory copies.\n\n## SemanticsÂ¶\n\nIn the example above, `StatusOr::StatusOr(T&&)` have the same semantics as\nlong as the copy and move constructors for `T` have the same semantics. Note\nthat there is no guarantee that `S::S(T&&)` and `S::S(const T&)` have the same\nsemantics for any single `S`, so weâre not providing automated fixes for\nthis check, and judgement should be exerted when making the suggested changes.\n\n## -Wreturn-std-moveÂ¶\n\nAnother case where the move cannot happen is the following:\n\n    \n    \n    StatusOr<std::vector<int>> Uncool() {\n      std::vector<int>&& obj = ...;\n      return obj;  // calls `StatusOr::StatusOr(const std::vector<int>&)`\n    }\n    \n\nIn that case the fix is more consensual: just return std::move(obj). This is\nhandled by the -Wreturn-std-move warning.",
                "disable": false
            },
            {
                "real_name": "performance-no-int-to-ptr",
                "display_name": "performance-no-int-to-ptr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-no-int-to-ptrÂ¶\n\nDiagnoses every integer to pointer cast.\n\nWhile casting an (integral) pointer to an integer is obvious - you just get\nthe integral value of the pointer, casting an integer to an (integral) pointer\nis deceivingly different. While you will get a pointer with that integral\nvalue, if you got that integral value via a pointer-to-integer cast\noriginally, the new pointer will lack the provenance information from the\noriginal pointer.\n\nSo while (integral) pointer to integer casts are effectively no-ops, and are\ntransparent to the optimizer, integer to (integral) pointer casts are _NOT_\ntransparent, and may conceal information from optimizer.\n\nWhile that may be the intention, it is not always so. For example, letâs\ntake a look at a routine to align the pointer up to the multiple of 16: The\nobvious, naive implementation for that is:\n\n    \n    \n    char* src(char* maybe_underbiased_ptr) {\n      uintptr_t maybe_underbiased_intptr = (uintptr_t)maybe_underbiased_ptr;\n      uintptr_t aligned_biased_intptr = maybe_underbiased_intptr + 15;\n      uintptr_t aligned_intptr = aligned_biased_intptr & (~15);\n      return (char*)aligned_intptr; // warning: avoid integer to pointer casts [performance-no-int-to-ptr]\n    }\n    \n\nThe check will rightfully diagnose that cast.\n\nBut when provenance concealment is not the goal of the code, but an accident,\nthis example can be rewritten as follows, without using integer to pointer\ncast:\n\n    \n    \n    char*\n    tgt(char* maybe_underbiased_ptr) {\n        uintptr_t maybe_underbiased_intptr = (uintptr_t)maybe_underbiased_ptr;\n        uintptr_t aligned_biased_intptr = maybe_underbiased_intptr + 15;\n        uintptr_t aligned_intptr = aligned_biased_intptr & (~15);\n        uintptr_t bias = aligned_intptr - maybe_underbiased_intptr;\n        return maybe_underbiased_ptr + bias;\n    }",
                "disable": false
            },
            {
                "real_name": "performance-noexcept-move-constructor",
                "display_name": "performance-noexcept-move-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-noexcept-move-constructorÂ¶\n\nThe check flags user-defined move constructors and assignment operators not\nmarked with `noexcept` or marked with `noexcept(expr)` where `expr` evaluates\nto `false` (but is not a `false` literal itself).\n\nMove constructors of all the types used with STL containers, for example, need\nto be declared `noexcept`. Otherwise STL will choose copy constructors\ninstead. The same is valid for move assignment operations.",
                "disable": false
            },
            {
                "real_name": "performance-trivially-destructible",
                "display_name": "performance-trivially-destructible",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-trivially-destructibleÂ¶\n\nFinds types that could be made trivially-destructible by removing out-of-line\ndefaulted destructor declarations.\n\n    \n    \n    struct A: TrivialType {\n      ~A(); // Makes A non-trivially-destructible.\n      TrivialType trivial_fields;\n    };\n    A::~A() = default;",
                "disable": false
            },
            {
                "real_name": "performance-type-promotion-in-math-fn",
                "display_name": "performance-type-promotion-in-math-fn",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-type-promotion-in-math-fnÂ¶\n\nFinds calls to C math library functions (from `math.h` or, in C++, `cmath`)\nwith implicit `float` to `double` promotions.\n\nFor example, warns on `::sin(0.f)`, because this functionâs parameter is a\ndouble. You probably meant to call `std::sin(0.f)` (in C++), or `sinf(0.f)`\n(in C).\n\n    \n    \n    float a;\n    asin(a);\n    \n    // becomes\n    \n    float a;\n    std::asin(a);",
                "disable": false
            },
            {
                "real_name": "performance-unnecessary-copy-initialization",
                "display_name": "performance-unnecessary-copy-initialization",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-unnecessary-copy-initializationÂ¶\n\nFinds local variable declarations that are initialized using the copy\nconstructor of a non-trivially-copyable type but it would suffice to obtain a\nconst reference.\n\nThe check is only applied if it is safe to replace the copy by a const\nreference. This is the case when the variable is const qualified or when it is\nonly used as a const, i.e. only const methods or operators are invoked on it,\nor it is used as const reference or value argument in constructors or function\ncalls.\n\nExample:\n\n    \n    \n    const string& constReference();\n    void Function() {\n      // The warning will suggest making this a const reference.\n      const string UnnecessaryCopy = constReference();\n    }\n    \n    struct Foo {\n      const string& name() const;\n    };\n    void Function(const Foo& foo) {\n      // The warning will suggest making this a const reference.\n      string UnnecessaryCopy1 = foo.name();\n      UnnecessaryCopy1.find(\"bar\");\n    \n      // The warning will suggest making this a const reference.\n      string UnnecessaryCopy2 = UnnecessaryCopy1;\n      UnnecessaryCopy2.find(\"bar\");\n    }\n    \n\n## OptionsÂ¶\n\n`AllowedTypes```Â¶\n\n    \n\nA semicolon-separated list of names of types allowed to be initialized by\ncopying. Regular expressions are accepted, e.g. [Rr]ef(erence)?$ matches every\ntype with suffix Ref, ref, Reference and reference. The default is empty. If a\nname in the list contains the sequence :: it is matched against the qualified\ntypename (i.e. namespace::Type, otherwise it is matched against only the type\nname (i.e. Type).\n\n`ExcludedContainerTypes```Â¶\n\n    \n\nA semicolon-separated list of names of types whose methods are allowed to\nreturn the const reference the variable is copied from. When an expensive to\ncopy variable is copy initialized by the return value from a type on this list\nthe check does not trigger. This can be used to exclude types known to be\nconst incorrect or where the lifetime or immutability of returned references\nis not tied to mutations of the container. An example are view types that\ndonât own the underlying data. Like for AllowedTypes above, regular\nexpressions are accepted and the inclusion of :: determines whether the\nqualified typename is matched or not.",
                "disable": false
            },
            {
                "real_name": "performance-unnecessary-value-param",
                "display_name": "performance-unnecessary-value-param",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# performance-unnecessary-value-paramÂ¶\n\nFlags value parameter declarations of expensive to copy types that are copied\nfor each invocation but it would suffice to pass them by const reference.\n\nThe check is only applied to parameters of types that are expensive to copy\nwhich means they are not trivially copyable or have a non-trivial copy\nconstructor or destructor.\n\nTo ensure that it is safe to replace the value parameter with a const\nreference the following heuristic is employed:\n\n  1. the parameter is const qualified;\n  2. the parameter is not const, but only const methods or operators are invoked on it, or it is used as const reference or value argument in constructors or function calls.\n\nExample:\n\n    \n    \n    void f(const string Value) {\n      // The warning will suggest making Value a reference.\n    }\n    \n    void g(ExpensiveToCopy Value) {\n      // The warning will suggest making Value a const reference.\n      Value.ConstMethd();\n      ExpensiveToCopy Copy(Value);\n    }\n    \n\nIf the parameter is not const, only copied or assigned once and has a non-\ntrivial move-constructor or move-assignment operator respectively the check\nwill suggest to move it.\n\nExample:\n\n    \n    \n    void setValue(string Value) {\n      Field = Value;\n    }\n    \n\nWill become:\n\n    \n    \n    #include <utility>\n    \n    void setValue(string Value) {\n      Field = std::move(Value);\n    }\n    \n\n## OptionsÂ¶\n\n`IncludeStyle```Â¶\n\n    \n\nA string specifying which include-style is used, llvm or google. Default is\nllvm.\n\n`AllowedTypes```Â¶\n\n    \n\nA semicolon-separated list of names of types allowed to be passed by value.\nRegular expressions are accepted, e.g. [Rr]ef(erence)?$ matches every type\nwith suffix Ref, ref, Reference and reference. The default is empty. If a name\nin the list contains the sequence :: it is matched against the qualified\ntypename (i.e. namespace::Type, otherwise it is matched against only the type\nname (i.e. Type).",
                "disable": false
            },
            {
                "real_name": "portability-restrict-system-includes",
                "display_name": "portability-restrict-system-includes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# portability-restrict-system-includesÂ¶\n\nChecks to selectively allow or disallow a configurable list of system headers.\n\nFor example:\n\nIn order to **only** allow zlib.h from the system you would set the options to\n-*,zlib.h.\n\n    \n    \n    #include <curses.h>       // Bad: disallowed system header.\n    #include <openssl/ssl.h>  // Bad: disallowed system header.\n    #include <zlib.h>         // Good: allowed system header.\n    #include \"src/myfile.h\"   // Good: non-system header always allowed.\n    \n\nIn order to allow everything **except** zlib.h from the system you would set\nthe options to *,-zlib.h.\n\n    \n    \n    #include <curses.h>       // Good: allowed system header.\n    #include <openssl/ssl.h>  // Good: allowed system header.\n    #include <zlib.h>         // Bad: disallowed system header.\n    #include \"src/myfile.h\"   // Good: non-system header always allowed.\n    \n\nSince the options support globbing you can use wildcarding to allow groups of\nheaders.\n\n-*,openssl/*.h will allow all openssl headers but disallow any others.\n    \n    \n    #include <curses.h>       // Bad: disallowed system header.\n    #include <openssl/ssl.h>  // Good: allowed system header.\n    #include <openssl/rsa.h>  // Good: allowed system header.\n    #include <zlib.h>         // Bad: disallowed system header.\n    #include \"src/myfile.h\"   // Good: non-system header always allowed.\n    \n\n## OptionsÂ¶\n\n`Includes```Â¶\n\n    \n\nA string containing a comma separated glob list of allowed include filenames.\nSimilar to the -checks glob list for running clang-tidy itself, the two\nwildcard characters are * and -, to include and exclude globs, respectively.\nThe default is *, which allows all includes.",
                "disable": false
            },
            {
                "real_name": "portability-simd-intrinsics",
                "display_name": "portability-simd-intrinsics",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# portability-simd-intrinsicsÂ¶\n\nFinds SIMD intrinsics calls and suggests `std::experimental::simd`\n([P0214](https://wg21.link/p0214)) alternatives.\n\nIf the option `Suggest` is set to true, for\n\n    \n    \n    _mm_add_epi32(a, b); // x86\n    vec_add(a, b);       // Power\n    \n\nthe check suggests an alternative: `operator+` on `std::experimental::simd`\nobjects.\n\nOtherwise, it just complains the intrinsics are non-portable (and there are\n[P0214](https://wg21.link/p0214) alternatives).\n\nMany architectures provide SIMD operations (e.g. x86 SSE/AVX, Power\nAltiVec/VSX, ARM NEON). It is common that SIMD code implementing the same\nalgorithm, is written in multiple target-dispatching pieces to optimize for\ndifferent architectures or micro-architectures.\n\nThe C++ standard proposal [P0214](https://wg21.link/p0214) and its extensions\ncover many common SIMD operations. By migrating from target-dependent\nintrinsics to [P0214](https://wg21.link/p0214) operations, the SIMD code can\nbe simplified and pieces for different targets can be unified.\n\nRefer to [P0214](https://wg21.link/p0214) for introduction and motivation for\nthe data-parallel standard library.\n\n## OptionsÂ¶\n\n`Suggest```Â¶\n\n    \n\nIf this option is set to true (default is false), the check will suggest\n[P0214](https://wg21.link/p0214) alternatives, otherwise it only points out\nthe intrinsic function is non-portable.\n\n`Std```Â¶\n\n    \n\nThe namespace used to suggest [P0214](https://wg21.link/p0214) alternatives.\nIf not specified, std:: for -std=c++20 and std::experimental:: for -std=c++11.",
                "disable": false
            },
            {
                "real_name": "portability-std-allocator-const",
                "display_name": "portability-std-allocator-const",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# portability-std-allocator-constÂ¶\n\nReport use of `std::vector<const T>` (and similar containers of const\nelements). These are not allowed in standard C++, and should usually be\n`std::vector<T>` instead.â\n\nPer C++ `[allocator.requirements.general]`: âT is any cv-unqualified object\ntypeâ, `std::allocator<const T>` is undefined. Many standard containers use\n`std::allocator` by default and therefore their `const T` instantiations are\nundefined.\n\nlibc++ defines `std::allocator<const T>` as an extension which will be removed\nin the future.\n\nlibstdc++ and MSVC do not support `std::allocator<const T>`:\n\n    \n    \n    // libstdc++ has a better diagnostic since https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48101\n    std::deque<const int> deque; // error: static assertion failed: std::deque must have a non-const, non-volatile value_type\n    std::set<const int> set; // error: static assertion failed: std::set must have a non-const, non-volatile value_type\n    std::vector<int* const> vector; // error: static assertion failed: std::vector must have a non-const, non-volatile value_type\n    \n    // MSVC\n    // error C2338: static_assert failed: 'The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.'\n    \n\nCode bases only compiled with libc++ may accrue such undefined usage. This\ncheck finds such code and prevents backsliding while clean-up is ongoing.",
                "disable": false
            },
            {
                "real_name": "readability-avoid-const-params-in-decls",
                "display_name": "readability-avoid-const-params-in-decls",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-avoid-const-params-in-declsÂ¶\n\nChecks whether a function declaration has parameters that are top level\n`const`.\n\n`const` values in declarations do not affect the signature of a function, so\nthey should not be put there.\n\nExamples:\n\n    \n    \n    void f(const string);   // Bad: const is top level.\n    void f(const string&);  // Good: const is not top level.",
                "disable": false
            },
            {
                "real_name": "readability-braces-around-statements",
                "display_name": "readability-braces-around-statements",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-braces-around-statementsÂ¶\n\ngoogle-readability-braces-around-statements redirects here as an alias for\nthis check.\n\nChecks that bodies of `if` statements and loops (`for`, `do while`, and\n`while`) are inside braces.\n\nBefore:\n\n    \n    \n    if (condition)\n      statement;\n    \n\nAfter:\n\n    \n    \n    if (condition) {\n      statement;\n    }\n    \n\n## OptionsÂ¶\n\n`ShortStatementLines```Â¶\n\n    \n\nDefines the minimal number of lines that the statement should have in order to\ntrigger this check.\n\nThe number of lines is counted from the end of condition or initial keyword\n(`do`/`else`) until the last line of the inner statement. Default value 0\nmeans that braces will be added to all statements (not having them already).",
                "disable": false
            },
            {
                "real_name": "readability-const-return-type",
                "display_name": "readability-const-return-type",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-const-return-typeÂ¶\n\nChecks for functions with a `const`-qualified return type and recommends\nremoval of the `const` keyword. Such use of const is usually superfluous, and\ncan prevent valuable compiler optimizations. Does not (yet) fix trailing\nreturn types.\n\nExamples:\n\n    \n    \n    const int foo();\n    const Clazz foo();\n    Clazz *const foo();\n    \n\nNote that this applies strictly to top-level qualification, which excludes\npointers or references to const values. For example, these are fine:\n\n    \n    \n    const int* foo();\n    const int& foo();\n    const Clazz* foo();",
                "disable": false
            },
            {
                "real_name": "readability-container-contains",
                "display_name": "readability-container-contains",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-container-containsÂ¶\n\nFinds usages of `container.count()` and `container.find() == container.end()`\nwhich should be replaced by a call to the `container.contains()` method\nintroduced in C++ 20.\n\nWhether an element is contained inside a container should be checked with\n`contains` instead of `count`/`find` because `contains` conveys the intent\nmore clearly. Furthermore, for containers which permit multiple entries per\nkey (`multimap`, `multiset`, â¦), `contains` is more efficient than `count`\nbecause `count` has to do unnecessary additional work.\n\nExamples:\n\nInitial expression | Result  \n---|---  \n`myMap.find(x) == myMap.end()` | `!myMap.contains(x)`  \n`myMap.find(x) != myMap.end()` | `myMap.contains(x)`  \n`if (myMap.count(x))` | `if (myMap.contains(x))`  \n`bool exists = myMap.count(x)` | `bool exists = myMap.contains(x)`  \n`bool exists = myMap.count(x) > 0` | `bool exists = myMap.contains(x)`  \n`bool exists = myMap.count(x) >= 1` | `bool exists = myMap.contains(x)`  \n`bool missing = myMap.count(x) == 0` | `bool missing = !myMap.contains(x)`  \n  \nThis check applies to `std::set`, `std::unordered_set`, `std::map`,\n`std::unordered_map` and the corresponding multi-key variants. It is only\nactive for C++20 and later, as the `contains` method was only added in C++20.",
                "disable": false
            },
            {
                "real_name": "readability-container-data-pointer",
                "display_name": "readability-container-data-pointer",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-container-data-pointerÂ¶\n\nFinds cases where code could use `data()` rather than the address of the\nelement at index 0 in a container. This pattern is commonly used to\nmaterialize a pointer to the backing data of a container. `std::vector` and\n`std::string` provide a `data()` accessor to retrieve the data pointer which\nshould be preferred.\n\nThis also ensures that in the case that the container is empty, the data\npointer access does not perform an errant memory access.",
                "disable": false
            },
            {
                "real_name": "readability-container-size-empty",
                "display_name": "readability-container-size-empty",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-container-size-emptyÂ¶\n\nChecks whether a call to the `size()` method can be replaced with a call to\n`empty()`.\n\nThe emptiness of a container should be checked using the `empty()` method\ninstead of the `size()` method. It is not guaranteed that `size()` is a\nconstant-time function, and it is generally more efficient and also shows\nclearer intent to use `empty()`. Furthermore some containers may implement the\n`empty()` method but not implement the `size()` method. Using `empty()`\nwhenever possible makes it easier to switch to another container in the\nfuture.\n\nThe check issues warning if a container has `size()` and `empty()` methods\nmatching following signatures:\n\n    \n    \n    size_type size() const;\n    bool empty() const;\n    \n\nsize_type can be any kind of integer type.",
                "disable": false
            },
            {
                "real_name": "readability-convert-member-functions-to-static",
                "display_name": "readability-convert-member-functions-to-static",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-convert-member-functions-to-staticÂ¶\n\nFinds non-static member functions that can be made `static` because the\nfunctions donât use `this`.\n\nAfter applying modifications as suggested by the check, running the check\nagain might find more opportunities to mark member functions `static`.\n\nAfter making a member function `static`, you might want to run the check\n[readability-static-accessed-through-instance](../readability/static-accessed-\nthrough-instance.html) to replace calls like `Instance.method()` by\n`Class::method()`.",
                "disable": false
            },
            {
                "real_name": "readability-delete-null-pointer",
                "display_name": "readability-delete-null-pointer",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-delete-null-pointerÂ¶\n\nChecks the `if` statements where a pointerâs existence is checked and then\ndeletes the pointer. The check is unnecessary as deleting a null pointer has\nno effect.\n\n    \n    \n    int *p;\n    if (p)\n      delete p;",
                "disable": false
            },
            {
                "real_name": "readability-duplicate-include",
                "display_name": "readability-duplicate-include",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-duplicate-includeÂ¶\n\nLooks for duplicate includes and removes them. The check maintains a list of\nincluded files and looks for duplicates. If a macro is defined or undefined\nthen the list of included files is cleared.\n\nExamples:\n\n    \n    \n    #include <memory>\n    #include <vector>\n    #include <memory>\n    \n\nbecomes\n\n    \n    \n    #include <memory>\n    #include <vector>\n    \n\nBecause of the intervening macro definitions, this code remains unchanged:\n\n    \n    \n    #undef NDEBUG\n    #include \"assertion.h\"\n    // ...code with assertions enabled\n    \n    #define NDEBUG\n    #include \"assertion.h\"\n    // ...code with assertions disabled",
                "disable": false
            },
            {
                "real_name": "readability-else-after-return",
                "display_name": "readability-else-after-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-else-after-returnÂ¶\n\n[LLVM Coding Standards](https://llvm.org/docs/CodingStandards.html) advises to\nreduce indentation where possible and where it makes understanding code\neasier. Early exit is one of the suggested enforcements of that. Please do not\nuse `else` or `else if` after something that interrupts control flow - like\n`return`, `break`, `continue`, `throw`.\n\nThe following piece of code illustrates how the check works. This piece of\ncode:\n\n    \n    \n    void foo(int Value) {\n      int Local = 0;\n      for (int i = 0; i < 42; i++) {\n        if (Value == 1) {\n          return;\n        } else {\n          Local++;\n        }\n    \n        if (Value == 2)\n          continue;\n        else\n          Local++;\n    \n        if (Value == 3) {\n          throw 42;\n        } else {\n          Local++;\n        }\n      }\n    }\n    \n\nWould be transformed into:\n\n    \n    \n    void foo(int Value) {\n      int Local = 0;\n      for (int i = 0; i < 42; i++) {\n        if (Value == 1) {\n          return;\n        }\n        Local++;\n    \n        if (Value == 2)\n          continue;\n        Local++;\n    \n        if (Value == 3) {\n          throw 42;\n        }\n        Local++;\n      }\n    }\n    \n\n## OptionsÂ¶\n\n`WarnOnUnfixable```Â¶\n\n    \n\nWhen true, emit a warning for cases where the check canât output a Fix-It.\nThese can occur with declarations inside the `else` branch that would have an\nextended lifetime if the `else` branch was removed. Default value is true.\n\n`WarnOnConditionVariables```Â¶\n\n    \n\nWhen true, the check will attempt to refactor a variable defined inside the\ncondition of the `if` statement that is used in the `else` branch defining\nthem just before the `if` statement. This can only be done if the `if`\nstatement is the last statement in its parentâs scope. Default value is\ntrue.\n\n## LLVM aliasÂ¶\n\nThere is an alias of this check called llvm-else-after-return. In that version\nthe options `WarnOnUnfixable` and `WarnOnConditionVariables` are both set to\nfalse by default.\n\nThis check helps to enforce this [LLVM Coding Standards\nrecommendation](https://llvm.org/docs/CodingStandards.html#don-t-use-else-\nafter-a-return).",
                "disable": false
            },
            {
                "real_name": "readability-function-cognitive-complexity",
                "display_name": "readability-function-cognitive-complexity",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-function-cognitive-complexityÂ¶\n\nChecks function Cognitive Complexity metric.\n\nThe metric is implemented as per the [COGNITIVE COMPLEXITY by\nSonarSource](https://www.sonarsource.com/docs/CognitiveComplexity.pdf)\nspecification version 1.2 (19 April 2017).\n\n## OptionsÂ¶\n\n`Threshold```Â¶\n\n    \n\nFlag functions with Cognitive Complexity exceeding this number. The default is\n25.\n\n`DescribeBasicIncrements```Â¶\n\n    \n\nIf set to true, then for each function exceeding the complexity threshold the\ncheck will issue additional diagnostics on every piece of code (loop, if\nstatement, etc.) which contributes to that complexity. See also the examples\nbelow. Default is true.\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will ignore code inside macros. Note, that also any\nmacro arguments are ignored, even if they should count to the complexity. As\nthis might change in the future, this option isnât guaranteed to be forward-\ncompatible. Default is false.\n\n## Building blocksÂ¶\n\nThere are three basic building blocks of a Cognitive Complexity metric:\n\n### IncrementÂ¶\n\nThe following structures increase the functionâs Cognitive Complexity metric\n(by 1):\n\n  * Conditional operators:\n\n>     * `if()`\n>     * `else if()`\n>     * `else`\n>     * `cond ? true : false`\n\n  * `switch()`\n\n  * Loops:\n\n>     * `for()`\n>     * C++11 range-based `for()`\n>     * `while()`\n>     * `do while()`\n\n  * `catch ()`\n\n  * `goto LABEL`, `goto *(&&LABEL))`,\n\n  * sequences of binary logical operators:\n\n>     * `boolean1 || boolean2`\n>     * `boolean1 && boolean2`\n\n### Nesting levelÂ¶\n\nWhile by itself the nesting level does not change the functionâs Cognitive\nComplexity metric, it is tracked, and is used by the next, third building\nblock. The following structures increase the nesting level (by 1):\n\n  * Conditional operators:\n\n>     * `if()`\n>     * `else if()`\n>     * `else`\n>     * `cond ? true : false`\n\n  * `switch()`\n\n  * Loops:\n\n>     * `for()`\n>     * C++11 range-based `for()`\n>     * `while()`\n>     * `do while()`\n\n  * `catch ()`\n\n  * Nested functions:\n\n>     * C++11 Lambda\n>     * Nested `class`\n>     * Nested `struct`\n\n  * GNU statement expression\n\n  * Apple Block Declaration\n\n### Nesting incrementÂ¶\n\nThis is where the previous basic building block, Nesting level, matters. The\nfollowing structures increase the functionâs Cognitive Complexity metric by\nthe current Nesting level:\n\n  * Conditional operators:\n\n>     * `if()`\n>     * `cond ? true : false`\n\n  * `switch()`\n\n  * Loops:\n\n>     * `for()`\n>     * C++11 range-based `for()`\n>     * `while()`\n>     * `do while()`\n\n  * `catch ()`\n\n## ExamplesÂ¶\n\nThe simplest case. This function has Cognitive Complexity of 0.\n\n    \n    \n    void function0() {}\n    \n\nSlightly better example. This function has Cognitive Complexity of 1.\n\n    \n    \n    int function1(bool var) {\n      if(var) // +1, nesting level +1\n        return 42;\n      return 0;\n    }\n    \n\nFull example. This function has Cognitive Complexity of 3.\n\n    \n    \n    int function3(bool var1, bool var2) {\n      if(var1) { // +1, nesting level +1\n        if(var2)  // +2 (1 + current nesting level of 1), nesting level +1\n          return 42;\n      }\n    \n      return 0;\n    }\n    \n\nIn the last example, the check will flag function3 if the option Threshold is\nset to 2 or smaller. If the option DescribeBasicIncrements is set to true, it\nwill additionally flag the two if statements with the amounts by which they\nincrease to the complexity of the function and the current nesting level.\n\n## LimitationsÂ¶\n\nThe metric is implemented with two notable exceptions:\n\n    \n\n  * preprocessor conditionals (`#ifdef`, `#if`, `#elif`, `#else`, `#endif`) are not accounted for.\n  * each method in a recursion cycle is not accounted for. It canât be fully implemented, because cross-translational-unit analysis would be needed, which is currently not possible in clang-tidy.",
                "disable": false
            },
            {
                "real_name": "readability-function-size",
                "display_name": "readability-function-size",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-function-sizeÂ¶\n\ngoogle-readability-function-size redirects here as an alias for this check.\n\nChecks for large functions based on various metrics.\n\n## OptionsÂ¶\n\n`LineThreshold```Â¶\n\n    \n\nFlag functions exceeding this number of lines. The default is -1 (ignore the\nnumber of lines).\n\n`StatementThreshold```Â¶\n\n    \n\nFlag functions exceeding this number of statements. This may differ\nsignificantly from the number of lines for macro-heavy code. The default is\n800.\n\n`BranchThreshold```Â¶\n\n    \n\nFlag functions exceeding this number of control statements. The default is -1\n(ignore the number of branches).\n\n`ParameterThreshold```Â¶\n\n    \n\nFlag functions that exceed a specified number of parameters. The default is -1\n(ignore the number of parameters).\n\n`NestingThreshold```Â¶\n\n    \n\nFlag compound statements which create next nesting level after\nNestingThreshold. This may differ significantly from the expected value for\nmacro-heavy code. The default is -1 (ignore the nesting level).\n\n`VariableThreshold```Â¶\n\n    \n\nFlag functions exceeding this number of variables declared in the body. The\ndefault is -1 (ignore the number of variables). Please note that function\nparameters and variables declared in lambdas, GNU Statement Expressions, and\nnested class inline functions are not counted.",
                "disable": false
            },
            {
                "real_name": "readability-identifier-length",
                "display_name": "readability-identifier-length",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-identifier-lengthÂ¶\n\nThis check finds variables and function parameters whose length are too short.\nThe desired name length is configurable.\n\nSpecial cases are supported for loop counters and for exception variable\nnames.\n\n## OptionsÂ¶\n\nThe following options are described below:\n\n>   * `MinimumVariableNameLength`, `IgnoredVariableNames`\n>   * `MinimumParameterNameLength`, `IgnoredParameterNames`\n>   * `MinimumLoopCounterNameLength`, `IgnoredLoopCounterNames`\n>   * `MinimumExceptionNameLength`, `IgnoredExceptionVariableNames`\n>\n\n`MinimumVariableNameLength```Â¶\n\n    \n\nAll variables (other than loop counter, exception names and function\nparameters) are expected to have at least a length of\nMinimumVariableNameLength (default is 3). Setting it to 0 or 1 disables the\ncheck entirely.\n\n    \n    \n    int doubler(int x)   // warns that x is too short\n    {\n       return 2 * x;\n    }\n    \n\nThis check does not have any fix suggestions in the general case since\nvariable names have semantic value.\n\n`IgnoredVariableNames```Â¶\n\n    \n\nSpecifies a regular expression for variable names that are to be ignored. The\ndefault value is empty, thus no names are ignored.\n\n`MinimumParameterNameLength```Â¶\n\n    \n\nAll function parameter names are expected to have a length of at least\nMinimumParameterNameLength (default is 3). Setting it to 0 or 1 disables the\ncheck entirely.\n\n    \n    \n    int i = 42;    // warns that 'i' is too short\n    \n\nThis check does not have any fix suggestions in the general case since\nvariable names have semantic value.\n\n`IgnoredParameterNames```Â¶\n\n    \n\nSpecifies a regular expression for parameters that are to be ignored. The\ndefault value is ^[n]$ for historical reasons.\n\n`MinimumLoopCounterNameLength```Â¶\n\n    \n\nLoop counter variables are expected to have a length of at least\nMinimumLoopCounterNameLength characters (default is 2). Setting it to 0 or 1\ndisables the check entirely.\n\n    \n    \n    // This warns that 'q' is too short.\n    for (int q = 0; q < size; ++ q) {\n       // ...\n    }\n    \n\n`IgnoredLoopCounterNames```Â¶\n\n    \n\nSpecifies a regular expression for counter names that are to be ignored. The\ndefault value is ^[ijk_]$; the first three symbols for historical reasons and\nthe last one since it is frequently used as a âdonât careâ value,\nspecifically in tools such as Google Benchmark.\n\n    \n    \n    // This does not warn by default, for historical reasons.\n    for (int i = 0; i < size; ++ i) {\n        // ...\n    }\n    \n\n`MinimumExceptionNameLength```Â¶\n\n    \n\nException clause variables are expected to have a length of at least\nMinimumExceptionNameLength (default is 2). Setting it to 0 or 1 disables the\ncheck entirely.\n\n    \n    \n    try {\n        // ...\n    }\n    // This warns that 'e' is too short.\n    catch (const std::exception& x) {\n        // ...\n    }\n    \n\n`IgnoredExceptionVariableNames```Â¶\n\n    \n\nSpecifies a regular expression for exception variable names that are to be\nignored. The default value is ^[e]$ mainly for historical reasons.\n\n    \n    \n    try {\n        // ...\n    }\n    // This does not warn by default, for historical reasons.\n    catch (const std::exception& e) {\n        // ...\n    }",
                "disable": false
            },
            {
                "real_name": "readability-identifier-naming",
                "display_name": "readability-identifier-naming",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-identifier-namingÂ¶\n\nChecks for identifiers naming style mismatch.\n\nThis check will try to enforce coding guidelines on the identifiers naming. It\nsupports one of the following casing types and tries to convert from one to\nanother if a mismatch is detected\n\nCasing types include:\n\n>   * `lower_case`,\n>   * `UPPER_CASE`,\n>   * `camelBack`,\n>   * `CamelCase`,\n>   * `camel_Snake_Back`,\n>   * `Camel_Snake_Case`,\n>   * `aNy_CasE`.\n>\n\nIt also supports a fixed prefix and suffix that will be prepended or appended\nto the identifiers, regardless of the casing.\n\nMany configuration options are available, in order to be able to create\ndifferent rules for different kinds of identifiers. In general, the rules are\nfalling back to a more generic rule if the specific case is not configured.\n\nThe naming of virtual methods is reported where they occur in the base class,\nbut not where they are overridden, as it canât be fixed locally there. This\nalso applies for pseudo-override patterns like CRTP.\n\n## OptionsÂ¶\n\nThe following options are described below:\n\n>   * `AbstractClassCase`, `AbstractClassPrefix`, `AbstractClassSuffix`,\n> `AbstractClassIgnoredRegexp`, `AbstractClassHungarianPrefix`\n>   * `AggressiveDependentMemberLookup`\n>   * `ClassCase`, `ClassPrefix`, `ClassSuffix`, `ClassIgnoredRegexp`,\n> `ClassHungarianPrefix`\n>   * `ClassConstantCase`, `ClassConstantPrefix`, `ClassConstantSuffix`,\n> `ClassConstantIgnoredRegexp`, `ClassConstantHungarianPrefix`\n>   * `ClassMemberCase`, `ClassMemberPrefix`, `ClassMemberSuffix`,\n> `ClassMemberIgnoredRegexp`, `ClassMemberHungarianPrefix`\n>   * `ClassMethodCase`, `ClassMethodPrefix`, `ClassMethodSuffix`,\n> `ClassMethodIgnoredRegexp`\n>   * `ConstantCase`, `ConstantPrefix`, `ConstantSuffix`,\n> `ConstantIgnoredRegexp`, `ConstantHungarianPrefix`\n>   * `ConstantMemberCase`, `ConstantMemberPrefix`, `ConstantMemberSuffix`,\n> `ConstantMemberIgnoredRegexp`, `ConstantMemberHungarianPrefix`\n>   * `ConstantParameterCase`, `ConstantParameterPrefix`,\n> `ConstantParameterSuffix`, `ConstantParameterIgnoredRegexp`,\n> `ConstantParameterHungarianPrefix`\n>   * `ConstantPointerParameterCase`, `ConstantPointerParameterPrefix`,\n> `ConstantPointerParameterSuffix`, `ConstantPointerParameterIgnoredRegexp`,\n> `ConstantPointerParameterHungarianPrefix`\n>   * `ConstexprFunctionCase`, `ConstexprFunctionPrefix`,\n> `ConstexprFunctionSuffix`, `ConstexprFunctionIgnoredRegexp`\n>   * `ConstexprMethodCase`, `ConstexprMethodPrefix`, `ConstexprMethodSuffix`,\n> `ConstexprMethodIgnoredRegexp`\n>   * `ConstexprVariableCase`, `ConstexprVariablePrefix`,\n> `ConstexprVariableSuffix`, `ConstexprVariableIgnoredRegexp`,\n> `ConstexprVariableHungarianPrefix`\n>   * `EnumCase`, `EnumPrefix`, `EnumSuffix`, `EnumIgnoredRegexp`\n>   * `EnumConstantCase`, `EnumConstantPrefix`, `EnumConstantSuffix`,\n> `EnumConstantIgnoredRegexp`, `EnumConstantHungarianPrefix`\n>   * `FunctionCase`, `FunctionPrefix`, `FunctionSuffix`,\n> `FunctionIgnoredRegexp`\n>   * `GetConfigPerFile`\n>   * `GlobalConstantCase`, `GlobalConstantPrefix`, `GlobalConstantSuffix`,\n> `GlobalConstantIgnoredRegexp`, `GlobalConstantHungarianPrefix`\n>   * `GlobalConstantPointerCase`, `GlobalConstantPointerPrefix`,\n> `GlobalConstantPointerSuffix`, `GlobalConstantPointerIgnoredRegexp`,\n> `GlobalConstantPointerHungarianPrefix`\n>   * `GlobalFunctionCase`, `GlobalFunctionPrefix`, `GlobalFunctionSuffix`,\n> `GlobalFunctionIgnoredRegexp`\n>   * `GlobalPointerCase`, `GlobalPointerPrefix`, `GlobalPointerSuffix`,\n> `GlobalPointerIgnoredRegexp`, `GlobalPointerHungarianPrefix`\n>   * `GlobalVariableCase`, `GlobalVariablePrefix`, `GlobalVariableSuffix`,\n> `GlobalVariableIgnoredRegexp`, `GlobalVariableHungarianPrefix`\n>   * `IgnoreMainLikeFunctions`\n>   * `InlineNamespaceCase`, `InlineNamespacePrefix`, `InlineNamespaceSuffix`,\n> `InlineNamespaceIgnoredRegexp`\n>   * `LocalConstantCase`, `LocalConstantPrefix`, `LocalConstantSuffix`,\n> `LocalConstantIgnoredRegexp`, `LocalConstantHungarianPrefix`\n>   * `LocalConstantPointerCase`, `LocalConstantPointerPrefix`,\n> `LocalConstantPointerSuffix`, `LocalConstantPointerIgnoredRegexp`,\n> `LocalConstantPointerHungarianPrefix`\n>   * `LocalPointerCase`, `LocalPointerPrefix`, `LocalPointerSuffix`,\n> `LocalPointerIgnoredRegexp`, `LocalPointerHungarianPrefix`\n>   * `LocalVariableCase`, `LocalVariablePrefix`, `LocalVariableSuffix`,\n> `LocalVariableIgnoredRegexp`, `LocalVariableHungarianPrefix`\n>   * `MacroDefinitionCase`, `MacroDefinitionPrefix`, `MacroDefinitionSuffix`,\n> `MacroDefinitionIgnoredRegexp`\n>   * `MemberCase`, `MemberPrefix`, `MemberSuffix`, `MemberIgnoredRegexp`,\n> `MemberHungarianPrefix`\n>   * `MethodCase`, `MethodPrefix`, `MethodSuffix`, `MethodIgnoredRegexp`\n>   * `NamespaceCase`, `NamespacePrefix`, `NamespaceSuffix`,\n> `NamespaceIgnoredRegexp`\n>   * `ParameterCase`, `ParameterPrefix`, `ParameterSuffix`,\n> `ParameterIgnoredRegexp`, `ParameterHungarianPrefix`\n>   * `ParameterPackCase`, `ParameterPackPrefix`, `ParameterPackSuffix`,\n> `ParameterPackIgnoredRegexp`\n>   * `PointerParameterCase`, `PointerParameterPrefix`,\n> `PointerParameterSuffix`, `PointerParameterIgnoredRegexp`,\n> `PointerParameterHungarianPrefix`\n>   * `PrivateMemberCase`, `PrivateMemberPrefix`, `PrivateMemberSuffix`,\n> `PrivateMemberIgnoredRegexp`, `PrivateMemberHungarianPrefix`\n>   * `PrivateMethodCase`, `PrivateMethodPrefix`, `PrivateMethodSuffix`,\n> `PrivateMethodIgnoredRegexp`\n>   * `ProtectedMemberCase`, `ProtectedMemberPrefix`, `ProtectedMemberSuffix`,\n> `ProtectedMemberIgnoredRegexp`, `ProtectedMemberHungarianPrefix`\n>   * `ProtectedMethodCase`, `ProtectedMethodPrefix`, `ProtectedMethodSuffix`,\n> `ProtectedMethodIgnoredRegexp`\n>   * `PublicMemberCase`, `PublicMemberPrefix`, `PublicMemberSuffix`,\n> `PublicMemberIgnoredRegexp`, `PublicMemberHungarianPrefix`\n>   * `PublicMethodCase`, `PublicMethodPrefix`, `PublicMethodSuffix`,\n> `PublicMethodIgnoredRegexp`\n>   * `ScopedEnumConstantCase`, `ScopedEnumConstantPrefix`,\n> `ScopedEnumConstantSuffix`, `ScopedEnumConstantIgnoredRegexp`\n>   * `StaticConstantCase`, `StaticConstantPrefix`, `StaticConstantSuffix`,\n> `StaticConstantIgnoredRegexp`, `StaticConstantHungarianPrefix`\n>   * `StaticVariableCase`, `StaticVariablePrefix`, `StaticVariableSuffix`,\n> `StaticVariableIgnoredRegexp`, `StaticVariableHungarianPrefix`\n>   * `StructCase`, `StructPrefix`, `StructSuffix`, `StructIgnoredRegexp`\n>   * `TemplateParameterCase`, `TemplateParameterPrefix`,\n> `TemplateParameterSuffix`, `TemplateParameterIgnoredRegexp`\n>   * `TemplateTemplateParameterCase`, `TemplateTemplateParameterPrefix`,\n> `TemplateTemplateParameterSuffix`, `TemplateTemplateParameterIgnoredRegexp`\n>   * `TypeAliasCase`, `TypeAliasPrefix`, `TypeAliasSuffix`,\n> `TypeAliasIgnoredRegexp`\n>   * `TypedefCase`, `TypedefPrefix`, `TypedefSuffix`, `TypedefIgnoredRegexp`\n>   * `TypeTemplateParameterCase`, `TypeTemplateParameterPrefix`,\n> `TypeTemplateParameterSuffix`, `TypeTemplateParameterIgnoredRegexp`\n>   * `UnionCase`, `UnionPrefix`, `UnionSuffix`, `UnionIgnoredRegexp`\n>   * `ValueTemplateParameterCase`, `ValueTemplateParameterPrefix`,\n> `ValueTemplateParameterSuffix`, `ValueTemplateParameterIgnoredRegexp`\n>   * `VariableCase`, `VariablePrefix`, `VariableSuffix`,\n> `VariableIgnoredRegexp`, `VariableHungarianPrefix`\n>   * `VirtualMethodCase`, `VirtualMethodPrefix`, `VirtualMethodSuffix`,\n> `VirtualMethodIgnoredRegexp`\n>\n\n`AbstractClassCase```Â¶\n\n    \n\nWhen defined, the check will ensure abstract class names conform to the\nselected casing.\n\n`AbstractClassPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure abstract class names will add the prefixed\nwith the given value (regardless of casing).\n\n`AbstractClassIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for abstract class names matching\nthis regular expression.\n\n`AbstractClassSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure abstract class names will add the suffix\nwith the given value (regardless of casing).\n\n`AbstractClassHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * AbstractClassCase of `lower_case`\n>   * AbstractClassPrefix of `pre_`\n>   * AbstractClassSuffix of `_post`\n>   * AbstractClassHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms abstract class names as follows:\n\nBefore:\n\n    \n    \n    class ABSTRACT_CLASS {\n    public:\n      ABSTRACT_CLASS();\n    };\n    \n\nAfter:\n\n    \n    \n    class pre_abstract_class_post {\n    public:\n      pre_abstract_class_post();\n    };\n    \n\n`AggressiveDependentMemberLookup```Â¶\n\n    \n\nWhen set to true the check will look in dependent base classes for dependent\nmember references that need changing. This can lead to errors with template\nspecializations so the default value is false.\n\nFor example using values of:\n\n>   * ClassMemberCase of `lower_case`\n>\n\nBefore:\n\n    \n    \n    template <typename T>\n    struct Base {\n      T BadNamedMember;\n    };\n    \n    template <typename T>\n    struct Derived : Base<T> {\n      void reset() {\n        this->BadNamedMember = 0;\n      }\n    };\n    \n\nAfter if AggressiveDependentMemberLookup is false:\n\n    \n    \n    template <typename T>\n    struct Base {\n      T bad_named_member;\n    };\n    \n    template <typename T>\n    struct Derived : Base<T> {\n      void reset() {\n        this->BadNamedMember = 0;\n      }\n    };\n    \n\nAfter if AggressiveDependentMemberLookup is true:\n\n    \n    \n    template <typename T>\n    struct Base {\n      T bad_named_member;\n    };\n    \n    template <typename T>\n    struct Derived : Base<T> {\n      void reset() {\n        this->bad_named_member = 0;\n      }\n    };\n    \n\n`ClassCase```Â¶\n\n    \n\nWhen defined, the check will ensure class names conform to the selected\ncasing.\n\n`ClassPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure class names will add the prefixed with the\ngiven value (regardless of casing).\n\n`ClassIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for class names matching this\nregular expression.\n\n`ClassSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure class names will add the suffix with the\ngiven value (regardless of casing).\n\n`ClassHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ClassCase of `lower_case`\n>   * ClassPrefix of `pre_`\n>   * ClassSuffix of `_post`\n>   * ClassHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms class names as follows:\n\nBefore:\n\n    \n    \n    class FOO {\n    public:\n      FOO();\n      ~FOO();\n    };\n    \n\nAfter:\n\n    \n    \n    class pre_foo_post {\n    public:\n      pre_foo_post();\n      ~pre_foo_post();\n    };\n    \n\n`ClassConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure class constant names conform to the\nselected casing.\n\n`ClassConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure class constant names will add the prefixed\nwith the given value (regardless of casing).\n\n`ClassConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for class constant names matching\nthis regular expression.\n\n`ClassConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure class constant names will add the suffix\nwith the given value (regardless of casing).\n\n`ClassConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ClassConstantCase of `lower_case`\n>   * ClassConstantPrefix of `pre_`\n>   * ClassConstantSuffix of `_post`\n>   * ClassConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms class constant names as follows:\n\nBefore:\n\n    \n    \n    class FOO {\n    public:\n      static const int CLASS_CONSTANT;\n    };\n    \n\nAfter:\n\n    \n    \n    class FOO {\n    public:\n      static const int pre_class_constant_post;\n    };\n    \n\n`ClassMemberCase```Â¶\n\n    \n\nWhen defined, the check will ensure class member names conform to the selected\ncasing.\n\n`ClassMemberPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure class member names will add the prefixed\nwith the given value (regardless of casing).\n\n`ClassMemberIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for class member names matching\nthis regular expression.\n\n`ClassMemberSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure class member names will add the suffix\nwith the given value (regardless of casing).\n\n`ClassMemberHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ClassMemberCase of `lower_case`\n>   * ClassMemberPrefix of `pre_`\n>   * ClassMemberSuffix of `_post`\n>   * ClassMemberHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms class member names as follows:\n\nBefore:\n\n    \n    \n    class FOO {\n    public:\n      static int CLASS_CONSTANT;\n    };\n    \n\nAfter:\n\n    \n    \n    class FOO {\n    public:\n      static int pre_class_constant_post;\n    };\n    \n\n`ClassMethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure class method names conform to the selected\ncasing.\n\n`ClassMethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure class method names will add the prefixed\nwith the given value (regardless of casing).\n\n`ClassMethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for class method names matching\nthis regular expression.\n\n`ClassMethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure class method names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * ClassMethodCase of `lower_case`\n>   * ClassMethodPrefix of `pre_`\n>   * ClassMethodSuffix of `_post`\n>\n\nIdentifies and/or transforms class method names as follows:\n\nBefore:\n\n    \n    \n    class FOO {\n    public:\n      int CLASS_MEMBER();\n    };\n    \n\nAfter:\n\n    \n    \n    class FOO {\n    public:\n      int pre_class_member_post();\n    };\n    \n\n`ConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure constant names conform to the selected\ncasing.\n\n`ConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constant names will add the prefixed with\nthe given value (regardless of casing).\n\n`ConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constant names matching this\nregular expression.\n\n`ConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constant names will add the suffix with\nthe given value (regardless of casing).\n\n`ConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ConstantCase of `lower_case`\n>   * ConstantPrefix of `pre_`\n>   * ConstantSuffix of `_post`\n>   * ConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms constant names as follows:\n\nBefore:\n\n    \n    \n    void function() { unsigned const MyConst_array[] = {1, 2, 3}; }\n    \n\nAfter:\n\n    \n    \n    void function() { unsigned const pre_myconst_array_post[] = {1, 2, 3}; }\n    \n\n`ConstantMemberCase```Â¶\n\n    \n\nWhen defined, the check will ensure constant member names conform to the\nselected casing.\n\n`ConstantMemberPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constant member names will add the\nprefixed with the given value (regardless of casing).\n\n`ConstantMemberIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constant member names\nmatching this regular expression.\n\n`ConstantMemberSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constant member names will add the suffix\nwith the given value (regardless of casing).\n\n`ConstantMemberHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ConstantMemberCase of `lower_case`\n>   * ConstantMemberPrefix of `pre_`\n>   * ConstantMemberSuffix of `_post`\n>   * ConstantMemberHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms constant member names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n      char const MY_ConstMember_string[4] = \"123\";\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n      char const pre_my_constmember_string_post[4] = \"123\";\n    }\n    \n\n`ConstantParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure constant parameter names conform to the\nselected casing.\n\n`ConstantParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constant parameter names will add the\nprefixed with the given value (regardless of casing).\n\n`ConstantParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constant parameter names\nmatching this regular expression.\n\n`ConstantParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constant parameter names will add the\nsuffix with the given value (regardless of casing).\n\n`ConstantParameterHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ConstantParameterCase of `lower_case`\n>   * ConstantParameterPrefix of `pre_`\n>   * ConstantParameterSuffix of `_post`\n>   * ConstantParameterHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms constant parameter names as follows:\n\nBefore:\n\n    \n    \n    void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);\n    \n\nAfter:\n\n    \n    \n    void GLOBAL_FUNCTION(int PARAMETER_1, int const pre_const_parameter_post);\n    \n\n`ConstantPointerParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure constant pointer parameter names conform\nto the selected casing.\n\n`ConstantPointerParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constant pointer parameter names will add\nthe prefixed with the given value (regardless of casing).\n\n`ConstantPointerParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constant pointer parameter\nnames matching this regular expression.\n\n`ConstantPointerParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constant pointer parameter names will add\nthe suffix with the given value (regardless of casing).\n\n`ConstantPointerParameterHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ConstantPointerParameterCase of `lower_case`\n>   * ConstantPointerParameterPrefix of `pre_`\n>   * ConstantPointerParameterSuffix of `_post`\n>   * ConstantPointerParameterHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms constant pointer parameter names as follows:\n\nBefore:\n\n    \n    \n    void GLOBAL_FUNCTION(int const *CONST_parameter);\n    \n\nAfter:\n\n    \n    \n    void GLOBAL_FUNCTION(int const *pre_const_parameter_post);\n    \n\n`ConstexprFunctionCase```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr function names conform to the\nselected casing.\n\n`ConstexprFunctionPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr function names will add the\nprefixed with the given value (regardless of casing).\n\n`ConstexprFunctionIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constexpr function names\nmatching this regular expression.\n\n`ConstexprFunctionSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr function names will add the\nsuffix with the given value (regardless of casing).\n\nFor example using values of:\n\n>   * ConstexprFunctionCase of `lower_case`\n>   * ConstexprFunctionPrefix of `pre_`\n>   * ConstexprFunctionSuffix of `_post`\n>\n\nIdentifies and/or transforms constexpr function names as follows:\n\nBefore:\n\n    \n    \n    constexpr int CE_function() { return 3; }\n    \n\nAfter:\n\n    \n    \n    constexpr int pre_ce_function_post() { return 3; }\n    \n\n`ConstexprMethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr method names conform to the\nselected casing.\n\n`ConstexprMethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr method names will add the\nprefixed with the given value (regardless of casing).\n\n`ConstexprMethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constexpr method names\nmatching this regular expression.\n\n`ConstexprMethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr method names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * ConstexprMethodCase of `lower_case`\n>   * ConstexprMethodPrefix of `pre_`\n>   * ConstexprMethodSuffix of `_post`\n>\n\nIdentifies and/or transforms constexpr method names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    public:\n      constexpr int CST_expr_Method() { return 2; }\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    public:\n      constexpr int pre_cst_expr_method_post() { return 2; }\n    }\n    \n\n`ConstexprVariableCase```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr variable names conform to the\nselected casing.\n\n`ConstexprVariablePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr variable names will add the\nprefixed with the given value (regardless of casing).\n\n`ConstexprVariableIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for constexpr variable names\nmatching this regular expression.\n\n`ConstexprVariableSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure constexpr variable names will add the\nsuffix with the given value (regardless of casing).\n\n`ConstexprVariableHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ConstexprVariableCase of `lower_case`\n>   * ConstexprVariablePrefix of `pre_`\n>   * ConstexprVariableSuffix of `_post`\n>   * ConstexprVariableHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms constexpr variable names as follows:\n\nBefore:\n\n    \n    \n    constexpr int ConstExpr_variable = MyConstant;\n    \n\nAfter:\n\n    \n    \n    constexpr int pre_constexpr_variable_post = MyConstant;\n    \n\n`EnumCase```Â¶\n\n    \n\nWhen defined, the check will ensure enumeration names conform to the selected\ncasing.\n\n`EnumPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure enumeration names will add the prefixed\nwith the given value (regardless of casing).\n\n`EnumIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for enumeration names matching\nthis regular expression.\n\n`EnumSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure enumeration names will add the suffix with\nthe given value (regardless of casing).\n\nFor example using values of:\n\n>   * EnumCase of `lower_case`\n>   * EnumPrefix of `pre_`\n>   * EnumSuffix of `_post`\n>\n\nIdentifies and/or transforms enumeration names as follows:\n\nBefore:\n\n    \n    \n    enum FOO { One, Two, Three };\n    \n\nAfter:\n\n    \n    \n    enum pre_foo_post { One, Two, Three };\n    \n\n`EnumConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure enumeration constant names conform to the\nselected casing.\n\n`EnumConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure enumeration constant names will add the\nprefixed with the given value (regardless of casing).\n\n`EnumConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for enumeration constant names\nmatching this regular expression.\n\n`EnumConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure enumeration constant names will add the\nsuffix with the given value (regardless of casing).\n\n`EnumConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * EnumConstantCase of `lower_case`\n>   * EnumConstantPrefix of `pre_`\n>   * EnumConstantSuffix of `_post`\n>   * EnumConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms enumeration constant names as follows:\n\nBefore:\n\n    \n    \n    enum FOO { One, Two, Three };\n    \n\nAfter:\n\n    \n    \n    enum FOO { pre_One_post, pre_Two_post, pre_Three_post };\n    \n\n`FunctionCase```Â¶\n\n    \n\nWhen defined, the check will ensure function names conform to the selected\ncasing.\n\n`FunctionPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure function names will add the prefixed with\nthe given value (regardless of casing).\n\n`FunctionIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for function names matching this\nregular expression.\n\n`FunctionSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure function names will add the suffix with\nthe given value (regardless of casing).\n\nFor example using values of:\n\n>   * FunctionCase of `lower_case`\n>   * FunctionPrefix of `pre_`\n>   * FunctionSuffix of `_post`\n>\n\nIdentifies and/or transforms function names as follows:\n\nBefore:\n\n    \n    \n    char MY_Function_string();\n    \n\nAfter:\n\n    \n    \n    char pre_my_function_string_post();\n    \n\n`GetConfigPerFile```Â¶\n\n    \n\nWhen true the check will look for the configuration for where an identifier is\ndeclared. Useful for when included header files use a different style. Default\nvalue is true.\n\n`GlobalConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure global constant names conform to the\nselected casing.\n\n`GlobalConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure global constant names will add the\nprefixed with the given value (regardless of casing).\n\n`GlobalConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for global constant names\nmatching this regular expression.\n\n`GlobalConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure global constant names will add the suffix\nwith the given value (regardless of casing).\n\n`GlobalConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * GlobalConstantCase of `lower_case`\n>   * GlobalConstantPrefix of `pre_`\n>   * GlobalConstantSuffix of `_post`\n>   * GlobalConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms global constant names as follows:\n\nBefore:\n\n    \n    \n    unsigned const MyConstGlobal_array[] = {1, 2, 3};\n    \n\nAfter:\n\n    \n    \n    unsigned const pre_myconstglobal_array_post[] = {1, 2, 3};\n    \n\n`GlobalConstantPointerCase```Â¶\n\n    \n\nWhen defined, the check will ensure global constant pointer names conform to\nthe selected casing.\n\n`GlobalConstantPointerPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure global constant pointer names will add the\nprefixed with the given value (regardless of casing).\n\n`GlobalConstantPointerIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for global constant pointer names\nmatching this regular expression.\n\n`GlobalConstantPointerSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure global constant pointer names will add the\nsuffix with the given value (regardless of casing).\n\n`GlobalConstantPointerHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * GlobalConstantPointerCase of `lower_case`\n>   * GlobalConstantPointerPrefix of `pre_`\n>   * GlobalConstantPointerSuffix of `_post`\n>   * GlobalConstantPointerHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms global constant pointer names as follows:\n\nBefore:\n\n    \n    \n    int *const MyConstantGlobalPointer = nullptr;\n    \n\nAfter:\n\n    \n    \n    int *const pre_myconstantglobalpointer_post = nullptr;\n    \n\n`GlobalFunctionCase```Â¶\n\n    \n\nWhen defined, the check will ensure global function names conform to the\nselected casing.\n\n`GlobalFunctionPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure global function names will add the\nprefixed with the given value (regardless of casing).\n\n`GlobalFunctionIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for global function names\nmatching this regular expression.\n\n`GlobalFunctionSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure global function names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * GlobalFunctionCase of `lower_case`\n>   * GlobalFunctionPrefix of `pre_`\n>   * GlobalFunctionSuffix of `_post`\n>\n\nIdentifies and/or transforms global function names as follows:\n\nBefore:\n\n    \n    \n    void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);\n    \n\nAfter:\n\n    \n    \n    void pre_global_function_post(int PARAMETER_1, int const CONST_parameter);\n    \n\n`GlobalPointerCase```Â¶\n\n    \n\nWhen defined, the check will ensure global pointer names conform to the\nselected casing.\n\n`GlobalPointerPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure global pointer names will add the prefixed\nwith the given value (regardless of casing).\n\n`GlobalPointerIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for global pointer names matching\nthis regular expression.\n\n`GlobalPointerSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure global pointer names will add the suffix\nwith the given value (regardless of casing).\n\n`GlobalPointerHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * GlobalPointerCase of `lower_case`\n>   * GlobalPointerPrefix of `pre_`\n>   * GlobalPointerSuffix of `_post`\n>   * GlobalPointerHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms global pointer names as follows:\n\nBefore:\n\n    \n    \n    int *GLOBAL3;\n    \n\nAfter:\n\n    \n    \n    int *pre_global3_post;\n    \n\n`GlobalVariableCase```Â¶\n\n    \n\nWhen defined, the check will ensure global variable names conform to the\nselected casing.\n\n`GlobalVariablePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure global variable names will add the\nprefixed with the given value (regardless of casing).\n\n`GlobalVariableIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for global variable names\nmatching this regular expression.\n\n`GlobalVariableSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure global variable names will add the suffix\nwith the given value (regardless of casing).\n\n`GlobalVariableHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * GlobalVariableCase of `lower_case`\n>   * GlobalVariablePrefix of `pre_`\n>   * GlobalVariableSuffix of `_post`\n>   * GlobalVariableHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms global variable names as follows:\n\nBefore:\n\n    \n    \n    int GLOBAL3;\n    \n\nAfter:\n\n    \n    \n    int pre_global3_post;\n    \n\n`IgnoreMainLikeFunctions```Â¶\n\n    \n\nWhen set to true functions that have a similar signature to `main` or `wmain`\nwonât enforce checks on the names of their parameters. Default value is\nfalse.\n\n`InlineNamespaceCase```Â¶\n\n    \n\nWhen defined, the check will ensure inline namespaces names conform to the\nselected casing.\n\n`InlineNamespacePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure inline namespaces names will add the\nprefixed with the given value (regardless of casing).\n\n`InlineNamespaceIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for inline namespaces names\nmatching this regular expression.\n\n`InlineNamespaceSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure inline namespaces names will add the\nsuffix with the given value (regardless of casing).\n\nFor example using values of:\n\n>   * InlineNamespaceCase of `lower_case`\n>   * InlineNamespacePrefix of `pre_`\n>   * InlineNamespaceSuffix of `_post`\n>\n\nIdentifies and/or transforms inline namespaces names as follows:\n\nBefore:\n\n    \n    \n    namespace FOO_NS {\n    inline namespace InlineNamespace {\n    ...\n    }\n    } // namespace FOO_NS\n    \n\nAfter:\n\n    \n    \n    namespace FOO_NS {\n    inline namespace pre_inlinenamespace_post {\n    ...\n    }\n    } // namespace FOO_NS\n    \n\n`LocalConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure local constant names conform to the\nselected casing.\n\n`LocalConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure local constant names will add the prefixed\nwith the given value (regardless of casing).\n\n`LocalConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for local constant names matching\nthis regular expression.\n\n`LocalConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure local constant names will add the suffix\nwith the given value (regardless of casing).\n\n`LocalConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * LocalConstantCase of `lower_case`\n>   * LocalConstantPrefix of `pre_`\n>   * LocalConstantSuffix of `_post`\n>   * LocalConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms local constant names as follows:\n\nBefore:\n\n    \n    \n    void foo() { int const local_Constant = 3; }\n    \n\nAfter:\n\n    \n    \n    void foo() { int const pre_local_constant_post = 3; }\n    \n\n`LocalConstantPointerCase```Â¶\n\n    \n\nWhen defined, the check will ensure local constant pointer names conform to\nthe selected casing.\n\n`LocalConstantPointerPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure local constant pointer names will add the\nprefixed with the given value (regardless of casing).\n\n`LocalConstantPointerIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for local constant pointer names\nmatching this regular expression.\n\n`LocalConstantPointerSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure local constant pointer names will add the\nsuffix with the given value (regardless of casing).\n\n`LocalConstantPointerHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * LocalConstantPointerCase of `lower_case`\n>   * LocalConstantPointerPrefix of `pre_`\n>   * LocalConstantPointerSuffix of `_post`\n>   * LocalConstantPointerHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms local constant pointer names as follows:\n\nBefore:\n\n    \n    \n    void foo() { int const *local_Constant = 3; }\n    \n\nAfter:\n\n    \n    \n    void foo() { int const *pre_local_constant_post = 3; }\n    \n\n`LocalPointerCase```Â¶\n\n    \n\nWhen defined, the check will ensure local pointer names conform to the\nselected casing.\n\n`LocalPointerPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure local pointer names will add the prefixed\nwith the given value (regardless of casing).\n\n`LocalPointerIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for local pointer names matching\nthis regular expression.\n\n`LocalPointerSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure local pointer names will add the suffix\nwith the given value (regardless of casing).\n\n`LocalPointerHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * LocalPointerCase of `lower_case`\n>   * LocalPointerPrefix of `pre_`\n>   * LocalPointerSuffix of `_post`\n>   * LocalPointerHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms local pointer names as follows:\n\nBefore:\n\n    \n    \n    void foo() { int *local_Constant; }\n    \n\nAfter:\n\n    \n    \n    void foo() { int *pre_local_constant_post; }\n    \n\n`LocalVariableCase```Â¶\n\n    \n\nWhen defined, the check will ensure local variable names conform to the\nselected casing.\n\n`LocalVariablePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure local variable names will add the prefixed\nwith the given value (regardless of casing).\n\n`LocalVariableIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for local variable names matching\nthis regular expression.\n\nFor example using values of:\n\n>   * LocalVariableCase of `CamelCase`\n>   * LocalVariableIgnoredRegexp of `\\w{1,2}`\n>\n\nWill exclude variables with a length less than or equal to 2 from the camel\ncase check applied to other variables.\n\n`LocalVariableSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure local variable names will add the suffix\nwith the given value (regardless of casing).\n\n`LocalVariableHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * LocalVariableCase of `lower_case`\n>   * LocalVariablePrefix of `pre_`\n>   * LocalVariableSuffix of `_post`\n>   * LocalVariableHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms local variable names as follows:\n\nBefore:\n\n    \n    \n    void foo() { int local_Constant; }\n    \n\nAfter:\n\n    \n    \n    void foo() { int pre_local_constant_post; }\n    \n\n`MacroDefinitionCase```Â¶\n\n    \n\nWhen defined, the check will ensure macro definitions conform to the selected\ncasing.\n\n`MacroDefinitionPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure macro definitions will add the prefixed\nwith the given value (regardless of casing).\n\n`MacroDefinitionIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for macro definitions matching\nthis regular expression.\n\n`MacroDefinitionSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure macro definitions will add the suffix with\nthe given value (regardless of casing).\n\nFor example using values of:\n\n>   * MacroDefinitionCase of `lower_case`\n>   * MacroDefinitionPrefix of `pre_`\n>   * MacroDefinitionSuffix of `_post`\n>\n\nIdentifies and/or transforms macro definitions as follows:\n\nBefore:\n\n    \n    \n    #define MY_MacroDefinition\n    \n\nAfter:\n\n    \n    \n    #define pre_my_macro_definition_post\n    \n\nNote: This will not warn on builtin macros or macros defined on the command\nline using the `-D` flag.\n\n`MemberCase```Â¶\n\n    \n\nWhen defined, the check will ensure member names conform to the selected\ncasing.\n\n`MemberPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure member names will add the prefixed with\nthe given value (regardless of casing).\n\n`MemberIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for member names matching this\nregular expression.\n\n`MemberSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure member names will add the suffix with the\ngiven value (regardless of casing).\n\n`MemberHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * MemberCase of `lower_case`\n>   * MemberPrefix of `pre_`\n>   * MemberSuffix of `_post`\n>   * MemberHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms member names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n      char MY_ConstMember_string[4];\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n      char pre_my_constmember_string_post[4];\n    }\n    \n\n`MethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure method names conform to the selected\ncasing.\n\n`MethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure method names will add the prefixed with\nthe given value (regardless of casing).\n\n`MethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for method names matching this\nregular expression.\n\n`MethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure method names will add the suffix with the\ngiven value (regardless of casing).\n\nFor example using values of:\n\n>   * MethodCase of `lower_case`\n>   * MethodPrefix of `pre_`\n>   * MethodSuffix of `_post`\n>\n\nIdentifies and/or transforms method names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n      char MY_Method_string();\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n      char pre_my_method_string_post();\n    }\n    \n\n`NamespaceCase```Â¶\n\n    \n\nWhen defined, the check will ensure namespace names conform to the selected\ncasing.\n\n`NamespacePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure namespace names will add the prefixed with\nthe given value (regardless of casing).\n\n`NamespaceIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for namespace names matching this\nregular expression.\n\n`NamespaceSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure namespace names will add the suffix with\nthe given value (regardless of casing).\n\nFor example using values of:\n\n>   * NamespaceCase of `lower_case`\n>   * NamespacePrefix of `pre_`\n>   * NamespaceSuffix of `_post`\n>\n\nIdentifies and/or transforms namespace names as follows:\n\nBefore:\n\n    \n    \n    namespace FOO_NS {\n    ...\n    }\n    \n\nAfter:\n\n    \n    \n    namespace pre_foo_ns_post {\n    ...\n    }\n    \n\n`ParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure parameter names conform to the selected\ncasing.\n\n`ParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure parameter names will add the prefixed with\nthe given value (regardless of casing).\n\n`ParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for parameter names matching this\nregular expression.\n\n`ParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure parameter names will add the suffix with\nthe given value (regardless of casing).\n\n`ParameterHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ParameterCase of `lower_case`\n>   * ParameterPrefix of `pre_`\n>   * ParameterSuffix of `_post`\n>   * ParameterHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms parameter names as follows:\n\nBefore:\n\n    \n    \n    void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);\n    \n\nAfter:\n\n    \n    \n    void GLOBAL_FUNCTION(int pre_parameter_post, int const CONST_parameter);\n    \n\n`ParameterPackCase```Â¶\n\n    \n\nWhen defined, the check will ensure parameter pack names conform to the\nselected casing.\n\n`ParameterPackPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure parameter pack names will add the prefixed\nwith the given value (regardless of casing).\n\n`ParameterPackIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for parameter pack names matching\nthis regular expression.\n\n`ParameterPackSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure parameter pack names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * ParameterPackCase of `lower_case`\n>   * ParameterPackPrefix of `pre_`\n>   * ParameterPackSuffix of `_post`\n>\n\nIdentifies and/or transforms parameter pack names as follows:\n\nBefore:\n\n    \n    \n    template <typename... TYPE_parameters> {\n      void FUNCTION(int... TYPE_parameters);\n    }\n    \n\nAfter:\n\n    \n    \n    template <typename... TYPE_parameters> {\n      void FUNCTION(int... pre_type_parameters_post);\n    }\n    \n\n`PointerParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure pointer parameter names conform to the\nselected casing.\n\n`PointerParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure pointer parameter names will add the\nprefixed with the given value (regardless of casing).\n\n`PointerParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for pointer parameter names\nmatching this regular expression.\n\n`PointerParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure pointer parameter names will add the\nsuffix with the given value (regardless of casing).\n\n`PointerParameterHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * PointerParameterCase of `lower_case`\n>   * PointerParameterPrefix of `pre_`\n>   * PointerParameterSuffix of `_post`\n>   * PointerParameterHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms pointer parameter names as follows:\n\nBefore:\n\n    \n    \n    void FUNCTION(int *PARAMETER);\n    \n\nAfter:\n\n    \n    \n    void FUNCTION(int *pre_parameter_post);\n    \n\n`PrivateMemberCase```Â¶\n\n    \n\nWhen defined, the check will ensure private member names conform to the\nselected casing.\n\n`PrivateMemberPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure private member names will add the prefixed\nwith the given value (regardless of casing).\n\n`PrivateMemberIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for private member names matching\nthis regular expression.\n\n`PrivateMemberSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure private member names will add the suffix\nwith the given value (regardless of casing).\n\n`PrivateMemberHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * PrivateMemberCase of `lower_case`\n>   * PrivateMemberPrefix of `pre_`\n>   * PrivateMemberSuffix of `_post`\n>   * PrivateMemberHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms private member names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    private:\n      int Member_Variable;\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    private:\n      int pre_member_variable_post;\n    }\n    \n\n`PrivateMethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure private method names conform to the\nselected casing.\n\n`PrivateMethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure private method names will add the prefixed\nwith the given value (regardless of casing).\n\n`PrivateMethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for private method names matching\nthis regular expression.\n\n`PrivateMethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure private method names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * PrivateMethodCase of `lower_case`\n>   * PrivateMethodPrefix of `pre_`\n>   * PrivateMethodSuffix of `_post`\n>\n\nIdentifies and/or transforms private method names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    private:\n      int Member_Method();\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    private:\n      int pre_member_method_post();\n    }\n    \n\n`ProtectedMemberCase```Â¶\n\n    \n\nWhen defined, the check will ensure protected member names conform to the\nselected casing.\n\n`ProtectedMemberPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure protected member names will add the\nprefixed with the given value (regardless of casing).\n\n`ProtectedMemberIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for protected member names\nmatching this regular expression.\n\n`ProtectedMemberSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure protected member names will add the suffix\nwith the given value (regardless of casing).\n\n`ProtectedMemberHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ProtectedMemberCase of `lower_case`\n>   * ProtectedMemberPrefix of `pre_`\n>   * ProtectedMemberSuffix of `_post`\n>   * ProtectedMemberHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms protected member names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    protected:\n      int Member_Variable;\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    protected:\n      int pre_member_variable_post;\n    }\n    \n\n`ProtectedMethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure protected method names conform to the\nselected casing.\n\n`ProtectedMethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure protected method names will add the\nprefixed with the given value (regardless of casing).\n\n`ProtectedMethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for protected method names\nmatching this regular expression.\n\n`ProtectedMethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure protected method names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * ProtectedMethodCase of `lower_case`\n>   * ProtectedMethodPrefix of `pre_`\n>   * ProtectedMethodSuffix of `_post`\n>\n\nIdentifies and/or transforms protect method names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    protected:\n      int Member_Method();\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    protected:\n      int pre_member_method_post();\n    }\n    \n\n`PublicMemberCase```Â¶\n\n    \n\nWhen defined, the check will ensure public member names conform to the\nselected casing.\n\n`PublicMemberPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure public member names will add the prefixed\nwith the given value (regardless of casing).\n\n`PublicMemberIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for public member names matching\nthis regular expression.\n\n`PublicMemberSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure public member names will add the suffix\nwith the given value (regardless of casing).\n\n`PublicMemberHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * PublicMemberCase of `lower_case`\n>   * PublicMemberPrefix of `pre_`\n>   * PublicMemberSuffix of `_post`\n>   * PublicMemberHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms public member names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    public:\n      int Member_Variable;\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    public:\n      int pre_member_variable_post;\n    }\n    \n\n`PublicMethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure public method names conform to the\nselected casing.\n\n`PublicMethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure public method names will add the prefixed\nwith the given value (regardless of casing).\n\n`PublicMethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for public method names matching\nthis regular expression.\n\n`PublicMethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure public method names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * PublicMethodCase of `lower_case`\n>   * PublicMethodPrefix of `pre_`\n>   * PublicMethodSuffix of `_post`\n>\n\nIdentifies and/or transforms public method names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    public:\n      int Member_Method();\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    public:\n      int pre_member_method_post();\n    }\n    \n\n`ScopedEnumConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure scoped enum constant names conform to the\nselected casing.\n\n`ScopedEnumConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure scoped enum constant names will add the\nprefixed with the given value (regardless of casing).\n\n`ScopedEnumConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for scoped enum constant names\nmatching this regular expression.\n\n`ScopedEnumConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure scoped enum constant names will add the\nsuffix with the given value (regardless of casing).\n\n`ScopedEnumConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * ScopedEnumConstantCase of `lower_case`\n>   * ScopedEnumConstantPrefix of `pre_`\n>   * ScopedEnumConstantSuffix of `_post`\n>   * ScopedEnumConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms enumeration constant names as follows:\n\nBefore:\n\n    \n    \n    enum class FOO { One, Two, Three };\n    \n\nAfter:\n\n    \n    \n    enum class FOO { pre_One_post, pre_Two_post, pre_Three_post };\n    \n\n`StaticConstantCase```Â¶\n\n    \n\nWhen defined, the check will ensure static constant names conform to the\nselected casing.\n\n`StaticConstantPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure static constant names will add the\nprefixed with the given value (regardless of casing).\n\n`StaticConstantIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for static constant names\nmatching this regular expression.\n\n`StaticConstantSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure static constant names will add the suffix\nwith the given value (regardless of casing).\n\n`StaticConstantHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * StaticConstantCase of `lower_case`\n>   * StaticConstantPrefix of `pre_`\n>   * StaticConstantSuffix of `_post`\n>   * StaticConstantHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms static constant names as follows:\n\nBefore:\n\n    \n    \n    static unsigned const MyConstStatic_array[] = {1, 2, 3};\n    \n\nAfter:\n\n    \n    \n    static unsigned const pre_myconststatic_array_post[] = {1, 2, 3};\n    \n\n`StaticVariableCase```Â¶\n\n    \n\nWhen defined, the check will ensure static variable names conform to the\nselected casing.\n\n`StaticVariablePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure static variable names will add the\nprefixed with the given value (regardless of casing).\n\n`StaticVariableIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for static variable names\nmatching this regular expression.\n\n`StaticVariableSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure static variable names will add the suffix\nwith the given value (regardless of casing).\n\n`StaticVariableHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * StaticVariableCase of `lower_case`\n>   * StaticVariablePrefix of `pre_`\n>   * StaticVariableSuffix of `_post`\n>   * StaticVariableHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms static variable names as follows:\n\nBefore:\n\n    \n    \n    static unsigned MyStatic_array[] = {1, 2, 3};\n    \n\nAfter:\n\n    \n    \n    static unsigned pre_mystatic_array_post[] = {1, 2, 3};\n    \n\n`StructCase```Â¶\n\n    \n\nWhen defined, the check will ensure struct names conform to the selected\ncasing.\n\n`StructPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure struct names will add the prefixed with\nthe given value (regardless of casing).\n\n`StructIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for struct names matching this\nregular expression.\n\n`StructSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure struct names will add the suffix with the\ngiven value (regardless of casing).\n\nFor example using values of:\n\n>   * StructCase of `lower_case`\n>   * StructPrefix of `pre_`\n>   * StructSuffix of `_post`\n>\n\nIdentifies and/or transforms struct names as follows:\n\nBefore:\n\n    \n    \n    struct FOO {\n      FOO();\n      ~FOO();\n    };\n    \n\nAfter:\n\n    \n    \n    struct pre_foo_post {\n      pre_foo_post();\n      ~pre_foo_post();\n    };\n    \n\n`TemplateParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure template parameter names conform to the\nselected casing.\n\n`TemplateParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure template parameter names will add the\nprefixed with the given value (regardless of casing).\n\n`TemplateParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for template parameter names\nmatching this regular expression.\n\n`TemplateParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure template parameter names will add the\nsuffix with the given value (regardless of casing).\n\nFor example using values of:\n\n>   * TemplateParameterCase of `lower_case`\n>   * TemplateParameterPrefix of `pre_`\n>   * TemplateParameterSuffix of `_post`\n>\n\nIdentifies and/or transforms template parameter names as follows:\n\nBefore:\n\n    \n    \n    template <typename T> class Foo {};\n    \n\nAfter:\n\n    \n    \n    template <typename pre_t_post> class Foo {};\n    \n\n`TemplateTemplateParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure template template parameter names conform\nto the selected casing.\n\n`TemplateTemplateParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure template template parameter names will add\nthe prefixed with the given value (regardless of casing).\n\n`TemplateTemplateParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for template template parameter\nnames matching this regular expression.\n\n`TemplateTemplateParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure template template parameter names will add\nthe suffix with the given value (regardless of casing).\n\nFor example using values of:\n\n>   * TemplateTemplateParameterCase of `lower_case`\n>   * TemplateTemplateParameterPrefix of `pre_`\n>   * TemplateTemplateParameterSuffix of `_post`\n>\n\nIdentifies and/or transforms template template parameter names as follows:\n\nBefore:\n\n    \n    \n    template <template <typename> class TPL_parameter, int COUNT_params,\n              typename... TYPE_parameters>\n    \n\nAfter:\n\n    \n    \n    template <template <typename> class pre_tpl_parameter_post, int COUNT_params,\n              typename... TYPE_parameters>\n    \n\n`TypeAliasCase```Â¶\n\n    \n\nWhen defined, the check will ensure type alias names conform to the selected\ncasing.\n\n`TypeAliasPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure type alias names will add the prefixed\nwith the given value (regardless of casing).\n\n`TypeAliasIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for type alias names matching\nthis regular expression.\n\n`TypeAliasSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure type alias names will add the suffix with\nthe given value (regardless of casing).\n\nFor example using values of:\n\n>   * TypeAliasCase of `lower_case`\n>   * TypeAliasPrefix of `pre_`\n>   * TypeAliasSuffix of `_post`\n>\n\nIdentifies and/or transforms type alias names as follows:\n\nBefore:\n\n    \n    \n    using MY_STRUCT_TYPE = my_structure;\n    \n\nAfter:\n\n    \n    \n    using pre_my_struct_type_post = my_structure;\n    \n\n`TypedefCase```Â¶\n\n    \n\nWhen defined, the check will ensure typedef names conform to the selected\ncasing.\n\n`TypedefPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure typedef names will add the prefixed with\nthe given value (regardless of casing).\n\n`TypedefIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for typedef names matching this\nregular expression.\n\n`TypedefSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure typedef names will add the suffix with the\ngiven value (regardless of casing).\n\nFor example using values of:\n\n>   * TypedefCase of `lower_case`\n>   * TypedefPrefix of `pre_`\n>   * TypedefSuffix of `_post`\n>\n\nIdentifies and/or transforms typedef names as follows:\n\nBefore:\n\n    \n    \n    typedef int MYINT;\n    \n\nAfter:\n\n    \n    \n    typedef int pre_myint_post;\n    \n\n`TypeTemplateParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure type template parameter names conform to\nthe selected casing.\n\n`TypeTemplateParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure type template parameter names will add the\nprefixed with the given value (regardless of casing).\n\n`TypeTemplateParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for type template names matching\nthis regular expression.\n\n`TypeTemplateParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure type template parameter names will add the\nsuffix with the given value (regardless of casing).\n\nFor example using values of:\n\n>   * TypeTemplateParameterCase of `lower_case`\n>   * TypeTemplateParameterPrefix of `pre_`\n>   * TypeTemplateParameterSuffix of `_post`\n>\n\nIdentifies and/or transforms type template parameter names as follows:\n\nBefore:\n\n    \n    \n    template <template <typename> class TPL_parameter, int COUNT_params,\n              typename... TYPE_parameters>\n    \n\nAfter:\n\n    \n    \n    template <template <typename> class TPL_parameter, int COUNT_params,\n              typename... pre_type_parameters_post>\n    \n\n`UnionCase```Â¶\n\n    \n\nWhen defined, the check will ensure union names conform to the selected\ncasing.\n\n`UnionPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure union names will add the prefixed with the\ngiven value (regardless of casing).\n\n`UnionIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for union names matching this\nregular expression.\n\n`UnionSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure union names will add the suffix with the\ngiven value (regardless of casing).\n\nFor example using values of:\n\n>   * UnionCase of `lower_case`\n>   * UnionPrefix of `pre_`\n>   * UnionSuffix of `_post`\n>\n\nIdentifies and/or transforms union names as follows:\n\nBefore:\n\n    \n    \n    union FOO {\n      int a;\n      char b;\n    };\n    \n\nAfter:\n\n    \n    \n    union pre_foo_post {\n      int a;\n      char b;\n    };\n    \n\n`ValueTemplateParameterCase```Â¶\n\n    \n\nWhen defined, the check will ensure value template parameter names conform to\nthe selected casing.\n\n`ValueTemplateParameterPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure value template parameter names will add\nthe prefixed with the given value (regardless of casing).\n\n`ValueTemplateParameterIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for value template parameter\nnames matching this regular expression.\n\n`ValueTemplateParameterSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure value template parameter names will add\nthe suffix with the given value (regardless of casing).\n\nFor example using values of:\n\n>   * ValueTemplateParameterCase of `lower_case`\n>   * ValueTemplateParameterPrefix of `pre_`\n>   * ValueTemplateParameterSuffix of `_post`\n>\n\nIdentifies and/or transforms value template parameter names as follows:\n\nBefore:\n\n    \n    \n    template <template <typename> class TPL_parameter, int COUNT_params,\n              typename... TYPE_parameters>\n    \n\nAfter:\n\n    \n    \n    template <template <typename> class TPL_parameter, int pre_count_params_post,\n              typename... TYPE_parameters>\n    \n\n`VariableCase```Â¶\n\n    \n\nWhen defined, the check will ensure variable names conform to the selected\ncasing.\n\n`VariablePrefix```Â¶\n\n    \n\nWhen defined, the check will ensure variable names will add the prefixed with\nthe given value (regardless of casing).\n\n`VariableIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for variable names matching this\nregular expression.\n\n`VariableSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure variable names will add the suffix with\nthe given value (regardless of casing).\n\n`VariableHungarianPrefix```Â¶\n\n    \n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\nFor example using values of:\n\n>   * VariableCase of `lower_case`\n>   * VariablePrefix of `pre_`\n>   * VariableSuffix of `_post`\n>   * VariableHungarianPrefix of `On`\n>\n\nIdentifies and/or transforms variable names as follows:\n\nBefore:\n\n    \n    \n    unsigned MyVariable;\n    \n\nAfter:\n\n    \n    \n    unsigned pre_myvariable_post;\n    \n\n`VirtualMethodCase```Â¶\n\n    \n\nWhen defined, the check will ensure virtual method names conform to the\nselected casing.\n\n`VirtualMethodPrefix```Â¶\n\n    \n\nWhen defined, the check will ensure virtual method names will add the prefixed\nwith the given value (regardless of casing).\n\n`VirtualMethodIgnoredRegexp```Â¶\n\n    \n\nIdentifier naming checks wonât be enforced for virtual method names matching\nthis regular expression.\n\n`VirtualMethodSuffix```Â¶\n\n    \n\nWhen defined, the check will ensure virtual method names will add the suffix\nwith the given value (regardless of casing).\n\nFor example using values of:\n\n>   * VirtualMethodCase of `lower_case`\n>   * VirtualMethodPrefix of `pre_`\n>   * VirtualMethodSuffix of `_post`\n>\n\nIdentifies and/or transforms virtual method names as follows:\n\nBefore:\n\n    \n    \n    class Foo {\n    public:\n      virtual int MemberFunction();\n    }\n    \n\nAfter:\n\n    \n    \n    class Foo {\n    public:\n      virtual int pre_member_function_post();\n    }\n    \n\n## The default mapping table of Hungarian NotationÂ¶\n\nIn Hungarian notation, a variable name starts with a group of lower-case\nletters which are mnemonics for the type or purpose of that variable, followed\nby whatever name the programmer has chosen; this last part is sometimes\ndistinguished as the given name. The first character of the given name can be\ncapitalized to separate it from the type indicators (see also CamelCase).\nOtherwise the case of this character denotes scope.\n\nThe following table is the default mapping table of Hungarian Notation which\nmaps Decl to its prefix string. You can also have your own style in config\nfile.\n\nPrimitive Types | Microsoft data types  \n---|---  \nType | Prefix | Type | Prefix | Type | Prefix  \nint8_t | i8 | signed int | si | BOOL | b  \nint16_t | i16 | signed short | ss | BOOLEAN | b  \nint32_t | i32 | signed short int | ssi | BYTE | by  \nint64_t | i64 | signed long long int | slli | CHAR | c  \nuint8_t | u8 | signed long long | sll | UCHAR | uc  \nuint16_t | u16 | signed long int | sli | SHORT | s  \nuint32_t | u32 | signed long | sl | USHORT | us  \nuint64_t | u64 | signed | s | WORD | w  \nchar8_t | c8 | unsigned long long int | ulli | DWORD | dw  \nchar16_t | c16 | unsigned long long | ull | DWORD32 | dw32  \nchar32_t | c32 | unsigned long int | uli | DWORD64 | dw64  \nfloat | f | unsigned long | ul | LONG | l  \ndouble | d | unsigned short int | usi | ULONG | ul  \nchar | c | unsigned short | us | ULONG32 | ul32  \nbool | b | unsigned int | ui | ULONG64 | ul64  \n_Bool | b | unsigned | u | ULONGLONG | ull  \nint | i | long long int | lli | HANDLE | h  \nsize_t | n | long double | ld | INT | i  \nshort | s | long long | ll | INT8 | i8  \nsigned | i | long int | li | INT16 | i16  \nunsigned | u | long | l | INT32 | i32  \nlong | l | ptrdiff_t | p | INT64 | i64  \nlong long | ll |  |  | UINT | ui  \nunsigned long | ul |  |  | UINT8 | u8  \nlong double | ld |  |  | UINT16 | u16  \nptrdiff_t | p |  |  | UINT32 | u32  \nwchar_t | wc |  |  | UINT64 | u64  \nshort int | si |  |  | PVOID | p  \nshort | s |  |  |  |  \n  \n**There are more trivial options for Hungarian Notation:**\n\n**HungarianNotation.General.***\n\n    Options are not belonging to any specific Decl.\n**HungarianNotation.CString.***\n\n    Options for NULL-terminated string.\n**HungarianNotation.DerivedType.***\n\n    Options for derived types.\n**HungarianNotation.PrimitiveType.***\n\n    Options for primitive types.\n**HungarianNotation.UserDefinedType.***\n\n    Options for user-defined types.\n\n## Options for Hungarian NotationÂ¶\n\n  * `HungarianNotation.General.TreatStructAsClass`\n  * `HungarianNotation.DerivedType.Array`\n  * `HungarianNotation.DerivedType.Pointer`\n  * `HungarianNotation.DerivedType.FunctionPointer`\n  * `HungarianNotation.CString.CharPrinter`\n  * `HungarianNotation.CString.CharArray`\n  * `HungarianNotation.CString.WideCharPrinter`\n  * `HungarianNotation.CString.WideCharArray`\n  * `HungarianNotation.PrimitiveType.*`\n  * `HungarianNotation.UserDefinedType.*`\n\n`HungarianNotation.General.TreatStructAsClass```Â¶\n\n    \n\nWhen defined, the check will treat naming of struct as a class. The default\nvalue is false.\n\n`HungarianNotation.DerivedType.Array```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is a.\n\n`HungarianNotation.DerivedType.Pointer```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is p.\n\n`HungarianNotation.DerivedType.FunctionPointer```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is fn.\n\nBefore:\n\n    \n    \n    // Array\n    int DataArray[2] = {0};\n    \n    // Pointer\n    void *DataBuffer = NULL;\n    \n    // FunctionPointer\n    typedef void (*FUNC_PTR)();\n    FUNC_PTR FuncPtr = NULL;\n    \n\nAfter:\n\n    \n    \n    // Array\n    int aDataArray[2] = {0};\n    \n    // Pointer\n    void *pDataBuffer = NULL;\n    \n    // FunctionPointer\n    typedef void (*FUNC_PTR)();\n    FUNC_PTR fnFuncPtr = NULL;\n    \n\n`HungarianNotation.CString.CharPrinter```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is sz.\n\n`HungarianNotation.CString.CharArray```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is sz.\n\n`HungarianNotation.CString.WideCharPrinter```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is wsz.\n\n`HungarianNotation.CString.WideCharArray```Â¶\n\n    \n\nWhen defined, the check will ensure variable name will add the prefix with the\ngiven string. The default prefix is wsz.\n\nBefore:\n\n    \n    \n    // CharPrinter\n    const char *NamePtr = \"Name\";\n    \n    // CharArray\n    const char NameArray[] = \"Name\";\n    \n    // WideCharPrinter\n    const wchar_t *WideNamePtr = L\"Name\";\n    \n    // WideCharArray\n    const wchar_t WideNameArray[] = L\"Name\";\n    \n\nAfter:\n\n    \n    \n    // CharPrinter\n    const char *szNamePtr = \"Name\";\n    \n    // CharArray\n    const char szNameArray[] = \"Name\";\n    \n    // WideCharPrinter\n    const wchar_t *wszWideNamePtr = L\"Name\";\n    \n    // WideCharArray\n    const wchar_t wszWideNameArray[] = L\"Name\";\n    \n\n`HungarianNotation.PrimitiveType.*```Â¶\n\n    \n\nWhen defined, the check will ensure variable name of involved primitive types\nwill add the prefix with the given string. The default prefixes are defined in\nthe default mapping table.\n\n`HungarianNotation.UserDefinedType.*```Â¶\n\n    \n\nWhen defined, the check will ensure variable name of involved primitive types\nwill add the prefix with the given string. The default prefixes are defined in\nthe default mapping table.\n\nBefore:\n\n    \n    \n    int8_t   ValueI8      = 0;\n    int16_t  ValueI16     = 0;\n    int32_t  ValueI32     = 0;\n    int64_t  ValueI64     = 0;\n    uint8_t  ValueU8      = 0;\n    uint16_t ValueU16     = 0;\n    uint32_t ValueU32     = 0;\n    uint64_t ValueU64     = 0;\n    float    ValueFloat   = 0.0;\n    double   ValueDouble  = 0.0;\n    ULONG    ValueUlong   = 0;\n    DWORD    ValueDword   = 0;\n    \n\nAfter:\n\n    \n    \n    int8_t   i8ValueI8    = 0;\n    int16_t  i16ValueI16  = 0;\n    int32_t  i32ValueI32  = 0;\n    int64_t  i64ValueI64  = 0;\n    uint8_t  u8ValueU8    = 0;\n    uint16_t u16ValueU16  = 0;\n    uint32_t u32ValueU32  = 0;\n    uint64_t u64ValueU64  = 0;\n    float    fValueFloat  = 0.0;\n    double   dValueDouble = 0.0;\n    ULONG    ulValueUlong = 0;\n    DWORD    dwValueDword = 0;",
                "disable": false
            },
            {
                "real_name": "readability-implicit-bool-conversion",
                "display_name": "readability-implicit-bool-conversion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-implicit-bool-conversionÂ¶\n\nThis check can be used to find implicit conversions between built-in types and\nbooleans. Depending on use case, it may simply help with readability of the\ncode, or in some cases, point to potential bugs which remain unnoticed due to\nimplicit conversions.\n\nThe following is a real-world example of bug which was hiding behind implicit\n`bool` conversion:\n\n    \n    \n    class Foo {\n      int m_foo;\n    \n    public:\n      void setFoo(bool foo) { m_foo = foo; } // warning: implicit conversion bool -> int\n      int getFoo() { return m_foo; }\n    };\n    \n    void use(Foo& foo) {\n      bool value = foo.getFoo(); // warning: implicit conversion int -> bool\n    }\n    \n\nThis code is the result of unsuccessful refactoring, where type of `m_foo`\nchanged from `bool` to `int`. The programmer forgot to change all occurrences\nof `bool`, and the remaining code is no longer correct, yet it still compiles\nwithout any visible warnings.\n\nIn addition to issuing warnings, fix-it hints are provided to help solve the\nreported issues. This can be used for improving readability of code, for\nexample:\n\n    \n    \n    void conversionsToBool() {\n      float floating;\n      bool boolean = floating;\n      // ^ propose replacement: bool boolean = floating != 0.0f;\n    \n      int integer;\n      if (integer) {}\n      // ^ propose replacement: if (integer != 0) {}\n    \n      int* pointer;\n      if (!pointer) {}\n      // ^ propose replacement: if (pointer == nullptr) {}\n    \n      while (1) {}\n      // ^ propose replacement: while (true) {}\n    }\n    \n    void functionTakingInt(int param);\n    \n    void conversionsFromBool() {\n      bool boolean;\n      functionTakingInt(boolean);\n      // ^ propose replacement: functionTakingInt(static_cast<int>(boolean));\n    \n      functionTakingInt(true);\n      // ^ propose replacement: functionTakingInt(1);\n    }\n    \n\nIn general, the following conversion types are checked:\n\n  * integer expression/literal to boolean (conversion from a single bit bitfield to boolean is explicitly allowed, since thereâs no ambiguity / information loss in this case),\n  * floating expression/literal to boolean,\n  * pointer/pointer to member/`nullptr`/`NULL` to boolean,\n  * boolean expression/literal to integer (conversion from boolean to a single bit bitfield is explicitly allowed),\n  * boolean expression/literal to floating.\n\nThe rules for generating fix-it hints are:\n\n  * in case of conversions from other built-in type to bool, an explicit comparison is proposed to make it clear what exactly is being compared:\n    * `bool boolean = floating;` is changed to `bool boolean = floating == 0.0f;`,\n    * for other types, appropriate literals are used (`0`, `0u`, `0.0f`, `0.0`, `nullptr`),\n  * in case of negated expressions conversion to bool, the proposed replacement with comparison is simplified:\n    * `if (!pointer)` is changed to `if (pointer == nullptr)`,\n  * in case of conversions from bool to other built-in types, an explicit `static_cast` is proposed to make it clear that a conversion is taking place:\n    * `int integer = boolean;` is changed to `int integer = static_cast<int>(boolean);`,\n  * if the conversion is performed on type literals, an equivalent literal is proposed, according to what type is actually expected, for example:\n    * `functionTakingBool(0);` is changed to `functionTakingBool(false);`,\n    * `functionTakingInt(true);` is changed to `functionTakingInt(1);`,\n    * for other types, appropriate literals are used (`false`, `true`, `0`, `1`, `0u`, `1u`, `0.0f`, `1.0f`, `0.0`, `1.0f`).\n\nSome additional accommodations are made for pre-C++11 dialects:\n\n  * `false` literal conversion to pointer is detected,\n  * instead of `nullptr` literal, `0` is proposed as replacement.\n\nOccurrences of implicit conversions inside macros and template instantiations\nare deliberately ignored, as it is not clear how to deal with such cases.\n\n## OptionsÂ¶\n\n`AllowIntegerConditions```Â¶\n\n    \n\nWhen true, the check will allow conditional integer conversions. Default is\nfalse.\n\n`AllowPointerConditions```Â¶\n\n    \n\nWhen true, the check will allow conditional pointer conversions. Default is\nfalse.",
                "disable": false
            },
            {
                "real_name": "readability-inconsistent-declaration-parameter-name",
                "display_name": "readability-inconsistent-declaration-parameter-name",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-inconsistent-declaration-parameter-nameÂ¶\n\nFind function declarations which differ in parameter names.\n\nExample:\n\n    \n    \n    // in foo.hpp:\n    void foo(int a, int b, int c);\n    \n    // in foo.cpp:\n    void foo(int d, int e, int f); // warning\n    \n\nThis check should help to enforce consistency in large projects, where it\noften happens that a definition of function is refactored, changing the\nparameter names, but its declaration in header file is not updated. With this\ncheck, we can easily find and correct such inconsistencies, keeping\ndeclaration and definition always in sync.\n\nUnnamed parameters are allowed and are not taken into account when comparing\nfunction declarations, for example:\n\n    \n    \n    void foo(int a);\n    void foo(int); // no warning\n    \n\nOne name is also allowed to be a case-insensitive prefix/suffix of the other:\n\n    \n    \n    void foo(int count);\n    void foo(int count_input) { // no warning\n      int count = adjustCount(count_input);\n    }\n    \n\nTo help with refactoring, in some cases fix-it hints are generated to align\nparameter names to a single naming convention. This works with the assumption\nthat the function definition is the most up-to-date version, as it directly\nreferences parameter names in its body. Example:\n\n    \n    \n    void foo(int a); // warning and fix-it hint (replace \"a\" to \"b\")\n    int foo(int b) { return b + 2; } // definition with use of \"b\"\n    \n\nIn the case of multiple redeclarations or function template specializations, a\nwarning is issued for every redeclaration or specialization inconsistent with\nthe definition or the first declaration seen in a translation unit.\n\n`IgnoreMacros```Â¶\n\n    \n\nIf this option is set to true (default is true), the check will not warn about\nnames declared inside macros.\n\n`Strict```Â¶\n\n    \n\nIf this option is set to true (default is false), then names must match\nexactly (or be absent).",
                "disable": false
            },
            {
                "real_name": "readability-isolate-declaration",
                "display_name": "readability-isolate-declaration",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-isolate-declarationÂ¶\n\nDetects local variable declarations declaring more than one variable and tries\nto refactor the code to one statement per declaration.\n\nThe automatic code-transformation will use the same indentation as the\noriginal for every created statement and add a line break after each\nstatement. It keeps the order of the variable declarations consistent, too.\n\n    \n    \n    void f() {\n      int * pointer = nullptr, value = 42, * const const_ptr = &value;\n      // This declaration will be diagnosed and transformed into:\n      // int * pointer = nullptr;\n      // int value = 42;\n      // int * const const_ptr = &value;\n    }\n    \n\nThe check excludes places where it is necessary or common to declare multiple\nvariables in one statement and there is no other way supported in the\nlanguage. Please note that structured bindings are not considered.\n\n    \n    \n    // It is not possible to transform this declaration and doing the declaration\n    // before the loop will increase the scope of the variable 'Begin' and 'End'\n    // which is undesirable.\n    for (int Begin = 0, End = 100; Begin < End; ++Begin);\n    if (int Begin = 42, Result = some_function(Begin); Begin == Result);\n    \n    // It is not possible to transform this declaration because the result is\n    // not functionality preserving as 'j' and 'k' would not be part of the\n    // 'if' statement anymore.\n    if (SomeCondition())\n      int i = 42, j = 43, k = function(i,j);\n    \n\n## LimitationsÂ¶\n\nGlobal variables and member variables are excluded.\n\nThe check currently does not support the automatic transformation of member-\npointer-types.\n\n    \n    \n    struct S {\n      int a;\n      const int b;\n      void f() {}\n    };\n    \n    void f() {\n      // Only a diagnostic message is emitted\n      int S::*p = &S::a, S::*const q = &S::a;\n    }\n    \n\nFurthermore, the transformation is very cautious when it detects various kinds\nof macros or preprocessor directives in the range of the statement. In this\ncase the transformation will not happen to avoid unexpected side-effects due\nto macros.\n\n    \n    \n    #define NULL 0\n    #define MY_NICE_TYPE int **\n    #define VAR_NAME(name) name##__LINE__\n    #define A_BUNCH_OF_VARIABLES int m1 = 42, m2 = 43, m3 = 44;\n    \n    void macros() {\n      int *p1 = NULL, *p2 = NULL;\n      // Will be transformed to\n      // int *p1 = NULL;\n      // int *p2 = NULL;\n    \n      MY_NICE_TYPE p3, v1, v2;\n      // Won't be transformed, but a diagnostic is emitted.\n    \n      int VAR_NAME(v3),\n          VAR_NAME(v4),\n          VAR_NAME(v5);\n      // Won't be transformed, but a diagnostic is emitted.\n    \n      A_BUNCH_OF_VARIABLES\n      // Won't be transformed, but a diagnostic is emitted.\n    \n      int Unconditional,\n    #if CONFIGURATION\n          IfConfigured = 42,\n    #else\n          IfConfigured = 0;\n    #endif\n      // Won't be transformed, but a diagnostic is emitted.\n    }",
                "disable": false
            },
            {
                "real_name": "readability-magic-numbers",
                "display_name": "readability-magic-numbers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-magic-numbersÂ¶\n\nDetects magic numbers, integer or floating point literals that are embedded in\ncode and not introduced via constants or symbols.\n\nMany coding guidelines advise replacing the magic values with symbolic\nconstants to improve readability. Here are a few references:\n\n>   * [Rule ES.45: Avoid âmagic constantsâ; use symbolic constants in C++\n> Core\n> Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-\n> magic)\n>   * [Rule 5.1.1 Use symbolic names instead of literal values in code in High\n> Integrity C++](http://www.codingstandard.com/rule/5-1-1-use-symbolic-names-\n> instead-of-literal-values-in-code/)\n>   * Item 17 in âC++ Coding Standards: 101 Rules, Guidelines and Best\n> Practicesâ by Herb Sutter and Andrei Alexandrescu\n>   * Chapter 17 in âClean Code - A handbook of agile software\n> craftsmanship.â by Robert C. Martin\n>   * Rule 20701 in âTRAIN REAL TIME DATA PROTOCOL Coding Rulesâ by Armin-\n> Hagen Weiss, Bombardier\n>   * <http://wiki.c2.com/?MagicNumber>\n>\n\nExamples of magic values:\n\n    \n    \n    double circleArea = 3.1415926535 * radius * radius;\n    \n    double totalCharge = 1.08 * itemPrice;\n    \n    int getAnswer() {\n       return -3; // FILENOTFOUND\n    }\n    \n    for (int mm = 1; mm <= 12; ++mm) {\n       std::cout << month[mm] << '\\n';\n    }\n    \n\nExample with magic values refactored:\n\n    \n    \n    double circleArea = M_PI * radius * radius;\n    \n    const double TAX_RATE = 0.08;  // or make it variable and read from a file\n    \n    double totalCharge = (1.0 + TAX_RATE) * itemPrice;\n    \n    int getAnswer() {\n       return E_FILE_NOT_FOUND;\n    }\n    \n    for (int mm = 1; mm <= MONTHS_IN_A_YEAR; ++mm) {\n       std::cout << month[mm] << '\\n';\n    }\n    \n\nFor integral literals by default only 0 and 1 (and -1) integer values are\naccepted without a warning. This can be overridden with the\n`IgnoredIntegerValues` option. Negative values are accepted if their absolute\nvalue is present in the `IgnoredIntegerValues` list.\n\nAs a special case for integral values, all powers of two can be accepted\nwithout warning by enabling the `IgnorePowersOf2IntegerValues` option.\n\nFor floating point literals by default the 0.0 floating point value is\naccepted without a warning. The set of ignored floating point literals can be\nconfigured using the `IgnoredFloatingPointValues` option. For each value in\nthat set, the given string value is converted to a floating-point value\nrepresentation used by the target architecture. If a floating-point literal\nvalue compares equal to one of the converted values, then that literal is not\ndiagnosed by this check. Because floating-point equality is used to determine\nwhether to diagnose or not, the user needs to be aware of the details of\nfloating-point representations for any values that cannot be precisely\nrepresented for their target architecture.\n\nFor each value in the `IgnoredFloatingPointValues` set, both the single-\nprecision form and double-precision form are accepted (for example, if 3.14 is\nin the set, neither 3.14f nor 3.14 will produce a warning).\n\nScientific notation is supported for both source code input and option.\nAlternatively, the check for the floating point numbers can be disabled for\nall floating point values by enabling the `IgnoreAllFloatingPointValues`\noption.\n\nSince values 0 and 0.0 are so common as the base counter of loops, or\ninitialization values for sums, they are always accepted without warning, even\nif not present in the respective ignored values list.\n\n## OptionsÂ¶\n\n`IgnoredIntegerValues```Â¶\n\n    \n\nSemicolon-separated list of magic positive integers that will be accepted\nwithout a warning. Default values are {1, 2, 3, 4}, and 0 is accepted\nunconditionally.\n\n`IgnorePowersOf2IntegerValues```Â¶\n\n    \n\nBoolean value indicating whether to accept all powers-of-two integer values\nwithout warning. Default value is false.\n\n`IgnoredFloatingPointValues```Â¶\n\n    \n\nSemicolon-separated list of magic positive floating point values that will be\naccepted without a warning. Default values are {1.0, 100.0} and 0.0 is\naccepted unconditionally.\n\n`IgnoreAllFloatingPointValues```Â¶\n\n    \n\nBoolean value indicating whether to accept all floating point values without\nwarning. Default value is false.\n\n`IgnoreBitFieldsWidths```Â¶\n\n    \n\nBoolean value indicating whether to accept magic numbers as bit field widths\nwithout warning. This is useful for example for register definitions which are\ngenerated from hardware specifications. Default value is true.",
                "disable": false
            },
            {
                "real_name": "readability-make-member-function-const",
                "display_name": "readability-make-member-function-const",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-make-member-function-constÂ¶\n\nFinds non-static member functions that can be made `const` because the\nfunctions donât use `this` in a non-const way.\n\nThis check tries to annotate methods according to [logical\nconstness](https://isocpp.org/wiki/faq/const-correctness#logical-vs-physical-\nstate) (not physical constness). Therefore, it will suggest to add a `const`\nqualifier to a non-const method only if this method does something that is\nalready possible though the public interface on a `const` pointer to the\nobject:\n\n  * reading a public member variable\n  * calling a public const-qualified member function\n  * returning const-qualified `this`\n  * passing const-qualified `this` as a parameter.\n\nThis check will also suggest to add a `const` qualifier to a non-const method\nif this method uses private data and functions in a limited number of ways\nwhere logical constness and physical constness coincide:\n\n  * reading a member variable of builtin type\n\nSpecifically, this check will not suggest to add a `const` to a non-const\nmethod if the method reads a private member variable of pointer type because\nthat allows to modify the pointee which might not preserve logical constness.\nFor the same reason, it does not allow to call private member functions or\nmember functions on private member variables.\n\nIn addition, this check ignores functions that\n\n  * are declared `virtual`\n  * contain a `const_cast`\n  * are templated or part of a class template\n  * have an empty body\n  * do not (implicitly) use `this` at all (see [readability-convert-member-functions-to-static](../readability/convert-member-functions-to-static.html)).\n\nThe following real-world examples will be preserved by the check:\n\n    \n    \n    class E1 {\n      Pimpl &getPimpl() const;\n    public:\n      int &get() {\n        // Calling a private member function disables this check.\n        return getPimpl()->i;\n      }\n      ...\n    };\n    \n    class E2 {\n    public:\n      const int *get() const;\n      // const_cast disables this check.\n      S *get() {\n        return const_cast<int*>(const_cast<const C*>(this)->get());\n      }\n      ...\n    };\n    \n\nAfter applying modifications as suggested by the check, running the check\nagain might find more opportunities to mark member functions `const`.",
                "disable": false
            },
            {
                "real_name": "readability-misleading-indentation",
                "display_name": "readability-misleading-indentation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-misleading-indentationÂ¶\n\nCorrect indentation helps to understand code. Mismatch of the syntactical\nstructure and the indentation of the code may hide serious problems. Missing\nbraces can also make it significantly harder to read the code, therefore it is\nimportant to use braces.\n\nThe way to avoid dangling else is to always check that an `else` belongs to\nthe `if` that begins in the same column.\n\nYou can omit braces when your inner part of e.g. an `if` statement has only\none statement in it. Although in that case you should begin the next statement\nin the same column with the `if`.\n\nExamples:\n\n    \n    \n    // Dangling else:\n    if (cond1)\n      if (cond2)\n        foo1();\n    else\n      foo2();  // Wrong indentation: else belongs to if(cond2) statement.\n    \n    // Missing braces:\n    if (cond1)\n      foo1();\n      foo2();  // Not guarded by if(cond1).\n    \n\n## LimitationsÂ¶\n\nNote that this check only works as expected when the tabs or spaces are used\nconsistently and not mixed.",
                "disable": false
            },
            {
                "real_name": "readability-misplaced-array-index",
                "display_name": "readability-misplaced-array-index",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-misplaced-array-indexÂ¶\n\nThis check warns for unusual array index syntax.\n\nThe following code has unusual array index syntax:\n\n    \n    \n    void f(int *X, int Y) {\n      Y[X] = 0;\n    }\n    \n\nbecomes\n\n    \n    \n    void f(int *X, int Y) {\n      X[Y] = 0;\n    }\n    \n\nThe check warns about such unusual syntax for readability reasons:\n\n    \n\n  * There are programmers that are not familiar with this unusual syntax.\n  * It is possible that variables are mixed up.",
                "disable": false
            },
            {
                "real_name": "readability-named-parameter",
                "display_name": "readability-named-parameter",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-named-parameterÂ¶\n\nFind functions with unnamed arguments.\n\nThe check implements the following rule originating in the Google C++ Style\nGuide:\n\n<https://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions>\n\nAll parameters should be named, with identical names in the declaration and\nimplementation.\n\nCorresponding cpplint.py check name: readability/function.",
                "disable": false
            },
            {
                "real_name": "readability-non-const-parameter",
                "display_name": "readability-non-const-parameter",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-non-const-parameterÂ¶\n\nThe check finds function parameters of a pointer type that could be changed to\npoint to a constant type instead.\n\nWhen `const` is used properly, many mistakes can be avoided. Advantages when\nusing `const` properly:\n\n  * prevent unintentional modification of data;\n  * get additional warnings such as using uninitialized data;\n  * make it easier for developers to see possible side effects.\n\nThis check is not strict about constness, it only warns when the constness\nwill make the function interface safer.\n\n    \n    \n    // warning here; the declaration \"const char *p\" would make the function\n    // interface safer.\n    char f1(char *p) {\n      return *p;\n    }\n    \n    // no warning; the declaration could be more const \"const int * const p\" but\n    // that does not make the function interface safer.\n    int f2(const int *p) {\n      return *p;\n    }\n    \n    // no warning; making x const does not make the function interface safer\n    int f3(int x) {\n      return x;\n    }\n    \n    // no warning; Technically, *p can be const (\"const struct S *p\"). But making\n    // *p const could be misleading. People might think that it's safe to pass\n    // const data to this function.\n    struct S { int *a; int *b; };\n    int f3(struct S *p) {\n      *(p->a) = 0;\n    }\n    \n    // no warning; p is referenced by an lvalue.\n    void f4(int *p) {\n      int &x = *p;\n    }",
                "disable": false
            },
            {
                "real_name": "readability-qualified-auto",
                "display_name": "readability-qualified-auto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-qualified-autoÂ¶\n\nAdds pointer qualifications to `auto`-typed variables that are deduced to\npointers.\n\n[LLVM Coding Standards](https://llvm.org/docs/CodingStandards.html#beware-\nunnecessary-copies-with-auto) advises to make it obvious if a `auto` typed\nvariable is a pointer. This check will transform `auto` to `auto *` when the\ntype is deduced to be a pointer.\n\n    \n    \n    for (auto Data : MutatablePtrContainer) {\n      change(*Data);\n    }\n    for (auto Data : ConstantPtrContainer) {\n      observe(*Data);\n    }\n    \n\nWould be transformed into:\n\n    \n    \n    for (auto *Data : MutatablePtrContainer) {\n      change(*Data);\n    }\n    for (const auto *Data : ConstantPtrContainer) {\n      observe(*Data);\n    }\n    \n\nNote `const` `volatile` qualified types will retain their `const` and\n`volatile` qualifiers. Pointers to pointers will not be fully qualified.\n\n    \n    \n    const auto Foo = cast<int *>(Baz1);\n    const auto Bar = cast<const int *>(Baz2);\n    volatile auto FooBar = cast<int *>(Baz3);\n    auto BarFoo = cast<int **>(Baz4);\n    \n\nWould be transformed into:\n\n    \n    \n    auto *const Foo = cast<int *>(Baz1);\n    const auto *const Bar = cast<const int *>(Baz2);\n    auto *volatile FooBar = cast<int *>(Baz3);\n    auto *BarFoo = cast<int **>(Baz4);\n    \n\n## OptionsÂ¶\n\n`AddConstToQualified```Â¶\n\n    \n\nWhen set to true the check will add const qualifiers variables defined as\n`auto *` or `auto &` when applicable. Default value is true.\n\n    \n    \n    auto Foo1 = cast<const int *>(Bar1);\n    auto *Foo2 = cast<const int *>(Bar2);\n    auto &Foo3 = cast<const int &>(Bar3);\n    \n\nIf AddConstToQualified is set to false, it will be transformed into:\n\n    \n    \n    const auto *Foo1 = cast<const int *>(Bar1);\n    auto *Foo2 = cast<const int *>(Bar2);\n    auto &Foo3 = cast<const int &>(Bar3);\n    \n\nOtherwise it will be transformed into:\n\n    \n    \n    const auto *Foo1 = cast<const int *>(Bar1);\n    const auto *Foo2 = cast<const int *>(Bar2);\n    const auto &Foo3 = cast<const int &>(Bar3);\n    \n\nNote in the LLVM alias, the default value is false.",
                "disable": false
            },
            {
                "real_name": "readability-redundant-access-specifiers",
                "display_name": "readability-redundant-access-specifiers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-access-specifiersÂ¶\n\nFinds classes, structs, and unions containing redundant member (field and\nmethod) access specifiers.\n\n## ExampleÂ¶\n\n    \n    \n    class Foo {\n    public:\n      int x;\n      int y;\n    public:\n      int z;\n    protected:\n      int a;\n    public:\n      int c;\n    }\n    \n\nIn the example above, the second `public` declaration can be removed without\nany changes of behavior.\n\n## OptionsÂ¶\n\n`CheckFirstDeclaration```Â¶\n\n    \n\nIf set to true, the check will also diagnose if the first access specifier\ndeclaration is redundant (e.g. `private` inside `class`, or `public` inside\n`struct` or `union`). Default is false.\n\n### ExampleÂ¶\n\n    \n    \n    struct Bar {\n    public:\n      int x;\n    }\n    \n\nIf CheckFirstDeclaration option is enabled, a warning about redundant access\nspecifier will be emitted, because `public` is the default member access for\nstructs.",
                "disable": false
            },
            {
                "real_name": "readability-redundant-control-flow",
                "display_name": "readability-redundant-control-flow",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-control-flowÂ¶\n\nThis check looks for procedures (functions returning no value) with `return`\nstatements at the end of the function. Such `return` statements are redundant.\n\nLoop statements (`for`, `while`, `do while`) are checked for redundant\n`continue` statements at the end of the loop body.\n\nExamples:\n\nThe following function f contains a redundant `return` statement:\n\n    \n    \n    extern void g();\n    void f() {\n      g();\n      return;\n    }\n    \n\nbecomes\n\n    \n    \n    extern void g();\n    void f() {\n      g();\n    }\n    \n\nThe following function k contains a redundant `continue` statement:\n\n    \n    \n    void k() {\n      for (int i = 0; i < 10; ++i) {\n        continue;\n      }\n    }\n    \n\nbecomes\n\n    \n    \n    void k() {\n      for (int i = 0; i < 10; ++i) {\n      }\n    }",
                "disable": false
            },
            {
                "real_name": "readability-redundant-declaration",
                "display_name": "readability-redundant-declaration",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-declarationÂ¶\n\nFinds redundant variable and function declarations.\n\n    \n    \n    extern int X;\n    extern int X;\n    \n\nbecomes\n\n    \n    \n    extern int X;\n    \n\nSuch redundant declarations can be removed without changing program behavior.\nThey can for instance be unintentional left overs from previous refactorings\nwhen code has been moved around. Having redundant declarations could in worst\ncase mean that there are typos in the code that cause bugs.\n\nNormally the code can be automatically fixed, **clang-tidy** can remove the\nsecond declaration. However there are 2 cases when you need to fix the code\nmanually:\n\n  * When the declarations are in different header files;\n  * When multiple variables are declared together.\n\n## OptionsÂ¶\n\n`IgnoreMacros```Â¶\n\n    \n\nIf set to true, the check will not give warnings inside macros. Default is\ntrue.",
                "disable": false
            },
            {
                "real_name": "readability-redundant-function-ptr-dereference",
                "display_name": "readability-redundant-function-ptr-dereference",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-function-ptr-dereferenceÂ¶\n\nFinds redundant dereferences of a function pointer.\n\nBefore:\n\n    \n    \n    int f(int,int);\n    int (*p)(int, int) = &f;\n    \n    int i = (**p)(10, 50);\n    \n\nAfter:\n\n    \n    \n    int f(int,int);\n    int (*p)(int, int) = &f;\n    \n    int i = (*p)(10, 50);",
                "disable": false
            },
            {
                "real_name": "readability-redundant-member-init",
                "display_name": "readability-redundant-member-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-member-initÂ¶\n\nFinds member initializations that are unnecessary because the same default\nconstructor would be called if they were not present.\n\n## ExampleÂ¶\n\n    \n    \n    // Explicitly initializing the member s is unnecessary.\n    class Foo {\n    public:\n      Foo() : s() {}\n    \n    private:\n      std::string s;\n    };\n    \n\n## OptionsÂ¶\n\n`IgnoreBaseInCopyConstructors```Â¶\n\n    \n\nDefault is false.\n\nWhen true, the check will ignore unnecessary base class initializations within\ncopy constructors, since some compilers issue warnings/errors when base\nclasses are not explicitly initialized in copy constructors. For example,\n`gcc` with `-Wextra` or `-Werror=extra` issues warning or error `base class\n'Bar' should be explicitly initialized in the copy constructor` if `Bar()`\nwere removed in the following example:\n\n    \n    \n    // Explicitly initializing member s and base class Bar is unnecessary.\n    struct Foo : public Bar {\n      // Remove s() below. If IgnoreBaseInCopyConstructors!=0, keep Bar().\n      Foo(const Foo& foo) : Bar(), s() {}\n      std::string s;\n    };",
                "disable": false
            },
            {
                "real_name": "readability-redundant-preprocessor",
                "display_name": "readability-redundant-preprocessor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-preprocessorÂ¶\n\nFinds potentially redundant preprocessor directives. At the moment the\nfollowing cases are detected:\n\n  * #ifdef .. #endif pairs which are nested inside an outer pair with the same condition. For example:\n\n    \n    \n    #ifdef FOO\n    #ifdef FOO // inner ifdef is considered redundant\n    void f();\n    #endif\n    #endif\n    \n\n  * Same for #ifndef .. #endif pairs. For example:\n\n    \n    \n    #ifndef FOO\n    #ifndef FOO // inner ifndef is considered redundant\n    void f();\n    #endif\n    #endif\n    \n\n  * #ifndef inside an #ifdef with the same condition:\n\n    \n    \n    #ifdef FOO\n    #ifndef FOO // inner ifndef is considered redundant\n    void f();\n    #endif\n    #endif\n    \n\n  * #ifdef inside an #ifndef with the same condition:\n\n    \n    \n    #ifndef FOO\n    #ifdef FOO // inner ifdef is considered redundant\n    void f();\n    #endif\n    #endif\n    \n\n  * #if .. #endif pairs which are nested inside an outer pair with the same condition. For example:\n\n    \n    \n    #define FOO 4\n    #if FOO == 4\n    #if FOO == 4 // inner if is considered redundant\n    void f();\n    #endif\n    #endif",
                "disable": false
            },
            {
                "real_name": "readability-redundant-smartptr-get",
                "display_name": "readability-redundant-smartptr-get",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-smartptr-getÂ¶\n\nFind and remove redundant calls to smart pointerâs `.get()` method.\n\nExamples:\n\n    \n    \n    ptr.get()->Foo()  ==>  ptr->Foo()\n    *ptr.get()  ==>  *ptr\n    *ptr->get()  ==>  **ptr\n    if (ptr.get() == nullptr) ... => if (ptr == nullptr) ...\n    \n\n`IgnoreMacros```Â¶\n\n    \n\nIf this option is set to true (default is true), the check will not warn about\ncalls inside macros.",
                "disable": false
            },
            {
                "real_name": "readability-redundant-string-cstr",
                "display_name": "readability-redundant-string-cstr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-string-cstrÂ¶\n\nFinds unnecessary calls to `std::string::c_str()` and `std::string::data()`.",
                "disable": false
            },
            {
                "real_name": "readability-redundant-string-init",
                "display_name": "readability-redundant-string-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-redundant-string-initÂ¶\n\nFinds unnecessary string initializations.\n\n## ExamplesÂ¶\n\n    \n    \n    // Initializing string with empty string literal is unnecessary.\n    std::string a = \"\";\n    std::string b(\"\");\n    \n    // becomes\n    \n    std::string a;\n    std::string b;\n    \n    // Initializing a string_view with an empty string literal produces an\n    // instance that compares equal to string_view().\n    std::string_view a = \"\";\n    std::string_view b(\"\");\n    \n    // becomes\n    std::string_view a;\n    std::string_view b;\n    \n\n## OptionsÂ¶\n\n`StringNames```Â¶\n\n    \n\nDefault is ::std::basic_string;::std::basic_string_view.\n\nSemicolon-delimited list of class names to apply this check to. By default\n::std::basic_string applies to `std::string` and `std::wstring`. Set to e.g.\n::std::basic_string;llvm::StringRef;QString to perform this check on custom\nclasses.",
                "disable": false
            },
            {
                "real_name": "readability-simplify-boolean-expr",
                "display_name": "readability-simplify-boolean-expr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-simplify-boolean-exprÂ¶\n\nLooks for boolean expressions involving boolean constants and simplifies them\nto use the appropriate boolean expression directly. Simplifies boolean\nexpressions by application of DeMorganâs Theorem.\n\nExamples:\n\nInitial expression | Result  \n---|---  \n`if (b == true)` | `if (b)`  \n`if (b == false)` | `if (!b)`  \n`if (b && true)` | `if (b)`  \n`if (b && false)` | `if (false)`  \n`if (b || true)` | `if (true)`  \n`if (b || false)` | `if (b)`  \n`e ? true : false` | `e`  \n`e ? false : true` | `!e`  \n`if (true) t(); else f();` | `t();`  \n`if (false) t(); else f();` | `f();`  \n`if (e) return true; else return false;` | `return e;`  \n`if (e) return false; else return true;` | `return !e;`  \n`if (e) b = true; else b = false;` | `b = e;`  \n`if (e) b = false; else b = true;` | `b = !e;`  \n`if (e) return true; return false;` | `return e;`  \n`if (e) return false; return true;` | `return !e;`  \n`!(!a || b)` | `a && !b`  \n`!(a || !b)` | `!a && b`  \n`!(!a || !b)` | `a && b`  \n`!(!a && b)` | `a || !b`  \n`!(a && !b)` | `!a || b`  \n`!(!a && !b)` | `a || b`  \n  \nThe resulting expression `e` is modified as follows:\n\n    \n\n  1. Unnecessary parentheses around the expression are removed.\n  2. Negated applications of `!` are eliminated.\n  3. Negated applications of comparison operators are changed to use the opposite condition.\n  4. Implicit conversions of pointers, including pointers to members, to `bool` are replaced with explicit comparisons to `nullptr` in C++11 or `NULL` in C++98/03.\n  5. Implicit casts to `bool` are replaced with explicit casts to `bool`.\n  6. Object expressions with `explicit operator bool` conversion operators are replaced with explicit casts to `bool`.\n  7. Implicit conversions of integral types to `bool` are replaced with explicit comparisons to `0`.\n\nExamples:\n\n    \n\n  1. The ternary assignment `bool b = (i < 0) ? true : false;` has redundant parentheses and becomes `bool b = i < 0;`.\n\n  2. The conditional return `if (!b) return false; return true;` has an implied double negation and becomes `return b;`.\n\n  3. The conditional return `if (i < 0) return false; return true;` becomes `return i >= 0;`.\n\nThe conditional return `if (i != 0) return false; return true;` becomes\n`return i == 0;`.\n\n  4. The conditional return `if (p) return true; return false;` has an implicit conversion of a pointer to `bool` and becomes `return p != nullptr;`.\n\nThe ternary assignment `bool b = (i & 1) ? true : false;` has an implicit\nconversion of `i & 1` to `bool` and becomes `bool b = (i & 1) != 0;`.\n\n  5. The conditional return `if (i & 1) return true; else return false;` has an implicit conversion of an integer quantity `i & 1` to `bool` and becomes `return (i & 1) != 0;`\n\n  6. Given `struct X { explicit operator bool(); };`, and an instance `x` of `struct X`, the conditional return `if (x) return true; return false;` becomes `return static_cast<bool>(x);`\n\n## OptionsÂ¶\n\n`ChainedConditionalReturn```Â¶\n\n    \n\nIf true, conditional boolean return statements at the end of an `if/else if`\nchain will be transformed. Default is false.\n\n`ChainedConditionalAssignment```Â¶\n\n    \n\nIf true, conditional boolean assignments at the end of an `if/else if` chain\nwill be transformed. Default is false.\n\n`SimplifyDeMorgan```Â¶\n\n    \n\nIf true, DeMorganâs Theorem will be applied to simplify negated conjunctions\nand disjunctions. Default is true.\n\n`SimplifyDeMorganRelaxed```Â¶\n\n    \n\nIf true, `SimplifyDeMorgan` will also transform negated conjunctions and\ndisjunctions where there is no negation on either operand. This option has no\neffect if `SimplifyDeMorgan` is false. Default is false.\n\nWhen Enabled:\n\nWould be transformed to:",
                "disable": false
            },
            {
                "real_name": "readability-simplify-subscript-expr",
                "display_name": "readability-simplify-subscript-expr",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-simplify-subscript-exprÂ¶\n\nThis check simplifies subscript expressions. Currently this covers calling\n`.data()` and immediately doing an array subscript operation to obtain a\nsingle element, in which case simply calling `operator[]` suffice.\n\nExamples:\n\n    \n    \n    std::string s = ...;\n    char c = s.data()[i];  // char c = s[i];\n    \n\n## OptionsÂ¶\n\n`Types```Â¶\n\n    \n\nThe list of type(s) that triggers this check. Default is\n::std::basic_string;::std::basic_string_view;::std::vector;::std::array",
                "disable": false
            },
            {
                "real_name": "readability-static-accessed-through-instance",
                "display_name": "readability-static-accessed-through-instance",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-static-accessed-through-instanceÂ¶\n\nChecks for member expressions that access static members through instances,\nand replaces them with uses of the appropriate qualified-id.\n\nExample:\n\nThe following code:\n\n    \n    \n    struct C {\n      static void foo();\n      static int x;\n    };\n    \n    C *c1 = new C();\n    c1->foo();\n    c1->x;\n    \n\nis changed to:\n\n    \n    \n    C *c1 = new C();\n    C::foo();\n    C::x;",
                "disable": false
            },
            {
                "real_name": "readability-static-definition-in-anonymous-namespace",
                "display_name": "readability-static-definition-in-anonymous-namespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-static-definition-in-anonymous-namespaceÂ¶\n\nFinds static function and variable definitions in anonymous namespace.\n\nIn this case, `static` is redundant, because anonymous namespace limits the\nvisibility of definitions to a single translation unit.\n\n    \n    \n    namespace {\n      static int a = 1; // Warning.\n      static const int b = 1; // Warning.\n      namespace inner {\n        static int c = 1; // Warning.\n      }\n    }\n    \n\nThe check will apply a fix by removing the redundant `static` qualifier.",
                "disable": false
            },
            {
                "real_name": "readability-string-compare",
                "display_name": "readability-string-compare",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-string-compareÂ¶\n\nFinds string comparisons using the compare method.\n\nA common mistake is to use the stringâs `compare` method instead of using\nthe equality or inequality operators. The compare method is intended for\nsorting functions and thus returns a negative number, a positive number or\nzero depending on the lexicographical relationship between the strings\ncompared. If an equality or inequality check can suffice, that is recommended.\nThis is recommended to avoid the risk of incorrect interpretation of the\nreturn value and to simplify the code. The string equality and inequality\noperators can also be faster than the `compare` method due to early\ntermination.\n\nExamples:\n\n    \n    \n    std::string str1{\"a\"};\n    std::string str2{\"b\"};\n    \n    // use str1 != str2 instead.\n    if (str1.compare(str2)) {\n    }\n    \n    // use str1 == str2 instead.\n    if (!str1.compare(str2)) {\n    }\n    \n    // use str1 == str2 instead.\n    if (str1.compare(str2) == 0) {\n    }\n    \n    // use str1 != str2 instead.\n    if (str1.compare(str2) != 0) {\n    }\n    \n    // use str1 == str2 instead.\n    if (0 == str1.compare(str2)) {\n    }\n    \n    // use str1 != str2 instead.\n    if (0 != str1.compare(str2)) {\n    }\n    \n    // Use str1 == \"foo\" instead.\n    if (str1.compare(\"foo\") == 0) {\n    }\n    \n\nThe above code examples show the list of if-statements that this check will\ngive a warning for. All of them uses `compare` to check if equality or\ninequality of two strings instead of using the correct operators.",
                "disable": false
            },
            {
                "real_name": "readability-suspicious-call-argument",
                "display_name": "readability-suspicious-call-argument",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-suspicious-call-argumentÂ¶\n\nFinds function calls where the arguments passed are provided out of order,\nbased on the difference between the argument name and the parameter names of\nthe function.\n\nGiven a function call `f(foo, bar);` and a function signature `void f(T tvar,\nU uvar)`, the arguments `foo` and `bar` are swapped if `foo` (the argument\nname) is more similar to `uvar` (the other parameter) than `tvar` (the\nparameter it is currently passed to) **and** `bar` is more similar to `tvar`\nthan `uvar`.\n\nWarnings might indicate either that the arguments are swapped, or that the\nnamesâ cross-similarity might hinder code comprehension.\n\n## HeuristicsÂ¶\n\nThe following heuristics are implemented in the check. If **any** of the\nenabled heuristics deem the arguments to be provided out of order, a warning\nwill be issued.\n\nThe heuristics themselves are implemented by considering pairs of strings, and\nare symmetric, so in the following there is no distinction on which string is\nthe argument name and which string is the parameter name.\n\n### EqualityÂ¶\n\nThe most trivial heuristic, which compares the two strings for case-\ninsensitive equality.\n\n### AbbreviationÂ¶\n\nCommon abbreviations can be specified which will deem the strings similar if\nthe abbreviated and the abbreviation stand together. For example, if `src` is\nregistered as an abbreviation for `source`, then the following code example\nwill be warned about.\n\n    \n    \n    void foo(int source, int x);\n    \n    foo(b, src);\n    \n\nThe abbreviations to recognise can be configured with the Abbreviations check\noption. This heuristic is case-insensitive.\n\n### PrefixÂ¶\n\nThe _prefix_ heuristic reports if one of the strings is a sufficiently long\nprefix of the other string, e.g. `target` to `targetPtr`. The similarity\npercentage is the length ratio of the prefix to the longer string, in the\nprevious example, it would be 6 / 9 = 66.66â¦%.\n\nThis heuristic can be configured with bounds. The default bounds are: below\n25% dissimilar and above 30% similar. This heuristic is case-insensitive.\n\n### SuffixÂ¶\n\nAnalogous to the Prefix heuristic. In the case of `oldValue` and `value`\ncompared, the similarity percentage is 8 / 5 = 62.5%.\n\nThis heuristic can be configured with bounds. The default bounds are: below\n25% dissimilar and above 30% similar. This heuristic is case-insensitive.\n\n### SubstringÂ¶\n\nThe substring heuristic combines the prefix and the suffix heuristic, and\ntries to find the _longest common substring_ in the two strings provided. The\nsimilarity percentage is the ratio of the found longest common substring\nagainst the _longer_ of the two input strings. For example, given `val` and\n`rvalue`, the similarity is 3 / 6 = 50%. If no characters are common in the\ntwo string, 0%.\n\nThis heuristic can be configured with bounds. The default bounds are: below\n40% dissimilar and above 50% similar. This heuristic is case-insensitive.\n\n### Levenshtein distance (as Levenshtein)Â¶\n\nThe [Levenshtein distance](http://en.wikipedia.org/wiki/Levenshtein_distance)\ndescribes how many single-character changes (additions, changes, or removals)\nmust be applied to transform one string into another.\n\nThe Levenshtein distance is translated into a similarity percentage by\ndividing it with the length of the _longer_ string, and taking its complement\nwith regards to 100%. For example, given `something` and `anything`, the\ndistance is 4 edits, and the similarity percentage is 100% \\- 4 / 9 =\n55.55â¦%.\n\nThis heuristic can be configured with bounds. The default bounds are: below\n50% dissimilar and above 66% similar. This heuristic is case-sensitive.\n\n### JaroâWinkler distance (as JaroWinkler)Â¶\n\nThe [JaroâWinkler\ndistance](http://en.wikipedia.org/wiki/JaroâWinkler_distance) is an edit\ndistance like the Levenshtein distance. It is calculated from the amount of\ncommon characters that are sufficiently close to each other in position, and\nto-be-changed characters. The original definition of Jaro has been extended by\nWinkler to weigh prefix similarities more. The similarity percentage is\nexpressed as an average of the common and non-common characters against the\nlength of both strings.\n\nThis heuristic can be configured with bounds. The default bounds are: below\n75% dissimilar and above 85% similar. This heuristic is case-insensitive.\n\n### SÃ¸rensenâDice coefficient (as Dice)Â¶\n\nThe [SÃ¸rensenâDice\ncoefficient](http://en.wikipedia.org/wiki/SÃ¸rensenâDice_coefficient) was\noriginally defined to measure the similarity of two sets. Formally, the\ncoefficient is calculated by dividing 2 * #(intersection) with #(set1) +\n#(set2), where #() is the cardinality function of sets. This metric is applied\nto strings by creating bigrams (substring sequences of length 2) of the two\nstrings and using the set of bigrams for the two strings as the two sets.\n\nThis heuristic can be configured with bounds. The default bounds are: below\n60% dissimilar and above 70% similar. This heuristic is case-insensitive.\n\n## OptionsÂ¶\n\n`MinimumIdentifierNameLength```Â¶\n\n    \n\nSets the minimum required length the argument and parameter names need to\nhave. Names shorter than this length will be ignored. Defaults to 3.\n\n`Abbreviations```Â¶\n\n    \n\nFor the **Abbreviation** heuristic (see here), this option configures the\nabbreviations in the âabbreviation=abbreviated_valueâ format. The option\nis a string, with each value joined by â;â.\n\nBy default, the following abbreviations are set:\n\n>   * addr=address\n>   * arr=array\n>   * attr=attribute\n>   * buf=buffer\n>   * cl=client\n>   * cnt=count\n>   * col=column\n>   * cpy=copy\n>   * dest=destination\n>   * dist=distance\n>   * dst=distance\n>   * elem=element\n>   * hght=height\n>   * i=index\n>   * idx=index\n>   * len=length\n>   * ln=line\n>   * lst=list\n>   * nr=number\n>   * num=number\n>   * pos=position\n>   * ptr=pointer\n>   * ref=reference\n>   * src=source\n>   * srv=server\n>   * stmt=statement\n>   * str=string\n>   * val=value\n>   * var=variable\n>   * vec=vector\n>   * wdth=width\n>\n\nThe configuration options for each implemented heuristic (see above) is\nconstructed dynamically. In the following, <HeuristicName> refers to one of\nthe keys from the heuristics implemented.\n\n`<HeuristicName>```Â¶\n\n    \n\nTrue or False, whether a particular heuristic, such as Equality or Levenshtein\nis enabled.\n\nDefaults to True for every heuristic.\n\n`<HeuristicName>DissimilarBelow````, ``<HeuristicName>SimilarAbove```Â¶\n\n    \n\nA value between 0 and 100, expressing a percentage. The bounds set what\npercentage of similarity the heuristic must deduce for the two identifiers to\nbe considered similar or dissimilar by the check.\n\nGiven arguments `arg1` and `arg2` passed to `param1` and `param2`,\nrespectively, the bounds check is performed in the following way: If the\nsimilarity of the currently passed argument order (`arg1` to `param1`) is\n**below** the DissimilarBelow threshold, and the similarity of the suggested\nswapped order (`arg1` to `param2`) is **above** the SimilarAbove threshold,\nthe swap is reported.\n\nFor the defaults of each heuristic, see above.\n\n## Name synthesisÂ¶\n\nWhen comparing the argument names and parameter names, the following logic is\nused to gather the names for comparison:\n\nParameter names are the identifiers as written in the source code.\n\nArgument names are:\n\n>   * If a variable is passed, the variableâs name.\n>   * If a subsequent function callâs return value is used as argument, the\n> called functionâs name.\n>   * Otherwise, empty string.\n>\n\nEmpty argument or parameter names are ignored by the heuristics.",
                "disable": false
            },
            {
                "real_name": "readability-uniqueptr-delete-release",
                "display_name": "readability-uniqueptr-delete-release",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-uniqueptr-delete-releaseÂ¶\n\nReplace `delete <unique_ptr>.release()` with `<unique_ptr> = nullptr`. The\nlatter is shorter, simpler and does not require use of raw pointer APIs.\n\n    \n    \n    std::unique_ptr<int> P;\n    delete P.release();\n    \n    // becomes\n    \n    std::unique_ptr<int> P;\n    P = nullptr;\n    \n\n## OptionsÂ¶\n\n`PreferResetCall```Â¶\n\n    \n\nIf true, refactor by calling the reset member function instead of assigning to\n`nullptr`. Default value is false.\n\n    \n    \n    std::unique_ptr<int> P;\n    delete P.release();\n    \n    // becomes\n    \n    std::unique_ptr<int> P;\n    P.reset();",
                "disable": false
            },
            {
                "real_name": "readability-uppercase-literal-suffix",
                "display_name": "readability-uppercase-literal-suffix",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-uppercase-literal-suffixÂ¶\n\ncert-dcl16-c redirects here as an alias for this check. By default, only the\nsuffixes that begin with `l` (`l`, `ll`, `lu`, `llu`, but not `u`, `ul`,\n`ull`) are diagnosed by that alias.\n\nhicpp-uppercase-literal-suffix redirects here as an alias for this check.\n\nDetects when the integral literal or floating point (decimal or hexadecimal)\nliteral has a non-uppercase suffix and provides a fix-it hint with the\nuppercase suffix.\n\nAll valid combinations of suffixes are supported.\n\n    \n    \n    auto x = 1;  // OK, no suffix.\n    \n    auto x = 1u; // warning: integer literal suffix 'u' is not upper-case\n    \n    auto x = 1U; // OK, suffix is uppercase.\n    \n    ...\n    \n\n## OptionsÂ¶\n\n`NewSuffixes```Â¶\n\n    \n\nOptionally, a list of the destination suffixes can be provided. When the\nsuffix is found, a case-insensitive lookup in that list is made, and if a\nreplacement is found that is different from the current suffix, then the\ndiagnostic is issued. This allows for fine-grained control of what suffixes to\nconsider and what their replacements should be.\n\n### ExampleÂ¶\n\nGiven a list L;uL:\n\n  * `l` -> `L`\n  * `L` will be kept as is.\n  * `ul` -> `uL`\n  * `Ul` -> `uL`\n  * `UL` -> `uL`\n  * `uL` will be kept as is.\n  * `ull` will be kept as is, since it is not in the list\n  * and so on.\n\n`IgnoreMacros```Â¶\n\n    \n\nIf this option is set to true (default is true), the check will not warn about\nliteral suffixes inside macros.",
                "disable": false
            },
            {
                "real_name": "readability-use-anyofallof",
                "display_name": "readability-use-anyofallof",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# readability-use-anyofallofÂ¶\n\nFinds range-based for loops that can be replaced by a call to `std::any_of` or\n`std::all_of`. In C++ 20 mode, suggests `std::ranges::any_of` or\n`std::ranges::all_of`.\n\nExample:\n\n    \n    \n    bool all_even(std::vector<int> V) {\n      for (int I : V) {\n        if (I % 2)\n          return false;\n      }\n      return true;\n      // Replace loop by\n      // return std::ranges::all_of(V, [](int I) { return I % 2 == 0; });\n    }",
                "disable": false
            },
            {
                "real_name": "zircon-temporary-objects",
                "display_name": "zircon-temporary-objects",
                "severity": "error",
                "category": "correctness",
                "rule_title": "",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "cpp"
                ],
                "solution": "",
                "owner": "",
                "labels": [],
                "description": "# zircon-temporary-objectsÂ¶\n\nWarns on construction of specific temporary objects in the Zircon kernel. If\nthe object should be flagged, If the object should be flagged, the fully\nqualified type name must be explicitly passed to the check.\n\nFor example, given the list of classes âFooâ and âNS::Barâ, all of the\nfollowing will trigger the warning:\n\n    \n    \n    Foo();\n    Foo F = Foo();\n    func(Foo());\n    \n    namespace NS {\n    \n    Bar();\n    \n    }\n    \n\nWith the same list, the following will not trigger the warning:\n\n    \n    \n    Foo F;                 // Non-temporary construction okay\n    Foo F(param);          // Non-temporary construction okay\n    Foo *F = new Foo();    // New construction okay\n    \n    Bar();                 // Not NS::Bar, so okay\n    NS::Bar B;             // Non-temporary construction okay\n    \n\nNote that objects must be explicitly specified in order to be flagged, and so\nobjects that inherit a specified object will not be flagged.\n\nThis check matches temporary objects without regard for inheritance and so a\nprohibited base class type does not similarly prohibit derived class types.\n\n    \n    \n    class Derived : Foo {} // Derived is not explicitly disallowed\n    Derived();             // and so temporary construction is okay\n    \n\n## OptionsÂ¶\n\n`Names```Â¶\n\n    \n\nA semi-colon-separated list of fully-qualified names of C++ classes that\nshould not be constructed as temporaries. Default is empty.",
                "disable": false
            }
        ],
        "open_user": true,
        "open_saas": false
    }
]