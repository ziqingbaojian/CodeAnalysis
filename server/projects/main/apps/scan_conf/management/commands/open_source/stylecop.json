[
  {
    "name": "stylecop",
    "display_name": "StyleCop",
    "description": "C# static analyzer",
    "license": "Ms-PL",
    "task_processes": [
      "analyze",
      "datahandle"
    ],
    "open_user": true,
    "scan_app": "codelint",
    "scm_url": null,
    "run_cmd": null,
    "envs": null,
    "build_flag": false,
    "checkrule_set": [
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ConstructorSummaryDocumentationMustBeginWithStandardText",
        "display_name": "ConstructorSummaryDocumentationMustBeginWithStandardText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml documentation header for a C# constructor does not contain the appropriate summary text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ConstructorSummaryDocumentationMustBeginWithStandardText\n\nConstructorSummaryDocumentationMustBeginWithStandardText\n|CheckId|SA1642\n\nSA1642\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml documentation header for a C# constructor does not contain the appropriate summary text.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the summary tag within the documentation header for a constructor does not begin with the proper text.\n\nThe rule is intended to standardize the summary text for a constructor based on the access level of the constructor. The summary for a non-private instance constructor must begin with “Initializes a new instance of the {class name} class.” For example, the following shows the constructor for the Customer class.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Initializes a new instance of the Customer class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nIt is possible to embed other tags into the summary text. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Initializes a new instance of the &lt;see cref=\"Customer\"/&gt; class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIf the class contains generic parameters, these can be annotated within the cref link using either of the following two formats:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Initializes a new instance of the &lt;see cref=\"Customer`1\"/&gt; class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n \n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Initializes a new instance of the &lt;see cref=\"Customer{T}\"/&gt; class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIf the constructor is static, the summary text should begin with “Initializes static members of the {class name} class.” For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Initializes static members of the Customer class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public static Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nPrivate instance constructors must use the summary text “Prevents a default instance of the {class name} class from being created.”\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Prevents a default instance of the Customer class from being created.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    private Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, edit the summary text for the constructor as described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1642.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DestructorSummaryDocumentationMustBeginWithStandardText",
        "display_name": "DestructorSummaryDocumentationMustBeginWithStandardText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml documentation header for a C# finalizer does not contain the appropriate summary text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DestructorSummaryDocumentationMustBeginWithStandardText\n\nDestructorSummaryDocumentationMustBeginWithStandardText\n|CheckId|SA1643\n\nSA1643\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml documentation header for a C# finalizer does not contain the appropriate summary text.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the summary tag within the documentation header for a finalizer does not begin with the proper text.\n\nThe rule is intended to standardize the summary text for a finalizer. The summary for a finalizer must begin with “Finalizes an instance of the {class name} class.” For example, the following shows the finalizer for the Customer class.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Finalizes an instance of the Customer class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    ~Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIt is possible to embed other tags into the summary text. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Finalizes an instance of the &lt;see cref=\"Customer\"/&gt; class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    ~Customer()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, edit the summary text for the finalizer as described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1643.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationHeadersMustNotContainBlankLines",
        "display_name": "DocumentationHeadersMustNotContainBlankLines",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A section within the Xml documentation header for a C# element contains blank lines.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationHeadersMustNotContainBlankLines\n\nDocumentationHeadersMustNotContainBlankLines\n|CheckId|SA1644\n\nSA1644\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA section within the Xml documentation header for a C# element contains blank lines.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the documentation header contains one or more blank lines within a section of documentation. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    ///<o:p></o:p>\n\n    /// Uses a simple form of string concatenation.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nRather than inserting blank lines into the documentation, use the &lt;para&gt; tag to denote paragraphs. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// &lt;para&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/para&gt;&lt;para&gt;<o:p></o:p>\n\n    /// Uses a simple form of string concatenation.<o:p></o:p>\n\n    /// &lt;/para&gt;<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank lines from the documentation header, and optionally replace them with &lt;para/&gt; tags.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1644.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationMustContainValidXml",
        "display_name": "DocumentationMustContainValidXml",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml within a C# element’s document header is badly formed.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationMustContainValidXml\n\nDocumentationMustContainValidXml\n|CheckId|SA1603\n\nSA1603\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml within a C# element’s document header is badly formed.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the documentation Xml is badly formed and cannot be parsed. This can occur if the Xml contains invalid characters, or if an Xml node is missing a closing tag, for example.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, replace the badly formed Xml with valid Xml that can be parsed by a standard Xml parser.<o:p></o:p>\n\n<a name=\"codeExampleToggle\"></a>The following example shows a class containing invalid Xml within its documentation header. The closing tag for the &lt;summary&gt; node is invalid.<o:p></o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// An example of badly formed Xml.<o:p></o:p>\n\n    /// &lt;/summa3ry&gt;<o:p></o:p>\n\n    public class Example<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1603.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationMustMeetCharacterPercentage",
        "display_name": "DocumentationMustMeetCharacterPercentage",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A section of the Xml header documentation for a C# element does not contain enough alphabetic characters.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationMustMeetCharacterPercentage\n\nDocumentationMustMeetCharacterPercentage\n|CheckId|SA1631\n\nSA1631\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA section of the Xml header documentation for a C# element does not contain enough alphabetic characters.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when part of the documentation does contain enough characters. This rule is calculated by counting the number of alphabetic characters and numbers within the documentation text, and comparing it against the number of symbols and other non-alphabetic characters. If the percentage of non-alphabetic characters is too high, this generally indicates poorly formatted documentation which will be difficult to read. For example, consider the follow summary documentation:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// @)$(*A name--------<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public class Name    <o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, rewrite the documentation text using grammatically proper language, and ensure that the ratio of symbols versus characters in the text is not too great.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1631.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationTextMustBeginWithACapitalLetter",
        "display_name": "DocumentationTextMustBeginWithACapitalLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A section of the Xml header documentation for a C# element does not begin with a capital letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationTextMustBeginWithACapitalLetter\n\nDocumentationTextMustBeginWithACapitalLetter\n|CheckId|SA1628\n\nSA1628\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA section of the Xml header documentation for a C# element does not begin with a capital letter.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when part of the documentation does not begin with a capital letter. For example, the summary text in the documentation below begins with a lower-case letter:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that all sections of the documentation begin with a capital letter.<o:p></o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1628.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationTextMustContainWhitespace",
        "display_name": "DocumentationTextMustContainWhitespace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A section of the Xml header documentation for a C# element does not contain any whitespace between words.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationTextMustContainWhitespace\n\nDocumentationTextMustContainWhitespace\n|CheckId|SA1630\n\nSA1630\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA section of the Xml header documentation for a C# element does not contain any whitespace between words.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when part of the documentation does contain any whitespace between words. This can indicate poorly written or poorly formatted documentation. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joinsnames<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;First&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;Last&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;Name&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that all sections of the documentation contain at least one instance of whitespace between words.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1630.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationTextMustEndWithAPeriod",
        "display_name": "DocumentationTextMustEndWithAPeriod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A section of the Xml header documentation for a C# element does not end with a period (also known as a full stop).",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationTextMustEndWithAPeriod\n\nDocumentationTextMustEndWithAPeriod\n|CheckId|SA1629\n\nSA1629\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA section of the Xml header documentation for a C# element does not end with a period (also known as a full stop).\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when part of the documentation does not end with a period. For example, the summary text in the documentation below does not end with a period:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name.&lt;/param&gt;<o:p></o:p>\n\n\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that all sections of the documentation end with a period.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1629.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationTextMustMeetMinimumCharacterLength",
        "display_name": "DocumentationTextMustMeetMinimumCharacterLength",
        "severity": "warning",
        "category": "convention",
        "rule_title": "From StyleCop 4.5 this rule is disabled by default.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationTextMustMeetMinimumCharacterLength\n\nDocumentationTextMustMeetMinimumCharacterLength\n|CheckId|SA1632\n\nSA1632\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nFrom StyleCop 4.5 this rule is disabled by default.\n\nA section of the Xml header documentation for a C# element is too short.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when part of the documentation is too short. This can often indicate that the documentation is not descriptive. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// A name<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public class Name    <o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, rewrite the documentation text using grammatically proper and descriptive language. In most cases, doing so will cause the length of the documentation text to be greater than the minimum length which causes this rule to fire.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1632.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/DocumentationTextMustNotBeEmpty",
        "display_name": "DocumentationTextMustNotBeEmpty",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml header documentation for a C# code element contains an empty tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationTextMustNotBeEmpty\n\nDocumentationTextMustNotBeEmpty\n|CheckId|SA1627\n\nSA1627\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml header documentation for a C# code element contains an empty tag.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the documentation header for an element contains an empty tag. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt; &lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;Part of the name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add documentation text within the empty tag.<o:p></o:p>\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1627.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementDocumentationMustBeSpelledCorrectly",
        "display_name": "ElementDocumentationMustBeSpelledCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The element documentation for the element contains one or more spelling mistakes \n                    or unrecognized words.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationMustBeSpelledCorrectly\n\nElementDocumentationMustBeSpelledCorrectly\n|CheckId|SA1650\n\nSA1650\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe element documentation for the element contains one or more spelling mistakes \n                    or unrecognized words.\n\n## Rule Description\n\nA violation of this rule occurs when the element documentation contains spelling \n                    mistakes:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joinsnames<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The \n                    first name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The \n                    last name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;Name&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        ...<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe spelling is checked using the culture specified in the Settings.StyleCop file \n                    (and en-US by default).\n\nIn this example the word Joinsnames in the summary element is misspelled. Either \n                    correct the spelling, insert any C# names in &lt;c&gt; &lt;/c&gt; elements, suppress the \n                    violation or add the Joinsnames to a CustomDictionary.xml file. \n\n\n<o:p>CustomDictionary.xml files can contain words that the spelling checker does \n                    not normally recognise.</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>The CustomDictionary.xml file should be placed in the same folder as the \n                    StyleCop.dll and the Rules. That folder (and all subfolders) are checked for the \n                    dictionary files.</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>StyleCop loads CustomDictionary.xml, CustomDictionary.en-GB.xml and then \n                    CustomDictionary.en.xml (where en-GB is the culture specified in the \n                    Settings.StyleCop file).</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>StyleCop also loads custom.dic, custom.en-GB.dic and then custom.en.dic \n                    (where en-GB is the culture specified in the Settings.StyleCop file).</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>Recognized words can also be added to the Settings.StyleCop file using the \n                    Settings Editor on the spelling tab.</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>Attribute values in the documentation xml of the element are not checked \n                    for spelling.</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>Any text inside &lt;c&gt; &lt;/c&gt; or &lt;code&gt; &lt;/code&gt; elements is also ignored.</o:p>\n\n\n<o:p></o:p>\n\n\n\n<o:p>Any text starting with and ending with '$' or starting and ending with '$$' \n                    is also ignored. i.e. $$(thtp kthpo kthpk)$$.</o:p>\n\n\n\n<o:p> </o:p><o:p> </o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, correct any spelling mistakes in the element \n                    documentation.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1650.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementDocumentationMustHaveSummary",
        "display_name": "ElementDocumentationMustHaveSummary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml header documentation for a C# element is missing a &lt;summary&gt; tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationMustHaveSummary\n\nElementDocumentationMustHaveSummary\n|CheckId|SA1604\n\nSA1604\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml header documentation for a C# element is missing a &lt;summary&gt; tag.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the element documentation is missing a &lt;summary&gt; tag.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add and fill-in a &lt;summary&gt; tag for the element, containing a description of the element.\n\nThe following example shows a class containing invalid Xml within its documentation header. The closing tag for the &lt;summary&gt; node is invalid.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Represents a customer in the database.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public class Customer<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1604.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementDocumentationMustHaveSummaryText",
        "display_name": "ElementDocumentationMustHaveSummaryText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The &lt;summary&gt; tag within the documentation header for a C# code element is empty.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationMustHaveSummaryText\n\nElementDocumentationMustHaveSummaryText\n|CheckId|SA1606\n\nSA1606\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe &lt;summary&gt; tag within the documentation header for a C# code element is empty.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the documentation header for an element contains an empty &lt;summary&gt; tag which does not contain a description of the element.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, fill-in the &lt;summary&gt; tag with a description of the code element.\n\nExample:\n\n<a name=\"codeExampleToggle\"></a>The following example shows a method which contains an empty &lt;summary&gt; tag.<o:p></o:p>\n\n/// &lt;summary&gt;  &lt;/summary&gt;<o:p></o:p>\n\n/// &lt;param name=\"customerId\"&gt;The ID of the customer to find.&lt;/param&gt;<o:p></o:p>\n\n/// &lt;returns&gt;The customer, or null if the customer could not be<o:p></o:p>\n\n/// found.&lt;/returns&gt;<o:p></o:p>\n\npublic Customer FindCustomer(int customerId)<o:p></o:p>\n\n{<o:p></o:p>\n\n    // ... finds the customer ...<o:p></o:p>\n\n}<o:p></o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1606.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementDocumentationMustNotBeCopiedAndPasted",
        "display_name": "ElementDocumentationMustNotBeCopiedAndPasted",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml documentation for a C# element contains two or more identical entries, indicating that the documentation has been copied and pasted. This can sometimes indicate invalid or poorly written documentation.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationMustNotBeCopiedAndPasted\n\nElementDocumentationMustNotBeCopiedAndPasted\n|CheckId|SA1625\n\nSA1625\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml documentation for a C# element contains two or more identical entries, indicating that the documentation has been copied and pasted. This can sometimes indicate invalid or poorly written documentation.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when an element contains two or more identical documentation texts. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;Part of the name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;Part of the name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIn some cases, a method may contain one or more parameters which are not used within the body of the method. In this case, the documentation for the parameter can be set to \"The parameter is not used.\" StyleCop will allow multiple parameters to contain identical documentation as long as the documentation string is \"The parameter is not used.\"\n\n## How to Fix Violations\n\nTo fix a violation of this rule, edit the documentation for the element and ensure that each of the individual documentation texts are unique. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1625.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementDocumentationMustNotHaveDefaultSummary",
        "display_name": "ElementDocumentationMustNotHaveDefaultSummary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The &lt;summary&gt; tag within an element’s Xml header documentation contains the default text generated by Visual Studio during the creation of the element.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationMustNotHaveDefaultSummary\n\nElementDocumentationMustNotHaveDefaultSummary\n|CheckId|SA1608\n\nSA1608\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe &lt;summary&gt; tag within an element’s Xml header documentation contains the default text generated by Visual Studio during the creation of the element.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nVisual Studio provides helper functionality for adding new elements such as classes to a project. Visual Studio will create a default documentation header for the new class and fill in this header with default documentation text.\n\nA violation of this rule occurs when the &lt;summary&gt; tag for a code element still contains the default documentation text generated by Visual Studio.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, replace the default documentation text with new text describing the contents of the code element.\n\nThe following example shows a class which contains the default summary text generated by Visual Studio.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Summary description for the Example class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public class Example<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1608.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementParameterDocumentationMustDeclareParameterName",
        "display_name": "ElementParameterDocumentationMustDeclareParameterName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A &lt;param&gt; tag within a C# element’s documentation header is missing a name attribute containing the name of the parameter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementParameterDocumentationMustDeclareParameterName\n\nElementParameterDocumentationMustDeclareParameterName\n|CheckId|SA1613\n\nSA1613\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA &lt;param&gt; tag within a C# element’s documentation header is missing a name attribute containing the name of the parameter.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if the documentation for an element contains a &lt;param&gt; tag which is missing a name attribute, or which contains an empty name attribute.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in the name attribute for the &lt;param&gt; tag to indicate the name of the parameter that the documentation is for.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1613.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementParameterDocumentationMustHaveText",
        "display_name": "ElementParameterDocumentationMustHaveText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A &lt;param&gt; tag within a C# element’s documentation header is empty.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementParameterDocumentationMustHaveText\n\nElementParameterDocumentationMustHaveText\n|CheckId|SA1614\n\nSA1614\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA &lt;param&gt; tag within a C# element’s documentation header is empty.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if the documentation for an element contains a &lt;param&gt; tag which is empty and does not contain a description of the parameter.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, fill-in a description of the parameter within the &lt;param&gt; tag.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1614.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementParameterDocumentationMustMatchElementParameters",
        "display_name": "ElementParameterDocumentationMustMatchElementParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The documentation describing the parameters to a C# method, constructor, delegate or indexer element does not match the actual parameters on the element.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementParameterDocumentationMustMatchElementParameters\n\nElementParameterDocumentationMustMatchElementParameters\n|CheckId|SA1612\n\nSA1612\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe documentation describing the parameters to a C# method, constructor, delegate or indexer element does not match the actual parameters on the element.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if the documentation for an element’s parameters does not match the actual parameters on the element, or if the parameter documentation is not listed in the same order as the element’s parameters.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, correct the parameter documentation so that the &lt;param&gt; tags in the documentation appear in the same order as the element’s parameters, and so that there is one &lt;param&gt; tag for each parameter on the element.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1612.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementParametersMustBeDocumented",
        "display_name": "ElementParametersMustBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# method, constructor, delegate or indexer element is missing documentation for one or more of its parameters.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementParametersMustBeDocumented\n\nElementParametersMustBeDocumented\n|CheckId|SA1611\n\nSA1611\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA C# method, constructor, delegate or indexer element is missing documentation for one or more of its parameters.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if an element containing parameters is missing documentation for one or more of its parameters.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in documentation text within a &lt;param&gt; tag for each parameter within the element.<o:p></o:p>\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1611.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementReturnValueDocumentationMustHaveText",
        "display_name": "ElementReturnValueDocumentationMustHaveText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The &lt;returns&gt; tag within a C# element’s documentation header is empty.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementReturnValueDocumentationMustHaveText\n\nElementReturnValueDocumentationMustHaveText\n|CheckId|SA1616\n\nSA1616\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe &lt;returns&gt; tag within a C# element’s documentation header is empty.\n\n## Rule Description \n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if an element contains an empty &lt;returns&gt; tag.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, fill-in documentation text within the &lt;returns&gt; tag describing the value returned from the element.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1616.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementReturnValueMustBeDocumented",
        "display_name": "ElementReturnValueMustBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# element is missing documentation for its return value.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementReturnValueMustBeDocumented\n\nElementReturnValueMustBeDocumented\n|CheckId|SA1615\n\nSA1615\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA C# element is missing documentation for its return value.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if an element containing a return value is missing a &lt;returns&gt; tag.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add and fill-in documentation text within a &lt;returns&gt; tag describing the value returned from the element.<o:p></o:p>\n\nThe following example shows a method with a valid documentation header:<o:p></o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1615.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/ElementsMustBeDocumented",
        "display_name": "ElementsMustBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# code element is missing a documentation header.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementsMustBeDocumented\n\nElementsMustBeDocumented\n|CheckId|SA1600\n\nSA1600\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA C# code element is missing a documentation header.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if an element is completely missing a documentation header, or if the header is empty. In C# the following types of elements can have documentation headers: classes, constructors, delegates, enums, events, finalizers, indexers, interfaces, methods, properties, and structs.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in a documentation header for the element.<o:p></o:p>\n\nthe following example shows a method with a valid documentation header:<o:p></o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name to join.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return firstName + \" \" + lastName;<o:p></o:p>\n\n    }<o:p></o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1600.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/EnumerationItemsMustBeDocumented",
        "display_name": "EnumerationItemsMustBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An item within a C# enumeration is missing an Xml documentation header.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|EnumerationItemsMustBeDocumented\n\nEnumerationItemsMustBeDocumented\n|CheckId|SA1602\n\nSA1602\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nAn item within a C# enumeration is missing an Xml documentation header.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when an item within an enumeration is missing a header. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Types of animals.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public enum Animals<o:p></o:p>\n\n    {<o:p></o:p>\n\n        Dog,<o:p></o:p>\n\n        Cat,<o:p></o:p>\n\n        Horse<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a documentation header for each item within the enum. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Types of animals.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public enum Animals<o:p></o:p>\n\n    {<o:p></o:p>\n\n        /// &lt;summary&gt;<o:p></o:p>\n\n        /// Represents a dog.<o:p></o:p>\n\n        /// &lt;/summary&gt;<o:p></o:p>\n\n        Dog,<o:p></o:p>\n\n<o:p> </o:p>\n\n        /// &lt;summary&gt;<o:p></o:p>\n\n        /// Represents a cat.<o:p></o:p>\n\n        /// &lt;/summary&gt;<o:p></o:p>\n\n        Cat,<o:p></o:p>\n\n<o:p> </o:p>\n\n        /// &lt;summary&gt;<o:p></o:p>\n\n        /// Represents a horse.<o:p></o:p>\n\n        /// &lt;/summary&gt;<o:p></o:p>\n\n        Horse<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1602.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderCompanyNameTextMustMatch",
        "display_name": "FileHeaderCompanyNameTextMustMatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file does not contain the appropriate company name text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderCompanyNameTextMustMatch\n\nFileHeaderCompanyNameTextMustMatch\n|CheckId|SA1641\n\nSA1641\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file does not contain the appropriate company name text.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file does not contain the company name text that has been specified for the project. To enable this rule, navigate to the StyleCop settings for the project and change to the Company Information tab, as shown below:\n\n<img alt=\"\" border=\"0\" src=\"Images/CompanyInformationSettings.JPG\"/>\n\nCheck the checkbox at the top of the settings page, and fill in the required company name text for your company. Click OK to save the settings. With these settings in place, every file within the project must contain the required company name text within its file header copyright tag, as shown in the example below:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add your company’s standard company name text to the file header copyright tag.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1641.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderCopyrightTextMustMatch",
        "display_name": "FileHeaderCopyrightTextMustMatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file does not contain the appropriate copyright text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderCopyrightTextMustMatch\n\nFileHeaderCopyrightTextMustMatch\n|CheckId|SA1636\n\nSA1636\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file does not contain the appropriate copyright text.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file does not contain the copyright text that has been specified for the project. To enable this rule, navigate to the StyleCop settings for the project and change to the Company Information tab, as shown below:\n\n\n\n\n\nCheck the checkbox at the top of the settings page, and fill in the required copyright text for your company. Click OK to save the settings. With these settings in place, every file within the project must contain the required copyright text within its file header copyright tag, as shown in the example below:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add your company’s standard copyright text to the file header copyright tag.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1636.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderFileNameDocumentationMustMatchFileName",
        "display_name": "FileHeaderFileNameDocumentationMustMatchFileName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file tag within the file header at the top of a C# code file does not contain the name of the file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderFileNameDocumentationMustMatchFileName\n\nFileHeaderFileNameDocumentationMustMatchFileName\n|CheckId|SA1638\n\nSA1638\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file tag within the file header at the top of a C# code file does not contain the name of the file.\n\n## Rule Description\n\nA violation of this rule occurs when the file tag within the file header at the top of a C# file does not contain the name of the file. For example, consider a C# source file named File1.cs, with the following header:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"File2.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nA violation of this rule would occur, since the file tag does not contain the \n                    correct name of the file. The header should be written as:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"File1.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add the name of the file to the file tag.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1638.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderFileNameDocumentationMustMatchTypeName",
        "display_name": "FileHeaderFileNameDocumentationMustMatchTypeName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file tag within the file header at the top of a C# code file does not match the first type declared in the file. For generics that are defined as Class1&lt;T&gt; \n                    the name of the file needs to be Class1{T}.cs and this should appear in the header also. Partial classes are ignored.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderFileNameDocumentationMustMatchTypeName\n\nFileHeaderFileNameDocumentationMustMatchTypeName\n|CheckId|SA1649\n\nSA1649\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file tag within the file header at the top of a C# code file does not match the first type declared in the file. For generics that are defined as Class1&lt;T&gt; \n                    the name of the file needs to be Class1{T}.cs and this should appear in the header also. Partial classes are ignored.\n\n## Rule Description\n\nA violation of this rule occurs when the file tag within the file header at the top of a C# file does not contain the name of the first type in the file. For example, consider a C# source file named \n                    Class1.cs, with the following header:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"ThisIsNotTheCorrectTypeName.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n    public\nclass Class1\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n\n\nA violation of this rule would occur, since the file tag does not contain the correct name of the first type in the file. The header should be written as:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Class1.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n    public\nclass Class1\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n<o:p> </o:p>\n\nA generic class should be written as:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Class1{T}.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n    public\nclass\nClass1&lt;T&gt;\n\n    {<o:p></o:p>\n\n\n<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add the name of the first type from the file to the file tag.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1649.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderMustContainFileName",
        "display_name": "FileHeaderMustContainFileName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file is missing the file name.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderMustContainFileName\n\nFileHeaderMustContainFileName\n|CheckId|SA1637\n\nSA1637\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file is missing the file name.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file does not contain a valid file name tag. For example:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nA file header should include a file tag containing the name of the file, as follows:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a file tag containing the name of the file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1637.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderMustHaveCopyrightText",
        "display_name": "FileHeaderMustHaveCopyrightText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file is missing copyright text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderMustHaveCopyrightText\n\nFileHeaderMustHaveCopyrightText\n|CheckId|SA1635\n\nSA1635\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file is missing copyright text.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file does not contain text within its copyright tag. For example:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"Sprocket Enterprises\"&gt;<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n<o:p> </o:p>\n\nA file header should include copyright text, as follows:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"Sprocket Enterprises\"&gt;<o:p></o:p>\n\n//     Copyright (c) Sprocket Enterprises. All rights reserved.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add your company’s standard copyright text to the copyright tag.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1635.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderMustHaveSummary",
        "display_name": "FileHeaderMustHaveSummary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file does not contain a filled-in summary tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderMustHaveSummary\n\nFileHeaderMustHaveSummary\n|CheckId|SA1639\n\nSA1639\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file does not contain a filled-in summary tag.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file does not contain a valid summary tag. This rule is disabled by default.\n\nFor example:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nIf this rule is enabled, the file header should contain a summary tag. For example:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n// &lt;summary&gt;This is the Widget class.&lt;/summary&gt;\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add and fill-in a summary tag describing the contents of the file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1639.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderMustHaveValidCompanyText",
        "display_name": "FileHeaderMustHaveValidCompanyText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file does not contain company name text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderMustHaveValidCompanyText\n\nFileHeaderMustHaveValidCompanyText\n|CheckId|SA1640\n\nSA1640\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file does not contain company name text.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file does not contain a company tag with company name text. For example:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nThe company attribute should have text in it. For example:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add and fill-in a company attribute containing the name of the company.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1640.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileHeaderMustShowCopyright",
        "display_name": "FileHeaderMustShowCopyright",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The file header at the top of a C# code file is missing a copyright tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileHeaderMustShowCopyright\n\nFileHeaderMustShowCopyright\n|CheckId|SA1634\n\nSA1634\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe file header at the top of a C# code file is missing a copyright tag.\n\n## Rule Description\n\nA violation of this rule occurs when the file header at the top of a C# file is missing a copyright tag. For example:\n\n <o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n//&lt;Tag&gt;A fileheader which does not contain a copyright tag&lt;/Tag&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nA file header should include a copyright tag, as follows:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"My Company\"&gt;<o:p></o:p>\n\n//     Custom company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a standard copyright tag to the file header.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1634.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/FileMustHaveHeader",
        "display_name": "FileMustHaveHeader",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# code file is missing a standard file header.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileMustHaveHeader\n\nFileMustHaveHeader\n|CheckId|SA1633\n\nSA1633\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA C# code file is missing a standard file header.\n\n## Rule Description\n\nA violation of this rule occurs when a C# source file is missing a file header. The file header must begin on the first line of the file, and must be formatted as a block of comments containing Xml, as follows:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"NameOfFile.cs\" company=\"CompanyName\"&gt;<o:p></o:p>\n\n//     Company copyright tag.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nFor example, a file called Widget.cs from a fictional company called Sprocket Enterprises should contain a file header similar to the following:\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"Sprocket Enterprises\"&gt;<o:p></o:p>\n\n//     Copyright (c) Sprocket Enterprises. All rights reserved.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nThe dashed lines at the top and bottom of the header are not strictly necessary, so the header could be written as:\n\n// &lt;copyright file=\"Widget.cs\" company=\"Sprocket Enterprises\"&gt;<o:p></o:p>\n\n//     Copyright (c) Sprocket Enterprises. All rights reserved.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n\n\nIt is possible to add additional tags, although they will not be checked or enforced by StyleCop:<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n// &lt;copyright file=\"Widget.cs\" company=\"Sprocket Enterprises\"&gt;<o:p></o:p>\n\n//     Copyright (c) Sprocket Enterprises. All rights reserved.<o:p></o:p>\n\n// &lt;/copyright&gt;<o:p></o:p>\n\n// &lt;author&gt;John Doe&lt;/author&gt;<o:p></o:p>\n\n//-----------------------------------------------------------------------<o:p></o:p>\n\n\n\nA file that is completely auto-generated by a tool, and which should not be checked or enforced by StyleCop, can include an “auto-generated” header rather than the standard file header. This will cause StyleCop to ignore the file. This type of header should never be placed on top of a manually written code file.\n\n// &lt;auto-generated /&gt;<o:p></o:p>\n\nnamespace Sample.Something<o:p></o:p>\n\n{<o:p></o:p>\n\n    // The contents of this file are completely auto-generated by a tool.<o:p></o:p>\n\n}<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a standard file header at the top of the file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1633.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/GenericTypeParameterDocumentationMustDeclareParameterName",
        "display_name": "GenericTypeParameterDocumentationMustDeclareParameterName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A &lt;typeparam&gt; tag within the Xml header documentation for a generic C# element is missing a name attribute, or contains an empty name attribute.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|GenericTypeParameterDocumentationMustDeclareParameterName\n\nGenericTypeParameterDocumentationMustDeclareParameterName\n|CheckId|SA1621\n\nSA1621\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA &lt;typeparam&gt; tag within the Xml header documentation for a generic C# element is missing a name attribute, or contains an empty name attribute.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if the element contains a &lt;typeparam&gt; tag within its Xml header documentation which does not declare the name of the type parameter.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in the name attribute for each &lt;typeparam&gt; tag, indicating the name of the type parameter that the documentation is for.<o:p></o:p>\n\nThe following example shows a method with a valid documentation header:<o:p></o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// A sample generic class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"S\"&gt;The first generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"T\"&gt;The second generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    public class Class1&lt;S, T&gt;<o:p></o:p>\n\n    { <o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1621.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/GenericTypeParameterDocumentationMustHaveText",
        "display_name": "GenericTypeParameterDocumentationMustHaveText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A &lt;typeparam&gt; tag within the Xml header documentation for a generic C# element is empty.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|GenericTypeParameterDocumentationMustHaveText\n\nGenericTypeParameterDocumentationMustHaveText\n|CheckId|SA1622\n\nSA1622\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA &lt;typeparam&gt; tag within the Xml header documentation for a generic C# element is empty.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if the element contains an empty &lt;typeparam&gt; tag within its Xml header documentation.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, fill-in each &lt;typeparam&gt; tag within a description of the generic type parameter.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// A sample generic class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"S\"&gt;The first generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"T\"&gt;The second generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    public class Class1&lt;S, T&gt;<o:p></o:p>\n\n    { <o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1622.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/GenericTypeParameterDocumentationMustMatchTypeParameters",
        "display_name": "GenericTypeParameterDocumentationMustMatchTypeParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The &lt;typeparam&gt; tags within the Xml header documentation for a generic C# element do not match the generic type parameters on the element.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|GenericTypeParameterDocumentationMustMatchTypeParameters\n\nGenericTypeParameterDocumentationMustMatchTypeParameters\n|CheckId|SA1620\n\nSA1620\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe &lt;typeparam&gt; tags within the Xml header documentation for a generic C# element do not match the generic type parameters on the element.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if the &lt;typeparam&gt; tags within the element’s header documentation do not match the generic type parameters on the element, or do not appear in the same order as the element’s type parameters.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add and fill-in one &lt;typeparam&gt; tag for each generic type parameter on the element, and make sure that the &lt;typeparam&gt; tags appear in the same order as the element’s type parameters.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// A sample generic class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"S\"&gt;The first generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"T\"&gt;The second generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    public class Class1&lt;S, T&gt;<o:p></o:p>\n\n    { <o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1620.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/GenericTypeParametersMustBeDocumented",
        "display_name": "GenericTypeParametersMustBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A generic C# element is missing documentation for one or more of its generic type parameters.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|GenericTypeParametersMustBeDocumented\n\nGenericTypeParametersMustBeDocumented\n|CheckId|SA1618\n\nSA1618\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA generic C# element is missing documentation for one or more of its generic type parameters.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if an element containing generic type parameters is missing documentation for one or more of its generic type parameters.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in documentation text within a &lt;typeparam&gt; tag for each generic type parameter on the element.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// A sample generic class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"S\"&gt;The first generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"T\"&gt;The second generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    public class Class1&lt;S, T&gt;<o:p></o:p>\n\n    { <o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1618.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/GenericTypeParametersMustBeDocumentedPartialClass",
        "display_name": "GenericTypeParametersMustBeDocumentedPartialClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A generic, partial C# element is missing documentation for one or more of its generic type parameters, and the documentation for the element contains a &lt;summary&gt; tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|GenericTypeParametersMustBeDocumentedPartialClass\n\nGenericTypeParametersMustBeDocumentedPartialClass\n|CheckId|SA1619\n\nSA1619\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA generic, partial C# element is missing documentation for one or more of its generic type parameters, and the documentation for the element contains a &lt;summary&gt; tag.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when a generic, partial element is missing documentation for one or more of its generic type parameters, and the documentation for the element contains a &lt;summary&gt; tag rather than a &lt;content&gt; tag.\n\nWhen documentation is provided on more than one part of the partial class, the documentation for the two classes may be merged together to form a single source of documentation. For example, consider the following two parts of a partial class:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the first part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the second part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThese two different parts of the same partial class each provide different documentation for the class. When the documentation for this class is built into an SDK, the tool building the documentation will either choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it may merge the two sources of documentation together, to form a string like: “Documentation for the first part of Class1. Documentation for the second part of Class1.”\n\nFor these reasons, it can be problematic to provide SDK documentation on more than one part of the partial class. However, it is still advisable to document each part of the class, to increase the readability and maintainability of the code, and StyleCop will require that each part of the class contain header documentation.\n\nThis problem is solved through the use of the &lt;content&gt; tag, which can replace the &lt;summary&gt; tag for partial classes. The recommended practice for documenting partial classes is to provide the official SDK documentation for the class on the main part of the partial class. This documentation should be written using the standard &lt;summary&gt; tag. All other parts of the partial class should omit the &lt;summary&gt; tag completely, and replace it with a &lt;content&gt; tag. This allows the developer to document all parts of the partial class while still centralizing all of the official SDK documentation for the class onto one part of the class. The &lt;content&gt; tags will be ignored by the SDK documentation tools.\n\nWhen a generic element contains a &lt;summary&gt; tag within its documentation header, StyleCop assumes that this is the main part of the class, and requires the header to contain &lt;typeparam&gt; tags for each of the generic type parameters on the class. However, if the documentation header for the class contains a &lt;content&gt; tag rather than a &lt;summary&gt; tag, StyleCop will assume that the generic type parameters are defined on another part of the class, and will not require &lt;typeparam&gt; tags on this part of the class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in documentation text within a &lt;typeparam&gt; tag for each generic type parameter on the element, or change the &lt;summary&gt; tag to a &lt;content&gt; tag if this is not the main part of the partial class.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// A sample generic class.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"S\"&gt;The first generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    /// &lt;typeparam name=\"T\"&gt;The second generic type parameter.&lt;/typeparam&gt;<o:p></o:p>\n\n    public class Class1&lt;S, T&gt;<o:p></o:p>\n\n    { <o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1619.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/IncludedDocumentationFileDoesNotExist",
        "display_name": "IncludedDocumentationFileDoesNotExist",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An included Xml documentation file does not exist.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|IncludedDocumentationFileDoesNotExist\n\nIncludedDocumentationFileDoesNotExist\n|CheckId|SA1645\n\nSA1645\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nAn included Xml documentation file does not exist.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx.](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx)\n\nAs an alternative to authoring documentation directly within the code file, it is possible to place documentation for multiple elements within a separate Xml file, and then reference a section of that file within an element's documentation header. This causes the compiler to import the documentation for that element from the included document. For example:\n\n    /// &lt;include file=\"IncludedDocumentation.xml\" path=\"root/EnabledMethodDocs\" /&gt;\n\n    public bool Enabled(bool true)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }\n\n<o:p></o:p> \n\nA violation of this rule occurs when the included file does not exist at the given location, or cannot be loaded.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, correct the path to the included documentation file to point to a valid file location.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1645.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/IncludedDocumentationXPathDoesNotExist",
        "display_name": "IncludedDocumentationXPathDoesNotExist",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An included Xml documentation link contains an invalid path.<o:p></o:p>",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|IncludedDocumentationXPathDoesNotExist\n\nIncludedDocumentationXPathDoesNotExist\n|CheckId|SA1646\n\nSA1646\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nAn included Xml documentation link contains an invalid path.<o:p></o:p>\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx.](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx)\n\nAs an alternative to authoring documentation directly within the code file, it is possible to place documentation for multiple elements within a separate Xml file, and then reference a section of that file within an element's documentation header. This causes the compiler to import the documentation for that element from the included document. For example:\n\n    /// &lt;include file=\"IncludedDocumentation.xml\" path=\"root/EnabledMethodDocs\" /&gt;\n\n    public bool Enabled(bool true)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }\n\n<o:p></o:p> \n\nA violation of this rule occurs when the path attribute does not link to a valid path within the included documentation file.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, correct the value of the path attribute to point to a valid path within the file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1646.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/IncludeNodeDoesNotContainValidFileAndPath",
        "display_name": "IncludeNodeDoesNotContainValidFileAndPath",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An include tag within an Xml documentation header does not contain valid file and path attribute.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|IncludeNodeDoesNotContainValidFileAndPath\n\nIncludeNodeDoesNotContainValidFileAndPath\n|CheckId|SA1647\n\nSA1647\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nAn include tag within an Xml documentation header does not contain valid file and path attribute.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx.](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx)\n\nAs an alternative to authoring documentation directly within the code file, it is possible to place documentation for multiple elements within a separate Xml file, and then reference a section of that file within an element's documentation header. This causes the compiler to import the documentation for that element from the included document. For example:\n\n    /// &lt;include file=\"IncludedDocumentation.xml\" path=\"root/EnabledMethodDocs\" /&gt;\n\n    public bool Enabled(bool true)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }\n\n<o:p></o:p> \n\nA violation of this rule occurs when the include tag is missing a file or path attribute, or contains an improperly formatted file or path attribute.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or correct the file and path attributes.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1647.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/InheritDocMustBeUsedWithInheritingClass",
        "display_name": "InheritDocMustBeUsedWithInheritingClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "&lt;inheritdoc&gt; has been used on an element that doesnt inherit from a base class or implement an interface..",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|InheritDocMustBeUsedWithInheritingClass\n\nInheritDocMustBeUsedWithInheritingClass\n|CheckId|SA1648\n\nSA1648\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\n&lt;inheritdoc&gt; has been used on an element that doesnt inherit from a base class or implement an interface..\n\n## Rule Description\n\nVerifies that an 'inheritdoc' tag is not used when the class or interface does not inherit from a base class or interface.\n\nA violation of this rule occurs when the element having the inheritdoc tag doesn't inherit from a base case or implement an interface.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the &lt;inheritdoc&gt; tag and document the element appropriately.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1648.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PartialElementDocumentationMustHaveSummary",
        "display_name": "PartialElementDocumentationMustHaveSummary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The &lt;summary&gt; or &lt;content&gt; tag within the documentation header for a C# code element is missing or empty.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PartialElementDocumentationMustHaveSummary\n\nPartialElementDocumentationMustHaveSummary\n|CheckId|SA1605\n\nSA1605\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe &lt;summary&gt; or &lt;content&gt; tag within the documentation header for a C# code element is missing or empty.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the documentation header for a partial element (an element with the partial attribute) is missing a &lt;summary&gt; or &lt;content&gt; tag, or contains an empty &lt;summary&gt; or &lt;content&gt; tag which does not contain a description of the element. In C# the following types of elements can be attributed with the partial attribute: classes, methods.\n\nWhen documentation is provided on more than one part of the partial class, the documentation for the two classes may be merged together to form a single source of documentation. For example, consider the following two parts of a partial class:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the first part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the second part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThese two different parts of the same partial class each provide different documentation for the class. When the documentation for this class is built into an SDK, the tool building the documentation will either choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it may merge the two sources of documentation together, to form a string like: “Documentation for the first part of Class1. Documentation for the second part of Class1.”\n\nFor these reasons, it can be problematic to provide SDK documentation on more than one part of the partial class. However, it is still advisable to document each part of the class, to increase the readability and maintainability of the code, and StyleCop will require that each part of the class contain header documentation.\n\nThis problem is solved through the use of the &lt;content&gt; tag, which can replace the &lt;summary&gt; tag for partial classes. The recommended practice for documenting partial classes is to provide the official SDK documentation for the class on the main part of the partial class. This documentation should be written using the standard &lt;summary&gt; tag. All other parts of the partial class should omit the &lt;summary&gt; tag completely, and replace it with a &lt;content&gt; tag. This allows the developer to document all parts of the partial class while still centralizing all of the official SDK documentation for the class onto one part of the class. The &lt;content&gt; tags will be ignored by the SDK documentation tools.\n\n## How to Fix Violations\n\n<a name=\"sectionToggle2\"></a>To fix a violation of this rule, add and fill-in a &lt;summary&gt; or &lt;content&gt; tag with a description of the code element.<o:p></o:p>\n\n<a name=\"codeExampleToggle\"></a>The following example shows a partial class with a fill-in &lt;summary&gt; tag.<o:p></o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Represents a customer in the database.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Customer<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1605.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PartialElementDocumentationMustHaveSummaryText",
        "display_name": "PartialElementDocumentationMustHaveSummaryText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The &lt;summary&gt; or &lt;content&gt; tag within the documentation header for a C# code element is empty.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PartialElementDocumentationMustHaveSummaryText\n\nPartialElementDocumentationMustHaveSummaryText\n|CheckId|SA1607\n\nSA1607\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe &lt;summary&gt; or &lt;content&gt; tag within the documentation header for a C# code element is empty.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when the documentation header for a partial element (an element with the partial attribute) contains an empty &lt;summary&gt; tag or &lt;content&gt; tag which does not contain a description of the element. In C# the following types of elements can be attributed with the partial attribute: classes, methods.\n\nWhen documentation is provided on more than one part of the partial class, the documentation for the two classes may be merged together to form a single source of documentation. For example, consider the following two parts of a partial class:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the first part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the second part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThese two different parts of the same partial class each provide different documentation for the class. When the documentation for this class is built into an SDK, the tool building the documentation will either choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it may merge the two sources of documentation together, to form a string like: “Documentation for the first part of Class1. Documentation for the second part of Class1.”\n\nFor these reasons, it can be problematic to provide SDK documentation on more than one part of the partial class. However, it is still advisable to document each part of the class, to increase the readability and maintainability of the code, and StyleCop will require that each part of the class contain header documentation.\n\nThis problem is solved through the use of the &lt;content&gt; tag, which can replace the &lt;summary&gt; tag for partial classes. The recommended practice for documenting partial classes is to provide the official SDK documentation for the class on the main part of the partial class. This documentation should be written using the standard &lt;summary&gt; tag. All other parts of the partial class should omit the &lt;summary&gt; tag completely, and replace it with a &lt;content&gt; tag. This allows the developer to document all parts of the partial class while still centralizing all of the official SDK documentation for the class onto one part of the class. The &lt;content&gt; tags will be ignored by the SDK documentation tools.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, fill-in the contents of the summary tag or content tag with a description of the code element.\n\nThe following example shows a method which contains an empty &lt;summary&gt; tag.\n\n/// &lt;summary&gt;  &lt;/summary&gt;<o:p></o:p>\n\n/// &lt;param name=\"customerId\"&gt;The ID of the customer to find.&lt;/param&gt;<o:p></o:p>\n\n/// &lt;returns&gt;The customer, or null if the customer could not be found.&lt;/returns&gt;<o:p></o:p>\n\npublic Customer FindCustomer(int customerId)<o:p></o:p>\n\n{<o:p></o:p>\n\n    // ... finds the customer ...<o:p></o:p>\n\n}\n\n \n\n<font face=\"Verdana\">To fix the violation, add valid summary text. For example: </font>\n\n<a name=\"codeExampleToggle\"></a><font face=\"Verdana\"></font>\n\n/// &lt;summary&gt;Attempts to locate a record for the customer with the given ID.&lt;/summary&gt;<o:p></o:p>\n\n/// &lt;param name=\"customerId\"&gt;The ID of the customer to find.&lt;/param&gt;<o:p></o:p>\n\n/// &lt;returns&gt;The customer, or null if the customer could not be found.&lt;/returns&gt;<o:p></o:p>\n\npublic Customer FindCustomer(int customerId)<o:p></o:p>\n\n{<o:p></o:p>\n\n    // ... finds the customer ...<o:p></o:p>\n\n}\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1607.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PartialElementsMustBeDocumented",
        "display_name": "PartialElementsMustBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# partial element is missing a documentation header.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PartialElementsMustBeDocumented\n\nPartialElementsMustBeDocumented\n|CheckId|SA1601\n\nSA1601\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA C# partial element is missing a documentation header.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if a partial element (an element with the partial attribute) is completely missing a documentation header, or if the header is empty. In C# the following types of elements can be attributed with the partial attribute: classes, methods.\n\nWhen documentation is provided on more than one part of the partial class, the documentation for the two classes may be merged together to form a single source of documentation. For example, consider the following two parts of a partial class:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the first part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Documentation for the second part of Class1.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Class1<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThese two different parts of the same partial class each provide different documentation for the class. When the documentation for this class is built into an SDK, the tool building the documentation will either choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it may merge the two sources of documentation together, to form a string like: “Documentation for the first part of Class1. Documentation for the second part of Class1.”\n\nFor these reasons, it can be problematic to provide SDK documentation on more than one part of the partial class. However, it is still advisable to document each part of the class, to increase the readability and maintainability of the code, and StyleCop will require that each part of the class contain header documentation.\n\nThis problem is solved through the use of the &lt;content&gt; tag, which can replace the &lt;summary&gt; tag for partial classes. The recommended practice for documenting partial classes is to provide the official SDK documentation for the class on the main part of the partial class. This documentation should be written using the standard &lt;summary&gt; tag. All other parts of the partial class should omit the &lt;summary&gt; tag completely, and replace it with a &lt;content&gt; tag. This allows the developer to document all parts of the partial class while still centralizing all of the official SDK documentation for the class onto one part of the class. The &lt;content&gt; tags will be ignored by the SDK documentation tools.<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or fill-in a documentation header for the element.\n\nFor example, the following example shows two parts of a partial class, one containing a &lt;summary&gt; header and another containing a &lt;content&gt; header.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Represents a customer in the database.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Customer<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    /// &lt;content&gt;<o:p></o:p>\n\n    /// Contains auto-generated functionality for the Customer class.<o:p></o:p>\n\n    /// &lt;/content&gt;<o:p></o:p>\n\n    public partial class Customer<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1601.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PropertyDocumentationMustHaveValue",
        "display_name": "PropertyDocumentationMustHaveValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml header documentation for a C# property does not contain a &lt;value&gt; tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PropertyDocumentationMustHaveValue\n\nPropertyDocumentationMustHaveValue\n|CheckId|SA1609\n\nSA1609\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml header documentation for a C# property does not contain a &lt;value&gt; tag.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nThe documentation for properties may include a &lt;value&gt; tag, which describes the value held by the property.\n\nA violation of this rule occurs when the &lt;value&gt; tag for a property is missing.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add and fill-in a &lt;value&gt; tag within the documentation header for the property.\n\nThe following example shows a property which contains a &lt;value&gt; tag within its documentation header.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets the name of the customer. <o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;value&gt;The name of the customer.&lt;/value&gt;<o:p></o:p>\n\n    public bool Name<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.name; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1609.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PropertyDocumentationMustHaveValueText",
        "display_name": "PropertyDocumentationMustHaveValueText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Xml header documentation for a C# property contains an empty &lt;value&gt; tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PropertyDocumentationMustHaveValueText\n\nPropertyDocumentationMustHaveValueText\n|CheckId|SA1610\n\nSA1610\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe Xml header documentation for a C# property contains an empty &lt;value&gt; tag.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nThe documentation for properties may include a &lt;value&gt; tag, which describes the value held by the property.\n\nA violation of this rule occurs when the &lt;value&gt; tag for a property is empty.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, fill-in a description of the value held by the property within the &lt;value&gt; tag.\n\nExample:\n\nThe following example shows a property which contains a &lt;value&gt; tag within its documentation header.\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets the name of the customer. <o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;value&gt;The name of the customer.&lt;/value&gt;<o:p></o:p>\n\n    public bool Name<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.name; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1610.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PropertySummaryDocumentationMustMatchAccessors",
        "display_name": "PropertySummaryDocumentationMustMatchAccessors",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The documentation text within a C# property’s &lt;summary&gt; tag does not match the accessors within the property.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PropertySummaryDocumentationMustMatchAccessors\n\nPropertySummaryDocumentationMustMatchAccessors\n|CheckId|SA1623\n\nSA1623\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe documentation text within a C# property’s &lt;summary&gt; tag does not match the accessors within the property.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if a property’s summary documentation does not match the accessors within the property.\n\nThe property’s summary text must begin with wording describing the types of accessors exposed within the property. If the property contains only a get accessor, the summary must begin with the word “Gets”. If the property contains only a set accessor, the summary must begin with the word “Sets”. If the property exposes both a get and set accessor, the summary text must begin with “Gets or sets”.\n\nFor example, consider the following property, which exposes both a get and set accessor. The summary text begins with the words “Gets or sets”.\n\n<font size=\"2\">    /// &lt;summary&gt;<o:p></o:p></font>\n\n    /// Gets or sets the name of the customer. <o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public string Name<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.name; }<o:p></o:p>\n\n        set { this.name = value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIf the property returns a Boolean value, an additional rule is applied. The summary text for Boolean properties must contain the words “Gets a value indicating whether”, “Sets a value indicating whether”, or “Gets or sets a value indicating whether”. For example, consider the following Boolean property, which only exposes a get accessor:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets a value indicating whether the item is enabled.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.enabled; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIn some situations, the set accessor for a property can have more restricted access than the get accessor. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets the name of the customer. <o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public string Name<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.name; }<o:p></o:p>\n\n        private set { this.name = value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIn this example, the set accessor has been given private access, meaning that it can only be accessed by local members of the class in which it is contained. The get accessor, however, inherits its access from the parent property, thus it can be accessed by any caller, since the property has public access.\n\n&gt;In this case, the documentation summary text should avoid referring to the set accessor, since it is not visible to external callers.\n\nStyleCop applies a series of rules to determine when the set accessor should be referenced in the property’s summary documentation. In general, these rules require the set accessor to be referenced whenever it is visible to the same set of callers as the get accessor, or whenever it is visible to external classes or inheriting classes.\n\nThe specific rules for determining whether to include the set accessor in the property’s summary documentation are:\n\n\n\n1. The set accessor has the same access level as the get accessor. For example:\n\n       /// &lt;summary&gt;<o:p></o:p>\n\n/// Gets or sets the name of the customer. <o:p></o:p>\n\n       /// &lt;/summary&gt;<o:p></o:p>\n\n       protected string Name<o:p></o:p>\n\n       {<o:p></o:p>\n\n           get { return this.name; }<o:p></o:p>\n\n    set { this.name = value; }<o:p></o:p>\n\n       }<o:p></o:p>\n\n\n\n2. The property is only internally accessible within the assembly, and the set accessor also has internal access. For example:\n\n       internal class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n           /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets or sets the name of the customer. <o:p></o:p>\n\n           /// &lt;/summary&gt;<o:p></o:p>\n\n           protected string Name<o:p></o:p>\n\n           {<o:p></o:p>\n\n               get { return this.name; }<o:p></o:p>\n\n        internal set { this.name = value; }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n<o:p> </o:p>\n\n       internal class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n\n\n    {<o:p></o:p>\n\n               /// &lt;summary&gt;<o:p></o:p>\n\n        /// Gets or sets the name of the customer. <o:p></o:p>\n\n               /// &lt;/summary&gt;<o:p></o:p>\n\n               public string Name<o:p></o:p>\n\n               {<o:p></o:p>\n\n                   get { return this.name; }<o:p></o:p>\n\n            internal set { this.name = value; }<o:p></o:p>\n\n               }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n\n\n3. The property is private or is contained beneath a private class, and the set accessor has any access modifier other than private. In the example below, the access modifier declared on the set accessor has no meaning, since the set accessor is contained within a private class and thus cannot be seen by other classes outside of Class1. This effectively gives the set accessor the same access level as the get accessor.\n\n<o:p></o:p>\n\npublic class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n    private class Class2<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public class Class3<o:p></o:p>\n\n        {<o:p></o:p>\n\n                   /// &lt;summary&gt;<o:p></o:p>\n\n            /// Gets or sets the name of the customer. <o:p></o:p>\n\n                   /// &lt;/summary&gt;<o:p></o:p>\n\n                   public string Name<o:p></o:p>\n\n                   {<o:p></o:p>\n\n                       get { return this.name; }<o:p></o:p>\n\n                internal set { this.name = value; }<o:p></o:p>\n\n                   }<o:p></o:p>\n\n               }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n\n\n4. Whenever the set accessor has protected or protected internal access, it should be referenced in the documentation. A protected or protected internal set accessor can always been seen by a class inheriting from the class containing the property.\n\n<o:p></o:p>\n\ninternal class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n    public class Class2<o:p></o:p>\n\n    {<o:p></o:p>\n\n               /// &lt;summary&gt;<o:p></o:p>\n\n        /// Gets or sets the name of the customer. <o:p></o:p>\n\n               /// &lt;/summary&gt;<o:p></o:p>\n\n               internal string Name<o:p></o:p>\n\n               {<o:p></o:p>\n\n                   get { return this.name; }<o:p></o:p>\n\n            protected set { this.name = value; }<o:p></o:p>\n\n               }<o:p></o:p>\n\n           }<o:p></o:p>\n\n           <o:p></o:p>\n\n           private class Class3 : Class2<o:p></o:p>\n\n           {<o:p></o:p>\n\n               public Class3(string name) { this.Name = name; }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n<o:p> </o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, update the property’s summary text so that the description begins with the proper wording, depending upon the type of the property and the types of accessors within the property.\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1623.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/PropertySummaryDocumentationMustOmitSetAccessorWithRestrictedAccess",
        "display_name": "PropertySummaryDocumentationOmitSetAccessorWithRestrictedAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The documentation text within a C# property’s &lt;summary&gt; tag takes into account all of the accessors within the property, but one of the accessors has limited access.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PropertySummaryDocumentationMustOmitSetAccessorWithRestrictedAccess\n\nPropertySummaryDocumentationMustOmitSetAccessorWithRestrictedAccess\n|CheckId|SA1624\n\nSA1624\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe documentation text within a C# property’s &lt;summary&gt; tag takes into account all of the accessors within the property, but one of the accessors has limited access.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs when one of the accessors within the property has limited access (usually the set accessor), but the summary documentation text for the property still refers to both accessors.\n\nNormally, a property’s summary text must begin with wording describing the types of accessors exposed within the property. If the property contains only a get accessor, the summary must begin with the word “Gets”. If the property contains only a set accessor, the summary must begin with the word “Sets”. If the property exposes both a get and set accessor, the summary text must begin with “Gets or sets”.\n\nHowever, when an accessor within the property is given an access level which is more limited than the access level of the property, this accessor should be omitted from the summary documentation. <br/><br/>It can sometimes be non-obvious whether the set accessor within a property is actually less accessible than the get accessor. For example, consider the case where a public property is contained within an internal class, and the set accessor is given internal accessor. In effect, both the get and set accessors have the same access level. In this case, the summary documentation should refer to both the get and set accessors, since they effectively have the same access level.\n\nIn some situations, the set accessor for a property can have more restricted access than the get accessor. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets the name of the customer. <o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public string Name<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.name; }<o:p></o:p>\n\n        private set { this.name = value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n<font face=\"Verdana\"><font size=\"2\">In this example, the set accessor has been given private access, meaning that it can only be accessed by local members of the class in which it is contained. The get accessor, however, inherits its access from the parent property, thus it can be accessed by any caller, since the property has public access.<o:p></o:p></font></font>\n\n<font face=\"Verdana\"><font size=\"2\">In this case, the documentation summary text should avoid referring to the set accessor, since it is not visible to external callers.<o:p></o:p></font></font>\n\n<font face=\"Verdana\"><font size=\"2\">StyleCop applies a series of rules to determine when the set accessor should be referenced in the property’s summary documentation. In general, these rules require the set accessor to be referenced whenever it is visible to the same set of callers as the get accessor, or whenever it is visible to external classes or inheriting classes. <o:p></o:p></font></font>\n\n<font face=\"Verdana\"><font size=\"2\">The specific rules for determining whether to include the set accessor in the property’s summary documentation are:<o:p></o:p></font></font>\n\n1. The set accessor has the same access level as the get accessor. For example:\n\n       /// &lt;summary&gt;<o:p></o:p>\n\n/// Gets or sets the name of the customer. <o:p></o:p>\n\n       /// &lt;/summary&gt;<o:p></o:p>\n\n       protected string Name<o:p></o:p>\n\n       {<o:p></o:p>\n\n           get { return this.name; }<o:p></o:p>\n\n    set { this.name = value; }<o:p></o:p>\n\n       }<o:p></o:p>\n\n<o:p> </o:p>\n\n2. The property is only internally accessible within the assembly, and the set accessor also has internal access. For example:\n\n       internal class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n           /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets or sets the name of the customer. <o:p></o:p>\n\n           /// &lt;/summary&gt;<o:p></o:p>\n\n           protected string Name<o:p></o:p>\n\n           {<o:p></o:p>\n\n               get { return this.name; }<o:p></o:p>\n\n        internal set { this.name = value; }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n<o:p> </o:p>\n\n       internal class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n\n\n    {<o:p></o:p>\n\n               /// &lt;summary&gt;<o:p></o:p>\n\n        /// Gets or sets the name of the customer. <o:p></o:p>\n\n               /// &lt;/summary&gt;<o:p></o:p>\n\n               public string Name<o:p></o:p>\n\n               {<o:p></o:p>\n\n                   get { return this.name; }<o:p></o:p>\n\n            internal set { this.name = value; }<o:p></o:p>\n\n               }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n<o:p> </o:p>\n\n3. The property is private or is contained beneath a private class, and the set accessor has any access modifier other than private. In the example below, the access modifier declared on the set accessor has no meaning, since the set accessor is contained within a private class and thus cannot be seen by other classes outside of Class1. This effectively gives the set accessor the same access level as the get accessor.\n\n<o:p></o:p>\n\npublic class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n    private class Class2<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public class Class3<o:p></o:p>\n\n        {<o:p></o:p>\n\n                   /// &lt;summary&gt;<o:p></o:p>\n\n            /// Gets or sets the name of the customer. <o:p></o:p>\n\n                   /// &lt;/summary&gt;<o:p></o:p>\n\n                   public string Name<o:p></o:p>\n\n                   {<o:p></o:p>\n\n                       get { return this.name; }<o:p></o:p>\n\n                internal set { this.name = value; }<o:p></o:p>\n\n                   }<o:p></o:p>\n\n               }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n<o:p> </o:p>\n\n4. Whenever the set accessor has protected or protected internal access, it should be referenced in the documentation. A protected or protected internal set accessor can always been seen by a class inheriting from the class containing the property.\n\n<o:p></o:p>\n\ninternal class Class1<o:p></o:p>\n\n{<o:p></o:p>\n\n    public class Class2<o:p></o:p>\n\n    {<o:p></o:p>\n\n               /// &lt;summary&gt;<o:p></o:p>\n\n        /// Gets or sets the name of the customer. <o:p></o:p>\n\n               /// &lt;/summary&gt;<o:p></o:p>\n\n               internal string Name<o:p></o:p>\n\n               {<o:p></o:p>\n\n                   get { return this.name; }<o:p></o:p>\n\n            protected set { this.name = value; }<o:p></o:p>\n\n               }<o:p></o:p>\n\n           }<o:p></o:p>\n\n           <o:p></o:p>\n\n           private class Class3 : Class2<o:p></o:p>\n\n           {<o:p></o:p>\n\n               public Class3(string name) { this.Name = name; }<o:p></o:p>\n\n           }<o:p></o:p>\n\n       }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, update the property’s summary text and remove wording which refers to the limited access accessor.<o:p></o:p>\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1624.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/SingleLineCommentsMustNotUseDocumentationStyleSlashes",
        "display_name": "SingleLineCommentsMustNotUseDocumentationStyleSlashes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains a single-line comment which begins with three forward slashes in a row.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SingleLineCommentsMustNotUseDocumentationStyleSlashes\n\nSingleLineCommentsMustNotUseDocumentationStyleSlashes\n|CheckId|SA1626\n\nSA1626\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nThe C# code contains a single-line comment which begins with three forward slashes in a row.\n\n## Rule Description\n\nA violation of this rule occurs when the code contains a single-line comment which begins with three slashes. Comments beginning with three slashes are reserved for Xml documentation headers. Single-line comments should begin with only two slashes. When commenting out lines of code, it is advisable to begin the comment with four slashes to differentiate it from normal comments. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Joins a first name and a last name together into a single string.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;Part of the name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;Part of the name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;returns&gt;The joined names.&lt;/returns&gt;<o:p></o:p>\n\n    public string JoinNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n**A legal comment beginning with two slashes:<o:p></o:p>**\n\n        // Join the names together.<o:p></o:p>\n\n        string fullName = firstName + \" \" + lastName;<o:p></o:p>\n\n<o:p> </o:p>\n\n**An illegal comment beginning with three slashes:<o:p></o:p>**\n\n        /// Trim the name.<o:p></o:p>\n\n        fullName = fullName.Trim();<o:p></o:p>\n\n<o:p> </o:p>\n\n**A line of commented-out code beginning with four slashes:<o:p></o:p>**\n\n        ////fullName = asfd; <o:p></o:p>\n\n<o:p> </o:p>\n\n        return fullName;<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove a slash from the beginning of the comment so that it begins with only two slashes.\n\n\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1626.html)"
      },
      {
        "real_name": "StyleCop.CSharp.DocumentationRules/VoidReturnValueMustNotBeDocumented",
        "display_name": "VoidReturnValueMustNotBeDocumented",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# code element does not contain a return value, or returns void, but the documentation header for the element contains a &lt;returns&gt; tag.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|VoidReturnValueMustNotBeDocumented\n\nVoidReturnValueMustNotBeDocumented\n|CheckId|SA1617\n\nSA1617\n|Category|Documentation Rules\n\nDocumentation Rules\n\n## Cause\n\nA C# code element does not contain a return value, or returns void, but the documentation header for the element contains a &lt;returns&gt; tag.\n\n## Rule Description\n\nC# syntax provides a mechanism for inserting documentation for classes and elements directly into the code, through the use of Xml documentation headers. For an introduction to these headers and a description of the header syntax, see the following article: [http://msdn.microsoft.com/en-us/magazine/cc302121.aspx](http://msdn.microsoft.com/en-us/magazine/cc302121.aspx).\n\nA violation of this rule occurs if an element which returns void contains a &lt;returns&gt; tag within its documentation header.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the &lt;returns&gt; tag from the element.\n\nThe following example shows a method with a valid documentation header:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Prints the given name.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"firstName\"&gt;The first name.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"lastName\"&gt;The last name.&lt;/param&gt;<o:p></o:p>\n\n    public void PrintNames(string firstName, string lastName)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        Console.WriteLine(firstName + \" \" + lastName);<o:p></o:p>\n\n    }\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1617.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/AllAccessorsMustBeMultiLineOrSingleLine",
        "display_name": "AllAccessorsMustBeMultiLineOrSingleLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Validates that an accessor in a property or indexer is only placed on a single line if all accessors in the property or indexer are placed on a single line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Validates that an accessor in a property or indexer is only placed on a single line if all accessors in the property or indexer are placed on a single line."
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/AllAccessorsMustBeSingleLineOrMultiLine",
        "display_name": "AllAccessorsMustBeSingleLineOrMultiLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Within a C# property, indexer or event, at least one of the child accessors is written on a single line, and at least one of the child accessors is written across multiple lines.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|AllAccessorsMustBeSingleLineOrMultiLine\n\nAllAccessorsMustBeSingleLineOrMultiLine\n|CheckId|SA1504\n\nSA1504\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nWithin a C# property, indexer or event, at least one of the child accessors is written on a single line, and at least one of the child accessors is written across multiple lines.\n\n## Rule Description\n\nA violation of this rule occurs when the accessors within a property, indexer or event are not consistently written on a single line or on multiple lines. This rule is intended to increase the readability of the code by requiring all of the accessors within an element to be formatted in the same way.\n\nFor example, the following property would generate a violation of this rule, because one accessor is written on a single line while the other accessor snaps multiple lines.\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.enabled; }<o:p></o:p>\n\n<o:p> </o:p>\n\n        set<o:p></o:p>\n\n        {<o:p></o:p>\n\n            this.enabled = value;<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe violation can be avoided by placing both accessors on a single line, or expanding both accessors across multiple lines:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.enabled; }<o:p></o:p>\n\n        set { this.enabled = value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        { <o:p></o:p>\n\n            return this.enabled; <o:p></o:p>\n\n        }<o:p></o:p>\n\n<o:p> </o:p>\n\n        set <o:p></o:p>\n\n        { <o:p></o:p>\n\n            this.enabled = value;<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n <o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, write each accessor on a single line if the accessors are short, or expand both accessors across multiple lines if the accessors are longer.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1504.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ChainedStatementBlocksMustNotBePrecededByBlankLine",
        "display_name": "ChainedStatementBlocksMustNotBePrecededByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Chained C# statements are separated by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ChainedStatementBlocksMustNotBePrecededByBlankLine\n\nChainedStatementBlocksMustNotBePrecededByBlankLine\n|CheckId|SA1510\n\nSA1510\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nChained C# statements are separated by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nSome types of C# statements can only be used when chained to the bottom of another statement. Examples include catch and finally statements, which must always be chained to the bottom of a try-statement. Another example is an else-statement, which must always be chained to the bottom of an if-statement, or to another else-statement. These types of chained statements must not be separated by a blank line. For example:\n\n    try<o:p></o:p>\n\n    {<o:p></o:p>\n\n        this.SomeMethod();<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    catch (Exception ex)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        Console.WriteLine(ex.ToString());<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove any blank lines between the chained statements.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1510.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ClosingCurlyBracketMustBeFollowedByBlankLine",
        "display_name": "ClosingCurlyBracketMustBeFollowedByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing curly bracket within a C# element, statement, or expression is not followed by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingCurlyBracketMustBeFollowedByBlankLine\n\nClosingCurlyBracketMustBeFollowedByBlankLine\n|CheckId|SA1513\n\nSA1513\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nA closing curly bracket within a C# element, statement, or expression is not followed by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when a closing curly bracket is not followed by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        { <o:p></o:p>\n\n            return this.enabled; <o:p></o:p>\n\n        }}<o:p></o:p>\n\n\n\nThe code above would generate one instance of this violation, since there is one place where a closing curly bracket is not followed by a blank line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure a blank line follows closing curly brackets.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1513.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ClosingCurlyBracketsMustNotBePrecededByBlankLine",
        "display_name": "ClosingCurlyBracketsMustNotBePrecededByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing curly bracket within a C# element, statement, or expression is preceded by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingCurlyBracketsMustNotBePrecededByBlankLine\n\nClosingCurlyBracketsMustNotBePrecededByBlankLine\n|CheckId|SA1508\n\nSA1508\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nA closing curly bracket within a C# element, statement, or expression is preceded by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.<o:p></o:p>\n\nA violation of this rule occurs when a closing curly bracket is preceded by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        { <o:p></o:p>\n\n            return this.enabled; <o:p></o:p>\n\n<o:p> </o:p>\n\n        }<o:p></o:p>\n\n<o:p> </o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate two instances of this violation, since there are two places where closing curly brackets are preceded by blank lines.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank line preceding the closing curly bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1508.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/CodeMustNotContainBlankLinesAtEndOfFile",
        "display_name": "CodeMustNotContainBlankLinesAtEndOfFile",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The code file has blank lines at the end.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainBlankLinesAtEndOfFile\n\nCodeMustNotContainBlankLinesAtEndOfFile\n|CheckId|SA1518\n\nSA1518\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nThe code file has blank lines at the end.\n\n## Rule Description\n\nTo improve the layout of the code, StyleCop requires no blank lines at the end of files.\n\nA violation of this rule occurs when one or more blank lines are at the end of the file.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank lines from the end of the file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1518.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/CodeMustNotContainBlankLinesAtStartOfFile",
        "display_name": "CodeMustNotContainBlankLinesAtStartOfFile",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The code file has blank lines at the start.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainBlankLinesAtStartOfFile\n\nCodeMustNotContainBlankLinesAtStartOfFile\n|CheckId|SA1517\n\nSA1517\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nThe code file has blank lines at the start.\n\n## Rule Description\n\nTo improve the layout of the code, StyleCop requires no blank lines at the start of files.\n\nA violation of this rule occurs when one or more blank lines are at the start of the file.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank lines from the start of the file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1517.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/CodeMustNotContainMultipleBlankLinesInARow",
        "display_name": "CodeMustNotContainMultipleBlankLinesInARow",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains multiple blank lines in a row.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainMultipleBlankLinesInARow\n\nCodeMustNotContainMultipleBlankLinesInARow\n|CheckId|SA1507\n\nSA1507\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nThe C# code contains multiple blank lines in a row.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when the code contains more than one blank line in a row. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        { <o:p></o:p>\n\n            Console.WriteLine(\"Getting the enabled flag.\");<o:p></o:p>\n\n<o:p> </o:p>\n\n<o:p> </o:p>\n\n            return this.enabled; <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate an instance of this violation, since it contains blank multiple lines in a row.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the extra blank lines.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1507.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/CurlyBracketsForMultiLineStatementsMustNotShareLine",
        "display_name": "CurlyBracketsForMultiLineStatementsMustNotShareLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The opening or closing curly bracket within a C# statement, element, or expression is not placed on its own line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CurlyBracketsForMultiLineStatementsMustNotShareLine\n\nCurlyBracketsForMultiLineStatementsMustNotShareLine\n|CheckId|SA1500\n\nSA1500\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nThe opening or closing curly bracket within a C# statement, element, or expression is not placed on its own line.\n\n## Rule Description\n\nA violation of this rule occurs when the opening or closing curly bracket within a statement, element, or expression is not placed on its own line. For example:\n\n    public object Method()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        lock (this) {<o:p></o:p>\n\n            return this.value;<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nWhen StyleCop checks this code, a violation of this rule will occur because the opening curly bracket of the lock statement is placed on the same line as the lock keyword, rather than being placed on its own line, as follows:\n\n    public object Method()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        lock (this) <o:p></o:p>\n\n        {<o:p></o:p>\n\n            return this.value;<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nA violation will also occur if the closing curly bracket shares a line with other code. For example:\n\n    public object Method()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        lock (this) <o:p></o:p>\n\n        {<o:p></o:p>\n\n            return this.value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that both the opening and closing curly brackets are placed on their own line, and do not share the line with any other code, other than comments.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1500.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/CurlyBracketsMustNotBeOmitted",
        "display_name": "CurlyBracketsMustNotBeOmitted",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The opening and closing curly brackets for a C# statement have been omitted.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CurlyBracketsMustNotBeOmitted\n\nCurlyBracketsMustNotBeOmitted\n|CheckId|SA1503\n\nSA1503\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nThe opening and closing curly brackets for a C# statement have been omitted.\n\n## Rule Description\n\nA violation of this rule occurs when the opening and closing curly brackets for a statement have been omitted. In C#, some types of statements may optionally include curly brackets. Examples include if, while, and for statements. For example, an if-statement may be written without curly brackets:\n\n    if (true) <o:p></o:p>\n\n        return this.value;<o:p></o:p>\n\n\n\nAlthough this is legal in C#, StyleCop always requires the curly brackets to be present, to increase the readability and maintainability of the code.\n\nWhen the curly brackets are omitted, it is possible to introduce an error in the code by inserting an additional statement beneath the if-statement. For example:\n\n    if (true) <o:p></o:p>\n\n        this.value = 2;       <o:p></o:p>\n\n        return this.value;<o:p></o:p>\n\n\n\nGlancing at this code, it appears as if both the assignment statement and the return statement are children of the if-statement. In fact, this is not true. Only the assignment statement is a child of the if-statement, and the return statement will always execute regardless of the outcome of the if-statement.\n\nStyleCop always requires the opening and closing curly brackets to be present, to prevent these kinds of errors:<o:p></o:p>\n\n    if (true) <o:p></o:p>\n\n    {<o:p></o:p>\n\n        this.value = 2;       <o:p></o:p>\n\n        return this.value;<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, wrap the body of the statement in curly brackets.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1503.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ElementDocumentationHeaderMustBePrecededByBlankLine",
        "display_name": "ElementDocumentationHeaderMustBePrecededByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An element documentation header above a C# element is not preceded by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationHeaderMustBePrecededByBlankLine\n\nElementDocumentationHeaderMustBePrecededByBlankLine\n|CheckId|SA1514\n\nSA1514\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nAn element documentation header above a C# element is not preceded by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when the element documentation header above an element is not preceded by a blank line. For example:\n\n    public bool Visible<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.visible; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets a value indicating whether the control is enabled.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.enabled; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate an instance of this violation, since the documentation header is not preceded by a blank line.\n\nAn exception to this rule occurs when the documentation header is the first item within its scope. In this case, the header should not be preceded by a blank line. For example:\n\n    public class Class1    <o:p></o:p>\n\n    {<o:p></o:p>\n\n        /// &lt;summary&gt;<o:p></o:p>\n\n        /// Gets a value indicating whether the control is enabled.<o:p></o:p>\n\n        /// &lt;/summary&gt;<o:p></o:p>\n\n        public bool Enabled<o:p></o:p>\n\n        {<o:p></o:p>\n\n            get { return this.enabled; }<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIn the code above, the header is the first item within its scope, and thus it should not be preceded by a blank line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a blank line above the documentation header.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1514.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ElementDocumentationHeadersMustNotBeFollowedByBlankLine",
        "display_name": "ElementDocumentationHeadersMustNotBeFollowedByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An element documentation header above a C# element is followed by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementDocumentationHeadersMustNotBeFollowedByBlankLine\n\nElementDocumentationHeadersMustNotBeFollowedByBlankLine\n|CheckId|SA1506\n\nSA1506\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nAn element documentation header above a C# element is followed by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when the element documentation header above an element is followed by a blank line. For example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Gets a value indicating whether the control is enabled.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n<o:p> </o:p>\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.enabled; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate an instance of this violation, since the documentation header is followed by a blank line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank line following the documentation header.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1506.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ElementMustNotBeOnSingleLine",
        "display_name": "ElementMustNotBeOnSingleLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# element containing opening and closing curly brackets is written completely on a single line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementMustNotBeOnSingleLine\n\nElementMustNotBeOnSingleLine\n|CheckId|SA1502\n\nSA1502\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nA C# element containing opening and closing curly brackets is written completely on a single line.\n\n## Rule Description\n\nA violation of this rule occurs when an element that is wrapped in opening and closing curly brackets is written on a single line. For example:\n\n    public object Method() { return null; }<o:p></o:p>\n\n\n\nWhen StyleCop checks this code, a violation of this rule will occur because the entire method is written on one line. The method should be written across multiple lines, with the opening and closing curly brackets each on their own line, as follows:\n\n    public object Method()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return null; <o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p></o:p> \n\n<o:p> </o:p>\n\nAs an exception to this rule, accessors within properties, events, or indexers are allowed to be written all on a single line, as long as the accessor is short.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, rewrite the element so that it expands across multiple lines.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1502.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/ElementsMustBeSeparatedByBlankLine",
        "display_name": "ElementsMustBeSeparatedByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Adjacent C# elements are not separated by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementsMustBeSeparatedByBlankLine\n\nElementsMustBeSeparatedByBlankLine\n|CheckId|SA1516\n\nSA1516\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nAdjacent C# elements are not separated by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when two adjacent element are not separated by a blank line. For example:\n\n    public void Method1()<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n    public bool Property<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return true; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nIn the example above, the method and property are not separated by a blank line, so a violation of this rule would occur.\n\n \n\n    public event EventHandler SomeEvent<br/>\n    {<br/>\n\n        \n                    add<br/>\n        {<br/>\n           \n                    // add event subscriber here<br/>\n        \n                    }<o:p><br/>\n</o:p>\n        \n                    remove<br/>\n        {<br/>\n          \n                    // remove event subscriber here<br/>\n        \n                    }<o:p><br/>\n</o:p>\n    }<o:p></o:p>\n\nIn the example above, the add and remove of the event need to be separated by a blank line because \n                    the add is multiline.\n\n \n\n## How to Fix Violations&gt;How to Fix Violations\n\nTo fix a violation of this rule, add a blank line between the adjacent elements.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1516.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/OpeningCurlyBracketsMustNotBeFollowedByBlankLine",
        "display_name": "OpeningCurlyBracketsMustNotBeFollowedByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening curly bracket within a C# element, statement, or expression is followed by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningCurlyBracketsMustNotBeFollowedByBlankLine\n\nOpeningCurlyBracketsMustNotBeFollowedByBlankLine\n|CheckId|SA1505\n\nSA1505\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nAn opening curly bracket within a C# element, statement, or expression is followed by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when an opening curly bracket is followed by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n<o:p> </o:p>\n\n        get <o:p></o:p>\n\n        { <o:p></o:p>\n\n<o:p> </o:p>\n\n            return this.enabled; <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate two instances of this violation, since there are two places where opening curly brackets are followed by blank lines.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank line following the opening curly bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1505.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/OpeningCurlyBracketsMustNotBePrecededByBlankLine",
        "display_name": "OpeningCurlyBracketsMustNotBePrecededByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening curly bracket within a C# element, statement, or expression is preceded by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningCurlyBracketsMustNotBePrecededByBlankLine\n\nOpeningCurlyBracketsMustNotBePrecededByBlankLine\n|CheckId|SA1509\n\nSA1509\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nAn opening curly bracket within a C# element, statement, or expression is preceded by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when an opening curly bracket is preceded by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n<o:p> </o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n<o:p> </o:p>\n\n        { <o:p></o:p>\n\n            return this.enabled; <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate two instances of this violation, since there are two places where opening curly brackets are preceded by blank lines.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank line preceding the opening curly bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1509.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/SingleLineCommentMustBePrecededByBlankLine",
        "display_name": "SingleLineCommentMustBePrecededByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A single-line comment within C# code is not preceded by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SingleLineCommentMustBePrecededByBlankLine\n\nSingleLineCommentMustBePrecededByBlankLine\n|CheckId|SA1515\n\nSA1515\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nA single-line comment within C# code is not preceded by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when a single-line comment is not preceded by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        {<o:p></o:p>\n\n            Console.WriteLine(\"Getting the enabled flag.\");<o:p></o:p>\n\n            // Return the value of the 'enabled' field.<o:p></o:p>\n\n            return this.enabled;  <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate an instance of this violation, since the single-line comment is not preceded by a blank line.\n\nAn exception to this rule occurs when the single-line comment is the first item within its scope. In this case, the comment should not be preceded by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        {<o:p></o:p>\n\n            // Return the value of the 'enabled' field.<o:p></o:p>\n\n            return this.enabled;  <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIn the code above, the comment is the first item within its scope, and thus it should not be preceded by a blank line.\n\nIf the comment is being used to comment out a line of code, begin the comment with four forward slashes rather than two. This will cause StyleCop to ignore this violation. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        {<o:p></o:p>\n\n            Console.WriteLine(\"Getting the enabled flag.\");<o:p></o:p>\n\n            ////return false;\n\n            return this.enabled;  <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a blank line above the comment.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1515.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/SingleLineCommentsMustNotBeFollowedByBlankLine",
        "display_name": "SingleLineCommentsMustNotBeFollowedByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A single-line comment within C# code is followed by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SingleLineCommentsMustNotBeFollowedByBlankLine\n\nSingleLineCommentsMustNotBeFollowedByBlankLine\n|CheckId|SA1512\n\nSA1512\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nA single-line comment within C# code is followed by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when a single-line comment is followed by a blank line. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        {<o:p></o:p>\n\n            // Return the value of the 'enabled' field.<o:p></o:p>\n\n\n\n            return this.enabled;  <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe code above would generate an instance of this violation, since the single-line comment is followed by a blank line.\n\nIt is allowed to place a blank line in between two blocks of single-line comments. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        {<o:p></o:p>\n\n            // This is a sample comment which doesn't really say anything.<o:p></o:p>\n\n            // This is another part of the comment.<o:p></o:p>\n\n\n\n            // There is a blank line above this comment but that is ok.<o:p></o:p>\n\n            return this.enabled;  <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nIf the comment is being used to comment out a line of code, place four forward slashes at the beginning of the comment, rather than two. This will cause StyleCop to ignore this violation. For example:\n\n    public bool Enabled<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get <o:p></o:p>\n\n        {<o:p></o:p>\n\n            ////return false;\n\n<o:p> </o:p>\n\n            return this.enabled;  <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the blank line following the single-line comment.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1512.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/StatementMustNotBeOnSingleLine",
        "display_name": "StatementMustNotBeOnSingleLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# statement containing opening and closing curly brackets is written completely on a single line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|StatementMustNotBeOnSingleLine\n\nStatementMustNotBeOnSingleLine\n|CheckId|SA1501\n\nSA1501\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nA C# statement containing opening and closing curly brackets is written completely on a single line.\n\n## Rule Description\n\nA violation of this rule occurs when a statement that is wrapped in opening and closing curly brackets is written on a single line. For example:\n\n    public object Method()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        lock (this) { return this.value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nWhen StyleCop checks this code, a violation of this rule will occur because the entire lock statement is written on one line. The statement should be written across multiple lines, with the opening and closing curly brackets each on their own line, as follows:\n\n    public object Method()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        lock (this) <o:p></o:p>\n\n        {<o:p></o:p>\n\n            return this.value; <o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, rewrite the statement so that it expands across multiple lines.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1501.html)"
      },
      {
        "real_name": "StyleCop.CSharp.LayoutRules/WhileDoFooterMustNotBePrecededByBlankLine",
        "display_name": "WhileDoFooterMustNotBePrecededByBlankLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The while footer at the bottom of a do-while statement is separated from the statement by a blank line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|WhileDoFooterMustNotBePrecededByBlankLine\n\nWhileDoFooterMustNotBePrecededByBlankLine\n|CheckId|SA1511\n\nSA1511\n|Category|Layout Rules\n\nLayout Rules\n\n## Cause\n\nThe while footer at the bottom of a do-while statement is separated from the statement by a blank line.\n\n## Rule Description\n\nTo improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits blank lines in other situations. This results in a consistent visual pattern across the code, which can improve recognition and readability of unfamiliar code.\n\nA violation of this rule occurs when the while keyword at the bottom of a do-while statement is separated from the main part of the statement by one or more blank lines. For example:\n\n    do<o:p></o:p>\n\n    {<o:p></o:p>\n\n        Console.WriteLine(\"Loop forever\");<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    while (true);<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove any blank lines before the while keyword.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1511.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/AccessModifierMustBeDeclared",
        "display_name": "AccessModifierMustBeDeclared",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The access modifier for a C# element has not been explicitly defined.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|AccessModifierMustBeDeclared\n\nAccessModifierMustBeDeclared\n|CheckId|SA1400\n\nSA1400\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nThe access modifier for a C# element has not been explicitly defined.\n\n## Rule Description\n\nC# allows elements to be defined without an access modifier. Depending upon the type of element, C# will automatically assign an access level to the element in this case.\n\nThis rule requires an access modifier to be explicitly defined for every element. This removes the need for the reader to make assumptions about the code, improving the readability of the code.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add an access modifier to the declaration of the element.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1400.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/ArithmeticExpressionsMustDeclarePrecedence",
        "display_name": "ArithmeticExpressionsMustDeclarePrecedence",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# statement contains a complex arithmetic expression which omits parenthesis around operators.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ArithmeticExpressionsMustDeclarePrecedence\n\nArithmeticExpressionsMustDeclarePrecedence\n|CheckId|SA1407\n\nSA1407\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA C# statement contains a complex arithmetic expression which omits parenthesis around operators.\n\n## Rule Description\n\nC# maintains a hierarchy of precedence for arithmetic operators. It is possible in C# to string multiple arithmetic operations together in one statement without wrapping any of the operations in parenthesis, in which case the compiler will automatically set the order and precedence of the operations based on these pre-established rules. For example:\n\n    int x = 5 + y * b / 6 % z - 2;<o:p></o:p>\n\n<o:p> </o:p>\n\nAlthough this code is legal, it is not highly readable or maintainable. In order to achieve full understanding of this code, the developer must know and understand the basic operator precedence rules in C#.\n\nThis rule is intended to increase the readability and maintainability of this type of code, and to reduce the risk of introducing bugs later, by forcing the developer to insert parenthesis to explicitly declare the operator precedence. The example below shows multiple arithmetic operations surrounded by parenthesis:\n\n    int x = 5 + (y * ((b / 6) % z)) - 2;<o:p></o:p>\n\n\n\nInserting parenthesis makes the code more obvious and easy to understand, and removes the need for the reader to make assumptions about the code.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, insert parenthesis within the arithmetic expression to declare the precedence of the operations.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1407.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/AttributeConstructorMustNotUseUnnecessaryParenthesis",
        "display_name": "AttributeConstructorMustNotUseUnnecessaryParenthesis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "TODO.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|AttributeConstructorMustNotUseUnnecessaryParenthesis\n\nAttributeConstructorMustNotUseUnnecessaryParenthesis\n|CheckId|SA1411\n\nSA1411\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nTODO.\n\n## Rule Description\n\nTODO\n\nA violation of this rule occurs when unneccsary parenthesis have been used in an attribute constructor. For example:\n\n    \n                    [Serializable()]\n\n\n\nThe parenthesis are unnecessary and should be removed:\n\n    \n                    [Serializable]\n\n\n\n## How to Fix Violations\n\nRemove the unnecessary parenthesis.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1411.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/CodeAnalysisSuppressionMustHaveJustification",
        "display_name": "CodeAnalysisSuppressionMustHaveJustification",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A Code Analysis SuppressMessage attribute does not include a justification.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeAnalysisSuppressionMustHaveJustification\n\nCodeAnalysisSuppressionMustHaveJustification\n|CheckId|SA1404\n\nSA1404\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA Code Analysis SuppressMessage attribute does not include a justification.\n\n## Rule Description\n\nA violation of this rule occurs when the code contains a Code Analysis SuppressMessage attribute, but a justification for the suppression has not been provided within the attribute. Whenever a Code Analysis rule is suppressed, a justification should be provided. This can increase the long-term maintainability of the code.\n\n    [SuppressMessage(\"Microsoft.Performance\", \"CA1804:RemoveUnusedLocals\", Justification = \"Used during unit testing\")]<o:p></o:p>\n\n    public bool Enable()\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix an instance of this violation, add a Justification tag and justification text to the SuppressMessage attribute describing the reason for the suppression.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1404.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/ConditionalExpressionsMustDeclarePrecedence",
        "display_name": "ConditionalExpressionsMustDeclarePrecedence",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# statement contains a complex conditional expression which omits parenthesis around operators.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ConditionalExpressionsMustDeclarePrecedence\n\nConditionalExpressionsMustDeclarePrecedence\n|CheckId|SA1408\n\nSA1408\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA C# statement contains a complex conditional expression which omits parenthesis around operators.\n\n## Rule Description\n\nC# maintains a hierarchy of precedence for conditional operators. It is possible in C# to string multiple conditional operations together in one statement without wrapping any of the operations in parenthesis, in which case the compiler will automatically set the order and precedence of the operations based on these pre-established rules. For example:\n\n    if (x || y &amp;&amp; z &amp;&amp; a || b)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nAlthough this code is legal, it is not highly readable or maintainable. In order to achieve full understanding of this code, the developer must know and understand the basic operator precedence rules in C#.\n\nThis rule is intended to increase the readability and maintainability of this type of code, and to reduce the risk of introducing bugs later, by forcing the developer to insert parenthesis to explicitly declare the operator precedence. For example, a developer could write this code as:\n\n    if ((x || y) &amp;&amp; z &amp;&amp; (a || b))<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nor\n\n    if (x || (y &amp;&amp; z &amp;&amp; a) || b)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nInserting parenthesis makes the code more obvious and easy to understand, and removes the need for the reader to make assumptions about the code.\n\n## How to Fix Violations\n\nInsert parenthesis within the conditional expression to declare the precedence of the operations.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1408.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/DebugAssertMustProvideMessageText",
        "display_name": "DebugAssertMustProvideMessageText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A call to Debug.Assert in C# code does not include a descriptive message.<o:p></o:p>",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DebugAssertMustProvideMessageText\n\nDebugAssertMustProvideMessageText\n|CheckId|SA1405\n\nSA1405\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA call to Debug.Assert in C# code does not include a descriptive message.<o:p></o:p>\n\n## Rule Description\n\nA violation of this rule occurs when the code contains a call to Debug.Assert which does not provide a description for the end-user. For example, the following assert includes a description message:\n\n    Debug.Assert(value != true, \"The value must always be true.\");<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a descriptive message to the assert which will appear to the end user when the assert is fired.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1405.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/DebugFailMustProvideMessageText",
        "display_name": "DebugFailMustProvideMessageText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A call to Debug.Fail in C# code does not include a descriptive message.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DebugFailMustProvideMessageText\n\nDebugFailMustProvideMessageText\n|CheckId|SA1406\n\nSA1406\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA call to Debug.Fail in C# code does not include a descriptive message.\n\n## Rule Description\n\nA violation of this rule occurs when the code contains a call to Debug.Fail which does not provide a description for the end-user. For example, the following call includes a description message:\n\n    Debug.Fail(\"The code should never reach this point.\");<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix an instance of this violation, add a descriptive message to the Debug.Fail call which will appear to the end user when the assert is fired.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1406.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/FieldsMustBePrivate",
        "display_name": "FieldsMustBePrivate",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A field within a C# class has an access modifier other than private.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FieldsMustBePrivate\n\nFieldsMustBePrivate\n|CheckId|SA1401\n\nSA1401\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA field within a C# class has an access modifier other than private.\n\n## Rule Description\n\nA violation of this rule occurs whenever a field in a class is given non-private access. For maintainability reasons, properties should always be used as the mechanism for exposing fields outside of a class, and fields should always be declared with private access. This allows the internal implementation of the property to change over time without changing the interface of the class.\n\nFields located within C# structs are allowed to have any access level.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, make the field private and add a property to expose the field outside of the class.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1401.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/FileMayOnlyContainASingleClass",
        "display_name": "FileMayOnlyContainASingleClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# code file contains more than one unique class.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileMayOnlyContainASingleClass\n\nFileMayOnlyContainASingleClass\n|CheckId|SA1402\n\nSA1402\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA C# code file contains more than one unique class.\n\n## Rule Description\n\nA violation of this rule occurs when a C# file contains more than one class. To increase long-term maintainability of the code-base, each class should be placed in its own file, and file names should reflect the name of the class within the file.\n\nIt is possible to place other supporting elements within the same file as the class, such as delegates, enums, etc., if they are related to the class.\n\nIt is also possible to place multiple parts of the same partial class within the same file.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, move each class into its own file.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1402.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/FileMayOnlyContainASingleNamespace",
        "display_name": "FileMayOnlyContainASingleNamespace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# code file contains more than one namespace.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FileMayOnlyContainASingleNamespace\n\nFileMayOnlyContainASingleNamespace\n|CheckId|SA1403\n\nSA1403\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA C# code file contains more than one namespace.\n\n## Rule Description\n\nA violation of this rule occurs when a C# file contains more than one namespace. To increase long-term maintainability of the code-base, each file should contain at most one namespace.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the file only contains a single namespace.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1403.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/RemoveDelegateParenthesisWhenPossible",
        "display_name": "RemoveDelegateParenthesisWhenPossible",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A call to a C# anonymous method does not contain any method parameters, yet the statement still includes parenthesis.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|RemoveDelegateParenthesisWhenPossible\n\nRemoveDelegateParenthesisWhenPossible\n|CheckId|SA1410\n\nSA1410\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA call to a C# anonymous method does not contain any method parameters, yet the statement still includes parenthesis.\n\n## Rule Description\n\nWhen an anonymous method does not contain any method parameters, the parenthesis around the parameters are optional.\n\nA violation of this rule occurs when the parenthesis are present on an anonymous method call which takes no method parameters. For example:\n\n    this.Method(delegate() { return 2; });<o:p></o:p>\n\n\n\nThe parenthesis are unnecessary and should be removed:\n\n    this.Method(delegate { return 2; });<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nRemove the unnecessary parenthesis after the delegate keyword.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1410.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/RemoveUnnecessaryCode",
        "display_name": "RemoveUnnecessaryCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# file contains code which is unnecessary and can be removed without changing the overall logic of the code.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|RemoveUnnecessaryCode\n\nRemoveUnnecessaryCode\n|CheckId|SA1409\n\nSA1409\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA C# file contains code which is unnecessary and can be removed without changing the overall logic of the code.\n\n## Rule Description\n\nA violation of this rule occurs when the file contains code which can be removed without changing the overall logic of the code.\n\nFor example, the following try-catch statement could be removed completely since the try and catch blocks are both empty.\n\n<o:p> </o:p>\n\n    try<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n    catch (Exception ex)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe try-finally statement below does contain code within the try block, but it does not contain any catch blocks, and the finally block is empty. Thus, the try-finally is not performing any useful function and can be removed.\n\n<o:p> </o:p>\n\n    try<o:p></o:p>\n\n    {<o:p></o:p>\n\n        this.Method();<o:p></o:p>\n\n    }<o:p></o:p>\n\n    finally<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nAs a final example, the unsafe statement below is empty, and thus provides no value.\n\n <o:p></o:p>\n\n    unsafe<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nThe fix a violation of this rule, remove the unnecessary code, or fill in the code with additional statements.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1409.html)"
      },
      {
        "real_name": "StyleCop.CSharp.MaintainabilityRules/StatementMustNotUseUnnecessaryParenthesis",
        "display_name": "StatementMustNotUseUnnecessaryParenthesis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# statement contains parenthesis which are unnecessary and should be removed.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|StatementMustNotUseUnnecessaryParenthesis\n\nStatementMustNotUseUnnecessaryParenthesis\n|CheckId|SA1119\n\nSA1119\n|Category|Maintainability Rules\n\nMaintainability Rules\n\n## Cause\n\nA C# statement contains parenthesis which are unnecessary and should be removed.\n\n## Rule Description\n\nIt is possible in C# to insert parenthesis around virtually any type of expression, statement, or clause, and in many situations use of parenthesis can greatly improve the readability of the code. However, excessive use of parenthesis can have the opposite effect, making it more difficult to read and maintain the code.\n\nA violation of this rule occurs when parenthesis are used in situations where they provide no practical value. Typically, this happens anytime the parenthesis surround an expression which does not strictly require the use of parenthesis, and the parenthesis expression is located at the root of a statement. For example, the following lines of code all contain unnecessary parenthesis which will result in violations of this rule:\n\n    int x = (5 + b);<o:p></o:p>\n\n    string y = (this.Method()).ToString();<o:p></o:p>\n\n    return (x.Value);<o:p></o:p>\n\n<o:p> </o:p>\n\nIn each of these statements, the extra parenthesis can be removed without sacrificing the readability of the code:\n\n<o:p> </o:p>\n\n    int x = 5 + b;<o:p></o:p>\n\n    string y = this.Method().ToString();<o:p></o:p>\n\n    return x.Value;<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the unnecessary parenthesis.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1119.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/AccessibleFieldsMustBeginWithUpperCaseLetter",
        "display_name": "AccessibleFieldsMustBeginWithUpperCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a public or internal field in C# does not begin with an upper-case letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|AccessibleFieldsMustBeginWithUpperCaseLetter\n\nAccessibleFieldsMustBeginWithUpperCaseLetter\n|CheckId|SA1307\n\nSA1307\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a public or internal field in C# does not begin with an upper-case letter.\n\n## Rule Description\n\nA violation of this rule occurs when the name of a public or internal field begins with a lower-case letter. Public or internal fields must being with an upper-case letter.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to start with a lower-case letter, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, change the name of the field so that it begins with an upper-case letter, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1307.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/ConstFieldNamesMustBeginWithUpperCaseLetter",
        "display_name": "ConstFieldNamesMustBeginWithUpperCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a constant C# field must begin with an upper-case letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ConstFieldNamesMustBeginWithUpperCaseLetter\n\nConstFieldNamesMustBeginWithUpperCaseLetter\n|CheckId|SA1303\n\nSA1303\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a constant C# field must begin with an upper-case letter.\n\n## Rule Description\n\nA violation of this rule occurs when the name of a field marked with the **const** attribute does not begin with an upper-case letter.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to begin with a lower-case letter, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations \n\nTo fix a violation of this rule, change the name of the constant field so that it begins with an upper-case letter, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1303.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/ElementMustBeginWithLowerCaseLetter",
        "display_name": "ElementMustBeginWithLowerCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "There are currently no situations in which this rule will fire.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementMustBeginWithLowerCaseLetter\n\nElementMustBeginWithLowerCaseLetter\n|CheckId|SA1301\n\nSA1301\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThere are currently no situations in which this rule will fire.\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1301.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/ElementMustBeginWithUpperCaseLetter",
        "display_name": "ElementMustBeginWithUpperCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a C# element does not begin with an upper-case letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementMustBeginWithUpperCaseLetter\n\nElementMustBeginWithUpperCaseLetter\n|CheckId|SA1300\n\nSA1300\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a C# element does not begin with an upper-case letter.\n\n## Rule Description\n\nA violation of this rule occurs when the names of certain types of elements do not begin with an upper-case letter. The following types of elements should use an upper-case letter as the first letter of the element name: **namespaces, classes, enums, structs, delegates, events, methods, **and** properties**.\n\nIn addition, any field which is public, internal, or marked with the const attribute should begin with an upper-case letter. Non-private readonly fields must also be named using an upper-case letter.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to begin with a lower-case letter, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, change the name of the element so that it begins with an upper-case letter, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1300.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/FieldNamesMustBeginWithLowerCaseLetter",
        "display_name": "FieldNamesMustBeginWithLowerCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a field or variable in C# does not begin with a lower-case letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FieldNamesMustBeginWithLowerCaseLetter\n\nFieldNamesMustBeginWithLowerCaseLetter\n|CheckId|SA1306\n\nSA1306\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a field or variable in C# does not begin with a lower-case letter.\n\n## Rule Description\n\nA violation of this rule occurs when the name of a field or variable begins with \n                    an upper-case letter. Constants, non-private readonly fields and static readonly must always start with an uppercase letter, whilst \n                    private readonly fields must start with a lowercase letter. Also, public or internal fields must always start with an uppercase letter.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to begin with an upper-case letter, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, change the name of the field or variable so that it begins with a lower-case letter, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1306.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/FieldNamesMustNotBeginWithUnderscore",
        "display_name": "FieldNamesMustNotBeginWithUnderscore",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A field name in C# begins with an underscore.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FieldNamesMustNotBeginWithUnderscore\n\nFieldNamesMustNotBeginWithUnderscore\n|CheckId|SA1309\n\nSA1309\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nA field name in C# begins with an underscore.\n\n## Rule Description\n\nA violation of this rule occurs when a field name begins with an underscore.\n\nBy default, StyleCop disallows the use of underscores, **m_**, etc., to mark local class fields, in favor of the ‘this.’ prefix. The advantage of using ‘this.’ is that it applies equally to all element types including methods, properties, etc., and not just fields, making all calls to class members instantly recognizable, regardless of which editor is being used to view the code. Another advantage is that it creates a quick, recognizable differentiation between instance members and static members, which will not be prefixed.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to begin with an underscore, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the underscore from the beginning of the field name, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1309.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/FieldNamesMustNotContainUnderscore",
        "display_name": "FieldNamesMustNotContainUnderscore",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A field name in C# contains an underscore.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FieldNamesMustNotContainUnderscore\n|CheckId|SA1310\n|Category|Naming Rules\n\n## Cause\n\nA field name in C# contains an underscore.\n\n## Rule Description\n\nA violation of this rule occurs when a field name contains an underscore. Fields and variables should be named using descriptive, readable wording which describes the function of the field or variable. Typically, these names will be written using camel case, and should not use underscores. For example, use **customerPostCode** rather than **customer_post_code**.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to include underscores, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the underscore from the name of the field, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1310.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/FieldNamesMustNotUseHungarianNotation",
        "display_name": "FieldNamesMustNotUseHungarianNotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a field or variable in C# uses Hungarian notation.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|FieldNamesMustNotUseHungarianNotation\n\nFieldNamesMustNotUseHungarianNotation\n|CheckId|SA1305\n\nSA1305\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a field or variable in C# uses Hungarian notation.\n\n## Rule Description\n\nA violation of this rule occurs when Hungarian notation is used in the naming of fields and variables. The use of Hungarian notation has become widespread in C++ code, but the trend in C# is to use longer, more descriptive names for variables, which are not based on the type of the variable but which instead describe what the variable is used for.\n\nIn addition, modern code editors such as Visual Studio make it easy to identify type information for a variable or field, typically by hovering the mouse cursor over the variable name. This reduces the need for Hungarian notation.\n\nStyleCop assumes that any variable name that begins with one or two lower-case letters followed by an upper-case letter is making use of Hungarian notation, and will flag a violation of this rule in each case. It is possible to declare certain prefixes as legal, in which case they will be ignored. For example, a variable named **onExecute** will appear to StyleCop to be using Hungarian notation, when in reality it is not. Thus, the **on** prefix should be flagged as an allowed prefix.\n\nTo configure the list of allowed prefixes, bring up the StyleCop settings for a project, and navigate to the Hungarian tab, as shown below:\n\n<img alt=\"\" border=\"0\" src=\"Images/HungarianSettings.JPG\"/>\n\nAdding a one or two letter prefix to this list will cause StyleCop to ignore variables or fields which begin with this prefix.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to use Hungarian notation, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the Hungarian notation from the field or variable name, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1305.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/InterfaceNamesMustBeginWithI",
        "display_name": "InterfaceNamesMustBeginWithI",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a C# interface does not begin with the capital letter I.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|InterfaceNamesMustBeginWithI\n\nInterfaceNamesMustBeginWithI\n|CheckId|SA1302\n\nSA1302\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a C# interface does not begin with the capital letter I.\n\n## Rule Description\n\nA violation of this rule occurs when the name of an interface does not begin with the capital letter I. Interface names should always begin with I. For example, **ICustomer**.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus cannot begin with the letter I, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add the capital letter I to the front of the interface name, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1302.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter",
        "display_name": "NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a non-private readonly C# field must being with an upper-case letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter\n\nNonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter\n|CheckId|SA1304\n\nSA1304\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nThe name of a non-private readonly C# field must being with an upper-case letter.\n\n## Rule Description\n\nA violation of this rule occurs when the name of a readonly field which is not private does not begin with an upper-case letter. Non-private readonly fields must always start with an upper-case letter.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to begin with a lower-case letter, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, change the name of the readonly field so that it begins with an upper-case letter, make the field private, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1304.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/StaticReadonlyFieldsMustBeginWithUpperCaseLetter",
        "display_name": "StaticReadonlyFieldsMustBeginWithUpperCaseLetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a static readonly field does not begin with an upper-case letter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|StaticReadonlyFieldsMustBeginWithUpperCaseLetter\n|CheckId|SA1311\n|Category|Naming Rules\n\n## Cause\n\nThe name of a static readonly field does not begin with an upper-case letter.\n\n## Rule Description\n\nA violation of this rule occurs when the name of a static readonly field begins \n                    with a lower-case letter. \n\n## How to Fix Violations\n\nTo fix a violation of this rule, change the name of the field so that it begins with an \n                    upper-case letter.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1311.html)"
      },
      {
        "real_name": "StyleCop.CSharp.NamingRules/VariableNamesMustNotBePrefixed",
        "display_name": "VariableNamesMustNotBePrefixed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A field name in C# is prefixed with **m_** or **s_**.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|VariableNamesMustNotBePrefixed\n\nVariableNamesMustNotBePrefixed\n|CheckId|SA1308\n\nSA1308\n|Category|Naming Rules\n\nNaming Rules\n\n## Cause\n\nA field name in C# is prefixed with **m_** or **s_**.\n\n## Rule Description\n\nA violation of this rule occurs when a field name is prefixed by **m_** or **s_**.\n\nBy default, StyleCop disallows the use of underscores, **m_**, etc., to mark local class fields, in favor of the ‘this.’ prefix. The advantage of using ‘this.’ is that it applies equally to all element types including methods, properties, etc., and not just fields, making all calls to class members instantly recognizable, regardless of which editor is being used to view the code. Another advantage is that it creates a quick, recognizable differentiation between instance members and static members, which will not be prefixed.\n\nIf the field or variable name is intended to match the name of an item associated with Win32 or COM, and thus needs to begin with the prefix, place the field or variable within a special **NativeMethods** class. A NativeMethods class is any class which contains a name ending in NativeMethods, and is intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a NativeMethods class.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the prefix from the beginning of the field name, or place the item within a NativeMethods class if appropriate.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1308.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/ConstantsMustAppearBeforeFields",
        "display_name": "ConstantsMustAppearBeforeFields",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A constant field is placed beneath a non-constant field.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ConstantsMustAppearBeforeFields\n\nConstantsMustAppearBeforeFields\n|CheckId|SA1203\n\nSA1203\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nA constant field is placed beneath a non-constant field.\n\n## Rule Description\n\nA violation of this rule occurs when a constant field is placed beneath a non-constant field. Constants must be placed above fields to indicate that the two are fundamentally different types of elements with different considerations for the compiler, different naming requirements, etc.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place all constants above all fields.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1203.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/DeclarationKeywordsMustFollowOrder",
        "display_name": "DeclarationKeywordsMustFollowOrder",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The keywords within the declaration of an element do not follow a standard ordering scheme.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DeclarationKeywordsMustFollowOrder\n\nDeclarationKeywordsMustFollowOrder\n|CheckId|SA1206\n\nSA1206\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nThe keywords within the declaration of an element do not follow a standard ordering scheme.\n\n## Rule Description\n\nA violation of this rule occurs when the keywords within an element’s declaration do not follow a standard ordering scheme.\n\nWithin an element declaration, keywords must appear in the following order:\n\n**Access modifiers**\n\n**static**\n\n**All other keywords**\n\n\n\nUsing a standard ordering scheme for element declaration keywords can make the code more readable by highlighting the access level of each element. This can help prevent elements from being given a higher access level than needed.\n\n## How To Fix Violations\n\nTo fix an instance of this violation, order the keywords in the element’s declaration as described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1206.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/ElementsMustAppearInTheCorrectOrder",
        "display_name": "ElementsMustAppearInTheCorrectOrder",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An element within a C# code file is out of order in relation to the other elements in the code.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementsMustAppearInTheCorrectOrder\n\nElementsMustAppearInTheCorrectOrder\n|CheckId|SA1201\n\nSA1201\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nAn element within a C# code file is out of order in relation to the other elements in the code.\n\n## Rule Description\n\nA violation of this rule occurs when the code elements within a file do not follow a standard ordering scheme.\n\nTo comply with this rule, elements at the file root level or within a namespace must be positioned in the following order:\n\n**Extern Alias Directives**\n\n**Using Directives**\n\n**Namespaces**\n\n**Delegates**\n\n**Enums**\n\n**Interfaces**\n\n**Structs**\n\n**Classes**\n\n\n\nWithin a class, struct, or interface, elements must be positioned in the following order:\n\n**Fields**\n\n**Constructors**\n\n**Finalizers (Destructors)**\n\n**Delegates**\n\n**Events**\n\n**Enums**\n\n**Interfaces**\n\n**Properties**\n\n**Indexers**\n\n**Methods**\n\n**Structs**\n\n**Classes**\n\n\n\nComplying with a standard ordering scheme based on element type can increase the readability and maintainability of the file and encourage code reuse.\n\nWhen implementing an interface, it is sometimes desirable to group all members of the interface next to one another. This will sometimes require violating this rule, if the interface contains elements of different types. This problem can be solved through the use of partial classes.\n\n1. Add the partial attribute to the class, if the class is not already partial.\n\n2. Add a second partial class with the same name. It is possible to place this in the same file, just below the original class, or within a second file.\n\n3. Move the interface inheritance and all members of the interface implementation to the second part of the class.\n\n\n\nFor example:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// Represents a customer of the system.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    public partial class Customer<o:p></o:p>\n\n    {<o:p></o:p>\n\n        // Contains the main functionality of the class.<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    /// &lt;content&gt;<o:p></o:p>\n\n    /// Implements the ICollection class.<o:p></o:p>\n\n    /// &lt;/content&gt;<o:p></o:p>\n\n    public partial class Customer : ICollection<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public int Count <o:p></o:p>\n\n        { <o:p></o:p>\n\n            get { return this.count; }<o:p></o:p>\n\n        }<o:p></o:p>\n\n        <o:p></o:p>\n\n        public bool IsSynchronized <o:p></o:p>\n\n        { <o:p></o:p>\n\n            get { return false; }<o:p></o:p>\n\n        }<o:p></o:p>\n\n        <o:p></o:p>\n\n        public object SyncRoot <o:p></o:p>\n\n        { <o:p></o:p>\n\n            get { return null; }<o:p></o:p>\n\n        }<o:p></o:p>\n\n        <o:p></o:p>\n\n        public void CopyTo(Array array, int index)<o:p></o:p>\n\n        {<o:p></o:p>\n\n            throw new NotImplementedException();<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix an instance of this violation, order the elements in the file in the order described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1201.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/ElementsMustBeOrderedByAccess",
        "display_name": "ElementsMustBeOrderedByAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An element within a C# code file is out of order within regard to access level, in relation to other elements in the code.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ElementsMustBeOrderedByAccess\n\nElementsMustBeOrderedByAccess\n|CheckId|SA1202\n\nSA1202\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nAn element within a C# code file is out of order within regard to access level, in relation to other elements in the code.\n\n## Rule Description\n\nA violation of this rule occurs when the code elements within a file do not follow a standard ordering scheme based on access level.\n\nTo comply with this rule, adjacent elements of the same type must be positioned in the following order by access level:\n\n**public<o:p></o:p>**\n\n**internal<o:p></o:p>**\n\n**protected internal<o:p></o:p>**\n\n**protected<o:p></o:p>**\n\n**private<o:p></o:p>**\n\n\n\nComplying with a standard ordering scheme based on access level can increase the readability and maintainability of the file and make it easier to identify the public interface that is being exposed from a class.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, order the elements in the file in the order described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1202.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/EventAccessorsMustFollowOrder",
        "display_name": "EventAccessorsMustFollowOrder",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An add accessor appears after a remove accessor within an event.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|EventAccessorsMustFollowOrder\n\nEventAccessorsMustFollowOrder\n|CheckId|SA1213\n\nSA1213\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nAn add accessor appears after a remove accessor within an event.\n\n## Rule Description\n\nA violation of this rule occurs when an add accessor is placed after a remove accessor within an event. To comply with this rule, the add accessor should appear before the remove accessor.\n\nFor example, the following code would raise an instance of this violation:\n\n    public event EventHandler NameChanged\n\n    { <o:p></o:p>\n\n        remove { this.nameChanged -= value; }<o:p></o:p>\n\n        \n\n    }\n\n \n\nThe code below would not raise this violation:\n\n\n\n    public event EventHandler NameChanged\n\n    { \n\n        add { this.nameChanged += value; }<o:p></o:p>\n\n        remove { this.nameChanged -= value; }<o:p></o:p>\n\n    }\n\n \n\n## How to Fix Violations\n\nTo fix an instance of this violation, place the add accessor before the remove accessor.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1213.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/InstanceReadonlyElementsMustAppearBeforeInstanceNonReadonlyElements",
        "display_name": "InstanceReadonlyElementsAppearBeforeInstanceNonReadonlyElements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An instance readonly element is positioned beneath an instance non-readonly element of the same type.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|InstanceReadonlyElementsMustAppearBeforeInstanceNonReadonlyElements\n|CheckId|SA1215\n|Category|Ordering Rules\n\n## Cause\n\nAn instance readonly element is positioned beneath an instance non-readonly element of the same type.\n\n## Rule Description\n\nA violation of this rule occurs when an instance readonly element is positioned beneath an instance non-readonly element of the same type.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place all instance readonly elements above all instance non-readonly elements of the same type.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1215.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/NoValueFirstComparison",
        "display_name": "NoValueFirstComparison",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Operands in relational expression go in reverse order, i.e. value first.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|NoValueFirstComparison\n|CheckId|SA1216\n|Category|Ordering Rules\n\n## Cause\n\nOperands in relational expression go in reverse order, i.e. value first.\n\n## Rule Description\n\nA violation of this rule occurs when comparison expression uses C++ assignment proof style: \"if (1 == a)\". Quite a few people call this style \"Yoda conditions\" because it's like saying \"if blue is the sky\" or \"if tall is the man\". Such reverse order has no benefits in C# and affects code readability.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, reverse the order of operands in expression so the value goes to the right hand side.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1216.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/PartialElementsMustDeclareAccess",
        "display_name": "PartialElementsMustDeclareAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The partial element does not have an access modifier defined. StyleCop may not be able to determine the correct\n          placement of the elements in the file. Please declare an access modifier for all partial elements.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PartialElementsMustDeclareAccess\n\nPartialElementsMustDeclareAccess\n|CheckId|SA1205\n\nSA1205\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nThe partial element does not have an access modifier defined. StyleCop may not be able to determine the correct\n          placement of the elements in the file. Please declare an access modifier for all partial elements.\n\n## Rule Description\n\nA violation of this rule occurs when the partial elements does not have an access modifier defined.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, specify an acess modifier for the partial element.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1205.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/PropertyAccessorsMustFollowOrder",
        "display_name": "PropertyAccessorsMustFollowOrder",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A get accessor appears after a set accessor within a property or indexer.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PropertyAccessorsMustFollowOrder\n\nPropertyAccessorsMustFollowOrder\n|CheckId|SA1212\n\nSA1212\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nA get accessor appears after a set accessor within a property or indexer.\n\n## Rule Description\n\nA violation of this rule occurs when a get accessor is placed after a set accessor within a property or indexer. To comply with this rule, the get accessor should appear before the set accessor.\n\nFor example, the following code would raise an instance of this violation:\n\n    public string Name\n\n    { <o:p></o:p>\n\n        set { this.name = value; }<o:p></o:p>\n\n        \n\n    }\n\n\n\nThe code below would not raise this violation:\n\n    public string Name\n\n    { \n\n        get { return this.name; }<o:p></o:p>\n\n        set { this.name = value; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place the get accessor before the set accessor.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1212.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/ProtectedMustComeBeforeInternal",
        "display_name": "ProtectedMustComeBeforeInternal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The keyword **protected** is positioned after the keyword **internal** within the declaration of a protected internal C# element.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ProtectedMustComeBeforeInternal\n\nProtectedMustComeBeforeInternal\n|CheckId|SA1207\n\nSA1207\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nThe keyword **protected** is positioned after the keyword **internal** within the declaration of a protected internal C# element.\n\n## Rule Description\n\nA violation of this rule occurs when a protected internal element’s access modifiers are written as **internal protected**. In reality, an element with the keywords **protected internal** will have the same access level as an element with the keywords **internal protected**. To make the code easier to read and more consistent, StyleCop standardizes the ordering of these keywords, so that a protected internal element will always be described as such, and never as internal protected. This can help to reduce confusion about whether these access levels are indeed the same.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place the **protected** keyword before the **internal** keyword.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1207.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/StaticElementsMustAppearBeforeInstanceElements",
        "display_name": "StaticElementsMustAppearBeforeInstanceElements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A static element is positioned beneath an instance element of the same type.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|StaticElementsMustAppearBeforeInstanceElements\n\nStaticElementsMustAppearBeforeInstanceElements\n|CheckId|SA1204\n\nSA1204\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nA static element is positioned beneath an instance element of the same type.\n\n## Rule Description\n\nA violation of this rule occurs when a static element is positioned beneath an instance element of the same type. All static elements must be placed above all instance elements of the same type to make it easier to see the interface exposed from the instance and static version of the class.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place all static elements above all instance elements of the same type.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1204.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/StaticReadonlyElementsMustAppearBeforeStaticNonReadonlyElements",
        "display_name": "StaticReadonlyElementsMustAppearBeforeStaticNonReadonlyElements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A static readonly element is positioned beneath a static non-readonly element of the same type.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|StaticReadonlyElementsMustAppearBeforeStaticNonReadonlyElements\n|CheckId|SA1214\n|Category|Ordering Rules\n\n## Cause\n\nA static readonly element is positioned beneath a static non-readonly element of the same type.\n\n## Rule Description\n\nA violation of this rule occurs when a static readonly element is positioned beneath a static non-readonly element of the same type. \n\n## How to Fix Violations\n\nTo fix an instance of this violation, place all static readonly elements above all static non-readonly elements of the same type.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1214.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives",
        "display_name": "SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A using directive which declares a member of the **System** namespace appears after a using directive which declares a member of a different namespace, within a C# code file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives\n\nSystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives\n|CheckId|SA1208\n\nSA1208\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nA using directive which declares a member of the **System** namespace appears after a using directive which declares a member of a different namespace, within a C# code file.\n\n## Rule Description\n\nA violation of this rule occurs when a using directive for the **System** namespace is placed after a non-**System** using directive. Placing all **System** using directives at the top of the using directives can make the code cleaner and easier to read, and can help make it easier to identify the namespaces that are being used by the code.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place the **System** using directive above all using directives for other namespaces.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1208.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName",
        "display_name": "UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The using-alias directives within a C# code file are not sorted alphabetically by alias name.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName\n\nUsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName\n|CheckId|SA1211\n\nSA1211\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nThe using-alias directives within a C# code file are not sorted alphabetically by alias name.\n\n## Rule Description\n\nA violation of this rule occurs when the using-alias directives are not sorted alphabetically by alias name. Sorting the using-alias directives alphabetically can make the code cleaner and easier to read, and can help make it easier to identify the namespaces that are being used by the code.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, order the using-alias directives alphabetically by alias name.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1211.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives",
        "display_name": "UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A using-alias directive is positioned before a regular using directive.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives\n\nUsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives\n|CheckId|SA1209\n\nSA1209\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nA using-alias directive is positioned before a regular using directive.\n\n## Rule Description\n\nA violation of this rule occurs when a using-alias directive is placed before a normal using directive. Using-alias directives have special behavior which can alter the meaning of the rest of the code within the file or namespace. Placing the using-alias directives together below all other using-directives can make the code cleaner and easier to read, and can help make it easier to identify the types used throughout the code.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, place all using-alias directives beneath all normal using directives.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1209.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/UsingDirectivesMustBeOrderedAlphabeticallyByNamespace",
        "display_name": "UsingDirectivesMustBeOrderedAlphabeticallyByNamespace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The using directives within a C# code file are not sorted alphabetically by namespace.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UsingDirectivesMustBeOrderedAlphabeticallyByNamespace\n\nUsingDirectivesMustBeOrderedAlphabeticallyByNamespace\n|CheckId|SA1210\n\nSA1210\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nThe using directives within a C# code file are not sorted alphabetically by namespace.\n\n## Rule Description\n\nA violation of this rule occurs when the using directives are not sorted alphabetically by namespace. Sorting the using directives alphabetically makes the code cleaner and easier to read, and can help make it easier to identify the namespaces that are being used by the code. The System namespaces are an exception to this rule and will always precede all other namespaces. See SA1208 for more details.\n\n## How to Fix Violations\n\nTo fix an instance of this violation, order the using directives alphabetically by namespace with all the System namespace entries first.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1210.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/UsingDirectivesMustBePlacedWithinNamespace",
        "display_name": "UsingDirectivesMustBePlacedWithinNamespace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# using directive is placed outside of a namespace element.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UsingDirectivesMustBePlacedWithinNamespace\n\nUsingDirectivesMustBePlacedWithinNamespace\n|CheckId|SA1200\n\nSA1200\n|Category|Ordering Rules\n\nOrdering Rules\n\n## Cause\n\nA C# using directive is placed outside of a namespace element.\n\n## Rule Description\n\nA violation of this rule occurs when a using directive or a using-alias directive is placed outside of a namespace element, unless the file does not contain any namespace elements.\n\nFor example, the following code would result in two violations of this rule.\n\nusing System;<o:p></o:p>\n\nusing Guid = System.Guid;<o:p></o:p>\n\n<o:p> </o:p>\n\nnamespace Microsoft.Sample<o:p></o:p>\n\n{<o:p></o:p>\n\n    public class Program<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n}<o:p></o:p>\n\n\n\nThe following code, however, would not result in any violations of this rule:\n\nnamespace Microsoft.Sample<o:p></o:p>\n\n{<o:p></o:p>\n\n    using System;<o:p></o:p>\n\n    using Guid = System.Guid;<o:p></o:p>\n\n<o:p> </o:p>\n\n    public class Program<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n}<o:p></o:p>\n\n\n\nThere are subtle differences between placing using directives within a namespace element, rather than outside of the namespace, including:\n\n1. Placing using-alias directives within the namespace eliminates compiler confusion between conflicting types.\n\n2. When multiple namespaces are defined within a single file, placing using directives within the namespace elements scopes references and aliases.\n\n**1. Eliminating Type Confusion**\n\nConsider the following code, which contains a using-alias directive defined outside of the namespace element. The code creates a new class called **Guid**, and also defines a using-alias directive to map the name **Guid **to the type **System.Guid. **Finally, the code creates an instance of the type **Guid**:\n\nusing Guid = System.Guid;<o:p></o:p>\n\n<o:p> </o:p>\n\nnamespace Microsoft.Sample<o:p></o:p>\n\n{<o:p></o:p>\n\n    public class Guid<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public Guid(string s)<o:p></o:p>\n\n        {<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public class Program<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public static void Main(string[] args)<o:p></o:p>\n\n        {<o:p></o:p>\n\n            Guid g = new Guid(\"hello\");<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n}<o:p></o:p>\n\n <o:p></o:p>\n\nThis code will compile cleanly, without any compiler errors. However, it is unclear which version of the **Guid** type is being allocated. If the using directive is moved inside of the namespace, as shown below, a compiler error will occur:\n\nnamespace Microsoft.Sample<o:p></o:p>\n\n{<o:p></o:p>\n\n    using Guid = System.Guid;<o:p></o:p>\n\n<o:p> </o:p>\n\n    public class Guid<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public Guid(string s)<o:p></o:p>\n\n        {<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public class Program<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public static void Main(string[] args)<o:p></o:p>\n\n        {<o:p></o:p>\n\n            Guid g = new Guid(\"hello\");<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n}<o:p></o:p>\n\n <o:p></o:p>\n\nThe code fails on the following compiler error, found on the line containing Guid g = new Guid(\"hello\");<o:p></o:p>\n\n**CS0576: Namespace 'Microsoft.Sample' contains a definition conflicting with alias 'Guid'<o:p></o:p>**\n\nThe code creates an alias to the **System.Guid** type called **Guid**, and also creates its own type called **Guid** with a matching constructor interface. Later, the code creates an instance of the type **Guid**. To create this instance, the compiler must choose between the two different definitions of **Guid**. When the using-alias directive is placed outside of the namespace element, the compiler will choose the local definition of **Guid** defined within the local namespace, and completely ignore the using-alias directive defined outside of the namespace. This, unfortunately, is not obvious when reading the code.\n\nWhen the using-alias directive is positioned within the namespace, however, the compiler has to choose between two different, conflicting **Guid** types both defined within the same namespace. Both of these types provide a matching constructor. The compiler is unable to make a decision, so it flags the compiler error.<o:p></o:p>\n\nPlacing the using-alias directive outside of the namespace is a bad practice because it can lead to confusion in situations such as this, where it is not obvious which version of the type is actually being used. This can potentially lead to a bug which might be difficult to diagnose.<o:p></o:p>\n\nPlacing using-alias directives within the namespace element eliminates this as a source of bugs. <o:p></o:p>\n\n**2. Multiple Namespaces<o:p></o:p>**\n\nPlacing multiple namespace elements within a single file is generally a bad idea, but if and when this is done, it is a good idea to place all using directives within each of the namespace elements, rather than globally at the top of the file. This will scope the namespaces tightly, and will also help to avoid the kind of behavior described above.\n\nIt is important to note that when code has been written with using directives placed outside of the namespace, care should be taken when moving these directives within the namespace, to ensure that this is not changing the semantics of the code. As explained above, placing using-alias directives within the namespace element allows the compiler to choose between conflicting types in ways that will not happen when the directives are placed outside of the namespace.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, move all using directives and using-alias directives within the namespace element.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1200.html)"
      },
      {
        "real_name": "StyleCop.CSharp.OrderingRules/UsingStaticDirectivesMustBePlacedAtTheCorrectLocation",
        "display_name": "UsingStaticDirectivesMustBePlacedAtTheCorrectLocation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Verifies that all using static directives are placed after all using namespace directives.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Verifies that all using static directives are placed after all using namespace directives."
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/BlockStatementsMustNotContainEmbeddedComments",
        "display_name": "BlockStatementsMustNotContainEmbeddedComments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# statement contains a comment between the declaration of the statement and the opening curly bracket of the statement.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|BlockStatementsMustNotContainEmbeddedComments\n\nBlockStatementsMustNotContainEmbeddedComments\n|CheckId|SA1108\n\nSA1108\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA C# statement contains a comment between the declaration of the statement and the opening curly bracket of the statement.\n\n## Rule Description\n\nA violation of this rule occurs when the code contains a comment in between the declaration and the opening curly bracket. For example:\n\n    if (x != y)<o:p></o:p>\n\n    // Make sure x does not equal y<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe comment can legally be placed above the statement, or within the body of the statement:\n\n    // Make sure x does not equal y<o:p></o:p>\n\n    if (x != y)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    if (x != y)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        // Make sure x does not equal y<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nIf the comment is being used to comment out a line of code, begin the comment with four forward slashes rather than two:\n\n    if (x != y)<o:p></o:p>\n\n    ////if (x == y)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, move the comment above the statement, within the body of the statement, or remove the comment.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1108.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/BlockStatementsMustNotContainEmbeddedRegions",
        "display_name": "BlockStatementsMustNotContainEmbeddedRegions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# statement contains a region tag between the declaration of the statement and the opening curly bracket of the statement.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|BlockStatementsMustNotContainEmbeddedRegions\n\nBlockStatementsMustNotContainEmbeddedRegions\n|CheckId|SA1109\n\nSA1109\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA C# statement contains a region tag between the declaration of the statement and the opening curly bracket of the statement.\n\n## Rule Description\n\nA violation of this rule occurs when the code contains a region tag in between the declaration and the opening curly bracket. For example:\n\n    if (x != y)<o:p></o:p>\n\n    #region<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n    #endregion<o:p></o:p>\n\n\n\nThis will result in the body of the statement being hidden when the region is collapsed.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the region or move it outside of the statement.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1109.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/ClosingParenthesisMustBeOnLineOfLastParameter",
        "display_name": "ClosingParenthesisMustBeOnLineOfLastParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the last parameter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingParenthesisMustBeOnLineOfLastParameter\n\nClosingParenthesisMustBeOnLineOfLastParameter\n|CheckId|SA1111\n\nSA1111\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the last parameter.\n\n## Rule Description\n\nA violation of this rule occurs when the closing bracket of a method or indexer call or declaration is not placed on the same line as the last parameter. The following examples show correct placement of the bracket:\n\n    public string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        string name = JoinStrings(<o:p></o:p>\n\n            first, <o:p></o:p>\n\n            last);<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public int this[int x]<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.items[x]; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the closing bracket is placed on the same line as the last parameter.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1111.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/ClosingParenthesisMustBeOnLineOfOpeningParenthesis",
        "display_name": "ClosingParenthesisMustBeOnLineOfOpeningParenthesis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the opening bracket when the element does not take any parameters.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingParenthesisMustBeOnLineOfOpeningParenthesis\n\nClosingParenthesisMustBeOnLineOfOpeningParenthesis\n|CheckId|SA1112\n\nSA1112\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the opening bracket when the element does not take any parameters.\n\n## Rule Description\n\nA violation of this rule occurs when a method or indexer does not take any parameters and the closing bracket of a call or declaration for the method or indexer is not placed on the same line as the opening bracket. The following example shows correct placement of the closing parenthesis:\n\n    public string GetName()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return this.name.Trim();<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the closing bracket is placed on the same line as the opening bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1112.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/CodeMustNotContainEmptyStatements",
        "display_name": "CodeMustNotContainEmptyStatements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains an extra semicolon.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainEmptyStatements\n\nCodeMustNotContainEmptyStatements\n|CheckId|SA1106\n\nSA1106\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe C# code contains an extra semicolon.\n\n## Rule Description\n\nA violation of this rule occurs when the code contain an extra semicolon. Syntactically, this results in an extra, empty statement in the code.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the unneeded semicolon.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1106.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/CodeMustNotContainMultipleStatementsOnOneLine",
        "display_name": "CodeMustNotContainMultipleStatementsOnOneLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains more than one statement on a single line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainMultipleStatementsOnOneLine\n\nCodeMustNotContainMultipleStatementsOnOneLine\n|CheckId|SA1107\n\nSA1107\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe C# code contains more than one statement on a single line.\n\n## Rule Description\n\nA violation of this rule occurs when the code contain more than one statement on the same line. Each statement must begin on a new line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, move each statement to begin on its own line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1107.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/CommaMustBeOnSameLineAsPreviousParameter",
        "display_name": "CommaMustBeOnSameLineAsPreviousParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or indexer, is not placed on the same line as the previous parameter.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CommaMustBeOnSameLineAsPreviousParameter\n\nCommaMustBeOnSameLineAsPreviousParameter\n|CheckId|SA1113\n\nSA1113\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or indexer, is not placed on the same line as the previous parameter.\n\n## Rule Description\n\nA violation of this rule occurs when a comma between two parameters to a method or indexer is not placed on the same line as the previous parameter. The following examples show correct placement of the comma:\n\n    public string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        string name = JoinStrings(<o:p></o:p>\n\n            first, <o:p></o:p>\n\n            last);<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public int this[int x, <o:p></o:p>\n\n       int y]<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.items[x, y]; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the comma is placed on the same line as the previous parameter.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1113.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/CommentsMustContainText",
        "display_name": "CommentsMustContainText",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# comment does not contain any comment text.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CommentsMustContainText\n\nCommentsMustContainText\n|CheckId|SA1120\n\nSA1120\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe C# comment does not contain any comment text.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains a C# comment which does not contain any text.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add text to the comment, or remove the comment.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1120.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/DoNotPlaceRegionsWithinElements",
        "display_name": "DoNotPlaceRegionsWithinElements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains a region within the body of a code element.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DoNotPlaceRegionsWithinElements\n\nDoNotPlaceRegionsWithinElements\n|CheckId|SA1123\n\nSA1123\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe C# code contains a region within the body of a code element.\n\n## Rule Description\n\nA violation of this rule occurs whenever a region is placed within the body of a code element. In many editors, including Visual Studio, the region will appear collapsed by default, hiding the code within the region. It is generally a bad practice to hide code within the body of an element, as this can lead to bad decisions as the code is maintained over time.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the region from the code.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1123.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/DoNotPrefixCallsWithBaseUnlessLocalImplementationExists",
        "display_name": "DoNotPrefixCallsWithBaseUnlessLocalImplementationExists",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A call to a member from an inherited class begins with ‘base.’, and the local class does not contain an override or implementation of the member.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DoNotPrefixCallsWithBaseUnlessLocalImplementationExists\n\nDoNotPrefixCallsWithBaseUnlessLocalImplementationExists\n|CheckId|SA1100\n\nSA1100\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA call to a member from an inherited class begins with ‘base.’, and the local class does not contain an override or implementation of the member.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains a call to a member from the base class prefixed with ‘base.’, and there is no local implementation of the member. For example:\n\n    string name = base.JoinName(\"John\", \"Doe\");<o:p></o:p>\n\nThis rule is in place to prevent a potential source of bugs. Consider a base class which contains the following virtual method:\n\n    public virtual string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nAnother class inherits from this base class but does not provide a local override of this method. Somewhere within this class, the base class method is called using base.JoinName(...). This works as expected. At a later date, someone adds a local override of this method to the class:\n\n    public override string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return “Bob”;<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nAt this point, the local call to base.JoinName(...) most likely introduces a bug into the code. This call will always call the base class method and will cause the local override to be ignored. \n\nFor this reason, calls to members from a base class should not begin with ‘base.’, unless a local override is implemented, and the developer wants to specifically call the base class member. When there is no local override of the base class member, the call should be prefixed with 'this.' rather than 'base.'.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, change the ‘base.’ prefix to ‘this.’.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1100.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/DoNotUseRegions",
        "display_name": "DoNotUseRegions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains a region.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DoNotUseRegions\n\nDoNotUseRegions\n|CheckId|SA1124\n\nSA1124\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe C# code contains a region.\n\n## Rule Description\n\nA violation of this rule occurs whenever a region is placed anywhere within the code. In many editors, including Visual Studio, the region will appear collapsed by default, hiding the code within the region. It is generally a bad practice to hide code, as this can lead to bad decisions as the code is maintained over time.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the region from the code.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1124.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/OpeningParenthesisMustBeOnDeclarationLine",
        "display_name": "OpeningParenthesisMustBeOnDeclarationLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The opening parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the method or indexer name.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningParenthesisMustBeOnDeclarationLine\n\nOpeningParenthesisMustBeOnDeclarationLine\n|CheckId|SA1110\n\nSA1110\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe opening parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the method or indexer name.\n\n## Rule Description\n\nA violation of this rule occurs when the opening bracket of a method or indexer call or declaration is not placed on the same line as the method or indexer. The following examples show correct placement of the opening bracket:\n\n    public string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        return JoinStrings(<o:p></o:p>\n\n            first, last);<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public int this[int x]<o:p></o:p>\n\n    {<o:p></o:p>\n\n        get { return this.items[x]; }<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the opening bracket is placed on the same line as the name of the method or indexer.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1110.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/ParameterListMustFollowDeclaration",
        "display_name": "ParameterListMustFollowDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The start of the parameter list for a method or indexer call or declaration does not begin on the same line as the opening bracket, or on the line after the opening bracket.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ParameterListMustFollowDeclaration\n\nParameterListMustFollowDeclaration\n|CheckId|SA1114\n\nSA1114\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe start of the parameter list for a method or indexer call or declaration does not begin on the same line as the opening bracket, or on the line after the opening bracket.\n\n## Rule Description\n\nA violation of this rule occurs when there are one or more blank lines between the opening bracket and the start of the parameter list. For example:\n\n    public string JoinName(<o:p></o:p>\n\n<o:p> </o:p>\n\n        string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nThe parameter list must begin on the same line as the opening bracket, or on the next line. For example:\n\n\n\n    public string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public string JoinName(<o:p></o:p>\n\n        string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the parameter list begins on the same line as the opening bracket, or on the next line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1114.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/ParameterMustFollowComma",
        "display_name": "ParameterMustFollowComma",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A parameter within a C# method or indexer call or declaration does not begin on the same line as the previous parameter, or on the next line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ParameterMustFollowComma\n\nParameterMustFollowComma\n|CheckId|SA1115\n\nSA1115\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA parameter within a C# method or indexer call or declaration does not begin on the same line as the previous parameter, or on the next line.\n\n## Rule Description\n\nA violation of this rule occurs when there are one or more blank lines between a parameter and the previous parameter. For example:\n\n    public string JoinName(<o:p></o:p>\n\n        string first, <o:p></o:p>\n\n<o:p> </o:p>\n\n        string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nThe parameter must begin on the same line as the previous comma, or on the next line. For example:\n\n\n\n    public string JoinName(string first, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public string JoinName(<o:p></o:p>\n\n        string first, <o:p></o:p>\n\n        string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the parameter begins on the same line as the previous comma, or on the next line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1115.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/ParameterMustNotSpanMultipleLines",
        "display_name": "ParameterMustNotSpanMultipleLines",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A parameter to a C# method or indexer, other than the first parameter, spans across multiple lines.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ParameterMustNotSpanMultipleLines\n\nParameterMustNotSpanMultipleLines\n|CheckId|SA1118\n\nSA1118\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA parameter to a C# method or indexer, other than the first parameter, spans across multiple lines.\n\n## Rule Description\n\nTo prevent method calls from becoming excessively complicated and unreadable, only the first parameter to a method or indexer call is allowed to span across multiple lines. The exception is an anonymous method passed as a parameter, which is always allowed to span multiple lines. A violation of this rule occurs whenever a parameter other than the first parameter spans across multiple lines, and the parameter does not contain an anonymous method.\n\nFor example, the following code would violate this rule, since the second parameter spans across multiple lines:\n\n    return JoinStrings(<o:p></o:p>\n\n        \"John\",<o:p></o:p>\n\n        \"Smith\" + <o:p></o:p>\n\n        \" Doe\");<o:p></o:p>\n\n<o:p> </o:p>\n\nWhen parameters other than the first parameter span across multiple lines, it can be difficult to tell how many parameters are passed to the method. In general, the code becomes difficult to read.\n\n\n\nTo fix the example above, ensure that the parameters after the first parameter do not span across multiple lines. If this will cause a parameter to be excessively long, store the value of the parameter within a temporary variable. For example:\n\n\n\n    string last = \"Smith\" + <o:p></o:p>\n\n        \" Doe\";<o:p></o:p>\n\n<o:p> </o:p>\n\n    return JoinStrings(<o:p></o:p>\n\n        \"John\",<o:p></o:p>\n\n        last);<o:p></o:p>\n\n<o:p> </o:p>\n\nIn some cases, this will allow the method to be written even more concisely, such as:\n\n<o:p> </o:p>\n\n    return JoinStrings(\"John\", last);<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the parameters after the first parameter do not span multiple lines, unless the parameter contains an anonymous method.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1118.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/ParametersMustBeOnSameLineOrSeparateLines",
        "display_name": "ParametersMustBeOnSameLineOrSeparateLines",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The parameters to a C# method or indexer call or declaration are not all on the same line or each on a separate line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ParametersMustBeOnSameLineOrSeparateLines\n\nParametersMustBeOnSameLineOrSeparateLines\n|CheckId|SA1117\n\nSA1117\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe parameters to a C# method or indexer call or declaration are not all on the same line or each on a separate line.\n\n## Rule Description\n\nA violation of this rule occurs when the parameters to a method or indexer are not all on the same line or each on its own line. For example:\n\n    public string JoinName(string first, string middle,<o:p></o:p>\n\n        string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nThe parameters can all be placed on the same line:\n\n\n\n    public string JoinName(string first, string middle, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n    public string JoinName(<o:p></o:p>\n\n        string first, string middle, string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nAlternatively, each parameter can be placed on its own line:\n\n\n\n    public string JoinName(<o:p></o:p>\n\n        string first, <o:p></o:p>\n\n        string middle, <o:p></o:p>\n\n        string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, place all parameters on the same line, or place each parameter on its own line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1117.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/PrefixCallsCorrectly",
        "display_name": "PrefixCallsCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A call to a member is not prefixed with the 'this.', 'base.', 'object.' or 'typename.' prefix to indicate the intended method call, within a C# code file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PrefixCallsCorrectly\n\nPrefixCallsCorrectly\n|CheckId|SA1126\n\nSA1126\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA call to a member is not prefixed with the 'this.', 'base.', 'object.' or 'typename.' prefix to indicate the intended method call, within a C# code file.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains a call to a member which is not prefixed correctly.\n\nIn some case from sourcecode analysis we cannot be sure which prefix is required. \n                    It could be 'this', 'base', 'object', the typename of the class we're in or one \n                    of our base classes.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, insert the correct prefix before the call to the class member.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1126.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/PrefixLocalCallsWithThis",
        "display_name": "PrefixLocalCallsWithThis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A call to an instance member of the local class or a base class is not prefixed with ‘this.’, within a C# code file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PrefixLocalCallsWithThis\n\nPrefixLocalCallsWithThis\n|CheckId|SA1101\n\nSA1101\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA call to an instance member of the local class or a base class is not prefixed with ‘this.’, within a C# code file.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains a call to an instance member of the local class or a base class which is not prefixed with ‘this.’. An exception to this rule occurs when there is a local override of a base class member, and the code intends to call the base class member directly, bypassing the local override. In this case the call can be prefixed with ‘base.’ rather than ‘this.’.\n\nBy default, StyleCop disallows the use of underscores or **m_** to mark local class fields, in favor of the ‘this.’ prefix. The advantage of using ‘this.’ is that it applies equally to all element types including methods, properties, etc., and not just fields, making all calls to class members instantly recognizable, regardless of which editor is being used to view the code. Another advantage is that it creates a quick, recognizable differentiation between instance members and static members, which are not be prefixed.\n\nA final advantage of using the ‘this.’ prefix is that typing **this.** will cause Visual Studio to show the IntelliSense popup, making it quick and easy for the developer to choose the class member to call.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, insert the ‘this.’ prefix before the call to the class member.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1101.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/QueryClauseMustBeginOnNewLineWhenPreviousClauseSpansMultipleLines",
        "display_name": "QueryClauseBeginOnNewLineWhenPreviousClauseSpansMultipleLines",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A clause within a C# query expression begins on the same line as the previous clause, when the previous clause spans across multiple lines.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|QueryClauseMustBeginOnNewLineWhenPreviousClauseSpansMultipleLines\n\nQueryClauseMustBeginOnNewLineWhenPreviousClauseSpansMultipleLines\n|CheckId|SA1104\n\nSA1104\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA clause within a C# query expression begins on the same line as the previous clause, when the previous clause spans across multiple lines.\n\n## Rule Description\n\nA violation of this rule occurs when a query clause spans across multiple lines, and the next clause begins on the same line as the end of the previous clause.\n\n    object x = <o:p></o:p>\n\n        select a <o:p></o:p>\n\n        in b.GetCustomers(<o:p></o:p>\n\n            2, “x”) from c;<o:p></o:p>\n\n\n\nThe query clause can correctly be written as:\n\n    object x = <o:p></o:p>\n\n        select a <o:p></o:p>\n\n        in b.GetCustomers(<o:p></o:p>\n\n            2, “x”) <o:p></o:p>\n\n        from c;<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, move the clause down to start on the next line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1104.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/QueryClauseMustFollowPreviousClause",
        "display_name": "QueryClauseMustFollowPreviousClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# query clause does not begin on the same line as the previous clause, or on the next line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|QueryClauseMustFollowPreviousClause\n\nQueryClauseMustFollowPreviousClause\n|CheckId|SA1102\n\nSA1102\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA C# query clause does not begin on the same line as the previous clause, or on the next line.\n\n## Rule Description\n\nA violation of this rule occurs when a clause within a query expression does not begin on the same line as the previous clause, or on the line after the query clause. For example:\n\n    object x = select a in b <o:p></o:p>\n\n<o:p> </o:p>\n\n        from c;<o:p></o:p>\n\n<o:p> </o:p>\n\nThe query clause can correctly be written as:\n\n    object x = select a in b from c;<o:p></o:p>\n\n<o:p> </o:p>\n\nor:\n\n    object x = <o:p></o:p>\n\n        select a <o:p></o:p>\n\n        in b <o:p></o:p>\n\n        from c;<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that each clause in the query expression begins on the same line as the previous clause, or on the following line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1102.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/QueryClausesMustBeOnSeparateLinesOrAllOnOneLine",
        "display_name": "QueryClausesMustBeOnSeparateLinesOrAllOnOneLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The clauses within a C# query expression are not all placed on the same line, and each clause is not placed on its own line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|QueryClausesMustBeOnSeparateLinesOrAllOnOneLine\n\nQueryClausesMustBeOnSeparateLinesOrAllOnOneLine\n|CheckId|SA1103\n\nSA1103\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe clauses within a C# query expression are not all placed on the same line, and each clause is not placed on its own line.\n\n## Rule Description\n\nA violation of this rule occurs when the query clauses are not either placed all on the same line, or each on its own line. For example:\n\n    object x = \n                    from num in numbers <o:p></o:p>\n\n        \nselect num;<o:p></o:p>\n\n<o:p> </o:p>\n\nThe query clauses can correctly be written as:\n\n    object x = \n                    from num in \n                    numbers select num;<o:p></o:p>\n\n<o:p> </o:p>\n\nor:\n\n    object x = <o:p></o:p>\n\n        \nfrom num in \n                    numbers <o:p></o:p>\n\n        \nselect num;<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that all clauses are placed together on the same line, or each clause begins on its own line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1103.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/QueryClausesSpanningMultipleLinesMustBeginOnOwnLine",
        "display_name": "QueryClausesSpanningMultipleLinesMustBeginOnOwnLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A clause within a C# query expression spans across multiple lines, and does not begin on its own line.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|QueryClausesSpanningMultipleLinesMustBeginOnOwnLine\n\nQueryClausesSpanningMultipleLinesMustBeginOnOwnLine\n|CheckId|SA1105\n\nSA1105\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nA clause within a C# query expression spans across multiple lines, and does not begin on its own line.\n\n## Rule Description\n\nA violation of this rule occurs when a query clause spans across multiple lines, but does not begin on its own line. For example:\n\n    object x = <o:p></o:p>\n\n        select a in b from c.GetCustomers(<o:p></o:p>\n\n            2, “x”);<o:p></o:p>\n\n\n\nThe query clause can correctly be written as:\n\n    object x = <o:p></o:p>\n\n        select a <o:p></o:p>\n\n        in b\n\n        from c.GetCustomers(<o:p></o:p>\n\n            2, “x”);<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, move the clause down to start on the next line.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1105.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/SplitParametersMustStartOnLineAfterDeclaration",
        "display_name": "SplitParametersMustStartOnLineAfterDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The parameters to a C# method or indexer call or declaration span across multiple lines, but the first parameter does not start on the line after the opening bracket.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SplitParametersMustStartOnLineAfterDeclaration\n\nSplitParametersMustStartOnLineAfterDeclaration\n|CheckId|SA1116\n\nSA1116\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe parameters to a C# method or indexer call or declaration span across multiple lines, but the first parameter does not start on the line after the opening bracket.\n\n## Rule Description\n\nA violation of this rule occurs when the parameters to a method or indexer span across multiple lines, but the first parameter does not start on the line after the opening bracket. For example:\n\n    public string JoinName(string first, <o:p></o:p>\n\n        string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nThe parameters must begin on the line after the declaration, whenever the parameter span across multiple lines:\n\n\n\n    public string JoinName(<o:p></o:p>\n\n        string first, <o:p></o:p>\n\n        string last)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the first parameter starts on the line after the opening bracket, or place all parameters on the same line if the parameters are not too long.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1116.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/UseBuiltInTypeAlias",
        "display_name": "UseBuiltInTypeAlias",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The code uses one of the basic C# types, but does not use the built-in alias for the type.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UseBuiltInTypeAlias\n\nUseBuiltInTypeAlias\n|CheckId|SA1121\n\nSA1121\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe code uses one of the basic C# types, but does not use the built-in alias for the type.\n\n## Rule Description\n\nA violation of this rule occurs when one of the following types are used anywhere in the code: **Boolean, Byte, Char, Decimal, Double, Int16, Int32, Int64, Object, SByte, Single, String, UInt16, UInt32, UInt64**.\n\nA violation also occurs when any of these types are represented in the code using the full namespace for the type: **System.Boolean, System.Byte, System.Char, System.Decimal, System.Double, System.Int16, System.Int32, System.Int64, System.Object, System.SByte, System.Single, System.String, System.UInt16, System.UInt32, System.UInt64**.\n\nRather than using the type name or the fully-qualified type name, the built-in aliases for these types should always be used: <em>bool, byte, char, decimal, double, short, int, long, object, sbyte, \n                    float, string, ushort, uint, ulong</em>.\n\nThe following table lists each of these types in all three formats:\n\n**Type Alias<o:p></o:p>**\n\n**Type<o:p></o:p>**\n\n**Fully Qualified Type<o:p></o:p>**\n\nbool\n\nBoolean\n\nSystem.Boolean\n\nbyte\n\nByte\n\nSystem.Byte\n\nchar\n\nChar\n\nSystem.Char\n\ndecimal\n\nDecimal\n\nSystem.Decimal\n\ndouble\n\nDouble\n\nSystem.Double\n\nshort\n\nInt16\n\nSystem.Int16\n\nint\n\nInt32\n\nSystem.Int32\n\nlong\n\nInt64\n\nSystem.Int64\n\nobject\n\nObject\n\nSystem.Object\n\nsbyte\n\nSByte\n\nSystem.SByte\n\nfloat\n\nSingle\n\nSystem.Single\n\nstring\n\nString\n\nSystem.String\n\nushort\n\nUInt16\n\nSystem.UInt16\n\nuint\n\nUInt32\n\nSystem.UInt32\n\nulong\n\nUInt64\n\nSystem.UInt64\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, replace the type with the built-in alias for the type.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1121.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/UseReadableConditions",
        "display_name": "UseReadableConditions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Validates that value first comparison is not used.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Validates that value first comparison is not used."
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/UseShorthandForNullableTypes",
        "display_name": "UseShorthandForNullableTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Nullable type has been defined not using the C# shorthand. For example, Nullable&lt;DateTime&gt; has been used instead of the preferred DateTime?",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UseShorthandForNullableTypes\n\nUseShorthandForNullableTypes\n|CheckId|SA1125\n\nSA1125\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe Nullable type has been defined not using the C# shorthand. For example, Nullable&lt;DateTime&gt; has been used instead of the preferred DateTime?\n\n## Rule Description\n\nA violation of this rule occurs whenever the Nullable type has been defined without using the shorthand C# style.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, use the shorthand version of the nullable type ie. int?, DateTime?, etc.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1125.html)"
      },
      {
        "real_name": "StyleCop.CSharp.ReadabilityRules/UseStringEmptyForEmptyStrings",
        "display_name": "UseStringEmptyForEmptyStrings",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code includes an empty string, written as “”.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|UseStringEmptyForEmptyStrings\n\nUseStringEmptyForEmptyStrings\n|CheckId|SA1122\n\nSA1122\n|Category|Readability Rules\n\nReadability Rules\n\n## Cause\n\nThe C# code includes an empty string, written as “”.\n\n## Rule Description\n\nA violation of this rule occurs when the code contains an empty string. For example:\n\n    string s = \"\";<o:p></o:p>\n\nThis will cause the compiler to embed an empty string into the compiled code. Rather than including a hard-coded empty string, use the static string.Empty property:\n\n    string s = string.Empty;<o:p></o:p>\n\n<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, replace the hard-coded empty string with string.Empty.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1122.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/ClosingAttributeBracketsMustBeSpacedCorrectly",
        "display_name": "ClosingAttributeBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing attribute bracket within a C# element is not spaced correctly.<o:p></o:p>",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingAttributeBracketsMustBeSpacedCorrectly\n\nClosingAttributeBracketsMustBeSpacedCorrectly\n|CheckId|SA1017\n\nSA1017\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA closing attribute bracket within a C# element is not spaced correctly.<o:p></o:p>\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a closing attribute bracket is not correct.\n\nA closing attribute bracket should never be preceded by whitespace, unless the bracket is the first character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that there is no whitespace before the closing attribute bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1017.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/ClosingCurlyBracketsMustBeSpacedCorrectly",
        "display_name": "ClosingCurlyBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing curly bracket within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingCurlyBracketsMustBeSpacedCorrectly\n\nClosingCurlyBracketsMustBeSpacedCorrectly\n|CheckId|SA1013\n\nSA1013\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA closing curly bracket within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a closing curly bracket is not correct.\n\nA closing curly bracket should always be followed by a single space, unless it is the last character on the line, or unless it is followed by a closing parenthesis, a comma, or a semicolon.\n\nA closing curly bracket must always be preceded by a single space, unless it is the first character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the closing curly bracket follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1013.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/ClosingGenericBracketsMustBeSpacedCorrectly",
        "display_name": "ClosingGenericBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing generic bracket within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingGenericBracketsMustBeSpacedCorrectly\n\nClosingGenericBracketsMustBeSpacedCorrectly\n|CheckId|SA1015\n\nSA1015\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA closing generic bracket within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a closing generic bracket is not correct.\n\nA closing generic bracket should never be preceded by whitespace, unless the bracket is the first character on the line.\n                    A closing generic bracket should be followed by an open parenthesis, a close \n                    parenthesis, a closing generic bracket, a nullable symbol, an end of \n                    line or a single whitespace (but not whitespace and an open parenthesis).\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure the whitespace around the closing generic bracket \n                    is correct.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1015.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/ClosingParenthesisMustBeSpacedCorrectly",
        "display_name": "ClosingParenthesisMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing parenthesis within a C# statement is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingParenthesisMustBeSpacedCorrectly\n\nClosingParenthesisMustBeSpacedCorrectly\n|CheckId|SA1009\n\nSA1009\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA closing parenthesis within a C# statement is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the closing parenthesis within a statement is not spaced correctly.\n\nA closing parenthesis should never be preceded by whitespace. In most cases, a closing parenthesis should be followed by a single space, unless the closing parenthesis comes at the end of a cast, or the closing parenthesis is followed by certain types of operator symbols, such as positive signs, negative signs, and colons.\n\nIf the closing parenthesis is followed by whitespace, the next non-whitespace character must not be an opening or closing parenthesis or square bracket, or a semicolon or comma.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the closing parenthesis follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1009.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/ClosingSquareBracketsMustBeSpacedCorrectly",
        "display_name": "ClosingSquareBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A closing square bracket within a C# statement is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ClosingSquareBracketsMustBeSpacedCorrectly\n\nClosingSquareBracketsMustBeSpacedCorrectly\n|CheckId|SA1011\n\nSA1011\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA closing square bracket within a C# statement is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a closing square bracket is not correct.\n\nA closing square bracket must never be preceded by whitespace, unless it is the first character on the line.\n\nA closing square bracket must be followed by whitespace, unless it is the last character on the line, it is followed by a closing bracket or an opening parenthesis, it is followed by a comma or semicolon, or it is followed by certain types of operator symbols.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the closing square bracket follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1011.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/CodeMustNotContainMultipleWhitespaceInARow",
        "display_name": "CodeMustNotContainMultipleWhitespaceInARow",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The code contains multiple whitespace characters in a row.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainMultipleWhitespaceInARow\n\nCodeMustNotContainMultipleWhitespaceInARow\n|CheckId|SA1025\n\nSA1025\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe code contains multiple whitespace characters in a row.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains multiple whitespace characters in a row, unless the characters come at the beginning or end of a line of code, \n                    following a comma or semicolon or preceeding a symbol.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the extra whitespace characters are leave only a single space.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1025.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation",
        "display_name": "NotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An implicitly typed new array allocation within a C# code file is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation\n\nCodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation\n|CheckId|SA1026\n\nSA1026\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn implicitly typed new array allocation within a C# code file is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains an implicitly typed new array allocation which is not spaced correctly. Within an implicitly typed new array allocation, there should not be any space between the new keyword and the opening array bracket. For example:\n\n    var a = new[] { 1, 10, 100, 1000 };<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove any whitespace between the new keyword and the opening array bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1026.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/ColonsMustBeSpacedCorrectly",
        "display_name": "ColonsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A colon within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|ColonsMustBeSpacedCorrectly\n\nColonsMustBeSpacedCorrectly\n|CheckId|SA1024\n\nSA1024\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA colon within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a colon is not correct.\n\nThe spacing around a colon depends upon the type of colon and how it is used within the code. A colon appearing within an element declaration must always have a single space on either side, unless it is the first or last character on the line. For example all of the colons below follow this rule:\n\n    public class Class2&lt;T&gt; : Class1 where T : MyType<o:p></o:p>\n\n    {<o:p></o:p>\n\n        public Class2(int x) : base(x)<o:p></o:p>\n\n        {<o:p></o:p>\n\n        }<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nWhen the colon comes at the end of a label or case statement, it must always be followed by whitespace or be the last character on the line, but should never be preceded by whitespace. For example:\n\n    _label:<o:p></o:p>\n\n    switch (x)<o:p></o:p>\n\n    {<o:p></o:p>\n\n        case 2: <o:p></o:p>\n\n            return x;<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\nFinally, when a colon is used within a conditional statement, it must always contain a single space on either side, unless the colon is the first or last character on the line. For example:\n\n    int x = y ? 2 : 3;<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the colon follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1024.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/CommasMustBeSpacedCorrectly",
        "display_name": "CommasMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The spacing around a comma is incorrect, within a C# code file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|CommasMustBeSpacedCorrectly\n\nCommasMustBeSpacedCorrectly\n|CheckId|SA1001\n\nSA1001\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe spacing around a comma is incorrect, within a C# code file.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a comma is incorrect.\n\nA comma should always be followed by a single space, unless it is the last character on the line, and a comma should never be preceded by any whitespace, unless it is the first character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the comma is followed by a single space, and is not preceded by any space.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1001.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/DereferenceAndAccessOfMustBeSpacedCorrectly",
        "display_name": "DereferenceAndAccessOfMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A dereference symbol or an access-of symbol within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DereferenceAndAccessOfMustBeSpacedCorrectly\n\nDereferenceAndAccessOfMustBeSpacedCorrectly\n|CheckId|SA1023\n\nSA1023\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA dereference symbol or an access-of symbol within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a dereference or access-of symbol is not correct.\n\nThe spacing around the symbol depends upon whether the symbol is used within a type declaration. If so, the symbol must always be followed by a single space, unless it is the last character on the line, or is followed by an opening square bracket or a parenthesis. In addition, the symbol should not be preceded by whitespace, and should not be the first character on the line. An example of a properly spaced dereference symbol used within a type declaration is:\n\n    object* x = null;<o:p></o:p>\n\nWhen a dereference or access-of symbol is used outside of a type declaration, the \n    opposite rule applies. In this case, the symbol must always be preceded by a \n    single space, unless it is the first character on the line, or is preceded by an \n    opening square bracket, a parenthesis or a symbol of the same type i.e. an \n    equals. The symbol should not be followed by whitespace, and should not be the last character on the line. For example:\n\n    y = *x;<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the dereference or address-of symbol follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1023.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly",
        "display_name": "DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Validates the spacing before and after a dereference or address-of symbol.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Validates the spacing before and after a dereference or address-of symbol."
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/DocumentationLinesMustBeginWithSingleSpace",
        "display_name": "DocumentationLinesMustBeginWithSingleSpace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A line within a documentation header above a C# element does not begin with a single space.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|DocumentationLinesMustBeginWithSingleSpace\n\nDocumentationLinesMustBeginWithSingleSpace\n|CheckId|SA1004\n\nSA1004\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA line within a documentation header above a C# element does not begin with a single space.\n\n## Rule Description\n\n<a name=\"sectionToggle1\"></a>A violation of this rule occurs when a line within a documentation header does not begin with a single space. For example:\n\n    ///&lt;summary&gt;<o:p></o:p>\n\n    ///The summary text.<o:p></o:p>\n\n    ///&lt;/summary&gt;<o:p></o:p>\n\n    ///   &lt;param name=\"x\"&gt;The document root.&lt;/param&gt;<o:p></o:p>\n\n    ///    &lt;param name=\"y\"&gt;The Xml header token.&lt;/param&gt;<o:p></o:p>\n\n    private void Method1(int x, int y)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nThe header lines should begin with a single space after the three leading forward slashes:\n\n    /// &lt;summary&gt;<o:p></o:p>\n\n    /// The summary text.<o:p></o:p>\n\n    /// &lt;/summary&gt;<o:p></o:p>\n\n    /// &lt;param name=\"x\"&gt;The document root.&lt;/param&gt;<o:p></o:p>\n\n    /// &lt;param name=\"y\"&gt;The Xml header token.&lt;/param&gt;<o:p></o:p>\n\n    private void Method1(int x, int y)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the header line begins with a single space.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1004.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/DoNotSplitNullConditionalOperators",
        "display_name": "DoNotSplitNullConditionalOperators",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Verifies that the code does not contain new rows or spaces.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Verifies that the code does not contain new rows or spaces."
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/IncrementDecrementSymbolsMustBeSpacedCorrectly",
        "display_name": "IncrementDecrementSymbolsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An increment or decrement symbol within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|IncrementDecrementSymbolsMustBeSpacedCorrectly\n\nIncrementDecrementSymbolsMustBeSpacedCorrectly\n|CheckId|SA1020\n\nSA1020\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn increment or decrement symbol within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around an increment or decrement symbol is not correct.\n\nThere should be no whitespace between the increment or decrement symbol and the item that is being incremented or decremented.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that there is no whitespace between the increment or decrement symbol and the item that is being incremented or decremented.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1020.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/KeywordsMustBeSpacedCorrectly",
        "display_name": "KeywordsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The spacing around a C# keyword is incorrect.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|KeywordsMustBeSpacedCorrectly\n\nKeywordsMustBeSpacedCorrectly\n|CheckId|SA1000\n\nSA1000\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe spacing around a C# keyword is incorrect.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a keyword is incorrect.\n\nThe following C# keywords must always be followed by a single space: **catch, fixed, for, foreach, from, group, if, in, into, join, let, lock, orderby, return, select, stackalloc, switch, throw, using, where, while, yield**.\n\nThe following keywords must not be followed by any space: **checked, default, sizeof, typeof, unchecked**.\n\nThe **new** keyword should always be followed by a space, unless it is used to create a new array, in which case there should be no space between the **new** keyword and the opening array bracket.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add or remove a space after the keyword, according to the description above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1000.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/MemberAccessSymbolsMustBeSpacedCorrectly",
        "display_name": "MemberAccessSymbolsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The spacing around a member access symbol is incorrect, within a C# code file.<o:p></o:p>",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|MemberAccessSymbolsMustBeSpacedCorrectly\n\nMemberAccessSymbolsMustBeSpacedCorrectly\n|CheckId|SA1019\n\nSA1019\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe spacing around a member access symbol is incorrect, within a C# code file.<o:p></o:p>\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a member access symbol is incorrect. A member access symbol should not have whitespace on either side, unless it is the first character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the member access symbol is not surrounded by any whitespace.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1019.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/NegativeSignsMustBeSpacedCorrectly",
        "display_name": "NegativeSignsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A negative sign within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|NegativeSignsMustBeSpacedCorrectly\n\nNegativeSignsMustBeSpacedCorrectly\n|CheckId|SA1021\n\nSA1021\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA negative sign within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a negative sign is not correct.\n\nA negative sign should always be preceded by a single space, unless it comes after an opening square bracket, a parenthesis, or is the first character on the line.\n\nA negative sign should never be followed by whitespace, and should never be the last character on a line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the negative sign follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1021.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/NullableTypeSymbolsMustNotBePrecededBySpace",
        "display_name": "NullableTypeSymbolsMustNotBePrecededBySpace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A nullable type symbol within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|NullableTypeSymbolsMustNotBePrecededBySpace\n\nNullableTypeSymbolsMustNotBePrecededBySpace\n|CheckId|SA1018\n\nSA1018\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA nullable type symbol within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a nullable type symbol is not correct.\n\nA nullable type symbol should never be preceded by whitespace, unless the symbol is the first character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that there is no whitespace before the nullable type symbol.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1018.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/OpeningAttributeBracketsMustBeSpacedCorrectly",
        "display_name": "OpeningAttributeBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening attribute bracket within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningAttributeBracketsMustBeSpacedCorrectly\n\nOpeningAttributeBracketsMustBeSpacedCorrectly\n|CheckId|SA1016\n\nSA1016\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn opening attribute bracket within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around an opening attribute bracket is not correct.\n\nAn opening attribute bracket should never be followed by whitespace, unless the bracket is the last character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that there is no whitespace after the opening attribute bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1016.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/OpeningCurlyBracketsMustBeSpacedCorrectly",
        "display_name": "OpeningCurlyBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening curly bracket within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningCurlyBracketsMustBeSpacedCorrectly\n\nOpeningCurlyBracketsMustBeSpacedCorrectly\n|CheckId|SA1012\n\nSA1012\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn opening curly bracket within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around an opening curly bracket is not correct.\n\nAn opening curly bracket should always be preceded by a single space, unless it is the first character on the line, or unless it is preceded by an opening parenthesis, in which case there should be no space between the parenthesis and the curly bracket.\n\nAn opening curly bracket must always be followed by a single space, unless it is the last character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the opening curly bracket follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1012.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/OpeningGenericBracketsMustBeSpacedCorrectly",
        "display_name": "OpeningGenericBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening generic bracket within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningGenericBracketsMustBeSpacedCorrectly\n\nOpeningGenericBracketsMustBeSpacedCorrectly\n|CheckId|SA1014\n\nSA1014\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn opening generic bracket within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around an opening generic bracket is not correct.\n\nAn opening generic bracket should never be preceded or followed by whitespace, unless the bracket is the first or last character on the line.\n\n## How to Fix Violations \n\nTo fix a violation of this rule, ensure that there is no whitespace on either side of the opening generic bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1014.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/OpeningParenthesisMustBeSpacedCorrectly",
        "display_name": "OpeningParenthesisMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening parenthesis within a C# statement is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningParenthesisMustBeSpacedCorrectly\n\nOpeningParenthesisMustBeSpacedCorrectly\n|CheckId|SA1008\n\nSA1008\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn opening parenthesis within a C# statement is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the opening parenthesis within a statement is not spaced correctly. An opening parenthesis should not be preceded by any whitespace, unless it is the first character on the line, or it is preceded by certain C# keywords such as if, while, or for. In addition, an opening parenthesis is allowed to be preceded by whitespace when it follows an operator symbol within an expression.\n\nAn opening parenthesis should not be followed by whitespace, unless it is the last character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the opening parenthesis follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1008.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/OpeningSquareBracketsMustBeSpacedCorrectly",
        "display_name": "OpeningSquareBracketsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An opening square bracket within a C# statement is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OpeningSquareBracketsMustBeSpacedCorrectly\n\nOpeningSquareBracketsMustBeSpacedCorrectly\n|CheckId|SA1010\n\nSA1010\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nAn opening square bracket within a C# statement is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when an opening square bracket within a statement is preceded or followed by whitespace.\n\nAn opening square bracket must never be preceded by whitespace, unless it is the first character on the line, and an opening square must never be followed by whitespace, unless it is the last character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that there is no whitespace on either side of the opening square bracket.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1010.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/OperatorKeywordMustBeFollowedBySpace",
        "display_name": "OperatorKeywordMustBeFollowedBySpace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator keyword within a C# operator overload method is not followed by any whitespace.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|OperatorKeywordMustBeFollowedBySpace\n\nOperatorKeywordMustBeFollowedBySpace\n|CheckId|SA1007\n\nSA1007\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe operator keyword within a C# operator overload method is not followed by any whitespace.\n\n## Rule Description\n\nA violation of this rule occurs when the operator keyword within an operator overload method is not followed by any whitespace. The operator keyword should always be followed by a single space. For example:\n\n    public MyClass operator +(MyClass a, MyClass b)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, add a single space after the operator keyword.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1007.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/PositiveSignsMustBeSpacedCorrectly",
        "display_name": "PositiveSignsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A positive sign within a C# element is not spaced correctly.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PositiveSignsMustBeSpacedCorrectly\n\nPositiveSignsMustBeSpacedCorrectly\n|CheckId|SA1022\n\nSA1022\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA positive sign within a C# element is not spaced correctly.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a positive sign is not correct.\n\nA positive sign should always be preceded by a single space, unless it comes after an opening square bracket, a parenthesis, or is the first character on the line.\n\nA positive sign should never be followed by whitespace, and should never be the last character on a line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the positive sign follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1022.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/PreprocessorKeywordsMustNotBePrecededBySpace",
        "display_name": "PreprocessorKeywordsMustNotBePrecededBySpace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A C# preprocessor-type keyword is preceded by space.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|PreprocessorKeywordsMustNotBePrecededBySpace\n\nPreprocessorKeywordsMustNotBePrecededBySpace\n|CheckId|SA1006\n\nSA1006\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA C# preprocessor-type keyword is preceded by space.\n\n## Rule Description\n\nA violation of this rule occurs when the preprocessor-type keyword in a preprocessor directive is preceded by space. For example:\n\n    # if Debug<o:p></o:p>\n\nThere should not be any whitespace between the opening hash mark and the preprocessor-type keyword:<o:p></o:p>\n\n    #if Debug<o:p></o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that there is no whitespace between the opening hash mark and the preprocessor-type keyword.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1006.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/SemicolonsMustBeSpacedCorrectly",
        "display_name": "SemicolonsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The spacing around a semicolon is incorrect, within a C# code file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SemicolonsMustBeSpacedCorrectly\n\nSemicolonsMustBeSpacedCorrectly\n|CheckId|SA1002\n\nSA1002\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe spacing around a semicolon is incorrect, within a C# code file.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around a semicolon is incorrect.\n\nA semicolon should always be followed by a single space, unless it is the last character on the line, and a semicolon should never be preceded by any whitespace, unless it is the first character on the line.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the semicolon is followed by a single space, and is not preceded by any space.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1002.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/SingleLineCommentsMustBeginWithSingleSpace",
        "display_name": "SingleLineCommentsMustBeginWithSingleSpace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A single-line comment within a C# code file does not begin with a single space.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SingleLineCommentsMustBeginWithSingleSpace\n\nSingleLineCommentsMustBeginWithSingleSpace\n|CheckId|SA1005\n\nSA1005\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nA single-line comment within a C# code file does not begin with a single space.\n\n## Rule Description\n\nA violation of this rule occurs when a single-line comment does not begin with a single space. For example:\n\n    private void Method1()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        //A single-line comment.<o:p></o:p>\n\n        //   A single-line comment.<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nThe comments should begin with a single space after the leading forward slashes:\n\n    private void Method1()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        // A single-line comment.<o:p></o:p>\n\n        // A single-line comment.<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\nAn exception to this rule occurs when the comment is being used to comment out a line of code. In this case, the space can be omitted if the comment begins with four forward slashes to indicate out-commented code. For example:\n\n    private void Method1()<o:p></o:p>\n\n    {<o:p></o:p>\n\n        ////int x = 2;<o:p></o:p>\n\n        ////return x;<o:p></o:p>\n\n    }<o:p></o:p>\n\n<o:p> </o:p>\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the comment begins with a single space. If the comment is being used to comment out a line of code, ensure that the comment begins with four forward slashes, in which case the leading space can be omitted.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1005.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/SymbolsMustBeSpacedCorrectly",
        "display_name": "SymbolsMustBeSpacedCorrectly",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The spacing around an operator symbol is incorrect, within a C# code file.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|SymbolsMustBeSpacedCorrectly\n\nSymbolsMustBeSpacedCorrectly\n|CheckId|SA1003\n\nSA1003\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe spacing around an operator symbol is incorrect, within a C# code file.\n\n## Rule Description\n\nA violation of this rule occurs when the spacing around an operator symbol is incorrect.\n\nThe following types of operator symbols must be surrounded by a single space on either side: colons, arithmetic operators, assignment operators, conditional operators, logical operators, relational operators, shift operators, and lambda operators. For example:\n\n    int x = 4 + y;<o:p></o:p>\n\nIn contrast, unary operators must be preceded by a single space, but must never be followed by any space. For example:\n\n    bool x = !value;<o:p></o:p>\n\n<o:p> </o:p>\n\nAn exception occurs whenever the symbol is preceded or followed by a parenthesis or bracket, in which case there should be no space between the symbol and the bracket. For example:\n\n<o:p> </o:p>\n\n    if (!value)<o:p></o:p>\n\n    {<o:p></o:p>\n\n    }<o:p></o:p>\n\n\n\n## How to Fix Violations\n\nTo fix a violation of this rule, ensure that the spacing around the symbol follows the rule described above.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1003.html)"
      },
      {
        "real_name": "StyleCop.CSharp.SpacingRules/TabsMustNotBeUsed",
        "display_name": "TabsMustNotBeUsed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The C# code contains a tab character.",
        "rule_params": "",
        "custom": false,
        "languages": [
          "cs"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "|TypeName|TabsMustNotBeUsed\n\nTabsMustNotBeUsed\n|CheckId|SA1027\n\nSA1027\n|Category|Spacing Rules\n\nSpacing Rules\n\n## Cause\n\nThe C# code contains a tab character.\n\n## Rule Description\n\nA violation of this rule occurs whenever the code contains a tab character.\n\nTabs should not be used within C# code, because the length of the tab character can vary depending upon the editor being used to view the code. This can cause the spacing and indexing of the code to vary from the developer’s original intention, and can in some cases make the code difficult to read.\n\nFor these reasons, tabs should not be used, and each level of indentation should consist of four spaces. This will ensure that the code looks the same no matter which editor is being used to view the code.\n\n## How to Fix Violations\n\nTo fix a violation of this rule, remove the tab character from the code.\n\n## How to Suppress Violations\n\n参考[官方文档-规则描述及代码示例](https://documentation.help/StyleCop/SA1027.html)"
      }
    ]
  }
]