[
  {
    "name": "dartanalyzer",
    "display_name": "DartAnalyzer",
    "description": "Dart static analyzer",
    "license": "BSD-3-Clause",
    "task_processes": [
      "analyze",
      "datahandle"
    ],
    "open_user": true,
    "open_saas": false,
    "scan_app": "codelint",
    "scm_url": null,
    "run_cmd": null,
    "envs": null,
    "build_flag": false,
    "checkrule_set": [
      {
        "real_name": "abstract_class_member",
        "display_name": "AbstractClassMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "abstract class member",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "abstract class member"
      },
      {
        "real_name": "abstract_enum",
        "display_name": "AbstractEnum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "abstract enum",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "abstract enum"
      },
      {
        "real_name": "abstract_static_method",
        "display_name": "AbstractStaticMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "abstract static method",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "abstract static method"
      },
      {
        "real_name": "abstract_super_member_reference",
        "display_name": "AbstractSuperMemberReference",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The {0} '{1}' is always abstract in the supertype.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the display name for the kind of the found abstract member\n1: the name of the member\n#### Description\n\nThe analyzer produces this diagnostic when an inherited member is\nreferenced using `super`, but there is no concrete implementation of the\nmember in the superclass chain. Abstract members can't be invoked.\n\n#### Examples\n\nThe following code produces this diagnostic because `B` doesn't inherit a\nconcrete implementation of `a`:\n\n```dart\nabstract class A {\nint get a;\n}\nclass B extends A {\nint get a => super.[!a!];\n}\n```\n\n#### Common fixes\n\nRemove the invocation of the abstract member, possibly replacing it with an\ninvocation of a concrete member.\nTODO(brianwilkerson) This either needs to be generalized (use 'member'\nrather than '{0}') or split into multiple codes."
      },
      {
        "real_name": "abstract_top_level_function",
        "display_name": "AbstractTopLevelFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "abstract top level function",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "abstract top level function"
      },
      {
        "real_name": "abstract_top_level_variable",
        "display_name": "AbstractTopLevelVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "abstract top level variable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "abstract top level variable"
      },
      {
        "real_name": "abstract_typedef",
        "display_name": "AbstractTypedef",
        "severity": "warning",
        "category": "convention",
        "rule_title": "abstract typedef",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "abstract typedef"
      },
      {
        "real_name": "access_private_enum_field",
        "display_name": "AccessPrivateEnumField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The private fields of an enum can't be accessed",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Enum proposal: It is also a compile-time error to explicitly instantiate an\nenum via 'new' or 'const' or to access its private fields.\n"
      },
      {
        "real_name": "ambiguous_export",
        "display_name": "AmbiguousExport",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' is defined in the libraries '{1}' and '{2}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the export of one of the librarie",
        "owner": null,
        "labels": [],
        "description": "14.2 Exports: It is a compile-time error if a name <i>N</i> is re-exported\nby a library <i>L</i> and <i>N</i> is introduced into the export namespace\nof <i>L</i> by more than one export, unless each all exports refer to same\ndeclaration for the name N.\n\nParameters:\n0: the name of the ambiguous element\n1: the name of the first library in which the type is found\n2: the name of the second library in which the type is found\n"
      },
      {
        "real_name": "ambiguous_extension_member_access",
        "display_name": "AmbiguousExtensionMemberAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A member named '{0}' is defined in extensions '{1}' and '{2}' and neither is more specific.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using an extension override to specify the extension you want to to be chosen.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the member\n1: the name of the first declaring extension\n2: the name of the second declaring extension\nTODO(brianwilkerson) This message doesn't handle the possible case where\nthere are more than 2 extensions, nor does it handle well the case where\none or more of the extensions is unnamed.\n#### Description\n\nWhen code refers to a member of an object (for example, `o.m()` or `o.m` or\n`o[i]`) where the static type of `o` doesn't declare the member (`m` or\n`[]`, for example), then the analyzer tries to find the member in an\nextension. For example, if the member is `m`, then the analyzer looks for\nextensions that declare a member named `m` and have an extended type that\nthe static type of `o` can be assigned to. When there's more than one such\nextension in scope, the extension whose extended type is most specific is\nselected.\n\nThe analyzer produces this diagnostic when none of the extensions has an\nextended type that's more specific than the extended types of all of the\nother extensions, making the reference to the member ambiguous.\n\n#### Examples\n\nThe following code produces this diagnostic because there's no way to\nchoose between the member in `E1` and the member in `E2`:\n\n```dart\nextension E1 on String {\nint get charCount => 1;\n}\n\nextension E2 on String {\nint get charCount => 2;\n}\n\nvoid f(String s) {\nprint(s.[!charCount!]);\n}\n```\n\n#### Common fixes\n\nIf you don't need both extensions, then you can delete or hide one of them.\n\nIf you need both, then explicitly select the one you want to use by using\nan extension override:\n\n```dart\nextension E1 on String {\nint get charCount => length;\n}\n\nextension E2 on String {\nint get charCount => length;\n}\n\nvoid f(String s) {\nprint(E2(s).charCount);\n}\n```"
      },
      {
        "real_name": "ambiguous_import",
        "display_name": "AmbiguousImport",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' is defined in the libraries {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using 'as prefix' for one of the import directive",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the ambiguous type\n1: the name of the first library that the type is found\n2: the name of the second library that the type is found\n#### Description\n\nThe analyzer produces this diagnostic when a name is referenced that is\ndeclared in two or more imported libraries.\n\n#### Examples\n\nGiven a library (`a.dart`) that defines a class (`C` in this example):\n\n```dart\n%uri=\"lib/a.dart\"\nclass A {}\nclass C {}\n```\n\nAnd a library (`b.dart`) that defines a different class with the same name:\n\n```dart\n%uri=\"lib/b.dart\"\nclass B {}\nclass C {}\n```\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'a.dart';\nimport 'b.dart';\n\nvoid f([!C!] c1, [!C!] c2) {}\n```\n\n#### Common fixes\n\nIf any of the libraries aren't needed, then remove the import directives\nfor them:\n\n```dart\nimport 'a.dart';\n\nvoid f(C c1, C c2) {}\n```\n\nIf the name is still defined by more than one library, then add a `hide`\nclause to the import directives for all except one library:\n\n```dart\nimport 'a.dart' hide C;\nimport 'b.dart';\n\nvoid f(C c1, C c2) {}\n```\n\nIf you must be able to reference more than one of these types, then add a\nprefix to each of the import directives, and qualify the references with\nthe appropriate prefix:\n\n```dart\nimport 'a.dart' as a;\nimport 'b.dart' as b;\n\nvoid f(a.C c1, b.C c2) {}\n```"
      },
      {
        "real_name": "ambiguous_set_or_map_literal_both",
        "display_name": "AmbiguousSetOrMapLiteralBoth",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This literal contains both 'Map' and 'Iterable' spreads",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing or changing some of the elements so that all of the elements are consistent.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nBecause map and set literals use the same delimiters (`{` and `}`), the\nanalyzer looks at the type arguments and the elements to determine which\nkind of literal you meant. When there are no type arguments and all of the\nelements are spread elements (which are allowed in both kinds of literals),\nthen the analyzer uses the types of the expressions that are being spread.\nIf all of the expressions have the type `Iterable`, then it's a set\nliteral; if they all have the type `Map`, then it's a map literal.\n\nThe analyzer produces this diagnostic when some of the expressions being\nspread have the type `Iterable` and others have the type `Map`, making it\nimpossible for the analyzer to determine whether you are writing a map\nliteral or a set literal.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nunion(Map<String, String> a, List<String> b, Map<String, String> c) =>\n[!{...a, ...b, ...c}!];\n```\n\nThe list `b` can only be spread into a set, and the maps `a` and `c` can\nonly be spread into a map, and the literal can't be both.\n\n#### Common fixes\n\nThere are two common ways to fix this problem. The first is to remove all\nof the spread elements of one kind or another, so that the elements are\nconsistent. In this case, that likely means removing the list and deciding\nwhat to do about the now unused parameter:\n\n```dart\nunion(Map<String, String> a, List<String> b, Map<String, String> c) =>\n{...a, ...c};\n```\n\nThe second fix is to change the elements of one kind into elements that are\nconsistent with the other elements. For example, you can add the elements\nof the list as keys that map to themselves:\n\n```dart\nunion(Map<String, String> a, List<String> b, Map<String, String> c) =>\n{...a, for (String s in b) s: s, ...c};\n```"
      },
      {
        "real_name": "ambiguous_set_or_map_literal_either",
        "display_name": "AmbiguousSetOrMapLiteralEither",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This literal must be either a map or a set",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding type arguments to the literal one for set",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nBecause map and set literals use the same delimiters (`{` and `}`), the\nanalyzer looks at the type arguments and the elements to determine which\nkind of literal you meant. When there are no type arguments and all of the\nelements are spread elements (which are allowed in both kinds of literals)\nthen the analyzer uses the types of the expressions that are being spread.\nIf all of the expressions have the type `Iterable`, then it's a set\nliteral; if they all have the type `Map`, then it's a map literal.\n\nThis diagnostic is produced when none of the expressions being spread have\na type that allows the analyzer to decide whether you were writing a map\nliteral or a set literal.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nunion(a, b) => [!{...a, ...b}!];\n```\n\nThe problem occurs because there are no type arguments, and there is no\ninformation about the type of either `a` or `b`.\n\n#### Common fixes\n\nThere are three common ways to fix this problem. The first is to add type\narguments to the literal. For example, if the literal is intended to be a\nmap literal, you might write something like this:\n\n```dart\nunion(a, b) => <String, String>{...a, ...b};\n```\n\nThe second fix is to add type information so that the expressions have\neither the type `Iterable` or the type `Map`. You can add an explicit cast\nor, in this case, add types to the declarations of the two parameters:\n\n```dart\nunion(List<int> a, List<int> b) => {...a, ...b};\n```\n\nThe third fix is to add context information. In this case, that means\nadding a return type to the function:\n\n```dart\nSet<String> union(a, b) => {...a, ...b};\n```\n\nIn other cases, you might add a type somewhere else. For example, say the\noriginal code looks like this:\n\n```dart\nunion(a, b) {\nvar x = [!{...a, ...b}!];\nreturn x;\n}\n```\n\nYou might add a type annotation on `x`, like this:\n\n```dart\nunion(a, b) {\nMap<String, String> x = {...a, ...b};\nreturn x;\n}\n```"
      },
      {
        "real_name": "analysis_option_deprecated",
        "display_name": "AnalysisOptionDeprecated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The option '{0}' is no longer supported.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that the given option is deprecated.\n"
      },
      {
        "real_name": "annotation_on_pointer_field",
        "display_name": "AnnotationOnPointerField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try removing the annotation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the annotation.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "annotation_with_non_class",
        "display_name": "AnnotationWithNonClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try importing the library that declares the clas",
        "owner": null,
        "labels": [],
        "description": "15 Metadata: The constant expression given in an annotation is type checked\nand evaluated in the scope surrounding the declaration being annotated.\n\n16.12.2 Const: It is a compile-time error if <i>T</i> is not a class\naccessible in the current scope, optionally followed by type arguments.\n\n16.12.2 Const: If <i>e</i> is of the form <i>const T.id(a<sub>1</sub>,\n&hellip;, a<sub>n</sub>, x<sub>n+1</sub>: a<sub>n+1</sub>, &hellip;\nx<sub>n+k</sub>: a<sub>n+k</sub>)</i> it is a compile-time error if\n<i>T</i> is not a class accessible in the current scope, optionally\nfollowed by type arguments.\n\nParameters:\n0: the name of the non-type element\n"
      },
      {
        "real_name": "annotation_with_type_arguments",
        "display_name": "AnnotationWithTypeArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "annotation with type arguments",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "annotation with type arguments"
      },
      {
        "real_name": "argument_type_not_assignable",
        "display_name": "ArgumentTypeNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The argument type '{0}' can't be assigned to the parameter type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the actual argument type\n1: the name of the expected type\n#### Description\n\nThe analyzer produces this diagnostic when the static type of an argument\ncan't be assigned to the static type of the corresponding parameter.\n\n#### Examples\n\nThe following code produces this diagnostic because a `num` can't be\nassigned to a `String`:\n\n```dart\nString f(String x) => x;\nString g(num y) => f([!y!]);\n```\n\n#### Common fixes\n\nIf possible, rewrite the code so that the static type is assignable. In the\nexample above you might be able to change the type of the parameter `y`:\n\n```dart\nString f(String x) => x;\nString g(String y) => f(y);\n```\n\nIf that fix isn't possible, then add code to handle the case where the\nargument value isn't the required type. One approach is to coerce other\ntypes to the required type:\n\n```dart\nString f(String x) => x;\nString g(num y) => f(y.toString());\n```\n\nAnother approach is to add explicit type tests and fallback code:\n\n```dart\nString f(String x) => x;\nString g(num y) => f(y is String ? y : '');\n```\n\nIf you believe that the runtime type of the argument will always be the\nsame as the static type of the parameter, and you're willing to risk having\nan exception thrown at runtime if you're wrong, then add an explicit cast:\n\n```dart\nString f(String x) => x;\nString g(num y) => f(y as String);\n```"
      },
      {
        "real_name": "assert_in_redirecting_constructor",
        "display_name": "AssertInRedirectingConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "assert in redirecting constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "assert in redirecting constructor"
      },
      {
        "real_name": "assignment_to_const",
        "display_name": "AssignmentToConst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant variables can't be assigned a value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the assignmen",
        "owner": null,
        "labels": [],
        "description": "5 Variables: Attempting to assign to a final variable elsewhere will cause\na NoSuchMethodError to be thrown, because no setter is defined for it. The\nassignment will also give rise to a static warning for the same reason.\n\nA constant variable is always implicitly final.\n"
      },
      {
        "real_name": "assignment_to_final",
        "display_name": "AssignmentToFinal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used as a setter because it's final.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try finding a different sette",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the final variable\n#### Description\n\nThe analyzer produces this diagnostic when it finds an invocation of a\nsetter, but there's no setter because the field with the same name was\ndeclared to be `final` or `const`.\n\n#### Examples\n\nThe following code produces this diagnostic because `v` is final:\n\n```dart\nclass C {\nfinal v = 0;\n}\n\nf(C c) {\nc.[!v!] = 1;\n}\n```\n\n#### Common fixes\n\nIf you need to be able to set the value of the field, then remove the\nmodifier `final` from the field:\n\n```dart\nclass C {\nint v = 0;\n}\n\nf(C c) {\nc.v = 1;\n}\n```"
      },
      {
        "real_name": "assignment_to_final_local",
        "display_name": "AssignmentToFinalLocal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The final variable '{0}' can only be set once.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try making '{0}' non-final.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a local variable that was\ndeclared to be final is assigned after it was initialized.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is final, so it\ncan't have a value assigned to it after it was initialized:\n\n```dart\nvoid f() {\nfinal x = 0;\n[!x!] = 3;\nprint(x);\n}\n```\n\n#### Common fixes\n\nRemove the keyword `final`, and replace it with `var` if there's no type\nannotation:\n\n```dart\nvoid f() {\nvar x = 0;\nx = 3;\nprint(x);\n}\n```"
      },
      {
        "real_name": "assignment_to_final_no_setter",
        "display_name": "AssignmentToFinalNoSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "There isn’t a setter named '{0}' in class '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to reference an existing sette",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a reference to a setter is\nfound; there is no setter defined for the type; but there is a getter\ndefined with the same name.\n\n#### Examples\n\nThe following code produces this diagnostic because there is no setter\nnamed `x` in `C`, but there is a getter named `x`:\n\n```dart\nclass C {\nint get x => 0;\nset y(int p) {}\n}\n\nvoid f(C c) {\nc.[!x!] = 1;\n}\n```\n\n#### Common fixes\n\nIf you want to invoke an existing setter, then correct the name:\n\n```dart\nclass C {\nint get x => 0;\nset y(int p) {}\n}\n\nvoid f(C c) {\nc.y = 1;\n}\n```\n\nIf you want to invoke the setter but it just doesn't exist yet, then\ndeclare it:\n\n```dart\nclass C {\nint get x => 0;\nset x(int p) {}\nset y(int p) {}\n}\n\nvoid f(C c) {\nc.x = 1;\n}\n```"
      },
      {
        "real_name": "assignment_to_function",
        "display_name": "AssignmentToFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Functions can't be assigned a value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "12.18 Assignment: It is as static warning if an assignment of the form\n<i>v = e</i> occurs inside a top level or static function (be it function,\nmethod, getter, or setter) or variable initializer and there is neither a\nlocal variable declaration with name <i>v</i> nor setter declaration with\nname <i>v=</i> in the lexical scope enclosing the assignment.\n"
      },
      {
        "real_name": "assignment_to_method",
        "display_name": "AssignmentToMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Methods can't be assigned a value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the target of an assignment is a\nmethod.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` can't be assigned a\nvalue because it's a method:\n\n```dart\nclass C {\nvoid f() {}\n\nvoid g() {\n[!f!] = null;\n}\n}\n```\n\n#### Common fixes\n\nRewrite the code so that there isn't an assignment to a method."
      },
      {
        "real_name": "assignment_to_type",
        "display_name": "AssignmentToType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Types can't be assigned a value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "12.18 Assignment: It is as static warning if an assignment of the form\n<i>v = e</i> occurs inside a top level or static function (be it function,\nmethod, getter, or setter) or variable initializer and there is neither a\nlocal variable declaration with name <i>v</i> nor setter declaration with\nname <i>v=</i> in the lexical scope enclosing the assignment.\n"
      },
      {
        "real_name": "async_for_in_wrong_context",
        "display_name": "AsyncForInWrongContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The async for-in can only be used in an async function.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try marking the function body with either 'async' or 'async*",
        "owner": null,
        "labels": [],
        "description": "17.6.3 Asynchronous For-in: It is a compile-time error if an asynchronous\nfor-in statement appears inside a synchronous function.\n"
      },
      {
        "real_name": "async_keyword_used_as_identifier",
        "display_name": "AsyncKeywordUsedAsIdentifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The keywords 'await' and 'yield' can't be used as identifiers in an asynchronous or generator function.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.32 Identifier Reference: It is a compile-time error if any of the\nidentifiers async, await, or yield is used as an identifier in a function\nbody marked with either async, async*, or sync*.\n"
      },
      {
        "real_name": "await_in_late_local_variable_initializer",
        "display_name": "AwaitInLateLocalVariableInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The await expression can't be used in a 'late' local variable.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the 'late' modifie",
        "owner": null,
        "labels": [],
        "description": "nnbd/feature-specification.md\n\nIt is an error for the initializer expression of a `late` local variable\nto use a prefix `await` expression.\n"
      },
      {
        "real_name": "await_in_wrong_context",
        "display_name": "AwaitInWrongContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The await expression can only be used in an async function.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try marking the function body with either 'async' or 'async*'.",
        "owner": null,
        "labels": [],
        "description": "16.30 Await Expressions: It is a compile-time error if the function\nimmediately enclosing _a_ is not declared asynchronous. (Where _a_ is the\nawait expression.)\n"
      },
      {
        "real_name": "body_might_complete_normally",
        "display_name": "BodyMightCompleteNormally",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The body might complete normally",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding either a return or a throw statement at the end.",
        "owner": null,
        "labels": [],
        "description": "It is an error if the body of a method, function, getter, or function\nexpression with a potentially non-nullable return type may completely\nnormally.\n"
      },
      {
        "real_name": "break_label_on_switch_member",
        "display_name": "BreakLabelOnSwitchMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "break label on switch member",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "break label on switch member"
      },
      {
        "real_name": "break_outside_of_loop",
        "display_name": "BreakOutsideOfLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "break outside of loop",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "break outside of loop"
      },
      {
        "real_name": "built_in_identifier_as_extension_name",
        "display_name": "BuiltInIdentifierAsExtensionName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The built-in identifier '{0}' can't be used as an extension name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try choosing a different name for the extension.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the built-in identifier that is being used\n#### Description\n\nThe analyzer produces this diagnostic when the name of an extension is a\nbuilt-in identifier. Built-in identifiers can’t be used as extension names.\n\n#### Examples\n\nThe following code produces this diagnostic because `mixin` is a built-in\nidentifier:\n\n```dart\nextension [!mixin!] on int {}\n```\n\n#### Common fixes\n\nChoose a different name for the extension."
      },
      {
        "real_name": "built_in_identifier_as_prefix_name",
        "display_name": "BuiltInIdentifierAsPrefixName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The built-in identifier '{0}' can't be used as a prefix name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try choosing a different name for the prefix.",
        "owner": null,
        "labels": [],
        "description": "16.33 Identifier Reference: It is a compile-time error if a built-in\nidentifier is used as the declared name of a prefix, class, type parameter\nor type alias.\n\nParameters:\n0: the built-in identifier that is being used\n"
      },
      {
        "real_name": "built_in_identifier_as_type",
        "display_name": "BuiltInIdentifierAsType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The built-in identifier '{0}' can't be used as a type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing type.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the built-in identifier that is being used\n#### Description\n\nThe analyzer produces this diagnostic when a built-in identifier is used\nwhere a type name is expected.\n\n#### Examples\n\nThe following code produces this diagnostic because `import` can't be used\nas a type because it's a built-in identifier:\n\n```dart\n[!import!]<int> x;\n```\n\n#### Common fixes\n\nReplace the built-in identifier with the name of a valid type:\n\n```dart\nList<int> x;\n```"
      },
      {
        "real_name": "built_in_identifier_as_type_name",
        "display_name": "BuiltInIdentifierAsTypeName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The built-in identifier '{0}' can't be used as a type name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try choosing a different name for the type.",
        "owner": null,
        "labels": [],
        "description": "16.33 Identifier Reference: It is a compile-time error if a built-in\nidentifier is used as the declared name of a prefix, class, type parameter\nor type alias.\n\nParameters:\n0: the built-in identifier that is being used\n"
      },
      {
        "real_name": "built_in_identifier_as_type_parameter_name",
        "display_name": "BuiltInIdentifierAsTypeParameterName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The built-in identifier '{0}' can't be used as a type parameter name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try choosing a different name for the type parameter.",
        "owner": null,
        "labels": [],
        "description": "16.33 Identifier Reference: It is a compile-time error if a built-in\nidentifier is used as the declared name of a prefix, class, type parameter\nor type alias.\n\nParameters:\n0: the built-in identifier that is being used\n"
      },
      {
        "real_name": "built_in_identifier_as_typedef_name",
        "display_name": "BuiltInIdentifierAsTypedefName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The built-in identifier '{0}' can't be used as a typedef name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try choosing a different name for the typedef.",
        "owner": null,
        "labels": [],
        "description": "16.33 Identifier Reference: It is a compile-time error if a built-in\nidentifier is used as the declared name of a prefix, class, type parameter\nor type alias.\n\nParameters:\n0: the built-in identifier that is being used\n"
      },
      {
        "real_name": "camera_permissions_incompatible",
        "display_name": "CameraPermissionsIncompatible",
        "severity": "warning",
        "category": "convention",
        "rule_title": "camera permissions incompatible",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "camera permissions incompatible"
      },
      {
        "real_name": "can_be_null_after_null_aware",
        "display_name": "CanBeNullAfterNullAware",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The target expression uses '?.'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Replace the '.' with a '?.' in the invocation.",
        "owner": null,
        "labels": [],
        "description": "When the target expression uses '?.' operator, it can be `null`, so all the\nsubsequent invocations should also use '?.' operator.\n"
      },
      {
        "real_name": "case_block_not_terminated",
        "display_name": "CaseBlockNotTerminated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The last statement of the 'case' should be 'break'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding one of the required statements.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the last statement in a case\nblock isn't one of the required terminators: `break`, `continue`,\n`rethrow`, `return`, or `throw`.\n\n#### Examples\n\nThe following code produces this diagnostic because the case block ends\nwith an assignment:\n\n```dart\nvoid f(int x) {\nswitch (x) {\n[!case!] 0:\nx += 2;\ndefault:\nx += 1;\n}\n}\n```\n\n#### Common fixes\n\nAdd one of the required terminators:\n\n```dart\nvoid f(int x) {\nswitch (x) {\ncase 0:\nx += 2;\nbreak;\ndefault:\nx += 1;\n}\n}\n```"
      },
      {
        "real_name": "case_expression_type_implements_equals",
        "display_name": "CaseExpressionTypeImplementsEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The switch case expression type '{0}' can't override the == operator.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "13.9 Switch: It is a compile-time error if the class <i>C</i> implements\nthe operator <i>==</i>.\n\nParameters:\n0: the this of the switch case expression\n"
      },
      {
        "real_name": "case_expression_type_is_not_switch_expression_subtype",
        "display_name": "CaseExpressionTypeIsNotSwitchExpressionSubtype",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The switch case expression type '{0}' must be a subtype of the switch expression type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n/ Given a switch statement which switches over an expression `e` of type\n/ `T`, where the cases are dispatched based on expressions `e0` ... `ek`:\n/\n/ It is an error if any of the `ei` evaluate to a value whose static type\n/ is not a subtype of `T`."
      },
      {
        "real_name": "cast_to_non_type",
        "display_name": "CastToNonType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the name to the name of an existing typ",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the name following the `as` in a\ncast expression is defined to be something other than a type.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is a variable, not\na type:\n\n```dart\nnum x = 0;\nint y = x as [!x!];\n```\n\n#### Common fixes\n\nReplace the name with the name of a type:\n\n```dart\nnum x = 0;\nint y = x as int;\n```"
      },
      {
        "real_name": "catch_syntax",
        "display_name": "CatchSyntax",
        "severity": "warning",
        "category": "convention",
        "rule_title": "catch syntax",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "catch syntax"
      },
      {
        "real_name": "catch_syntax_extra_parameters",
        "display_name": "CatchSyntaxExtraParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "catch syntax extra parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "catch syntax extra parameters"
      },
      {
        "real_name": "class_in_class",
        "display_name": "ClassInClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "class in class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "class in class"
      },
      {
        "real_name": "colon_in_place_of_in",
        "display_name": "ColonInPlaceOfIn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "colon in place of in",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "colon in place of in"
      },
      {
        "real_name": "concrete_class_with_abstract_member",
        "display_name": "ConcreteClassWithAbstractMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' must have a method body because '{1}' isn't abstract.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try making '{1}' abstrac",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the abstract method\n1: the name of the enclosing class\n#### Description\n\nThe analyzer produces this diagnostic when a member of a concrete class is\nfound that doesn't have a concrete implementation. Concrete classes aren't\nallowed to contain abstract members.\n\n#### Examples\n\nThe following code produces this diagnostic because `m` is an abstract\nmethod but `C` isn't an abstract class:\n\n```dart\nclass C {\n[!void m();!]\n}\n```\n\n#### Common fixes\n\nIf it's valid to create instances of the class, provide an implementation\nfor the member:\n\n```dart\nclass C {\nvoid m() {}\n}\n```\n\nIf it isn't valid to create instances of the class, mark the class as being\nabstract:\n\n```dart\nabstract class C {\nvoid m();\n}\n```"
      },
      {
        "real_name": "conflicting_constructor_and_static_field",
        "display_name": "ConflictingConstructorAndStaticField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used to name both a constructor and a static field in this class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming either the constructor or the field.",
        "owner": null,
        "labels": [],
        "description": "10.11 Class Member Conflicts: Let `C` be a class. It is a compile-time\nerror if `C` declares a constructor named `C.n`, and a static member with\nbasename `n`.\n\nParameters:\n0: the name of the constructor\n"
      },
      {
        "real_name": "conflicting_constructor_and_static_method",
        "display_name": "ConflictingConstructorAndStaticMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used to name both a constructor and a static method in this class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming either the constructor or the method.",
        "owner": null,
        "labels": [],
        "description": "10.11 Class Member Conflicts: Let `C` be a class. It is a compile-time\nerror if `C` declares a constructor named `C.n`, and a static member with\nbasename `n`.\n\nParameters:\n0: the name of the constructor\n"
      },
      {
        "real_name": "conflicting_field_and_method",
        "display_name": "ConflictingFieldAndMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Class '{0}' can't define field '{1}' and have method '{2}.{1}' with the same name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try converting the getter to a metho",
        "owner": null,
        "labels": [],
        "description": "10.11 Class Member Conflicts: Let `C` be a class. It is a compile-time\nerror if `C` declares a getter or a setter with basename `n`, and has a\nmethod named `n`.\n\nParameters:\n0: the name of the class defining the conflicting field\n1: the name of the conflicting field\n2: the name of the class defining the method with which the field conflicts\n"
      },
      {
        "real_name": "conflicting_generic_interfaces",
        "display_name": "ConflictingGenericInterfaces",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' cannot implement both '{1}' and '{2}' because the type arguments are different.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "10.10 Superinterfaces: It is a compile-time error if a class `C` has two\nsuperinterfaces that are different instantiations of the same generic\nclass. For example, a class may not have both `List<int>` and `List<num>`\nas superinterfaces.\n\nParameters:\n0: the name of the class implementing the conflicting interface\n1: the first conflicting type\n1: the second conflicting type\n"
      },
      {
        "real_name": "conflicting_method_and_field",
        "display_name": "ConflictingMethodAndField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Class '{0}' can't define method '{1}' and have field '{2}.{1}' with the same name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try converting the method to a gette",
        "owner": null,
        "labels": [],
        "description": "10.11 Class Member Conflicts: Let `C` be a class. It is a compile-time\nerror if `C` declares a method named `n`, and has a getter or a setter\nwith basename `n`.\n\nParameters:\n0: the name of the class defining the conflicting method\n1: the name of the conflicting method\n2: the name of the class defining the field with which the method conflicts\n"
      },
      {
        "real_name": "conflicting_modifiers",
        "display_name": "ConflictingModifiers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "conflicting modifiers",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "conflicting modifiers"
      },
      {
        "real_name": "conflicting_static_and_instance",
        "display_name": "ConflictingStaticAndInstance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Class '{0}' can't define static member '{1}' and have instance member '{2}.{1}' with the same name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming the member to a name that doesn't conflict.",
        "owner": null,
        "labels": [],
        "description": "10.11 Class Member Conflicts: Let `C` be a class. It is a compile-time\nerror if `C` declares a static member with basename `n`, and has an\ninstance member with basename `n`.\n\nParameters:\n0: the name of the class defining the conflicting member\n1: the name of the conflicting static member\n2: the name of the class defining the field with which the method conflicts\n"
      },
      {
        "real_name": "conflicting_type_variable_and_class",
        "display_name": "ConflictingTypeVariableAndClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used to name both a type variable and the class in which the type variable is defined.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming either the type variable or the class.",
        "owner": null,
        "labels": [],
        "description": "7. Classes: It is a compile time error if a generic class declares a type\nvariable with the same name as the class or any of its members or\nconstructors.\n\nParameters:\n0: the name of the type variable\n"
      },
      {
        "real_name": "conflicting_type_variable_and_member",
        "display_name": "ConflictingTypeVariableAndMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used to name both a type variable and a member in this class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming either the type variable or the member.",
        "owner": null,
        "labels": [],
        "description": "7. Classes: It is a compile time error if a generic class declares a type\nvariable with the same name as the class or any of its members or\nconstructors.\n\nParameters:\n0: the name of the type variable\n"
      },
      {
        "real_name": "const_after_factory",
        "display_name": "ConstAfterFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const after factory",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const after factory"
      },
      {
        "real_name": "const_and_covariant",
        "display_name": "ConstAndCovariant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const and covariant",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const and covariant"
      },
      {
        "real_name": "const_and_final",
        "display_name": "ConstAndFinal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const and final",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const and final"
      },
      {
        "real_name": "const_and_var",
        "display_name": "ConstAndVar",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const and var",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const and var"
      },
      {
        "real_name": "const_class",
        "display_name": "ConstClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const class"
      },
      {
        "real_name": "const_constructor_field_type_mismatch",
        "display_name": "ConstConstructorFieldTypeMismatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A value of type '{0}' can't be assigned to the field '{1}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if evaluation of a constant\nobject results in an uncaught exception being thrown.\n"
      },
      {
        "real_name": "const_constructor_param_type_mismatch",
        "display_name": "ConstConstructorParamTypeMismatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A value of type '{0}' can't be assigned to a parameter of type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if evaluation of a constant\nobject results in an uncaught exception being thrown.\n"
      },
      {
        "real_name": "const_constructor_throws_exception",
        "display_name": "ConstConstructorThrowsException",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Const constructors can't throw exceptions.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the throw statemen",
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if evaluation of a constant\nobject results in an uncaught exception being thrown.\n"
      },
      {
        "real_name": "const_constructor_with_body",
        "display_name": "ConstConstructorWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const constructor with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const constructor with body"
      },
      {
        "real_name": "const_constructor_with_field_initialized_by_non_const",
        "display_name": "ConstConstructorWithFieldInitializedByNonConst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Can't define the const constructor because the field '{0}' is initialized with a non-constant value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try initializing the field to a constant valu",
        "owner": null,
        "labels": [],
        "description": "10.6.3 Constant Constructors: It is a compile-time error if a constant\nconstructor is declared by a class C if any instance variable declared in C\nis initialized with an expression that is not a constant expression.\n\nParameters:\n0: the name of the field\n"
      },
      {
        "real_name": "const_constructor_with_mixin_with_field",
        "display_name": "ConstConstructorWithMixinWithField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Const constructor can't be declared for a class with a mixin that declares an instance field.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the 'const' keyword or removing the 'with' clause from the class declaratio",
        "owner": null,
        "labels": [],
        "description": "7.6.3 Constant Constructors: The superinitializer that appears, explicitly\nor implicitly, in the initializer list of a constant constructor must\nspecify a constant constructor of the superclass of the immediately\nenclosing class or a compile-time error occurs.\n\n12.1 Mixin Application: For each generative constructor named ... an\nimplicitly declared constructor named ... is declared. If Sq is a\ngenerative const constructor, and M does not declare any fields, Cq is\nalso a const constructor.\n"
      },
      {
        "real_name": "const_constructor_with_non_const_super",
        "display_name": "ConstConstructorWithNonConstSuper",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant constructor can't call non-constant super constructor of '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try calling a const constructor in the superclas",
        "owner": null,
        "labels": [],
        "description": "7.6.3 Constant Constructors: The superinitializer that appears, explicitly\nor implicitly, in the initializer list of a constant constructor must\nspecify a constant constructor of the superclass of the immediately\nenclosing class or a compile-time error occurs.\n\nParameters:\n0: the name of the superclass\n"
      },
      {
        "real_name": "const_constructor_with_non_final_field",
        "display_name": "ConstConstructorWithNonFinalField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Can't define a const constructor for a class with non-final fields.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try making all of the fields fina",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a constructor is marked as a\nconst constructor, but the constructor is defined in a class that has at\nleast one non-final instance field (either directly or by inheritance).\n\n#### Examples\n\nThe following code produces this diagnostic because the field `x` isn't\nfinal:\n\n```dart\nclass C {\nint x;\n\nconst [!C!](this.x);\n}\n```\n\n#### Common fixes\n\nIf it's possible to mark all of the fields as final, then do so:\n\n```dart\nclass C {\nfinal int x;\n\nconst C(this.x);\n}\n```\n\nIf it isn't possible to mark all of the fields as final, then remove the\nkeyword `const` from the constructor:\n\n```dart\nclass C {\nint x;\n\nC(this.x);\n}\n```"
      },
      {
        "real_name": "const_deferred_class",
        "display_name": "ConstDeferredClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Deferred classes can't be created with 'const'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using 'new' to create the instanc",
        "owner": null,
        "labels": [],
        "description": "12.12.2 Const: It is a compile-time error if <i>T</i> is a deferred type.\n"
      },
      {
        "real_name": "const_enum",
        "display_name": "ConstEnum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const enum",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const enum"
      },
      {
        "real_name": "const_eval_throws_exception",
        "display_name": "ConstEvalThrowsException",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Evaluation of this constant expression throws an exception.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if evaluation of a constant\nobject results in an uncaught exception being thrown.\n"
      },
      {
        "real_name": "const_eval_throws_idbze",
        "display_name": "ConstEvalThrowsIdbze",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Evaluation of this constant expression throws an IntegerDivisionByZeroException.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if evaluation of a constant\nobject results in an uncaught exception being thrown.\n"
      },
      {
        "real_name": "const_eval_type_bool",
        "display_name": "ConstEvalTypeBool",
        "severity": "warning",
        "category": "convention",
        "rule_title": "In constant expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: An expression of one of the forms !e, e1 && e2 or e1 || e2,\nwhere e, e1 and e2 are constant expressions that evaluate to a boolean\nvalue.\n"
      },
      {
        "real_name": "const_eval_type_bool_int",
        "display_name": "ConstEvalTypeBoolInt",
        "severity": "warning",
        "category": "convention",
        "rule_title": "In constant expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: An expression of one of the forms !e, e1 && e2 or e1 || e2,\nwhere e, e1 and e2 are constant expressions that evaluate to a boolean\nvalue.\n"
      },
      {
        "real_name": "const_eval_type_bool_num_string",
        "display_name": "ConstEvalTypeBoolNumString",
        "severity": "warning",
        "category": "convention",
        "rule_title": "In constant expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: An expression of one of the forms e1 == e2 or e1 != e2 where\ne1 and e2 are constant expressions that evaluate to a numeric, string or\nboolean value or to null.\n"
      },
      {
        "real_name": "const_eval_type_int",
        "display_name": "ConstEvalTypeInt",
        "severity": "warning",
        "category": "convention",
        "rule_title": "In constant expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: An expression of one of the forms ~e, e1 ^ e2, e1 & e2,\ne1 | e2, e1 >> e2 or e1 << e2, where e, e1 and e2 are constant expressions\nthat evaluate to an integer value or to null.\n"
      },
      {
        "real_name": "const_eval_type_num",
        "display_name": "ConstEvalTypeNum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "In constant expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: An expression of one of the forms e, e1 + e2, e1 - e2, e1 *\ne2, e1 / e2, e1 ~/ e2, e1 > e2, e1 < e2, e1 >= e2, e1 <= e2 or e1 % e2,\nwhere e, e1 and e2 are constant expressions that evaluate to a numeric\nvalue or to null.\n"
      },
      {
        "real_name": "const_eval_type_type",
        "display_name": "ConstEvalTypeType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const eval type type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const eval type type"
      },
      {
        "real_name": "const_factory",
        "display_name": "ConstFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const factory",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const factory"
      },
      {
        "real_name": "const_field_initializer_not_assignable",
        "display_name": "ConstFieldInitializerNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The initializer type '{0}' can't be assigned to the field type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: In checked mode, it is a dynamic type error\nif o is not <b>null</b> and the interface of the class of <i>o</i> is not a\nsubtype of the static type of the field <i>v</i>.\n\n16.12.2 Const: It is a compile-time error if evaluation of a constant\nobject results in an uncaught exception being thrown.\n\nParameters:\n0: the name of the type of the initializer expression\n1: the name of the type of the field\n"
      },
      {
        "real_name": "const_formal_parameter",
        "display_name": "ConstFormalParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Parameters can't be const.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the 'const' keyword.",
        "owner": null,
        "labels": [],
        "description": "6.2 Formal Parameters: It is a compile-time error if a formal parameter is\ndeclared as a constant variable.\n"
      },
      {
        "real_name": "const_initialized_with_non_constant_value",
        "display_name": "ConstInitializedWithNonConstantValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Const variables must be initialized with a constant value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the initializer to be a constant expression.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a value that isn't statically\nknown to be a constant is assigned to a variable that's declared to be a\n'const' variable.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` isn't declared to\nbe `const`:\n\n```dart\nvar x = 0;\nconst y = [!x!];\n```\n\n#### Common fixes\n\nIf the value being assigned can be declared to be `const`, then change the\ndeclaration:\n\n```dart\nconst x = 0;\nconst y = x;\n```\n\nIf the value can't be declared to be `const`, then remove the `const`\nmodifier from the variable, possibly using `final` in its place:\n\n```dart\nvar x = 0;\nfinal y = x;\n```"
      },
      {
        "real_name": "const_initialized_with_non_constant_value_from_deferred_library",
        "display_name": "ConstInitializedWithNonConstantValueFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used to initialized a const variable.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try initializing the variable without referencing members of the deferred librar",
        "owner": null,
        "labels": [],
        "description": "5 Variables: A constant variable must be initialized to a compile-time\nconstant or a compile-time error occurs.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "const_instance_field",
        "display_name": "ConstInstanceField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Only static fields can be declared as const.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try declaring the field as fina",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an instance field is marked as\nbeing const.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` is an instance\nfield:\n\n```dart\nclass C {\n[!const!] int f = 3;\n}\n```\n\n#### Common fixes\n\nIf the field needs to be an instance field, then remove the keyword\n`const`, or replace it with `final`:\n\n```dart\nclass C {\nfinal int f = 3;\n}\n```\n\nIf the field really should be a const field, then make it a static field:\n\n```dart\nclass C {\nstatic const int f = 3;\n}\n```"
      },
      {
        "real_name": "const_map_key_expression_type_implements_equals",
        "display_name": "ConstMapKeyExpressionTypeImplementsEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constant map entry key expression type '{0}' can't override the == operator.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a different value for the ke",
        "owner": null,
        "labels": [],
        "description": "12.8 Maps: It is a compile-time error if the key of an entry in a constant\nmap literal is an instance of a class that implements the operator\n<i>==</i> unless the key is a string or integer.\n\nParameters:\n0: the type of the entry's key\n"
      },
      {
        "real_name": "const_method",
        "display_name": "ConstMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const method",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const method"
      },
      {
        "real_name": "const_not_initialized",
        "display_name": "ConstNotInitialized",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constant '{0}' must be initialized.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an initialization to the declaration.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the uninitialized final variable\n#### Description\n\nThe analyzer produces this diagnostic when a variable that is declared to\nbe a constant doesn't have an initializer.\n\n#### Examples\n\nThe following code produces this diagnostic because `c` isn't initialized:\n\n```dart\nconst [!c!];\n```\n\n#### Common fixes\n\nAdd an initializer:\n\n```dart\nconst c = 'c';\n```"
      },
      {
        "real_name": "const_set_element_type_implements_equals",
        "display_name": "ConstSetElementTypeImplementsEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constant set element type '{0}' can't override the == operator.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a different value for the elemen",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the element\n"
      },
      {
        "real_name": "const_spread_expected_list_or_set",
        "display_name": "ConstSpreadExpectedListOrSet",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A list or a set is expected in this spread.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the expression of a spread\noperator in a constant list or set evaluates to something other than a list\nor a set.\n\n#### Examples\n\nThe following code produces this diagnostic because the value of `list1` is\n`null`, which is neither a list nor a set:\n\n```dart\nconst List<int> list1 = null;\nconst List<int> list2 = [...[!list1!]];\n```\n\n#### Common fixes\n\nChange the expression to something that evaluates to either a constant list\nor a constant set:\n\n```dart\nconst List<int> list1 = [];\nconst List<int> list2 = [...list1];\n```"
      },
      {
        "real_name": "const_spread_expected_map",
        "display_name": "ConstSpreadExpectedMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A map is expected in this spread.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the expression of a spread\noperator in a constant map evaluates to something other than a map.\n\n#### Examples\n\nThe following code produces this diagnostic because the value of `map1` is\n`null`, which isn't a map:\n\n```dart\nconst Map<String, int> map1 = null;\nconst Map<String, int> map2 = {...[!map1!]};\n```\n\n#### Common fixes\n\nChange the expression to something that evaluates to a constant map:\n\n```dart\nconst Map<String, int> map1 = {};\nconst Map<String, int> map2 = {...map1};\n```"
      },
      {
        "real_name": "const_typedef",
        "display_name": "ConstTypedef",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const typedef",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const typedef"
      },
      {
        "real_name": "const_with_abstract_class",
        "display_name": "ConstWithAbstractClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "const with abstract class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "const with abstract class"
      },
      {
        "real_name": "const_with_non_const",
        "display_name": "ConstWithNonConst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constructor being called isn't a const constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing 'const' from the constructor invocation.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the keyword `const` is used to\ninvoke a constructor that isn't marked with `const`.\n\n#### Examples\n\nThe following code produces this diagnostic because the constructor in `A`\nisn't a const constructor:\n\n```dart\nclass A {\nA();\n}\n\nA f() => [!const!] A();\n```\n\n#### Common fixes\n\nIf it's desirable and possible to make the class a constant class (by\nmaking all of the fields of the class, including inherited fields, final),\nthen add the keyword `const` to the constructor:\n\n```dart\nclass A {\nconst A();\n}\n\nA f() => const A();\n```\n\nOtherwise, remove the keyword `const`:\n\n```dart\nclass A {\nA();\n}\n\nA f() => A();\n```"
      },
      {
        "real_name": "const_with_non_constant_argument",
        "display_name": "ConstWithNonConstantArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Arguments of a constant creation must be constant expressions.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try making the argument a valid constan",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a const constructor is invoked\nwith an argument that isn't a constant expression.\n\n#### Examples\n\nThe following code produces this diagnostic because `i` isn't a constant:\n\n```dart\nclass C {\nfinal int i;\nconst C(this.i);\n}\nC f(int i) => const C([!i!]);\n```\n\n#### Common fixes\n\nEither make all of the arguments constant expressions, or remove the\n`const` keyword to use the non-constant form of the constructor:\n\n```dart\nclass C {\nfinal int i;\nconst C(this.i);\n}\nC f(int i) => C(i);\n```"
      },
      {
        "real_name": "const_with_non_type",
        "display_name": "ConstWithNonType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing class.",
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if <i>T</i> is not a class\naccessible in the current scope, optionally followed by type arguments.\n\n16.12.2 Const: If <i>e</i> is of the form <i>const T.id(a<sub>1</sub>,\n&hellip;, a<sub>n</sub>, x<sub>n+1</sub>: a<sub>n+1</sub>, &hellip;\nx<sub>n+k</sub>: a<sub>n+k</sub>)</i> it is a compile-time error if\n<i>T</i> is not a class accessible in the current scope, optionally\nfollowed by type arguments.\n\nParameters:\n0: the name of the non-type element\n"
      },
      {
        "real_name": "const_with_type_parameters",
        "display_name": "ConstWithTypeParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A constant creation can't use a type parameter as a type argument.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the type parameter with a different type.",
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: If <i>T</i> is a parameterized type, it is a compile-time\nerror if <i>T</i> includes a type variable among its type arguments.\n"
      },
      {
        "real_name": "const_with_undefined_constructor",
        "display_name": "ConstWithUndefinedConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' doesn't have a constant constructor '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try calling a different constructor.",
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if <i>T.id</i> is not the name of\na constant constructor declared by the type <i>T</i>.\n\nParameters:\n0: the name of the type\n1: the name of the requested constant constructor\n"
      },
      {
        "real_name": "const_with_undefined_constructor_default",
        "display_name": "ConstWithUndefinedConstructorDefault",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' doesn't have a default constant constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try calling a different constructor.",
        "owner": null,
        "labels": [],
        "description": "16.12.2 Const: It is a compile-time error if <i>T.id</i> is not the name of\na constant constructor declared by the type <i>T</i>.\n\nParameters:\n0: the name of the type\n"
      },
      {
        "real_name": "constructor_with_return_type",
        "display_name": "ConstructorWithReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "constructor with return type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "constructor with return type"
      },
      {
        "real_name": "continue_label_on_switch",
        "display_name": "ContinueLabelOnSwitch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "continue label on switch",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "continue label on switch"
      },
      {
        "real_name": "continue_outside_of_loop",
        "display_name": "ContinueOutsideOfLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "continue outside of loop",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "continue outside of loop"
      },
      {
        "real_name": "continue_without_label_in_case",
        "display_name": "ContinueWithoutLabelInCase",
        "severity": "warning",
        "category": "convention",
        "rule_title": "continue without label in case",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "continue without label in case"
      },
      {
        "real_name": "could_not_infer",
        "display_name": "CouldNotInfer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "could not infer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "could not infer"
      },
      {
        "real_name": "covariant_after_final",
        "display_name": "CovariantAfterFinal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "covariant after final",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "covariant after final"
      },
      {
        "real_name": "covariant_after_var",
        "display_name": "CovariantAfterVar",
        "severity": "warning",
        "category": "convention",
        "rule_title": "covariant after var",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "covariant after var"
      },
      {
        "real_name": "covariant_and_static",
        "display_name": "CovariantAndStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "covariant and static",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "covariant and static"
      },
      {
        "real_name": "covariant_constructor",
        "display_name": "CovariantConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "covariant constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "covariant constructor"
      },
      {
        "real_name": "covariant_member",
        "display_name": "CovariantMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "covariant member",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "covariant member"
      },
      {
        "real_name": "covariant_top_level_declaration",
        "display_name": "CovariantTopLevelDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "covariant top level declaration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "covariant top level declaration"
      },
      {
        "real_name": "dead_code",
        "display_name": "DeadCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Dead code.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the cod",
        "owner": null,
        "labels": [],
        "description": "Dead code is code that is never reached, this can happen for instance if a\nstatement follows a return statement.\n\nNo parameters.\n#### Description\n\nThe analyzer produces this diagnostic when code is found that won't be\nexecuted because execution will never reach the code.\n\n#### Examples\n\nThe following code produces this diagnostic because the invocation of\n`print` occurs after the function has returned:\n\n```dart\nvoid f() {\nreturn;\n[!print('here');!]\n}\n```\n\n#### Common fixes\n\nIf the code isn't needed, then remove it:\n\n```dart\nvoid f() {\nreturn;\n}\n```\n\nIf the code needs to be executed, then either move the code to a place\nwhere it will be executed:\n\n```dart\nvoid f() {\nprint('here');\nreturn;\n}\n```\n\nOr, rewrite the code before it, so that it can be reached:\n\n```dart\nvoid f({bool skipPrinting = true}) {\nif (skipPrinting) {\nreturn;\n}\nprint('here');\n}\n```"
      },
      {
        "real_name": "dead_code_catch_following_catch",
        "display_name": "DeadCodeCatchFollowingCatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Dead code: Catch clauses after a 'catch e)' or an 'on Object catch e)' are never reached.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try reordering the catch clauses so that they can be reache",
        "owner": null,
        "labels": [],
        "description": "Dead code is code that is never reached. This case covers cases where the\nuser has catch clauses after `catch (e)` or `on Object catch (e)`.\n\nNo parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a catch clause is found that\ncan't be executed because it’s after a catch clause of the form `catch (e)`\nor `on Object catch (e)`. The first catch clause that matches the thrown\nobject is selected, and both of those forms will match any object, so no\ncatch clauses that follow them will be selected.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nvoid f() {\ntry {\n} catch (e) {\n} [!on String {\n}!]\n}\n```\n\n#### Common fixes\n\nIf the clause should be selectable, then move the clause before the general\nclause:\n\n```dart\nvoid f() {\ntry {\n} on String {\n} catch (e) {\n}\n}\n```\n\nIf the clause doesn't need to be selectable, then remove it:\n\n```dart\nvoid f() {\ntry {\n} catch (e) {\n}\n}\n```"
      },
      {
        "real_name": "dead_code_on_catch_subtype",
        "display_name": "DeadCodeOnCatchSubtype",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Dead code: This on-catch block won’t be executed because '{0}' is a subtype of '{1}' and hence will have been caught already.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try reordering the catch clauses so that this block can be reache",
        "owner": null,
        "labels": [],
        "description": "Dead code is code that is never reached. This case covers cases where the\nuser has an on-catch clause such as `on A catch (e)`, where a supertype of\n`A` was already caught.\n\nParameters:\n0: name of the subtype\n1: name of the supertype\n#### Description\n\nThe analyzer produces this diagnostic when a catch clause is found that\ncan't be executed because it is after a catch clause that catches either\nthe same type or a supertype of the clause's type. The first catch clause\nthat matches the thrown object is selected, and the earlier clause l always\nmatches anything matchable by the highlighted clause, so the highlighted\nclause will never be selected.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nvoid f() {\ntry {\n} on num {\n} [!on int {\n}!]\n}\n```\n\n#### Common fixes\n\nIf the clause should be selectable, then move the clause before the general\nclause:\n\n```dart\nvoid f() {\ntry {\n} on int {\n} on num {\n}\n}\n```\n\nIf the clause doesn't need to be selectable, then remove it:\n\n```dart\nvoid f() {\ntry {\n} on num {\n}\n}\n```"
      },
      {
        "real_name": "dead_null_aware_expression",
        "display_name": "DeadNullAwareExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The left operand can't be null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the right operand.",
        "owner": null,
        "labels": [],
        "description": "It is a warning to use null aware operators '??' or '??=' on an\nexpression of type `T` if `T` is strictly non-nullable.\n\nNo parameters.\n"
      },
      {
        "real_name": "default_list_constructor",
        "display_name": "DefaultListConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "It is an error to call the default List constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using 'List.filled' or 'List.generate'.",
        "owner": null,
        "labels": [],
        "description": "It is an error to call the default `List` constructor.\n"
      },
      {
        "real_name": "default_value_in_function_type",
        "display_name": "DefaultValueInFunctionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "default value in function type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "default value in function type"
      },
      {
        "real_name": "default_value_in_function_typed_parameter",
        "display_name": "DefaultValueInFunctionTypedParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Default values aren't allowed in function typed parameters.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the default value.",
        "owner": null,
        "labels": [],
        "description": "6.2.1 Required Formals: By means of a function signature that names the\nparameter and describes its type as a function type. It is a compile-time\nerror if any default values are specified in the signature of such a\nfunction type.\n"
      },
      {
        "real_name": "default_value_in_redirecting_factory_constructor",
        "display_name": "DefaultValueInRedirectingFactoryConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Default values aren't allowed in factory constructors that redirect to another constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the default value.",
        "owner": null,
        "labels": [],
        "description": "7.6.2 Factories: It is a compile-time error if <i>k</i> explicitly\nspecifies a default value for an optional parameter.\n"
      },
      {
        "real_name": "default_value_on_required_parameter",
        "display_name": "DefaultValueOnRequiredParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Required named parameters can't have a default value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing either the default value or the 'required' modifier.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a named parameter has both the\n`required` modifier and a default value. If the parameter is required, then\na value for the parameter is always provided at the call sites, so the\ndefault value can never be used.\n\n#### Examples\n\nThe following code generates this diagnostic:\n\n```dart\nvoid log({required String [!message!] = 'no message'}) {}\n```\n\n#### Common fixes\n\nIf the parameter is really required, then remove the default value:\n\n```dart\nvoid log({required String message}) {}\n```\n\nIf the parameter isn't always required, then remove the `required`\nmodifier:\n\n```dart\nvoid log({String message = 'no message'}) {}\n``` */"
      },
      {
        "real_name": "deferred_after_prefix",
        "display_name": "DeferredAfterPrefix",
        "severity": "warning",
        "category": "convention",
        "rule_title": "deferred after prefix",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "deferred after prefix"
      },
      {
        "real_name": "deferred_import_of_extension",
        "display_name": "DeferredImportOfExtension",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Imports of deferred libraries must hide all extensions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding either a show combinator listing the names you need to reference or a hide combinator listing all of the extensions.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "definitely_unassigned_late_local_variable",
        "display_name": "DefinitelyUnassignedLateLocalVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The late local variable '{0}' is definitely unassigned.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Ensure that it is assigned on necessary execution paths.",
        "owner": null,
        "labels": [],
        "description": "It is a compile time error to read a local variable marked `late` when the\nvariable is definitely unassigned. This includes all forms of reads,\nincluding implicit reads via the composite assignment operators as well\nas pre and post-fix operators.\n\nParameters:\n0: the name of the variable that is invalid\n"
      },
      {
        "real_name": "deprecated_analysis_options_file_name",
        "display_name": "DeprecatedAnalysisOptionsFileName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of the analysis options file {0} is deprecated; consider renaming it to analysis_options.yaml.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating the analysis options file name is deprecated and\nthe file should be renamed.\n\nParameters:\n0: the uri of the file which should be renamed\n"
      },
      {
        "real_name": "deprecated_extends_function",
        "display_name": "DeprecatedExtendsFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extending 'Function' is deprecated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing 'Function' from the 'extends' clause.",
        "owner": null,
        "labels": [],
        "description": "`Function` should not be extended anymore.\n"
      },
      {
        "real_name": "deprecated_function_class_declaration",
        "display_name": "DeprecatedFunctionClassDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Declaring a class named 'Function' is deprecated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming the class.",
        "owner": null,
        "labels": [],
        "description": "Users should not create a class named `Function` anymore.\n"
      },
      {
        "real_name": "deprecated_member_use",
        "display_name": "DeprecatedMemberUse",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is deprecated and shouldn't be used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the use of the deprecated member with the replacement.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the member\n#### Description\n\nThe analyzer produces this diagnostic when a deprecated library or class\nmember is used in a different package.\n\n#### Examples\n\nIf the method `m` in the class `C` is annotated with `@deprecated`, then\nthe following code produces this diagnostic:\n\n```dart\nvoid f(C c) {\nc.[!m!]();\n}\n```\n\n#### Common fixes\n\nThe documentation for declarations that are annotated with `@deprecated`\nshould indicate what code to use in place of the deprecated code."
      },
      {
        "real_name": "deprecated_member_use_from_same_package",
        "display_name": "DeprecatedMemberUseFromSamePackage",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is deprecated and shouldn't be used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the use of the deprecated member with the replacement.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the member\n#### Description\n\nThe analyzer produces this diagnostic when a deprecated library member or\nclass member is used in the same package in which it's declared.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is deprecated:\n\n```dart\n@deprecated\nvar x = 0;\nvar y = [!x!];\n```\n\n#### Common fixes\n\nThe fix depends on what's been deprecated and what the replacement is. The\ndocumentation for deprecated declarations should indicate what code to use\nin place of the deprecated code."
      },
      {
        "real_name": "deprecated_member_use_from_same_package_with_message",
        "display_name": "DeprecatedMemberUseFromSamePackageWithMessage",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is deprecated and shouldn't be used. {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the use of the deprecated member with the replacement.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the member\n1: message details\n"
      },
      {
        "real_name": "deprecated_member_use_with_message",
        "display_name": "DeprecatedMemberUseWithMessage",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is deprecated and shouldn't be used. {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the use of the deprecated member with the replacement.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the member\n1: message details\n"
      },
      {
        "real_name": "deprecated_mixin_function",
        "display_name": "DeprecatedMixinFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Mixing in 'Function' is deprecated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing 'Function' from the 'with' clause.",
        "owner": null,
        "labels": [],
        "description": "`Function` should not be mixed in anymore.\n"
      },
      {
        "real_name": "directive_after_declaration",
        "display_name": "DirectiveAfterDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "directive after declaration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "directive after declaration"
      },
      {
        "real_name": "division_optimization",
        "display_name": "DivisionOptimization",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator x ~/ y is more efficient than x / y).toInt).",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try re-writing the expression to use the '~/' operator.",
        "owner": null,
        "labels": [],
        "description": "Hint to use the ~/ operator.\n"
      },
      {
        "real_name": "duplicate_constructor_default",
        "display_name": "DuplicateConstructorDefault",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The default constructor is already defined.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try giving one of the constructors a name.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a class declares more than one\nunnamed constructor or when it declares more than one constructor with the\nsame name.\n\n#### Examples\n\nThe following code produces this diagnostic because there are two\ndeclarations for the unnamed constructor:\n\n```dart\nclass C {\nC();\n\n[!C!]();\n}\n```\n\nThe following code produces this diagnostic because there are two\ndeclarations for the constructor named `m`:\n\n```dart\nclass C {\nC.m();\n\n[!C.m!]();\n}\n```\n\n#### Common fixes\n\nIf there are multiple unnamed constructors and all of the constructors are\nneeded, then give all of them, or all except one of them, a name:\n\n```dart\nclass C {\nC();\n\nC.n();\n}\n```\n\nIf there are multiple unnamed constructors and all except one of them are\nunneeded, then remove the constructors that aren't needed:\n\n```dart\nclass C {\nC();\n}\n```\n\nIf there are multiple named constructors and all of the constructors are\nneeded, then rename all except one of them:\n\n```dart\nclass C {\nC.m();\n\nC.n();\n}\n```\n\nIf there are multiple named constructors and all except one of them are\nunneeded, then remove the constructorsthat aren't needed:\n\n```dart\nclass C {\nC.m();\n}\n```"
      },
      {
        "real_name": "duplicate_constructor_name",
        "display_name": "DuplicateConstructorName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constructor with name '{0}' is already defined.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming one of the constructors.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the duplicate entity\n"
      },
      {
        "real_name": "duplicate_deferred",
        "display_name": "DuplicateDeferred",
        "severity": "warning",
        "category": "convention",
        "rule_title": "duplicate deferred",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "duplicate deferred"
      },
      {
        "real_name": "duplicate_definition",
        "display_name": "DuplicateDefinition",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' is already defined.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming one of the declarations.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the duplicate entity\n#### Description\n\nThe analyzer produces this diagnostic when a name is declared, and there is\na previous declaration with the same name in the same scope.\n\n#### Examples\n\nThe following code produces this diagnostic because the name `x` is\ndeclared twice:\n\n```dart\nint x = 0;\nint [!x!] = 1;\n```\n\n#### Common fixes\n\nChoose a different name for one of the declarations.\n\n```dart\nint x = 0;\nint y = 1;\n```"
      },
      {
        "real_name": "duplicate_hidden_name",
        "display_name": "DuplicateHiddenName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Duplicate hidden name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the repeated name from the list of hidden members.",
        "owner": null,
        "labels": [],
        "description": "Duplicate hidden names.\n"
      },
      {
        "real_name": "duplicate_import",
        "display_name": "DuplicateImport",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Duplicate import.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one import of the library.",
        "owner": null,
        "labels": [],
        "description": "Duplicate imports.\n\nNo parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an import directive is found\nthat is the same as an import before it in the file. The second import\ndoesn’t add value and should be removed.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'package:meta/meta.dart';\nimport [!'package:meta/meta.dart'!];\n\n@sealed class C {}\n```\n\n#### Common fixes\n\nRemove the unnecessary import:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@sealed class C {}\n```"
      },
      {
        "real_name": "duplicate_label_in_switch_statement",
        "display_name": "DuplicateLabelInSwitchStatement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An enum must declare at least one constant name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try declaring a constant.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the label that was duplicated\nParameters:\n0: the modifier that was duplicated\n"
      },
      {
        "real_name": "duplicate_named_argument",
        "display_name": "DuplicateNamedArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The argument for the named parameter '{0}' was already specified.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing one of the named argument",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the parameter that was duplicated\n#### Description\n\nThe analyzer produces this diagnostic when an invocation has two or more\nnamed arguments that have the same name.\n\n#### Examples\n\nThe following code produces this diagnostic because there are two arguments\nwith the name `a`:\n\n```dart\nvoid f(C c) {\nc.m(a: 0, [!a!]: 1);\n}\n\nclass C {\nvoid m({int a, int b}) {}\n}\n```\n\n#### Common fixes\n\nIf one of the arguments should have a different name, then change the name:\n\n```dart\nvoid f(C c) {\nc.m(a: 0, b: 1);\n}\n\nclass C {\nvoid m({int a, int b}) {}\n}\n```\n\nIf one of the arguments is wrong, then remove it:\n\n```dart\nvoid f(C c) {\nc.m(a: 1);\n}\n\nclass C {\nvoid m({int a, int b}) {}\n}\n```"
      },
      {
        "real_name": "duplicate_part",
        "display_name": "DuplicatePart",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The library already contains a part with the uri '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one of the duplicated part directives.",
        "owner": null,
        "labels": [],
        "description": "18.3 Parts: It's a compile-time error if the same library contains two part\ndirectives with the same URI.\n\nParameters:\n0: the URI of the duplicate part\n"
      },
      {
        "real_name": "duplicate_prefix",
        "display_name": "DuplicatePrefix",
        "severity": "warning",
        "category": "convention",
        "rule_title": "duplicate prefix",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "duplicate prefix"
      },
      {
        "real_name": "duplicate_shown_name",
        "display_name": "DuplicateShownName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Duplicate shown name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the repeated name from the list of shown members.",
        "owner": null,
        "labels": [],
        "description": "Duplicate shown names.\n"
      },
      {
        "real_name": "duplicated_modifier",
        "display_name": "DuplicatedModifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "duplicated modifier",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "duplicated modifier"
      },
      {
        "real_name": "dynamic_invoke",
        "display_name": "DynamicInvoke",
        "severity": "warning",
        "category": "convention",
        "rule_title": "dynamic invoke",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "dynamic invoke"
      },
      {
        "real_name": "empty_enum_body",
        "display_name": "EmptyEnumBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "empty enum body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "empty enum body"
      },
      {
        "real_name": "enum_in_class",
        "display_name": "EnumInClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "enum in class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "enum in class"
      },
      {
        "real_name": "equal_elements_in_const_set",
        "display_name": "EqualElementsInConstSet",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Two elements in a constant set literal can't be equal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Change or remove the duplicate element.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when two elements in a constant set\nliteral have the same value. The set can only contain each value once,\nwhich means that one of the values is unnecessary.\n\n#### Examples\n\nThe following code produces this diagnostic because the string `'a'` is\nspecified twice:\n\n```dart\nconst Set<String> set = {'a', [!'a'!]};\n```\n\n#### Common fixes\n\nRemove one of the duplicate values:\n\n```dart\nconst Set<String> set = {'a'};\n```\n\nNote that literal sets preserve the order of their elements, so the choice\nof which element to remove might affect the order in which elements are\nreturned by an iterator."
      },
      {
        "real_name": "equal_elements_in_set",
        "display_name": "EqualElementsInSet",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Two elements in a set literal shouldn't be equal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Change or remove the duplicate element.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "equal_keys_in_const_map",
        "display_name": "EqualKeysInConstMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Two keys in a constant map literal can't be equal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Change or remove the duplicate key.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a key in a constant map is the\nsame as a previous key in the same map. If two keys are the same, then the\nsecond value would overwrite the first value, which makes having both pairs\npointless.\n\n#### Examples\n\nThe following code produces this diagnostic because the key `1` is used\ntwice:\n\n```dart\nconst map = <int, String>{1: 'a', 2: 'b', [!1!]: 'c', 4: 'd'};\n```\n\n#### Common fixes\n\nIf both entries should be included in the map, then change one of the keys\nto be different:\n\n```dart\nconst map = <int, String>{1: 'a', 2: 'b', 3: 'c', 4: 'd'};\n```\n\nIf only one of the entries is needed, then remove the one that isn't\nneeded:\n\n```dart\nconst map = <int, String>{1: 'a', 2: 'b', 4: 'd'};\n```\n\nNote that literal maps preserve the order of their entries, so the choice\nof which entry to remove might affect the order in which keys and values\nare returned by an iterator."
      },
      {
        "real_name": "equal_keys_in_map",
        "display_name": "EqualKeysInMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Two keys in a map literal shouldn't be equal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Change or remove the duplicate key.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "equality_cannot_be_equality_operand",
        "display_name": "EqualityCannotBeEqualityOperand",
        "severity": "warning",
        "category": "convention",
        "rule_title": "equality cannot be equality operand",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "equality cannot be equality operand"
      },
      {
        "real_name": "expected_body",
        "display_name": "ExpectedBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected body"
      },
      {
        "real_name": "expected_case_or_default",
        "display_name": "ExpectedCaseOrDefault",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected case or default",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected case or default"
      },
      {
        "real_name": "expected_class_member",
        "display_name": "ExpectedClassMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected class member",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected class member"
      },
      {
        "real_name": "expected_else_or_comma",
        "display_name": "ExpectedElseOrComma",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected else or comma",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected else or comma"
      },
      {
        "real_name": "expected_executable",
        "display_name": "ExpectedExecutable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected executable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected executable"
      },
      {
        "real_name": "expected_instead",
        "display_name": "ExpectedInstead",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected instead",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected instead"
      },
      {
        "real_name": "expected_list_or_map_literal",
        "display_name": "ExpectedListOrMapLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected list or map literal",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected list or map literal"
      },
      {
        "real_name": "expected_one_list_type_arguments",
        "display_name": "ExpectedOneListTypeArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "List literals require exactly one type argument or none",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adjusting the number of type arguments.",
        "owner": null,
        "labels": [],
        "description": "12.7 Lists: A fresh instance (7.6.1) <i>a</i>, of size <i>n</i>, whose\nclass implements the built-in class <i>List&lt;E></i> is allocated.\n\nParameters:\n0: the number of provided type arguments\n"
      },
      {
        "real_name": "expected_one_set_type_arguments",
        "display_name": "ExpectedOneSetTypeArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Set literals require exactly one type argument or none",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adjusting the number of type arguments.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the number of provided type arguments\n"
      },
      {
        "real_name": "expected_string_literal",
        "display_name": "ExpectedStringLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected string literal",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected string literal"
      },
      {
        "real_name": "expected_token",
        "display_name": "ExpectedToken",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Expected to find '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the token that was expected but not found\n"
      },
      {
        "real_name": "expected_two_map_type_arguments",
        "display_name": "ExpectedTwoMapTypeArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Map literals require exactly two type arguments or none",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adjusting the number of type arguments.",
        "owner": null,
        "labels": [],
        "description": "12.8 Maps: A fresh instance (7.6.1) <i>m</i>, of size <i>n</i>, whose class\nimplements the built-in class <i>Map&lt;K, V></i> is allocated.\n\nParameters:\n0: the number of provided type arguments\n"
      },
      {
        "real_name": "expected_type_name",
        "display_name": "ExpectedTypeName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "expected type name",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "expected type name"
      },
      {
        "real_name": "experiment_not_enabled",
        "display_name": "ExperimentNotEnabled",
        "severity": "warning",
        "category": "convention",
        "rule_title": "experiment not enabled",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "experiment not enabled"
      },
      {
        "real_name": "export_directive_after_part_directive",
        "display_name": "ExportDirectiveAfterPartDirective",
        "severity": "warning",
        "category": "convention",
        "rule_title": "export directive after part directive",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "export directive after part directive"
      },
      {
        "real_name": "export_duplicated_library_named",
        "display_name": "ExportDuplicatedLibraryNamed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The exported libraries '{0}' and '{1}' can't have the same name '{2}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding a hide clause to one of the export directives.",
        "owner": null,
        "labels": [],
        "description": "14.2 Exports: It is a static warning to export two different libraries with\nthe same name.\n\nParameters:\n0: the uri pointing to a first library\n1: the uri pointing to a second library\n2:e the shared name of the exported libraries\n"
      },
      {
        "real_name": "export_internal_library",
        "display_name": "ExportInternalLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The library '{0}' is internal and can't be exported.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "SDK implementation libraries can be exported only by other SDK libraries.\n\nParameters:\n0: the uri pointing to a library\n"
      },
      {
        "real_name": "export_legacy_symbol",
        "display_name": "ExportLegacySymbol",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The symbol '{0}' is defined in a legacy library",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Use show / hide combinators to avoid exporting these symbol",
        "owner": null,
        "labels": [],
        "description": "It is an error for an opted-in library to re-export symbols which are\ndefined in a legacy library.\n\nParameters:\n0: the name of a symbol defined in a legacy library\n"
      },
      {
        "real_name": "export_of_non_library",
        "display_name": "ExportOfNonLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The exported library '{0}' can't have a part-of directive.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try exporting the library that the part is a part of.",
        "owner": null,
        "labels": [],
        "description": "14.2 Exports: It is a compile-time error if the compilation unit found at\nthe specified URI is not a library declaration.\n\nParameters:\n0: the uri pointing to a non-library declaration\n"
      },
      {
        "real_name": "expression_in_map",
        "display_name": "ExpressionInMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Expressions can't be used in a map literal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the expression or converting it to be a map entry.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the analyzer finds an\nexpression, rather than a map entry, in what appears to be a map literal.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nvar map = <String, int>{'a': 0, 'b': 1, [!'c'!]};\n```\n\n#### Common fixes\n\nIf the expression is intended to compute either a key or a value in an\nentry, fix the issue by replacing the expression with the key or the value.\nFor example:\n\n```dart\nvar map = <String, int>{'a': 0, 'b': 1, 'c': 2};\n```"
      },
      {
        "real_name": "extends_deferred_class",
        "display_name": "ExtendsDeferredClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes can't extend deferred classes.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a different superclas",
        "owner": null,
        "labels": [],
        "description": "7.9 Superclasses: It is a compile-time error if the extends clause of a\nclass <i>C</i> includes a deferred type expression.\n\nParameters:\n0: the name of the type that cannot be extended\n\nSee [IMPLEMENTS_DEFERRED_CLASS], and [MIXIN_DEFERRED_CLASS].\n"
      },
      {
        "real_name": "extends_disallowed_class",
        "display_name": "ExtendsDisallowedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes can't extend '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a different superclas",
        "owner": null,
        "labels": [],
        "description": "12.2 Null: It is a compile-time error for a class to attempt to extend or\nimplement Null.\n\n12.3 Numbers: It is a compile-time error for a class to attempt to extend\nor implement int.\n\n12.3 Numbers: It is a compile-time error for a class to attempt to extend\nor implement double.\n\n12.3 Numbers: It is a compile-time error for any type other than the types\nint and double to\nattempt to extend or implement num.\n\n12.4 Booleans: It is a compile-time error for a class to attempt to extend\nor implement bool.\n\n12.5 Strings: It is a compile-time error for a class to attempt to extend\nor implement String.\n\nParameters:\n0: the name of the type that cannot be extended\n\nSee [IMPLEMENTS_DISALLOWED_CLASS] and [MIXIN_OF_DISALLOWED_CLASS].\n\nTODO(scheglov) We might want to restore specific code with FrontEnd.\nhttps://github.com/dart-lang/sdk/issues/31821\n"
      },
      {
        "real_name": "extends_non_class",
        "display_name": "ExtendsNonClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes can only extend other classes.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a different superclas",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name in the extends clause\n#### Description\n\nThe analyzer produces this diagnostic when an extends clause contains a\nname that is declared to be something other than a class.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` is declared to be a\nfunction:\n\n```dart\nvoid f() {}\n\nclass C extends [!f!] {}\n```\n\n#### Common fixes\n\nIf you want the class to extend a class other than `Object`, then replace\nthe name in the extends clause with the name of that class:\n\n```dart\nvoid f() {}\n\nclass C extends B {}\n\nclass B {}\n```\n\nIf you want the class to extend `Object`, then remove the extends clause:\n\n```dart\nvoid f() {}\n\nclass C {}\n```"
      },
      {
        "real_name": "extension_as_expression",
        "display_name": "ExtensionAsExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extension '{0}' can't be used as an expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing it with a valid expression.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the extension\n#### Description\n\nThe analyzer produces this diagnostic when the name of an extension is used\nin an expression other than in an extension override or to qualify an\naccess to a static member of the extension. Because classes define a type,\nthe name of a class can be used to refer to the instance of `Type`\nrepresenting the type of the class. Extensions, on the other hand, don't\ndefine a type and can't be used as a type literal.\n\n#### Examples\n\nThe following code produces this diagnostic because `E` is an extension:\n\n```dart\nextension E on int {\nstatic String m() => '';\n}\n\nvar x = [!E!];\n```\n\n#### Common fixes\n\nReplace the name of the extension with a name that can be referenced, such\nas a static member defined on the extension:\n\n```dart\nextension E on int {\nstatic String m() => '';\n}\n\nvar x = E.m();\n```"
      },
      {
        "real_name": "extension_conflicting_static_and_instance",
        "display_name": "ExtensionConflictingStaticAndInstance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extension '{0}' can't define static member '{1}' and an instance member with the same name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming the member to a name that doesn't conflict.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the extension defining the conflicting member\n1: the name of the conflicting static member\n#### Description\n\nThe analyzer produces this diagnostic when an extension declaration\ncontains both an instance member and a static member that have the same\nname. The instance member and the static member can't have the same name\nbecause it's unclear which member is being referenced by an unqualified use\nof the name within the body of the extension.\n\n#### Examples\n\nThe following code produces this diagnostic because the name `a` is being\nused for two different members:\n\n```dart\nextension E on Object {\nint get a => 0;\nstatic int [!a!]() => 0;\n}\n```\n\n#### Common fixes\n\nRename or remove one of the members:\n\n```dart\nextension E on Object {\nint get a => 0;\nstatic int b() => 0;\n}\n```"
      },
      {
        "real_name": "extension_declares_abstract_member",
        "display_name": "ExtensionDeclaresAbstractMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "External getters can't have a body.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the body of the gette",
        "owner": null,
        "labels": [],
        "description": "No parameters.\nNo parameters.\nNo parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an abstract declaration is\ndeclared in an extension. Extensions can declare only concrete members.\n\n#### Examples\n\nThe following code produces this diagnostic because the method `a` doesn't\nhave a body:\n\n```dart\nextension E on String {\nint [!a!]();\n}\n```\n\n#### Common fixes\n\nEither provide an implementation for the member or remove it.\n#### Description\n\nThe analyzer produces this diagnostic when a constructor declaration is\nfound in an extension. It isn't valid to define a constructor because\nextensions aren't classes, and it isn't possible to create an instance of\nan extension.\n\n#### Examples\n\nThe following code produces this diagnostic because there is a constructor\ndeclaration in `E`:\n\n```dart\nextension E on String {\n[!E!]() : super();\n}\n```\n\n#### Common fixes\n\nRemove the constructor or replace it with a static method.\n#### Description\n\nThe analyzer produces this diagnostic when an instance field declaration is\nfound in an extension. It isn't valid to define an instance field because\nextensions can only add behavior, not state.\n\n#### Examples\n\nThe following code produces this diagnostic because `s` is an instance\nfield:\n\n```dart\nextension E on String {\nString [!s!];\n}\n```\n\n#### Common fixes\n\nRemove the field, make it a static field, or convert it to be a getter,\nsetter, or method."
      },
      {
        "real_name": "extension_declares_constructor",
        "display_name": "ExtensionDeclaresConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "extension declares constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "extension declares constructor"
      },
      {
        "real_name": "extension_declares_instance_field",
        "display_name": "ExtensionDeclaresInstanceField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "extension declares instance field",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "extension declares instance field"
      },
      {
        "real_name": "extension_declares_member_of_object",
        "display_name": "ExtensionDeclaresMemberOfObject",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extensions can't declare members with the same name as a member declared by 'Object'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a different name for the member.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an extension declaration\ndeclares a member with the same name as a member declared in the class\n`Object`. Such a member can never be used because the member in `Object` is\nalways found first.\n\n#### Examples\n\nThe following code produces this diagnostic because `toString` is defined\nby `Object`:\n\n```dart\nextension E on String {\nString [!toString!]() => this;\n}\n```\n\n#### Common fixes\n\nRemove the member or rename it so that the name doesn't conflict with the\nmember in `Object`:\n\n```dart\nextension E on String {\nString displayString() => this;\n}\n```"
      },
      {
        "real_name": "extension_override_access_to_static_member",
        "display_name": "ExtensionOverrideAccessToStaticMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An extension override can't be used to access a static member from an extension.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using just the name of the extension.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is the\ntarget of the invocation of a static member. Similar to static members in\nclasses, the static members of an extension should be accessed using the\nname of the extension, not an extension override.\n\n#### Examples\n\nThe following code produces this diagnostic because `m` is static:\n\n```dart\nextension E on String {\nstatic void m() {}\n}\n\nvoid f() {\nE('').[!m!]();\n}\n```\n\n#### Common fixes\n\nReplace the extension override with the name of the extension:\n\n```dart\nextension E on String {\nstatic void m() {}\n}\n\nvoid f() {\nE.m();\n}\n```"
      },
      {
        "real_name": "extension_override_argument_not_assignable",
        "display_name": "ExtensionOverrideArgumentNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type of the argument to the extension override '{0}' isn't assignable to the extended type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the argument\n1: the extended type\n#### Description\n\nThe analyzer produces this diagnostic when the argument to an extension\noverride isn't assignable to the type being extended by the extension.\n\n#### Examples\n\nThe following code produces this diagnostic because `3` isn't a `String`:\n\n```dart\nextension E on String {\nvoid method() {}\n}\n\nvoid f() {\nE([!3!]).method();\n}\n```\n\n#### Common fixes\n\nIf you're using the correct extension, then update the argument to have the\ncorrect type:\n\n```dart\nextension E on String {\nvoid method() {}\n}\n\nvoid f() {\nE(3.toString()).method();\n}\n```\n\nIf there's a different extension that's valid for the type of the argument,\nthen either replace the name of the extension or unwrap the target so that\nthe correct extension is found."
      },
      {
        "real_name": "extension_override_with_cascade",
        "display_name": "ExtensionOverrideWithCascade",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extension overrides have no value so they can't be used as the target of a cascade expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using '.' instead of '..'.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is used as\nthe target of a cascade expression. The value of a cascade expression\n`e..m` is the value of the target `e`, but extension overrides are not\nexpressions and don't have a value.\n\n#### Examples\n\nThe following code produces this diagnostic because `E(3)` isn't an\nexpression:\n\n```dart\nextension E on int {\nvoid m() {}\n}\nf() {\nE(3)[!..!]m();\n}\n```\n\n#### Common fixes\n\nUse '.' rather than '..':\n\n```dart\nextension E on int {\nvoid m() {}\n}\nf() {\nE(3).m();\n}\n```\n\nIf there are multiple cascaded accesses, you'll need to duplicate the\nextension override for each one."
      },
      {
        "real_name": "extension_override_without_access",
        "display_name": "ExtensionOverrideWithoutAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "An extension override can only be used to access instance members.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Consider adding an access to an instance member.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is found\nthat isn't being used to access one of the members of the extension. The\nextension override syntax doesn't have any runtime semantics; it only\ncontrols which member is selected at compile time.\n\n#### Examples\n\nThe following code produces this diagnostic because `E(i)` isn't an\nexpression:\n\n```dart\nextension E on int {\nint get a => 0;\n}\n\nvoid f(int i) {\nprint([!E(i)!]);\n}\n```\n\n#### Common fixes\n\nIf you want to invoke one of the members of the extension, then add the\ninvocation:\n\n```dart\nextension E on int {\nint get a => 0;\n}\n\nvoid f(int i) {\nprint(E(i).a);\n}\n```\n\nIf you don't want to invoke a member, then unwrap the target:\n\n```dart\nextension E on int {\nint get a => 0;\n}\n\nvoid f(int i) {\nprint(i);\n}\n```"
      },
      {
        "real_name": "external_after_const",
        "display_name": "ExternalAfterConst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external after const",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external after const"
      },
      {
        "real_name": "external_after_factory",
        "display_name": "ExternalAfterFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external after factory",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external after factory"
      },
      {
        "real_name": "external_after_static",
        "display_name": "ExternalAfterStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external after static",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external after static"
      },
      {
        "real_name": "external_class",
        "display_name": "ExternalClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external class"
      },
      {
        "real_name": "external_constructor_with_body",
        "display_name": "ExternalConstructorWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external constructor with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external constructor with body"
      },
      {
        "real_name": "external_constructor_with_initializer",
        "display_name": "ExternalConstructorWithInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external constructor with initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external constructor with initializer"
      },
      {
        "real_name": "external_enum",
        "display_name": "ExternalEnum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external enum",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external enum"
      },
      {
        "real_name": "external_factory_redirection",
        "display_name": "ExternalFactoryRedirection",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external factory redirection",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external factory redirection"
      },
      {
        "real_name": "external_factory_with_body",
        "display_name": "ExternalFactoryWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external factory with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external factory with body"
      },
      {
        "real_name": "external_field",
        "display_name": "ExternalField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external field",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external field"
      },
      {
        "real_name": "external_getter_with_body",
        "display_name": "ExternalGetterWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external getter with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external getter with body"
      },
      {
        "real_name": "external_method_with_body",
        "display_name": "ExternalMethodWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external method with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external method with body"
      },
      {
        "real_name": "external_operator_with_body",
        "display_name": "ExternalOperatorWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external operator with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external operator with body"
      },
      {
        "real_name": "external_setter_with_body",
        "display_name": "ExternalSetterWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external setter with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external setter with body"
      },
      {
        "real_name": "external_typedef",
        "display_name": "ExternalTypedef",
        "severity": "warning",
        "category": "convention",
        "rule_title": "external typedef",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "external typedef"
      },
      {
        "real_name": "extra_annotation_on_struct_field",
        "display_name": "ExtraAnnotationOnStructField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try removing the extra annotation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the extra annotation.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "extra_positional_arguments",
        "display_name": "ExtraPositionalArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Too many positional arguments: {0} expected",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the extra arguments.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the maximum number of positional arguments\n1: the actual number of positional arguments given\n#### Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas more positional arguments than the method or function allows.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` defines 2\nparameters but is invoked with 3 arguments:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\nf[!(1, 2, 3)!];\n}\n```\n\n#### Common fixes\n\nRemove the arguments that don't correspond to parameters:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\nf(1, 2);\n}\n```"
      },
      {
        "real_name": "extra_positional_arguments_could_be_named",
        "display_name": "ExtraPositionalArgumentsCouldBeNamed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Too many positional arguments: {0} expected",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the extra positional argument",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the maximum number of positional arguments\n1: the actual number of positional arguments given\n#### Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas more positional arguments than the method or function allows, but the\nmethod or function defines named parameters.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` defines 2\npositional parameters but has a named parameter that could be used for the\nthird argument:\n\n```dart\nvoid f(int a, int b, {int c}) {}\nvoid g() {\nf[!(1, 2, 3)!];\n}\n```\n\n#### Common fixes\n\nIf some of the arguments should be values for named parameters, then add\nthe names before the arguments:\n\n```dart\nvoid f(int a, int b, {int c}) {}\nvoid g() {\nf(1, 2, c: 3);\n}\n```\n\nOtherwise, remove the arguments that don't correspond to positional\nparameters:\n\n```dart\nvoid f(int a, int b, {int c}) {}\nvoid g() {\nf(1, 2);\n}\n```"
      },
      {
        "real_name": "extraneous_modifier",
        "display_name": "ExtraneousModifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "extraneous modifier",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "extraneous modifier"
      },
      {
        "real_name": "factory_top_level_declaration",
        "display_name": "FactoryTopLevelDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "factory top level declaration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "factory top level declaration"
      },
      {
        "real_name": "factory_with_initializers",
        "display_name": "FactoryWithInitializers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "factory with initializers",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "factory with initializers"
      },
      {
        "real_name": "factory_without_body",
        "display_name": "FactoryWithoutBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "factory without body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "factory without body"
      },
      {
        "real_name": "field_in_struct_with_initializer",
        "display_name": "FieldInStructWithInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try removing the initializer.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the initializer.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "field_initialized_by_multiple_initializers",
        "display_name": "FieldInitializedByMultipleInitializers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The field '{0}' can't be initialized twice in the same constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing one of the initializations.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Let <i>k</i> be a generative constructor. It\nis a compile time error if more than one initializer corresponding to a\ngiven instance variable appears in <i>k</i>'s list.\n\nParameters:\n0: the name of the field being initialized multiple times\n"
      },
      {
        "real_name": "field_initialized_in_initializer_and_declaration",
        "display_name": "FieldInitializedInInitializerAndDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Fields can't be initialized in the constructor if they are final and have already been initialized at their declaration.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing one of the initializations.",
        "owner": null,
        "labels": [],
        "description": "5. Variables: It is a static warning if a final instance variable that has\nbeen initialized at its point of declaration is also initialized in a\nconstructor.\n"
      },
      {
        "real_name": "field_initialized_in_parameter_and_initializer",
        "display_name": "FieldInitializedInParameterAndInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Fields can't be initialized in both the parameter list and the initializers.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing one of the initializations.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Let <i>k</i> be a generative constructor. It\nis a compile time error if <i>k</i>'s initializer list contains an\ninitializer for a variable that is initialized by means of an initializing\nformal of <i>k</i>.\n"
      },
      {
        "real_name": "field_initialized_outside_declaring_class",
        "display_name": "FieldInitializedOutsideDeclaringClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "field initialized outside declaring class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "field initialized outside declaring class"
      },
      {
        "real_name": "field_initializer_factory_constructor",
        "display_name": "FieldInitializerFactoryConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Initializing formal parameters can't be used in factory constructors.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a normal parameter.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: It is a compile-time error if an\ninitializing formal is used by a function other than a non-redirecting\ngenerative constructor.\n"
      },
      {
        "real_name": "field_initializer_in_struct",
        "display_name": "FieldInitializerInStruct",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try removing the field initializer.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the field initializer.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "field_initializer_not_assignable",
        "display_name": "FieldInitializerNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The initializer type '{0}' can't be assigned to the field type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Execution of an initializer of the form\n<b>this</b>.<i>v</i> = <i>e</i> proceeds as follows: First, the expression\n<i>e</i> is evaluated to an object <i>o</i>. Then, the instance variable\n<i>v</i> of the object denoted by this is bound to <i>o</i>.\n\n12.14.2 Binding Actuals to Formals: Let <i>T<sub>i</sub></i> be the static\ntype of <i>a<sub>i</sub></i>, let <i>S<sub>i</sub></i> be the type of\n<i>p<sub>i</sub>, 1 &lt;= i &lt;= n+k</i> and let <i>S<sub>q</sub></i> be\nthe type of the named parameter <i>q</i> of <i>f</i>. It is a static\nwarning if <i>T<sub>j</sub></i> may not be assigned to <i>S<sub>j</sub>, 1\n&lt;= j &lt;= m</i>.\n\nParameters:\n0: the name of the type of the initializer expression\n1: the name of the type of the field\n"
      },
      {
        "real_name": "field_initializer_outside_constructor",
        "display_name": "FieldInitializerOutsideConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Initializing formal parameters can only be used in constructors.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a normal parameter.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: It is a compile-time error if an\ninitializing formal is used by a function other than a non-redirecting\ngenerative constructor.\n"
      },
      {
        "real_name": "field_initializer_redirecting_constructor",
        "display_name": "FieldInitializerRedirectingConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The redirecting constructor can't have a field initializer.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a normal parameter.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: A generative constructor may be redirecting,\nin which case its only action is to invoke another generative constructor.\n\n7.6.1 Generative Constructors: It is a compile-time error if an\ninitializing formal is used by a function other than a non-redirecting\ngenerative constructor.\n"
      },
      {
        "real_name": "field_initializing_formal_not_assignable",
        "display_name": "FieldInitializingFormalNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The parameter type '{0}' is incompatible with the field type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing or removing the parameter's typ",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: An initializing formal has the form\n<i>this.id</i>. It is a static warning if the static type of <i>id</i> is\nnot assignable to <i>T<sub>id</sub></i>.\n\nParameters:\n0: the name of the type of the field formal parameter\n1: the name of the type of the field\n"
      },
      {
        "real_name": "file_import_inside_lib_references_file_outside",
        "display_name": "FileImportInsideLibReferencesFileOutside",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A file in the 'lib' directory shouldn't import a file outside the 'lib' directory.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the impor",
        "owner": null,
        "labels": [],
        "description": "It is a bad practice for a source file in a package \"lib\" directory\nhierarchy to traverse outside that directory hierarchy. For example, a\nsource file in the \"lib\" directory should not contain a directive such as\n`import '../web/some.dart'` which references a file outside the lib\ndirectory.\n"
      },
      {
        "real_name": "file_import_outside_lib_references_file_inside",
        "display_name": "FileImportOutsideLibReferencesFileInside",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A file outside the 'lib' directory shouldn't reference a file inside the 'lib' directory using a relative path.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "URI instead.",
        "owner": null,
        "labels": [],
        "description": "It is a bad practice for a source file ouside a package \"lib\" directory\nhierarchy to traverse into that directory hierarchy. For example, a source\nfile in the \"web\" directory should not contain a directive such as\n`import '../lib/some.dart'` which references a file inside the lib\ndirectory.\n"
      },
      {
        "real_name": "final_and_covariant",
        "display_name": "FinalAndCovariant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final and covariant",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final and covariant"
      },
      {
        "real_name": "final_and_covariant_late_with_initializer",
        "display_name": "FinalAndCovariantLateWithInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final and covariant late with initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final and covariant late with initializer"
      },
      {
        "real_name": "final_and_var",
        "display_name": "FinalAndVar",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final and var",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final and var"
      },
      {
        "real_name": "final_class",
        "display_name": "FinalClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final class"
      },
      {
        "real_name": "final_constructor",
        "display_name": "FinalConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final constructor"
      },
      {
        "real_name": "final_enum",
        "display_name": "FinalEnum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final enum",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final enum"
      },
      {
        "real_name": "final_initialized_in_declaration_and_constructor",
        "display_name": "FinalInitializedInDeclarationAndConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is final and was given a value when it was declared",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing one of the initializations.",
        "owner": null,
        "labels": [],
        "description": "5. Variables: It is a static warning if a final instance variable that has\nbeen initialized at its point of declaration is also initialized in a\nconstructor.\n\nParameters:\n0: the name of the field in question\n"
      },
      {
        "real_name": "final_initialized_multiple_times",
        "display_name": "FinalInitializedMultipleTimes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is a final field and so can only be set once.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one of the initializations.",
        "owner": null,
        "labels": [],
        "description": "5 Variables: It is a compile-time error if a final instance variable that\nhas is initialized by means of an initializing formal of a constructor is\nalso initialized elsewhere in the same constructor.\n\nParameters:\n0: the name of the field in question\n"
      },
      {
        "real_name": "final_method",
        "display_name": "FinalMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final method",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final method"
      },
      {
        "real_name": "final_not_initialized",
        "display_name": "FinalNotInitialized",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The final variable '{0}' must be initialized.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try initializing the variable.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the uninitialized final variable\n#### Description\n\nThe analyzer produces this diagnostic when a final field or variable isn't\ninitialized.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` doesn't have an\ninitializer:\n\n```dart\nfinal [!x!];\n```\n\n#### Common fixes\n\nFor variables and static fields, you can add an initializer:\n\n```dart\nfinal x = 0;\n```\n\nFor instance fields, you can add an initializer as shown in the previous\nexample, or you can initialize the field in every constructor. You can\ninitialize the field by using a field formal parameter:\n\n```dart\nclass C {\nfinal int x;\nC(this.x);\n}\n```\n\nYou can also initialize the field by using an initializer in the\nconstructor:\n\n```dart\nclass C {\nfinal int x;\nC(int y) : x = y * 2;\n}\n```\nTODO(brianwilkerson) Split this error code so that we can suggest\ninitializing fields in constructors (FINAL_FIELD_NOT_INITIALIZED\nand FINAL_VARIABLE_NOT_INITIALIZED)."
      },
      {
        "real_name": "final_not_initialized_constructor_1",
        "display_name": "FinalNotInitializedConstructor1",
        "severity": "warning",
        "category": "convention",
        "rule_title": "All final variables must be initialized",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an initializer for the field.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the uninitialized final variable\n#### Description\n\nThe analyzer produces this diagnostic when a class defines one or more\nfinal instance fields without initializers and has at least one constructor\nthat doesn't initialize those fields. All final instance fields must be\ninitialized when the instance is created, either by the field's initializer\nor by the constructor.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nclass C {\nfinal String value;\n\n[!C!]();\n}\n```\n\n#### Common fixes\n\nIf the value should be passed in to the constructor directly, then use a\nfield formal parameter to initialize the field `value`:\n\n```dart\nclass C {\nfinal String value;\n\nC(this.value);\n}\n```\n\nIf the value should be computed indirectly from a value provided by the\ncaller, then add a parameter and include an initializer:\n\n```dart\nclass C {\nfinal String value;\n\nC(Object o) : value = o.toString();\n}\n```\n\nIf the value of the field doesn't depend on values that can be passed to\nthe constructor, then add an initializer for the field as part of the field\ndeclaration:\n\n```dart\nclass C {\nfinal String value = '';\n\nC();\n}\n```\n\nIf the value of the field doesn't depend on values that can be passed to\nthe constructor but different constructors need to initialize it to\ndifferent values, then add an initializer for the field in the initializer\nlist:\n\n```dart\nclass C {\nfinal String value;\n\nC() : value = '';\n\nC.named() : value = 'c';\n}\n```\n\nHowever, if the value is the same for all instances, then consider using a\nstatic field instead of an instance field:\n\n```dart\nclass C {\nstatic const String value = '';\n\nC();\n}\n```"
      },
      {
        "real_name": "final_not_initialized_constructor_2",
        "display_name": "FinalNotInitializedConstructor2",
        "severity": "warning",
        "category": "convention",
        "rule_title": "All final variables must be initialized",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding initializers for the fields.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the uninitialized final variable\n1: the name of the uninitialized final variable\n"
      },
      {
        "real_name": "final_not_initialized_constructor_3_plus",
        "display_name": "FinalNotInitializedConstructor3Plus",
        "severity": "warning",
        "category": "convention",
        "rule_title": "All final variables must be initialized",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding initializers for the fields.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the uninitialized final variable\n1: the name of the uninitialized final variable\n2: the number of additional not initialized variables that aren't listed\n"
      },
      {
        "real_name": "final_typedef",
        "display_name": "FinalTypedef",
        "severity": "warning",
        "category": "convention",
        "rule_title": "final typedef",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "final typedef"
      },
      {
        "real_name": "for_in_of_invalid_element_type",
        "display_name": "ForInOfInvalidElementType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type '{0}' used in the 'for' loop must implement {1} with a type argument that can be assigned to '{2}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "17.6.2 For-in. It the iterable expression does not implement Iterable with\na type argument that can be assigned to the for-in variable's type, this\nwarning is reported.\n\nParameters:\n0: The type of the iterable expression.\n1: The sequence type -- Iterable for `for` or Stream for `await for`.\n2: The loop variable type.\n"
      },
      {
        "real_name": "for_in_of_invalid_type",
        "display_name": "ForInOfInvalidType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type '{0}' used in the 'for' loop must implement {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: The type of the iterable expression.\n1: The sequence type -- Iterable for `for` or Stream for `await for`.\n#### Description\n\nThe analyzer produces this diagnostic when the expression following `in` in\na for-in loop has a type that isn't a subclass of `Iterable`.\n\n#### Examples\n\nThe following code produces this diagnostic because `m` is a `Map`, and\n`Map` isn't a subclass of `Iterable`:\n\n```dart\nvoid f(Map<String, String> m) {\nfor (String s in [!m!]) {\nprint(s);\n}\n}\n```\n\n#### Common fixes\n\nReplace the expression with one that produces an iterable value:\n\n```dart\nvoid f(Map<String, String> m) {\nfor (String s in m.values) {\nprint(s);\n}\n}\n```"
      },
      {
        "real_name": "for_in_with_const_variable",
        "display_name": "ForInWithConstVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "for in with const variable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "for in with const variable"
      },
      {
        "real_name": "function_typed_parameter_var",
        "display_name": "FunctionTypedParameterVar",
        "severity": "warning",
        "category": "convention",
        "rule_title": "function typed parameter var",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "function typed parameter var"
      },
      {
        "real_name": "generic_function_type_cannot_be_bound",
        "display_name": "GenericFunctionTypeCannotBeBound",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Generic function types can't be used as type parameter bounds",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try making the free variable in the function type part of the larger declaration signature",
        "owner": null,
        "labels": [],
        "description": "It is a compile-time error if a generic function type is used as a bound\nfor a formal type parameter of a class or a function.\n"
      },
      {
        "real_name": "generic_function_type_cannot_be_type_argument",
        "display_name": "GenericFunctionTypeCannotBeTypeArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A generic function type can't be a type argument.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing type parameters from the generic function typ",
        "owner": null,
        "labels": [],
        "description": "It is a compile-time error if a generic function type is used as an actual\ntype argument.\n"
      },
      {
        "real_name": "generic_struct_subclass",
        "display_name": "GenericStructSubclass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try removing the type parameters from '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the type parameters from '{0}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the struct class\n"
      },
      {
        "real_name": "getter_constructor",
        "display_name": "GetterConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "getter constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "getter constructor"
      },
      {
        "real_name": "getter_in_function",
        "display_name": "GetterInFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "getter in function",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "getter in function"
      },
      {
        "real_name": "getter_not_assignable_setter_types",
        "display_name": "GetterNotAssignableSetterTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type of getter '{0}' is '{1}' which isn't assignable to the type '{2}' of its setter '{3}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the types so that they are compatible.",
        "owner": null,
        "labels": [],
        "description": "10.3 Setters: It is a compile-time error if a class has a setter named\n`v=` with argument type `T` and a getter named `v` with return type `S`,\nand `S` may not be assigned to `T`.\n\nParameters:\n0: the name of the getter\n1: the type of the getter\n2: the type of the setter\n3: the name of the setter\n"
      },
      {
        "real_name": "getter_not_subtype_setter_types",
        "display_name": "GetterNotSubtypeSetterTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type of getter '{0}' is '{1}' which isn't a subtype of the type '{2}' of its setter '{3}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the types so that they are compatible.",
        "owner": null,
        "labels": [],
        "description": "nnbd/feature-specification.md\n\nIt is an error if a class has a setter and a getter with the same basename\nwhere the return type of the getter is not a subtype of the argument type\nof the setter. Note that this error specifically requires subtyping and\nnot assignability and hence makes no exception for `dynamic`.\n\nParameters:\n0: the name of the getter\n1: the type of the getter\n2: the type of the setter\n3: the name of the setter\n"
      },
      {
        "real_name": "getter_with_parameters",
        "display_name": "GetterWithParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "getter with parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "getter with parameters"
      },
      {
        "real_name": "if_element_condition_from_deferred_library",
        "display_name": "IfElementConditionFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "if element condition from deferred library",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "if element condition from deferred library"
      },
      {
        "real_name": "illegal_assignment_to_non_assignable",
        "display_name": "IllegalAssignmentToNonAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "illegal assignment to non assignable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "illegal assignment to non assignable"
      },
      {
        "real_name": "illegal_async_generator_return_type",
        "display_name": "IllegalAsyncGeneratorReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Functions marked 'async*' must have a return type assignable to 'Stream'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try fixing the return type of the functio",
        "owner": null,
        "labels": [],
        "description": "9 Functions: It is a static warning if the declared return type of a\nfunction marked async* may not be assigned to Stream.\n"
      },
      {
        "real_name": "illegal_async_return_type",
        "display_name": "IllegalAsyncReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Functions marked 'async' must have a return type assignable to 'Future'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try fixing the return type of the functio",
        "owner": null,
        "labels": [],
        "description": "9 Functions: It is a static warning if the declared return type of a\nfunction marked async may not be assigned to Future.\n"
      },
      {
        "real_name": "illegal_character",
        "display_name": "IllegalCharacter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "illegal character",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "illegal character"
      },
      {
        "real_name": "illegal_sync_generator_return_type",
        "display_name": "IllegalSyncGeneratorReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Functions marked 'sync*' must have a return type assignable to 'Iterable'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try fixing the return type of the functio",
        "owner": null,
        "labels": [],
        "description": "9 Functions: It is a static warning if the declared return type of a\nfunction marked sync* may not be assigned to Iterable.\n"
      },
      {
        "real_name": "implements_before_extends",
        "display_name": "ImplementsBeforeExtends",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implements before extends",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implements before extends"
      },
      {
        "real_name": "implements_before_on",
        "display_name": "ImplementsBeforeOn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implements before on",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implements before on"
      },
      {
        "real_name": "implements_before_with",
        "display_name": "ImplementsBeforeWith",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implements before with",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implements before with"
      },
      {
        "real_name": "implements_deferred_class",
        "display_name": "ImplementsDeferredClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes and mixins can't implement deferred classes.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a different interfac",
        "owner": null,
        "labels": [],
        "description": "7.10 Superinterfaces: It is a compile-time error if the implements clause\nof a class <i>C</i> specifies a malformed type or deferred type as a\nsuperinterface.\n\nSee [EXTENDS_DEFERRED_CLASS], and [MIXIN_DEFERRED_CLASS].\n"
      },
      {
        "real_name": "implements_disallowed_class",
        "display_name": "ImplementsDisallowedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes and mixins can't implement '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a different interfac",
        "owner": null,
        "labels": [],
        "description": "12.2 Null: It is a compile-time error for a class to attempt to extend or\nimplement Null.\n\n12.3 Numbers: It is a compile-time error for a class to attempt to extend\nor implement int.\n\n12.3 Numbers: It is a compile-time error for a class to attempt to extend\nor implement double.\n\n12.3 Numbers: It is a compile-time error for any type other than the types\nint and double to\nattempt to extend or implement num.\n\n12.4 Booleans: It is a compile-time error for a class to attempt to extend\nor implement bool.\n\n12.5 Strings: It is a compile-time error for a class to attempt to extend\nor implement String.\n\nParameters:\n0: the name of the type that cannot be implemented\n\nSee [EXTENDS_DISALLOWED_CLASS].\n"
      },
      {
        "real_name": "implements_non_class",
        "display_name": "ImplementsNonClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes and mixins can only implement other classes and mixins.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying a class or mixi",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the interface that was not found\n#### Description\n\nThe analyzer produces this diagnostic when a name used in the implements\nclause of a class or mixin declaration is defined to be something other\nthan a class or mixin.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is a variable\nrather than a class or mixin:\n\n```dart\nvar x;\nclass C implements [!x!] {}\n```\n\n#### Common fixes\n\nIf the name is the name of an existing class or mixin that's already being\nimported, then add a prefix to the import so that the local definition of\nthe name doesn't shadow the imported name.\n\nIf the name is the name of an existing class or mixin that isn't being\nimported, then add an import, with a prefix, for the library in which it’s\ndeclared.\n\nOtherwise, either replace the name in the implements clause with the name\nof an existing class or mixin, or remove the name from the implements\nclause."
      },
      {
        "real_name": "implements_repeated",
        "display_name": "ImplementsRepeated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can only be implemented once.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one occurrence of the class name.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the interface that is implemented more than once\n#### Description\n\nThe analyzer produces this diagnostic when a single class is specified more\nthan once in an implements clause.\n\n#### Examples\n\nThe following code produces this diagnostic because `A` is in the list\ntwice:\n\n```dart\nclass A {}\nclass B implements A, [!A!] {}\n```\n\n#### Common fixes\n\nRemove all except one occurrence of the class name:\n\n```dart\nclass A {}\nclass B implements A {}\n```"
      },
      {
        "real_name": "implements_super_class",
        "display_name": "ImplementsSuperClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used in both 'extends' and 'implements' clauses.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing one of the occurrences.",
        "owner": null,
        "labels": [],
        "description": "7.10 Superinterfaces: It is a compile-time error if the superclass of a\nclass <i>C</i> appears in the implements clause of <i>C</i>.\n\nParameters:\n0: the name of the class that appears in both \"extends\" and \"implements\"\nclauses\n"
      },
      {
        "real_name": "implicit_dynamic_field",
        "display_name": "ImplicitDynamicField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic field",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic field"
      },
      {
        "real_name": "implicit_dynamic_function",
        "display_name": "ImplicitDynamicFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic function",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic function"
      },
      {
        "real_name": "implicit_dynamic_invoke",
        "display_name": "ImplicitDynamicInvoke",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic invoke",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic invoke"
      },
      {
        "real_name": "implicit_dynamic_list_literal",
        "display_name": "ImplicitDynamicListLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic list literal",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic list literal"
      },
      {
        "real_name": "implicit_dynamic_map_literal",
        "display_name": "ImplicitDynamicMapLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic map literal",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic map literal"
      },
      {
        "real_name": "implicit_dynamic_method",
        "display_name": "ImplicitDynamicMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic method",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic method"
      },
      {
        "real_name": "implicit_dynamic_parameter",
        "display_name": "ImplicitDynamicParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic parameter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic parameter"
      },
      {
        "real_name": "implicit_dynamic_return",
        "display_name": "ImplicitDynamicReturn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic return",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic return"
      },
      {
        "real_name": "implicit_dynamic_type",
        "display_name": "ImplicitDynamicType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic type"
      },
      {
        "real_name": "implicit_dynamic_variable",
        "display_name": "ImplicitDynamicVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implicit dynamic variable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "implicit dynamic variable"
      },
      {
        "real_name": "implicit_this_reference_in_initializer",
        "display_name": "ImplicitThisReferenceInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Only static members can be accessed in initializers.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when it finds a reference to an\ninstance member in a constructor's initializer list.\n\n#### Examples\n\nThe following code produces this diagnostic because `defaultX` is an\ninstance member:\n\n```dart\nclass C {\nint x;\n\nC() : x = [!defaultX!];\n\nint get defaultX => 0;\n}\n```\n\n#### Common fixes\n\nIf the member can be made static, then do so:\n\n```dart\nclass C {\nint x;\n\nC() : x = defaultX;\n\nstatic int get defaultX => 0;\n}\n```\n\nIf not, then replace the reference in the initializer with a different\nexpression that doesn't use an instance member:\n\n```dart\nclass C {\nint x;\n\nC() : x = 0;\n\nint get defaultX => 0;\n}\n```"
      },
      {
        "real_name": "import_deferred_library_with_load_function",
        "display_name": "ImportDeferredLibraryWithLoadFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The library '{0}' defines a top-level function named 'loadLibrary' which is hidden by deferring this library.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the import to not be deferre",
        "owner": null,
        "labels": [],
        "description": "Deferred libraries shouldn't define a top level function 'loadLibrary'.\n"
      },
      {
        "real_name": "import_directive_after_part_directive",
        "display_name": "ImportDirectiveAfterPartDirective",
        "severity": "warning",
        "category": "convention",
        "rule_title": "import directive after part directive",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "import directive after part directive"
      },
      {
        "real_name": "import_duplicated_library_named",
        "display_name": "ImportDuplicatedLibraryNamed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The imported libraries '{0}' and '{1}' can't have the same name '{2}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding a hide clause to one of the imports.",
        "owner": null,
        "labels": [],
        "description": "14.1 Imports: It is a static warning to import two different libraries with\nthe same name.\n\nParameters:\n0: the uri pointing to a first library\n1: the uri pointing to a second library\n2: the shared name of the imported libraries\n"
      },
      {
        "real_name": "import_internal_library",
        "display_name": "ImportInternalLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The library '{0}' is internal and can't be imported.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "SDK implementation libraries can be imported only by other SDK libraries.\n\nParameters:\n0: the uri pointing to a library\n"
      },
      {
        "real_name": "import_of_non_library",
        "display_name": "ImportOfNonLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The imported library '{0}' can't have a part-of directive.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try importing the library that the part is a part of.",
        "owner": null,
        "labels": [],
        "description": "14.1 Imports: It is a compile-time error if the specified URI of an\nimmediate import does not refer to a library declaration.\n\nParameters:\n0: the uri pointing to a non-library declaration\n"
      },
      {
        "real_name": "include_file_not_found",
        "display_name": "IncludeFileNotFound",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The include file {0} in {1} cannot be found.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating a specified include file could not be found.\n\nParameters:\n0: the uri of the file to be included\n1: the path of the file containing the include directive\n"
      },
      {
        "real_name": "included_file_parse_error",
        "display_name": "IncludedFileParseError",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{3} in {0}{1}..{2})'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that there is a syntactic error in the included\nfile.\n\nParameters:\n0: the path of the file containing the error\n1: the starting offset of the text in the file that contains the error\n2: the ending offset of the text in the file that contains the error\n3: the error message\n"
      },
      {
        "real_name": "included_file_warning",
        "display_name": "IncludedFileWarning",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Warning in the included options file {0}{1}..{2}): {3}",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating a specified include file has a warning.\n\nParameters:\n0: the path of the file containing the warnings\n1: the starting offset of the text in the file that contains the warning\n2: the ending offset of the text in the file that contains the warning\n3: the warning message\n"
      },
      {
        "real_name": "inconsistent_case_expression_types",
        "display_name": "InconsistentCaseExpressionTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Case expressions must have the same types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "13.9 Switch: It is a compile-time error if values of the expressions\n<i>e<sub>k</sub></i> are not instances of the same class <i>C</i>, for all\n<i>1 &lt;= k &lt;= n</i>.\n\nParameters:\n0: the expression source code that is the unexpected type\n1: the name of the expected type\n"
      },
      {
        "real_name": "inconsistent_inheritance",
        "display_name": "InconsistentInheritance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Superinterfaces don't have a valid override for '{0}': {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an explicit override that is consistent with all of the inherited members.",
        "owner": null,
        "labels": [],
        "description": "If a class declaration does not have a member declaration with a\nparticular name, but some super-interfaces do have a member with that\nname, it's a compile-time error if there is no signature among the\nsuper-interfaces that is a valid override of all the other super-interface\nsignatures with the same name. That \"most specific\" signature becomes the\nsignature of the class's interface.\n\nParameters:\n0: the name of the instance member with inconsistent inheritance.\n1: the list of all inherited signatures for this member.\n"
      },
      {
        "real_name": "inconsistent_inheritance_getter_and_method",
        "display_name": "InconsistentInheritanceGetterAndMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is inherited as a getter from '{1}') and also a method from '{2}').",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adjusting the supertypes of this class to remove the inconsistency.",
        "owner": null,
        "labels": [],
        "description": "11.1.1 Inheritance and Overriding. Let `I` be the implicit interface of a\nclass `C` declared in library `L`. `I` inherits all members of\n`inherited(I, L)` and `I` overrides `m'` if `m' ∈ overrides(I, L)`. It is\na compile-time error if `m` is a method and `m'` is a getter, or if `m`\nis a getter and `m'` is a method.\n\nParameters:\n0: the name of the the instance member with inconsistent inheritance.\n1: the name of the superinterface that declares the name as a getter.\n2: the name of the superinterface that declares the name as a method.\n"
      },
      {
        "real_name": "inference_failure_on_collection_literal",
        "display_name": "InferenceFailureOnCollectionLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type arguments) of '{0}' can't be inferred.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Use explicit type arguments) for '{0}'.",
        "owner": null,
        "labels": [],
        "description": "When \"strict-inference\" is enabled, collection literal types must be\ninferred via the context type, or have type arguments.\n"
      },
      {
        "real_name": "inference_failure_on_function_return_type",
        "display_name": "InferenceFailureOnFunctionReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type of '{0}' cannot be inferred.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Declare the return type of '{0}'.",
        "owner": null,
        "labels": [],
        "description": "When \"strict-inference\" is enabled, recursive local functions, top-level\nfunctions, methods, and function-typed function parameters must all\nspecify a return type. See the strict-inference resource:\n\nhttps://github.com/dart-lang/language/blob/master/resources/type-system/strict-inference.md\n"
      },
      {
        "real_name": "inference_failure_on_instance_creation",
        "display_name": "InferenceFailureOnInstanceCreation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type arguments) of '{0}' can't be inferred.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Use explicit type arguments) for '{0}'.",
        "owner": null,
        "labels": [],
        "description": "When \"strict-inference\" is enabled, types in instance creation\n(constructor calls) must be inferred via the context type, or have type\narguments.\n"
      },
      {
        "real_name": "inference_failure_on_uninitialized_variable",
        "display_name": "InferenceFailureOnUninitializedVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type of {0} can't be inferred without either a type or initializer.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying the type of the variable.",
        "owner": null,
        "labels": [],
        "description": "When \"strict-inference\" in enabled, uninitialized variables must be\ndeclared with a specific type.\n"
      },
      {
        "real_name": "inference_failure_on_untyped_parameter",
        "display_name": "InferenceFailureOnUntypedParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type of {0} can't be inferred; a type must be explicitly provided.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying the type of the parameter.",
        "owner": null,
        "labels": [],
        "description": "When \"strict-inference\" in enabled, function parameters must be\ndeclared with a specific type, or inherit a type.\n"
      },
      {
        "real_name": "initialized_variable_in_for_each",
        "display_name": "InitializedVariableInForEach",
        "severity": "warning",
        "category": "convention",
        "rule_title": "initialized variable in for each",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "initialized variable in for each"
      },
      {
        "real_name": "initializer_for_non_existent_field",
        "display_name": "InitializerForNonExistentField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' isn't a field in the enclosing class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing fiel",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the initializing formal that is not an instance variable in\nthe immediately enclosing class\n#### Description\n\nThe analyzer produces this diagnostic when a constructor initializes a\nfield that isn't declared in the class containing the constructor.\nConstructors can't initialize fields that aren't declared and fields that\nare inherited from superclasses.\n\n#### Examples\n\nThe following code produces this diagnostic because the initializer is\ninitializing `x`, but `x` isn't a field in the class:\n\n```dart\nclass C {\nint y;\n\nC() : [!x = 0!];\n}\n```\n\n#### Common fixes\n\nIf a different field should be initialized, then change the name to the\nname of the field:\n\n```dart\nclass C {\nint y;\n\nC() : y = 0;\n}\n```\n\nIf the field must be declared, then add a declaration:\n\n```dart\nclass C {\nint x;\nint y;\n\nC() : x = 0;\n}\n```"
      },
      {
        "real_name": "initializer_for_static_field",
        "display_name": "InitializerForStaticField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is a static field in the enclosing class. Fields initialized in a constructor can't be static.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the initialization.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Let <i>k</i> be a generative constructor. It\nis a compile-time error if <i>k</i>'s initializer list contains an\ninitializer for a variable that is not an instance variable declared in the\nimmediately surrounding class.\n\nParameters:\n0: the name of the initializing formal that is a static variable in the\nimmediately enclosing class\n\nSee [INITIALIZING_FORMAL_FOR_STATIC_FIELD].\n"
      },
      {
        "real_name": "initializing_formal_for_non_existent_field",
        "display_name": "InitializingFormalForNonExistentField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' isn't a field in the enclosing class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing fiel",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the initializing formal that is not an instance variable in\nthe immediately enclosing class\n#### Description\n\nThe analyzer produces this diagnostic when a field formal parameter is\nfound in a constructor in a class that doesn't declare the field being\ninitialized. Constructors can't initialize fields that aren't declared and\nfields that are inherited from superclasses.\n\n#### Examples\n\nThe following code produces this diagnostic because the field `x` isn't\ndefined:\n\n```dart\nclass C {\nint y;\n\nC([!this.x!]);\n}\n```\n\n#### Common fixes\n\nIf the field name was wrong, then change it to the name of an existing\nfield:\n\n```dart\nclass C {\nint y;\n\nC(this.y);\n}\n```\n\nIf the field name is correct but hasn't yet been defined, then declare the\nfield:\n\n```dart\nclass C {\nint x;\nint y;\n\nC(this.x);\n}\n```\n\nIf the parameter is needed but shouldn't initialize a field, then convert\nit to a normal parameter and use it:\n\n```dart\nclass C {\nint y;\n\nC(int x) : y = x * 2;\n}\n```\n\nIf the parameter isn't needed, then remove it:\n\n```dart\nclass C {\nint y;\n\nC();\n}\n```"
      },
      {
        "real_name": "initializing_formal_for_static_field",
        "display_name": "InitializingFormalForStaticField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is a static field in the enclosing class. Fields initialized in a constructor can't be static.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the initialization.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: An initializing formal has the form\n<i>this.id</i>. It is a compile-time error if <i>id</i> is not the name of\nan instance variable of the immediately enclosing class.\n\nParameters:\n0: the name of the initializing formal that is a static variable in the\nimmediately enclosing class\n\nSee [INITIALIZER_FOR_STATIC_FIELD].\n"
      },
      {
        "real_name": "instance_access_to_static_member",
        "display_name": "InstanceAccessToStaticMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Static {1} '{0}' can't be accessed through an instance.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using the class '{2}' to access the {1}.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the static member\n1: the kind of the static member (field, getter, setter, or method)\n2: the name of the defining class\n#### Description\n\nThe analyzer produces this diagnostic when an access operator is used to\naccess a static member through an instance of the class.\n\n#### Examples\n\nThe following code produces this diagnostic because `zero` is a static\nfield, but it’s being accessed as if it were an instance field:\n\n```dart\nvoid f(C c) {\nc.[!zero!];\n}\n\nclass C {\nstatic int zero = 0;\n}\n```\n\n#### Common fixes\n\nUse the class to access the static member:\n\n```dart\nvoid f(C c) {\nC.zero;\n}\n\nclass C {\nstatic int zero = 0;\n}\n```"
      },
      {
        "real_name": "instance_member_access_from_factory",
        "display_name": "InstanceMemberAccessFromFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Instance members can't be accessed from a factory constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the reference to the instance member.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a factory constructor contains\nan unqualified reference to an instance member. In a generative\nconstructor, the instance of the class is created and initialized before\nthe body of the constructor is executed, so the instance can be bound to\n`this` and accessed just like it would be in an instance method. But, in a\nfactory constructor, the instance isn't created before executing the body,\nso `this` can't be used to reference it.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` isn't in scope in\nthe factory constructor:\n\n```dart\nclass C {\nint x;\nfactory C() {\nreturn C._([!x!]);\n}\nC._(this.x);\n}\n```\n\n#### Common fixes\n\nRewrite the code so that it doesn't reference the instance member:\n\n```dart\nclass C {\nint x;\nfactory C() {\nreturn C._(0);\n}\nC._(this.x);\n}\n```"
      },
      {
        "real_name": "instance_member_access_from_static",
        "display_name": "InstanceMemberAccessFromStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Instance members can't be accessed from a static method.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the reference to the instance membe",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a static method contains an\nunqualified reference to an instance member.\n\n#### Examples\n\nThe following code produces this diagnostic because the instance field `x`\nis being referenced in a static method:\n\n```dart\nclass C {\nint x;\n\nstatic int m() {\nreturn [!x!];\n}\n}\n```\n\n#### Common fixes\n\nIf the method must reference the instance member, then it can't be static,\nso remove the keyword:\n\n```dart\nclass C {\nint x;\n\nint m() {\nreturn x;\n}\n}\n```\n\nIf the method can't be made an instance method, then add a parameter so\nthat an instance of the class can be passed in:\n\n```dart\nclass C {\nint x;\n\nstatic int m(C c) {\nreturn c.x;\n}\n}\n```"
      },
      {
        "real_name": "instantiate_abstract_class",
        "display_name": "InstantiateAbstractClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Abstract classes can't be instantiated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try creating an instance of a concrete subtype.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when it finds a constructor\ninvocation and the constructor is declared in an abstract class. Even\nthough you can't create an instance of an abstract class, abstract classes\ncan declare constructors that can be invoked by subclasses.\n\n#### Examples\n\nThe following code produces this diagnostic because `C` is an abstract\nclass:\n\n```dart\nabstract class C {}\n\nvar c = new [!C!]();\n```\n\n#### Common fixes\n\nIf there's a concrete subclass of the abstract class that can be used, then\ncreate an instance of the concrete subclass."
      },
      {
        "real_name": "instantiate_enum",
        "display_name": "InstantiateEnum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Enums can't be instantiated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using one of the defined constants.",
        "owner": null,
        "labels": [],
        "description": "Enum proposal: It is also a compile-time error to explicitly instantiate an\nenum via 'new' or 'const' or to access its private fields.\n"
      },
      {
        "real_name": "integer_literal_imprecise_as_double",
        "display_name": "IntegerLiteralImpreciseAsDouble",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The integer literal is being used as a double",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using the BigInt clas",
        "owner": null,
        "labels": [],
        "description": "An integer literal with static type `double` and numeric value `i`\nevaluates to an instance of the `double` class representing the value `i`.\nIt is a compile-time error if the value `i` cannot be represented\n_precisely_ by the an instace of `double`.\n"
      },
      {
        "real_name": "integer_literal_out_of_range",
        "display_name": "IntegerLiteralOutOfRange",
        "severity": "warning",
        "category": "convention",
        "rule_title": "integer literal out of range",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "integer literal out of range"
      },
      {
        "real_name": "invalid_annotation",
        "display_name": "InvalidAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Annotation must be either a const variable reference or const constructor invocation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "15 Metadata: Metadata consists of a series of annotations, each of which\nbegin with the character @, followed by a constant expression that must be\neither a reference to a compile-time constant variable, or a call to a\nconstant constructor.\n"
      },
      {
        "real_name": "invalid_annotation_from_deferred_library",
        "display_name": "InvalidAnnotationFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used as annotations.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the annotatio",
        "owner": null,
        "labels": [],
        "description": "15 Metadata: Metadata consists of a series of annotations, each of which\nbegin with the character @, followed by a constant expression that must be\neither a reference to a compile-time constant variable, or a call to a\nconstant constructor.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "invalid_annotation_getter",
        "display_name": "InvalidAnnotationGetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Getters can't be used as annotations.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a top-level variable or a field.",
        "owner": null,
        "labels": [],
        "description": "15 Metadata: Metadata consists of a series of annotations, each of which\nbegin with the character @, followed by a constant expression that must be\neither a reference to a compile-time constant variable, or a call to a\nconstant constructor.\n"
      },
      {
        "real_name": "invalid_assignment",
        "display_name": "InvalidAssignment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A value of type '{0}' can't be assigned to a variable of type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the type of the variabl",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the right hand side type\n1: the name of the left hand side type\n#### Description\n\nThe analyzer produces this diagnostic when the static type of an expression\nthat is assigned to a variable isn't assignable to the type of the\nvariable.\n\n#### Examples\n\nThe following code produces this diagnostic because the type of the\ninitializer (`int`) isn't assignable to the type of the variable\n(`String`):\n\n```dart\nint i = 0;\nString s = [!i!];\n```\n\n#### Common fixes\n\nIf the value being assigned is always assignable at runtime, even though\nthe static types don't reflect that, then add an explicit cast.\n\nOtherwise, change the value being assigned so that it has the expected\ntype. In the previous example, this might look like:\n\n```dart\nint i = 0;\nString s = i.toString();\n```\n\nIf you can’t change the value, then change the type of the variable to be\ncompatible with the type of the value being assigned:\n\n```dart\nint i = 0;\nint s = i;\n```"
      },
      {
        "real_name": "invalid_await_in_for",
        "display_name": "InvalidAwaitInFor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid await in for",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid await in for"
      },
      {
        "real_name": "invalid_cast_function",
        "display_name": "InvalidCastFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast function",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast function"
      },
      {
        "real_name": "invalid_cast_function_expr",
        "display_name": "InvalidCastFunctionExpr",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast function expr",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast function expr"
      },
      {
        "real_name": "invalid_cast_literal",
        "display_name": "InvalidCastLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast literal",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast literal"
      },
      {
        "real_name": "invalid_cast_literal_list",
        "display_name": "InvalidCastLiteralList",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast literal list",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast literal list"
      },
      {
        "real_name": "invalid_cast_literal_map",
        "display_name": "InvalidCastLiteralMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast literal map",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast literal map"
      },
      {
        "real_name": "invalid_cast_literal_set",
        "display_name": "InvalidCastLiteralSet",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast literal set",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast literal set"
      },
      {
        "real_name": "invalid_cast_method",
        "display_name": "InvalidCastMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast method",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast method"
      },
      {
        "real_name": "invalid_cast_new_expr",
        "display_name": "InvalidCastNewExpr",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid cast new expr",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid cast new expr"
      },
      {
        "real_name": "invalid_code_point",
        "display_name": "InvalidCodePoint",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The escape sequence '{0}' isn't a valid code point.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the invalid escape sequence\n"
      },
      {
        "real_name": "invalid_comment_reference",
        "display_name": "InvalidCommentReference",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid comment reference",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid comment reference"
      },
      {
        "real_name": "invalid_constant",
        "display_name": "InvalidConstant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid constant value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "TODO(brianwilkerson) Remove this when we have decided on how to report\nerrors in compile-time constants. Until then, this acts as a placeholder\nfor more informative errors.\n\nSee TODOs in ConstantVisitor\n"
      },
      {
        "real_name": "invalid_constructor_name",
        "display_name": "InvalidConstructorName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid constructor name.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6 Constructors: It is a compile-time error if the name of a constructor\nis not a constructor name.\n"
      },
      {
        "real_name": "invalid_exception_value",
        "display_name": "InvalidExceptionValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try removing the exceptional return value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the exceptional return value.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "invalid_extension_argument_count",
        "display_name": "InvalidExtensionArgumentCount",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extension overrides must have exactly one argument: the value of 'this' in the extension method.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try specifying exactly one argument.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an extension override doesn't\nhave exactly one argument. The argument is the expression used to compute\nthe value of `this` within the extension method, so there must be one\nargument.\n\n#### Examples\n\nThe following code produces this diagnostic because there are no arguments:\n\n```dart\nextension E on String {\nString join(String other) => '$this $other';\n}\n\nvoid f() {\nE[!()!].join('b');\n}\n```\n\nAnd, the following code produces this diagnostic because there's more than\none argument:\n\n```dart\nextension E on String {\nString join(String other) => '$this $other';\n}\n\nvoid f() {\nE[!('a', 'b')!].join('c');\n}\n```\n\n#### Common fixes\n\nProvide one argument for the extension override:\n\n```dart\nextension E on String {\nString join(String other) => '$this $other';\n}\n\nvoid f() {\nE('a').join('b');\n}\n```"
      },
      {
        "real_name": "invalid_factory_annotation",
        "display_name": "InvalidFactoryAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Only methods can be annotated as factories.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere a @factory annotation is associated with\nanything other than a method.\n"
      },
      {
        "real_name": "invalid_factory_method_decl",
        "display_name": "InvalidFactoryMethodDecl",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Factory method '{0}' must have a return type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere a @factory annotation is associated with\na method that does not declare a return type.\n"
      },
      {
        "real_name": "invalid_factory_method_impl",
        "display_name": "InvalidFactoryMethodImpl",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Factory method '{0}' doesn't return a newly allocated object.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere a @factory annotation is associated with\na non-abstract method that can return anything other than a newly allocated\nobject.\n\nParameters:\n0: the name of the method\n"
      },
      {
        "real_name": "invalid_factory_name_not_a_class",
        "display_name": "InvalidFactoryNameNotAClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name of a factory constructor must be the same as the name of the immediately enclosing class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the name of a factory\nconstructor isn't the same as the name of the surrounding class.\n\n#### Examples\n\nThe following code produces this diagnostic because the name of the factory\nconstructor (`A`) isn't the same as the surrounding class (`C`):\n\n```dart\nclass A {}\n\nclass C {\nfactory [!A!]() => throw 0;\n}\n```\n\n#### Common fixes\n\nIf the factory returns an instance of the surrounding class, then rename\nthe factory:\n\n```dart\nclass A {}\n\nclass C {\nfactory C() => throw 0;\n}\n```\n\nIf the factory returns an instance of a different class, then move the\nfactory to that class:\n\n```dart\nclass A {\nfactory A() => throw 0;\n}\n\nclass C {}\n```\n\nIf the factory returns an instance of a different class, but you can't\nmodify that class or don't want to move the factory, then convert it to be\na static method:\n\n```dart\nclass A {}\n\nclass C {\nstatic A a() => throw 0;\n}\n```"
      },
      {
        "real_name": "invalid_field_type_in_struct",
        "display_name": "InvalidFieldTypeInStruct",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'double' or 'Pointer'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using 'int",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the field\n"
      },
      {
        "real_name": "invalid_generic_function_type",
        "display_name": "InvalidGenericFunctionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid generic function type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid generic function type"
      },
      {
        "real_name": "invalid_hex_escape",
        "display_name": "InvalidHexEscape",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid hex escape",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid hex escape"
      },
      {
        "real_name": "invalid_immutable_annotation",
        "display_name": "InvalidImmutableAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Only classes can be annotated as being immutable.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere an @immutable annotation is associated with\nanything other than a class.\n"
      },
      {
        "real_name": "invalid_initializer",
        "display_name": "InvalidInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid initializer"
      },
      {
        "real_name": "invalid_inline_function_type",
        "display_name": "InvalidInlineFunctionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid inline function type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid inline function type"
      },
      {
        "real_name": "invalid_language_version_override_at_sign",
        "display_name": "InvalidLanguageVersionOverrideAtSign",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Dart language version override number must begin with '@dart'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_language_version_override_equals",
        "display_name": "InvalidLanguageVersionOverrideEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Dart language version override comment must be specified with an '=' character",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_language_version_override_location",
        "display_name": "InvalidLanguageVersionOverrideLocation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid language version override location",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid language version override location"
      },
      {
        "real_name": "invalid_language_version_override_lower_case",
        "display_name": "InvalidLanguageVersionOverrideLowerCase",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Dart language version override comment must be specified with the word 'dart' in all lower case",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_language_version_override_number",
        "display_name": "InvalidLanguageVersionOverrideNumber",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Dart language version override comment must be specified with a version number",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_language_version_override_prefix",
        "display_name": "InvalidLanguageVersionOverridePrefix",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Dart language version override number can't be prefixed with a letter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_language_version_override_trailing_characters",
        "display_name": "InvalidLanguageVersionOverrideTrailingCharacters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The Dart language version override comment can't be followed by any non-whitespace characters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_language_version_override_two_slashes",
        "display_name": "InvalidLanguageVersionOverrideTwoSlashes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'The Dart language version override comment must be specified with ' 'exactly two slashes.'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Specify a Dart language version override with a comment like '// @dart = 2.0'.",
        "owner": null,
        "labels": [],
        "description": "\n/ Invalid Dart language version comments don't follow the specification [1].\n/ If a comment begins with \"@dart\" or \"dart\" (letters in any case),\n/ followed by optional whitespace, followed by optional non-alphanumeric,\n/ non-whitespace characters, followed by optional whitespace, followed by\n/ an optional alphabetical character, followed by a digit, then the\n/ comment is considered to be an attempt at a language version override\n/ comment. If this attempted language version override comment is not a\n/ valid language version override comment, it is reported.\n/\n/ [1] https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override"
      },
      {
        "real_name": "invalid_literal_annotation",
        "display_name": "InvalidLiteralAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Only const constructors can have the `@literal` annotation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the `@literal` annotation is\napplied to anything other than a const constructor.\n\n#### Examples\n\nThe following code produces this diagnostic because the constructor is not\na `const` constructor:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n[!@literal!]\nC();\n}\n```\n\nThe following code produces this diagnostic because `x` isn't a\nconstructor:\n\n```dart\nimport 'package:meta/meta.dart';\n\n[!@literal!]\nvar x;\n```\n\n#### Common fixes\n\nIf the annotation is on a constructor and the constructor should always be\ninvoked with `const`, when possible, then mark the constructor with the\n`const` keyword:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n@literal\nconst C();\n}\n```\n\nIf the constructor can't be marked as `const`, then remove the annotation.\n\nIf the annotation is on anything other than a constructor, then remove the\nannotation:\n\n```dart\nvar x;\n```"
      },
      {
        "real_name": "invalid_literal_in_configuration",
        "display_name": "InvalidLiteralInConfiguration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid literal in configuration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid literal in configuration"
      },
      {
        "real_name": "invalid_modifier_on_constructor",
        "display_name": "InvalidModifierOnConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The modifier '{0}' can't be applied to the body of a constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the modifier.",
        "owner": null,
        "labels": [],
        "description": "9. Functions: It is a compile-time error if an async, async* or sync*\nmodifier is attached to the body of a setter or constructor.\n"
      },
      {
        "real_name": "invalid_modifier_on_setter",
        "display_name": "InvalidModifierOnSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The modifier '{0}' can't be applied to the body of a setter.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the modifier.",
        "owner": null,
        "labels": [],
        "description": "9. Functions: It is a compile-time error if an async, async* or sync*\nmodifier is attached to the body of a setter or constructor.\n"
      },
      {
        "real_name": "invalid_non_virtual_annotation",
        "display_name": "InvalidNonVirtualAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' can't be '@nonVirtual' because it isn't a concrete instance member.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing @nonVirtual.",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where `@nonVirtual` annotates something\nother than a non-abstract instance member in a class or mixin.\n\nParameters:\n0: the name of the member\n"
      },
      {
        "real_name": "invalid_null_aware_operator",
        "display_name": "InvalidNullAwareOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The target expression can't be null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replace the operator '{0}' with '{1}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: The null-aware operator that is invalid\n1: The non-null-aware operator that can replace the invalid operator\n"
      },
      {
        "real_name": "invalid_operator",
        "display_name": "InvalidOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator '{0}' can't be used with 'super'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the operator that is invalid\nParameters:\n0: the operator being applied to 'super'\n\nOnly generated by the old parser.\nReplaced by INVALID_OPERATOR_QUESTIONMARK_PERIOD_FOR_SUPER.\n"
      },
      {
        "real_name": "invalid_operator_for_super",
        "display_name": "InvalidOperatorForSuper",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid operator for super",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid operator for super"
      },
      {
        "real_name": "invalid_operator_questionmark_period_for_super",
        "display_name": "InvalidOperatorQuestionmarkPeriodForSuper",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid operator questionmark period for super",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid operator questionmark period for super"
      },
      {
        "real_name": "invalid_option",
        "display_name": "InvalidOption",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid option specified for '{0}': {1}",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that a plugin is being configured with an invalid\nvalue for an option and a detail message is provided.\n"
      },
      {
        "real_name": "invalid_override",
        "display_name": "InvalidOverride",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{1}.{0}' '{2}') isn't a valid override of '{3}.{0}' '{4}').",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the declared member that is not a valid override.\n1: the name of the interface that declares the member.\n2: the type of the declared member in the interface.\n3. the name of the interface with the overridden member.\n4. the type of the overridden member.\n#### Description\n\nThe analyzer produces this diagnostic when a member of a class is found\nthat overrides a member from a supertype and the override isn't valid. An\noverride is valid if all of these are true:\n* It allows all of the arguments allowed by the overridden member.\n* It doesn't require any arguments that aren't required by the overridden\nmember.\n* The type of every parameter of the overridden member is assignable to the\ncorresponding parameter of the override.\n* The return type of the override is assignable to the return type of the\noverridden member.\n\n#### Examples\n\nThe following code produces this diagnostic because the type of the\nparameter `s` (`String`) isn't assignable to the type of the parameter `i`\n(`int`):\n\n```dart\nclass A {\nvoid m(int i) {}\n}\n\nclass B extends A {\nvoid [!m!](String s) {}\n}\n```\n\n#### Common fixes\n\nIf the invalid method is intended to override the method from the\nsuperclass, then change it to conform:\n\n```dart\nclass A {\nvoid m(int i) {}\n}\n\nclass B extends A {\nvoid m(int i) {}\n}\n```\n\nIf it isn't intended to override the method from the superclass, then\nrename it:\n\n```dart\nclass A {\nvoid m(int i) {}\n}\n\nclass B extends A {\nvoid m2(String s) {}\n}\n```"
      },
      {
        "real_name": "invalid_override_different_default_values_named",
        "display_name": "InvalidOverrideDifferentDefaultValuesNamed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Parameters can't override default values",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using the same default value in both methods.",
        "owner": null,
        "labels": [],
        "description": "7.1 Instance Methods: It is a static warning if an instance method\n<i>m1</i> overrides an instance member <i>m2</i>, the signature of\n<i>m2</i> explicitly specifies a default value for a formal parameter\n<i>p</i> and the signature of <i>m1</i> specifies a different default value\nfor <i>p</i>.\n"
      },
      {
        "real_name": "invalid_override_different_default_values_positional",
        "display_name": "InvalidOverrideDifferentDefaultValuesPositional",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Parameters can't override default values",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using the same default value in both methods.",
        "owner": null,
        "labels": [],
        "description": "7.1 Instance Methods: It is a static warning if an instance method\n<i>m1</i> overrides an instance member <i>m2</i>, the signature of\n<i>m2</i> explicitly specifies a default value for a formal parameter\n<i>p</i> and the signature of <i>m1</i> specifies a different default value\nfor <i>p</i>.\n"
      },
      {
        "real_name": "invalid_override_of_non_virtual_member",
        "display_name": "InvalidOverrideOfNonVirtualMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' is declared non-virtual in '{1}' and can't be overridden in subclasses.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where an instance member annotated with\n`@nonVirtual` is overridden in a subclass.\n\nParameters:\n0: the name of the member\n1: the name of the defining class\n"
      },
      {
        "real_name": "invalid_parameter_declaration",
        "display_name": "InvalidParameterDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid parameter declaration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid parameter declaration"
      },
      {
        "real_name": "invalid_reference_to_this",
        "display_name": "InvalidReferenceToThis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid reference to 'this' expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when `this` is used outside of an\ninstance method or a generative constructor. The reserved word `this` is\nonly defined in the context of an instance method or a generative\nconstructor.\n\n#### Examples\n\nThe following code produces this diagnostic because `v` is a top-level\nvariable:\n\n```dart\nC f() => [!this!];\n\nclass C {}\n```\n\n#### Common fixes\n\nUse a variable of the appropriate type in place of `this`, declaring it if\nnecessary:\n\n```dart\nC f(C c) => c;\n\nclass C {}\n```"
      },
      {
        "real_name": "invalid_required_named_param",
        "display_name": "InvalidRequiredNamedParam",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type parameter '{0}' is annotated with @required but only named parameters without a default value can be annotated with it.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Remove @required.",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where `@required` annotates a named\nparameter with a default value.\n\nParameters:\n0: the name of the member\n"
      },
      {
        "real_name": "invalid_required_optional_positional_param",
        "display_name": "InvalidRequiredOptionalPositionalParam",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Incorrect use of the annotation @required on the optional positional parameter '{0}'. Optional positional parameters cannot be required.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Remove @required.",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where `@required` annotates an optional\npositional parameter.\n\nParameters:\n0: the name of the member\n"
      },
      {
        "real_name": "invalid_required_param",
        "display_name": "InvalidRequiredParam",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type parameter '{0}' is annotated with @required but only named parameters without default value can be annotated with it.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Remove @required.",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where `@required` annotates a non named\nparameter or a named parameter with default value.\n\nParameters:\n0: the name of the member\n\nDeprecated: Use the more specific [INVALID_REQUIRED_NAMED_PARAM],\n[INVALID_REQUIRED_OPTIONAL_POSITION_PARAM], and\n[INVALID_REQUIRED_POSITION_PARAM]\n"
      },
      {
        "real_name": "invalid_required_positional_param",
        "display_name": "InvalidRequiredPositionalParam",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Redundant use of the annotation @required on the required positional parameter '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Remove @required.",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where `@required` annotates a non optional\npositional parameter.\n\nParameters:\n0: the name of the member\n"
      },
      {
        "real_name": "invalid_sealed_annotation",
        "display_name": "InvalidSealedAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' is annotated with '@sealed' but only classes can be annotated with it.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Remove @sealed.",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where `@sealed` annotates something other\nthan a class.\n\nParameters:\n0: the name of the member\n"
      },
      {
        "real_name": "invalid_section_format",
        "display_name": "InvalidSectionFormat",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid format for the '{0}' section.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating an invalid format for an options file section.\n\nParameters:\n0: the section name\n"
      },
      {
        "real_name": "invalid_star_after_async",
        "display_name": "InvalidStarAfterAsync",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid star after async",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid star after async"
      },
      {
        "real_name": "invalid_super_in_initializer",
        "display_name": "InvalidSuperInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid super in initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid super in initializer"
      },
      {
        "real_name": "invalid_super_invocation",
        "display_name": "InvalidSuperInvocation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid super invocation",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid super invocation"
      },
      {
        "real_name": "invalid_sync",
        "display_name": "InvalidSync",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid sync",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid sync"
      },
      {
        "real_name": "invalid_this_in_initializer",
        "display_name": "InvalidThisInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid this in initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid this in initializer"
      },
      {
        "real_name": "invalid_type_argument_in_const_list",
        "display_name": "InvalidTypeArgumentInConstList",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant list literals can't include a type parameter as a type argument",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the type parameter with a different type.",
        "owner": null,
        "labels": [],
        "description": "12.6 Lists: It is a compile time error if the type argument of a constant\nlist literal includes a type parameter.\n\nParameters:\n0: the name of the type parameter\n"
      },
      {
        "real_name": "invalid_type_argument_in_const_map",
        "display_name": "InvalidTypeArgumentInConstMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant map literals can't include a type parameter as a type argument",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the type parameter with a different type.",
        "owner": null,
        "labels": [],
        "description": "12.7 Maps: It is a compile time error if the type arguments of a constant\nmap literal include a type parameter.\n\nParameters:\n0: the name of the type parameter\n"
      },
      {
        "real_name": "invalid_type_argument_in_const_set",
        "display_name": "InvalidTypeArgumentInConstSet",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid type argument in const set",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid type argument in const set"
      },
      {
        "real_name": "invalid_unicode_escape",
        "display_name": "InvalidUnicodeEscape",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invalid unicode escape",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "invalid unicode escape"
      },
      {
        "real_name": "invalid_uri",
        "display_name": "InvalidUri",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid URI syntax: '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the URI that is invalid\n#### Description\n\nThe analyzer produces this diagnostic when a URI in a directive doesn't\nconform to the syntax of a valid URI.\n\n#### Examples\n\nThe following code produces this diagnostic because `'#'` isn't a valid\nURI:\n\n```dart\nimport [!'#'!];\n```\n\n#### Common fixes\n\nReplace the invalid URI with a valid URI."
      },
      {
        "real_name": "invalid_use_of_covariant",
        "display_name": "InvalidUseOfCovariant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The 'covariant' keyword can only be used for parameters in instance methods or before non-final instance fields.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the 'covariant' keyword.",
        "owner": null,
        "labels": [],
        "description": "The 'covariant' keyword was found in an inappropriate location.\n"
      },
      {
        "real_name": "invalid_use_of_covariant_in_extension",
        "display_name": "InvalidUseOfCovariantInExtension",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Local function declarations can't specify any modifiers.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the modifier.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a member declared inside an\nextension uses the keyword `covariant` in the declaration of a parameter.\nExtensions aren't classes and don't have subclasses, so the keyword serves\nno purpose.\n\n#### Examples\n\nThe following code produces this diagnostic because `i` is marked as being\ncovariant:\n\n```dart\nextension E on String {\nvoid a([!covariant!] int i) {}\n}\n```\n\n#### Common fixes\n\nRemove the 'covariant' keyword:\n\n```dart\nextension E on String {\nvoid a(int i) {}\n}\n```"
      },
      {
        "real_name": "invalid_use_of_null_value",
        "display_name": "InvalidUseOfNullValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This expression is invalid as it will always be null.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the typ",
        "owner": null,
        "labels": [],
        "description": "For the purposes of experimenting with potential non-null type semantics.\n\nWhereas [UNCHECKED_USE_OF_NULLABLE] refers to using a value of type T? as\nif it were a T, this refers to using a value of type [Null] itself. These\noccur at many of the same times ([Null] is a potentially nullable type) but\nit indicates a different type of programmer error and has different\ncorrections.\n\nNo parameters.\n"
      },
      {
        "real_name": "invalid_use_of_protected_member",
        "display_name": "InvalidUseOfProtectedMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' can only be used within instance members of subclasses of '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where a member annotated with `@protected`\nis used outside an instance member of a subclass.\n\nParameters:\n0: the name of the member\n1: the name of the defining class\n"
      },
      {
        "real_name": "invalid_use_of_visible_for_template_member",
        "display_name": "InvalidUseOfVisibleForTemplateMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' can only be used within '{1}' or a template library.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where a member annotated with\n`@visibleForTemplate` is used outside of a \"template\" Dart file.\n\nParameters:\n0: the name of the member\n1: the name of the defining class\n"
      },
      {
        "real_name": "invalid_use_of_visible_for_testing_member",
        "display_name": "InvalidUseOfVisibleForTestingMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' can only be used within '{1}' or a test.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where a member annotated with\n`@visibleForTesting` is used outside the defining library, or a test.\n\nParameters:\n0: the name of the member\n1: the name of the defining class\n"
      },
      {
        "real_name": "invalid_visibility_annotation",
        "display_name": "InvalidVisibilityAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The member '{0}' is annotated with '{1}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where a private declaration is annotated\nwith `@visibleForTemplate` or `@visibleForTesting`.\n\nParameters:\n0: the name of the member\n1: the name of the annotation\n#### Description\n\nThe analyzer produces this diagnostic when either the `@visibleForTemplate`\nor `@visibleForTesting` annotation is applied to a non-public declaration.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'package:meta/meta.dart';\n\n[!@visibleForTesting!]\nvoid _someFunction() {}\n\nvoid f() => _someFunction();\n```\n\n#### Common fixes\n\nIf the declaration doesn't need to be used by test code, then remove the\nannotation:\n\n```dart\nvoid _someFunction() {}\n\nvoid f() => _someFunction();\n```\n\nIf it does, then make it public:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@visibleForTesting\nvoid someFunction() {}\n\nvoid f() => someFunction();\n```"
      },
      {
        "real_name": "invocation_of_extension_without_call",
        "display_name": "InvocationOfExtensionWithoutCall",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The extension '{0}' doesn't define a 'call' method so the override can't be used in an invocation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the extension\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a function but the extension doesn't declare a `call` method.\n\n#### Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't define a `call` method:\n\n```dart\nextension E on String {}\n\nvoid f() {\n[!E('')!]();\n}\n```\n\n#### Common fixes\n\nIf the extension is intended to define a `call` method, then declare it:\n\n```dart\nextension E on String {\nint call() => 0;\n}\n\nvoid f() {\nE('')();\n}\n```\n\nIf the extended type defines a `call` method, then remove the extension\noverride.\n\nIf the `call` method isn't defined, then rewrite the code so that it\ndoesn't invoke the `call` method."
      },
      {
        "real_name": "invocation_of_non_function",
        "display_name": "InvocationOfNonFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' isn't a function.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing functio",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the identifier that is not a function type\n#### Description\n\nThe analyzer produces this diagnostic when it finds a function invocation,\nbut the name of the function being invoked is defined to be something other\nthan a function.\n\n#### Examples\n\nThe following code produces this diagnostic because `Binary` is the name of\na function type, not a function:\n\n```dart\ntypedef Binary = int Function(int, int);\n\nint f() {\nreturn [!Binary!](1, 2);\n}\n```\n\n#### Common fixes\n\nReplace the name with the name of a function.\nTODO(brianwilkerson) Split this error code so that we can provide\nbetter error and correction messages."
      },
      {
        "real_name": "invocation_of_non_function_expression",
        "display_name": "InvocationOfNonFunctionExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The expression doesn't evaluate to a function",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a function invocation is found,\nbut the name being referenced isn't the name of a function, or when the\nexpression computing the function doesn't compute a function.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` isn't a function:\n\n```dart\nint x = 0;\n\nint f() => x;\n\nvar y = [!x!]();\n```\n\nThe following code produces this diagnostic because `f()` doesn't return a\nfunction:\n\n```dart\nint x = 0;\n\nint f() => x;\n\nvar y = [!f()!]();\n```\n\n#### Common fixes\n\nIf you need to invoke a function, then replace the code before the argument\nlist with the name of a function or with an expression that computes a\nfunction:\n\n```dart\nint x = 0;\n\nint f() => x;\n\nvar y = f();\n```"
      },
      {
        "real_name": "is_double",
        "display_name": "IsDouble",
        "severity": "warning",
        "category": "convention",
        "rule_title": "When compiled to JS",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try testing for 'num' instead.",
        "owner": null,
        "labels": [],
        "description": "Hint for the `x is double` type checks.\n"
      },
      {
        "real_name": "is_int",
        "display_name": "IsInt",
        "severity": "warning",
        "category": "convention",
        "rule_title": "When compiled to JS",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try testing for 'num' instead.",
        "owner": null,
        "labels": [],
        "description": "Hint for the `x is int` type checks.\nTODO(brianwilkerson) This hint isn't being generated. Decide whether to\ngenerate it or remove it."
      },
      {
        "real_name": "is_not_double",
        "display_name": "IsNotDouble",
        "severity": "warning",
        "category": "convention",
        "rule_title": "When compiled to JS",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try testing for 'num' instead.",
        "owner": null,
        "labels": [],
        "description": "Hint for the `x is! double` type checks.\n"
      },
      {
        "real_name": "is_not_int",
        "display_name": "IsNotInt",
        "severity": "warning",
        "category": "convention",
        "rule_title": "When compiled to JS",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try testing for 'num' instead.",
        "owner": null,
        "labels": [],
        "description": "Hint for the `x is! int` type checks.\nTODO(brianwilkerson) This hint isn't being generated. Decide whether to\ngenerate it or remove it."
      },
      {
        "real_name": "label_in_outer_scope",
        "display_name": "LabelInOuterScope",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Can't reference label '{0}' declared in an outer method.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "13.13 Break: It is a compile-time error if no such statement\n<i>s<sub>E</sub></i> exists within the innermost function in which\n<i>s<sub>b</sub></i> occurs.\n\n13.14 Continue: It is a compile-time error if no such statement or case\nclause <i>s<sub>E</sub></i> exists within the innermost function in which\n<i>s<sub>c</sub></i> occurs.\n\nParameters:\n0: the name of the unresolvable label\n"
      },
      {
        "real_name": "label_undefined",
        "display_name": "LabelUndefined",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Can't reference undefined label '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try defining the labe",
        "owner": null,
        "labels": [],
        "description": "13.13 Break: It is a compile-time error if no such statement\n<i>s<sub>E</sub></i> exists within the innermost function in which\n<i>s<sub>b</sub></i> occurs.\n\n13.14 Continue: It is a compile-time error if no such statement or case\nclause <i>s<sub>E</sub></i> exists within the innermost function in which\n<i>s<sub>c</sub></i> occurs.\n\nParameters:\n0: the name of the unresolvable label\n"
      },
      {
        "real_name": "late_final_field_with_const_constructor",
        "display_name": "LateFinalFieldWithConstConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Can't have a late final field in a class with a const constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the 'late' modifie",
        "owner": null,
        "labels": [],
        "description": "nnbd/feature-specification.md\n\nIt is an error for a class with a `const` constructor to have a\n`late final` field.\n"
      },
      {
        "real_name": "late_final_local_already_assigned",
        "display_name": "LateFinalLocalAlreadyAssigned",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The late final local variable is already definitely assigned.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the 'late' modifie",
        "owner": null,
        "labels": [],
        "description": "nnbd/feature-specification.md\n\nIt is a compile time error to assign a value to a local variable marked\n`late` and `final` when the variable is definitely assigned.\n"
      },
      {
        "real_name": "library_directive_not_first",
        "display_name": "LibraryDirectiveNotFirst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "library directive not first",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "library directive not first"
      },
      {
        "real_name": "list_element_type_not_assignable",
        "display_name": "ListElementTypeNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The element type '{0}' can't be assigned to the list type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the actual type of the list element\n1: the expected type of the list element\n#### Description\n\nThe analyzer produces this diagnostic when the type of an element in a list\nliteral isn't assignable to the element type of the list.\n\n#### Examples\n\nThe following code produces this diagnostic because `2.5` is a double, and\nthe list can hold only integers:\n\n```dart\nList<int> x = [1, [!2.5!], 3];\n```\n\n#### Common fixes\n\nIf you intended to add a different object to the list, then replace the\nelement with an expression that computes the intended object:\n\n```dart\nList<int> x = [1, 2, 3];\n```\n\nIf the object shouldn't be in the list, then remove the element:\n\n```dart\nList<int> x = [1, 3];\n```\n\nIf the object being computed is correct, then widen the element type of the\nlist to allow all of the different types of objects it needs to contain:\n\n```dart\nList<num> x = [1, 2.5, 3];\n```"
      },
      {
        "real_name": "local_function_declaration_modifier",
        "display_name": "LocalFunctionDeclarationModifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "local function declaration modifier",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "local function declaration modifier"
      },
      {
        "real_name": "map_entry_not_in_map",
        "display_name": "MapEntryNotInMap",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Map entries can only be used in a map literal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try converting the collection to a map or removing the map entry.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a map entry (a key/value pair)\nis found in a set literal.\n\n#### Examples\n\nThe following code produces this diagnostic because the literal has a map\nentry even though it's a set literal:\n\n```dart\nconst collection = <String>{[!'a' : 'b'!]};\n```\n\n#### Common fixes\n\nIf you intended for the collection to be a map, then change the code so\nthat it is a map. In the previous example, you could do this by adding\nanother type argument:\n\n```dart\nconst collection = <String, String>{'a' : 'b'};\n```\n\nIn other cases, you might need to change the explicit type from `Set` to\n`Map`.\n\nIf you intended for the collection to be a set, then remove the map entry,\npossibly by replacing the colon with a comma if both values should be\nincluded in the set:\n\n```dart\nconst collection = <String>{'a', 'b'};\n```"
      },
      {
        "real_name": "map_key_type_not_assignable",
        "display_name": "MapKeyTypeNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The element type '{0}' can't be assigned to the map key type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the expression being used as a key\n1: the type of keys declared for the map\n#### Description\n\nThe analyzer produces this diagnostic when a key of a key-value pair in a\nmap literal has a type that isn't assignable to the key type of the map.\n\n#### Examples\n\nThe following code produces this diagnostic because `2` is an `int`, but\nthe keys of the map are required to be `String`s:\n\n```dart\nvar m = <String, String>{[!2!] : 'a'};\n```\n\n#### Common fixes\n\nIf the type of the map is correct, then change the key to have the correct\ntype:\n\n```dart\nvar m = <String, String>{'2' : 'a'};\n```\n\nIf the type of the key is correct, then change the key type of the map:\n\n```dart\nvar m = <int, String>{2 : 'a'};\n```"
      },
      {
        "real_name": "map_value_type_not_assignable",
        "display_name": "MapValueTypeNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The element type '{0}' can't be assigned to the map value type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the expression being used as a value\n1: the type of values declared for the map\n#### Description\n\nThe analyzer produces this diagnostic when a value of a key-value pair in a\nmap literal has a type that isn't assignable to the the value type of the\nmap.\n\n#### Examples\n\nThe following code produces this diagnostic because `2` is an `int`, but/\nthe values of the map are required to be `String`s:\n\n```dart\nvar m = <String, String>{'a' : [!2!]};\n```\n\n#### Common fixes\n\nIf the type of the map is correct, then change the value to have the\ncorrect type:\n\n```dart\nvar m = <String, String>{'a' : '2'};\n```\n\nIf the type of the value is correct, then change the value type of the map:\n\n```dart\nvar m = <String, int>{'a' : 2};\n```"
      },
      {
        "real_name": "member_with_class_name",
        "display_name": "MemberWithClassName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Class members can't have the same name as the enclosing class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7 Classes: It is a compile time error if a class <i>C</i> declares a member\nwith the same name as <i>C</i>.\n"
      },
      {
        "real_name": "mismatched_annotation_on_struct_field",
        "display_name": "MismatchedAnnotationOnStructField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try using a different annotation or changing the declared type to match.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a different annotation or changing the declared type to match.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "missing_annotation_on_struct_field",
        "display_name": "MissingAnnotationOnStructField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try adding an annotation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an annotation.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "missing_assignable_selector",
        "display_name": "MissingAssignableSelector",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing assignable selector",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing assignable selector"
      },
      {
        "real_name": "missing_assignment_in_initializer",
        "display_name": "MissingAssignmentInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing assignment in initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing assignment in initializer"
      },
      {
        "real_name": "missing_catch_or_finally",
        "display_name": "MissingCatchOrFinally",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing catch or finally",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing catch or finally"
      },
      {
        "real_name": "missing_class_body",
        "display_name": "MissingClassBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing class body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing class body"
      },
      {
        "real_name": "missing_closing_parenthesis",
        "display_name": "MissingClosingParenthesis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing closing parenthesis",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing closing parenthesis"
      },
      {
        "real_name": "missing_const_final_var_or_type",
        "display_name": "MissingConstFinalVarOrType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing const final var or type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing const final var or type"
      },
      {
        "real_name": "missing_const_in_list_literal",
        "display_name": "MissingConstInListLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "List literals must be prefixed with 'const' when used as a constant expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding the keyword 'const' before the literal.",
        "owner": null,
        "labels": [],
        "description": "12.1 Constants: A constant expression is ... a constant list literal.\n"
      },
      {
        "real_name": "missing_const_in_map_literal",
        "display_name": "MissingConstInMapLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Map literals must be prefixed with 'const' when used as a constant expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding the keyword 'const' before the literal.",
        "owner": null,
        "labels": [],
        "description": "12.1 Constants: A constant expression is ... a constant map literal.\n"
      },
      {
        "real_name": "missing_const_in_set_literal",
        "display_name": "MissingConstInSetLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Set literals must be prefixed with 'const' when used as a constant expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding the keyword 'const' before the literal.",
        "owner": null,
        "labels": [],
        "description": "12.1 Constants: A constant expression is ... a constant set literal.\n"
      },
      {
        "real_name": "missing_dart_library",
        "display_name": "MissingDartLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing dart library",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing dart library"
      },
      {
        "real_name": "missing_default_value_for_parameter",
        "display_name": "MissingDefaultValueForParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The parameter '{0}' can't have a value of 'null' because of its type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding either a default value or the 'required' modifier.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an optional parameter doesn't\nhave a default value, but has a\n<a href=”#potentially-non-nullable”>potentially non-nullable</a> type.\nOptional parameters that have no explicit default value have an implicit\ndefault value of `null`. If the type of the parameter doesn't allow the\nparameter to have a value of null, then the implicit default value is not\nvalid.\n\n#### Examples\n\nThe following code generates this diagnostic:\n\n```dart\nvoid log({String [!message!]}) {}\n```\n\n#### Common fixes\n\nIf the parameter can have the value `null`, then add a question mark after\nthe type annotation:\n\n```dart\nvoid log({String? message}) {}\n```\n\nIf the parameter can't be null, then either provide a default value:\n\n```dart\nvoid log({String message = ''}) {}\n```\n\nor add the `required` modifier to the parameter:\n\n```dart\nvoid log({required String message}) {}\n``` */"
      },
      {
        "real_name": "missing_digit",
        "display_name": "MissingDigit",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing digit",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing digit"
      },
      {
        "real_name": "missing_enum_body",
        "display_name": "MissingEnumBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing enum body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing enum body"
      },
      {
        "real_name": "missing_enum_constant_in_switch",
        "display_name": "MissingEnumConstantInSwitch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Missing case clause for '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding a case clause for the missing constan",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the constant that is missing\n#### Description\n\nThe analyzer produces this diagnostic when a switch statement for an enum\ndoesn't include an option for one of the values in the enumeration.\n\nNote that `null` is always a possible value for an enum and therefore also\nmust be handled.\n\n#### Examples\n\nThe following code produces this diagnostic because the enum constant `e2`\nisn't handled:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E e) {\n[!switch (e)!] {\ncase E.e1:\nbreak;\n}\n}\n```\n\n#### Common fixes\n\nIf there's special handling for the missing values, then add a case clause\nfor each of the missing values:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E e) {\nswitch (e) {\ncase E.e1:\nbreak;\ncase E.e2:\nbreak;\n}\n}\n```\n\nIf the missing values should be handled the same way, then add a default\nclause:\n\n```dart\nenum E { e1, e2 }\n\nvoid f(E e) {\nswitch (e) {\ncase E.e1:\nbreak;\ndefault:\nbreak;\n}\n}\n```\nTODO(brianwilkerson) This documentation will need to be updated when NNBD\nships."
      },
      {
        "real_name": "missing_exception_value",
        "display_name": "MissingExceptionValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try adding an exceptional return value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an exceptional return value.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "missing_expression_in_initializer",
        "display_name": "MissingExpressionInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing expression in initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing expression in initializer"
      },
      {
        "real_name": "missing_expression_in_throw",
        "display_name": "MissingExpressionInThrow",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing expression in throw",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing expression in throw"
      },
      {
        "real_name": "missing_field_type_in_struct",
        "display_name": "MissingFieldTypeInStruct",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'double' or 'Pointer'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using 'int",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the field\n"
      },
      {
        "real_name": "missing_function_body",
        "display_name": "MissingFunctionBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing function body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing function body"
      },
      {
        "real_name": "missing_function_keyword",
        "display_name": "MissingFunctionKeyword",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing function keyword",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing function keyword"
      },
      {
        "real_name": "missing_function_parameters",
        "display_name": "MissingFunctionParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing function parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing function parameters"
      },
      {
        "real_name": "missing_get",
        "display_name": "MissingGet",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing get",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing get"
      },
      {
        "real_name": "missing_hex_digit",
        "display_name": "MissingHexDigit",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing hex digit",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing hex digit"
      },
      {
        "real_name": "missing_identifier",
        "display_name": "MissingIdentifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing identifier",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing identifier"
      },
      {
        "real_name": "missing_initializer",
        "display_name": "MissingInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing initializer",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing initializer"
      },
      {
        "real_name": "missing_js_lib_annotation",
        "display_name": "MissingJsLibAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The @JS) annotation can only be used if it is also declared on the library directive.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding the annotation to the library directive.",
        "owner": null,
        "labels": [],
        "description": "Generate a hint for an element that is annotated with `@JS(...)` whose\nlibrary declaration is not similarly annotated.\n"
      },
      {
        "real_name": "missing_keyword_operator",
        "display_name": "MissingKeywordOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing keyword operator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing keyword operator"
      },
      {
        "real_name": "missing_method_parameters",
        "display_name": "MissingMethodParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing method parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing method parameters"
      },
      {
        "real_name": "missing_name_for_named_parameter",
        "display_name": "MissingNameForNamedParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing name for named parameter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing name for named parameter"
      },
      {
        "real_name": "missing_name_in_library_directive",
        "display_name": "MissingNameInLibraryDirective",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing name in library directive",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing name in library directive"
      },
      {
        "real_name": "missing_name_in_part_of_directive",
        "display_name": "MissingNameInPartOfDirective",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing name in part of directive",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing name in part of directive"
      },
      {
        "real_name": "missing_prefix_in_deferred_import",
        "display_name": "MissingPrefixInDeferredImport",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing prefix in deferred import",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing prefix in deferred import"
      },
      {
        "real_name": "missing_quote",
        "display_name": "MissingQuote",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing quote",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing quote"
      },
      {
        "real_name": "missing_required_argument",
        "display_name": "MissingRequiredArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The named parameter '{0}' is required but was not provided.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding the required argument.",
        "owner": null,
        "labels": [],
        "description": "It is an error if a named parameter that is marked as being required is\nnot bound to an argument at a call site.\n\nParameters:\n0: the name of the parameter\n"
      },
      {
        "real_name": "missing_required_param",
        "display_name": "MissingRequiredParam",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The parameter '{0}' is required.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Generate a hint for a constructor, function or method invocation where a\nrequired parameter is missing.\n\nParameters:\n0: the name of the parameter\n#### Description\n\nThe analyzer produces this diagnostic when a method or function with a\nnamed parameter that is annotated as being required is invoked without\nproviding a value for the parameter.\n\n#### Examples\n\nThe following code produces this diagnostic because the named parameter `x`\nis required:\n\n```dart\nimport 'package:meta/meta.dart';\n\nvoid f({@required int x}) {}\n\nvoid g() {\n[!f!]();\n}\n```\n\n#### Common fixes\n\nProvide the required value:\n\n```dart\nimport 'package:meta/meta.dart';\n\nvoid f({@required int x}) {}\n\nvoid g() {\nf(x: 2);\n}\n```"
      },
      {
        "real_name": "missing_required_param_with_details",
        "display_name": "MissingRequiredParamWithDetails",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The parameter '{0}' is required. {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Generate a hint for a constructor, function or method invocation where a\nrequired parameter is missing.\n\nParameters:\n0: the name of the parameter\n1: message details\n"
      },
      {
        "real_name": "missing_return",
        "display_name": "MissingReturn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This function has a return type of '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding a return statemen",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the declared return type\n#### Description\n\nAny function or method that doesn't end with either an explicit return or a\nthrow implicitly returns `null`. This is rarely the desired behavior. The\nanalyzer produces this diagnostic when it finds an implicit return.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` doesn't end with a\nreturn:\n\n```dart\nint [!f!](int x) {\nif (x < 0) {\nreturn 0;\n}\n}\n```\n\n#### Common fixes\n\nAdd a return statement that makes the return value explicit, even if `null`\nis the appropriate value."
      },
      {
        "real_name": "missing_star_after_sync",
        "display_name": "MissingStarAfterSync",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing star after sync",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing star after sync"
      },
      {
        "real_name": "missing_statement",
        "display_name": "MissingStatement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing statement",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing statement"
      },
      {
        "real_name": "missing_terminator_for_parameter_group",
        "display_name": "MissingTerminatorForParameterGroup",
        "severity": "warning",
        "category": "convention",
        "rule_title": "There is no '{0}' to close the parameter group.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try inserting a '{0}' at the end of the group.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the terminator that is missing\n"
      },
      {
        "real_name": "missing_typedef_parameters",
        "display_name": "MissingTypedefParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing typedef parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing typedef parameters"
      },
      {
        "real_name": "missing_variable_in_for_each",
        "display_name": "MissingVariableInForEach",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing variable in for each",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "missing variable in for each"
      },
      {
        "real_name": "mixed_parameter_groups",
        "display_name": "MixedParameterGroups",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixed parameter groups",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixed parameter groups"
      },
      {
        "real_name": "mixed_return_types",
        "display_name": "MixedReturnTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixed return types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixed return types"
      },
      {
        "real_name": "mixin_application_concrete_super_invoked_member_type",
        "display_name": "MixinApplicationConcreteSuperInvokedMemberType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The super-invoked member '{0}' has the type '{1}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "It's a compile-time error to apply a mixin containing super-invocations to\na class that doesn't have a concrete implementation of the super-invoked\nmembers compatible with the super-constraint interface.\n\nThis ensures that if more than one super-constraint interface declares a\nmember with the same name, at least one of those members is more specific\nthan the rest, and this is the unique signature that super-invocations\nare allowed to invoke.\n\nParameters:\n0: the name of the super-invoked member\n1: the display name of the type of the super-invoked member in the mixin\n2: the display name of the type of the concrete member in the class\n"
      },
      {
        "real_name": "mixin_application_no_concrete_super_invoked_member",
        "display_name": "MixinApplicationNoConcreteSuperInvokedMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class doesn't have a concrete implementation of the super-invoked member '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "It's a compile-time error to apply a mixin containing super-invocations to\na class that doesn't have a concrete implementation of the super-invoked\nmembers compatible with the super-constraint interface.\n\nParameters:\n0: the display name of the member without a concrete implementation\n"
      },
      {
        "real_name": "mixin_application_not_implemented_interface",
        "display_name": "MixinApplicationNotImplementedInterface",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be mixed onto '{1}' because '{1}' doesn't implement '{2}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending the class '{0}'.",
        "owner": null,
        "labels": [],
        "description": "It's a compile-time error to apply a mixin to a class that doesn't\nimplement all the `on` type requirements of the mixin declaration.\n\nParameters:\n0: the display name of the mixin\n1: the display name of the superclass\n2: the display name of the type that is not implemented\n"
      },
      {
        "real_name": "mixin_class_declares_constructor",
        "display_name": "MixinClassDeclaresConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' can't be used as a mixin because it declares a constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "9 Mixins: It is a compile-time error if a declared or derived mixin\nexplicitly declares a constructor.\n\nParameters:\n0: the name of the mixin that is invalid\n"
      },
      {
        "real_name": "mixin_declares_constructor",
        "display_name": "MixinDeclaresConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Mixins can't declare constructors.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "The <i>mixinMember</i> production allows the same instance or static\nmembers that a class would allow, but no constructors (for now).\n"
      },
      {
        "real_name": "mixin_deferred_class",
        "display_name": "MixinDeferredClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes can't mixin deferred classes.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the import to not be deferred.",
        "owner": null,
        "labels": [],
        "description": "9.1 Mixin Application: It is a compile-time error if the with clause of a\nmixin application <i>C</i> includes a deferred type expression.\n\nParameters:\n0: the name of the type that cannot be extended\n\nSee [EXTENDS_DEFERRED_CLASS], and [IMPLEMENTS_DEFERRED_CLASS].\n"
      },
      {
        "real_name": "mixin_inference_inconsistent_matching_classes",
        "display_name": "MixinInferenceInconsistentMatchingClasses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixin inference inconsistent matching classes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixin inference inconsistent matching classes"
      },
      {
        "real_name": "mixin_inference_no_matching_class",
        "display_name": "MixinInferenceNoMatchingClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixin inference no matching class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixin inference no matching class"
      },
      {
        "real_name": "mixin_inference_no_possible_substitution",
        "display_name": "MixinInferenceNoPossibleSubstitution",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixin inference no possible substitution",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixin inference no possible substitution"
      },
      {
        "real_name": "mixin_inherits_from_not_object",
        "display_name": "MixinInheritsFromNotObject",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' can't be used as a mixin because it extends a class other than Object.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "9 Mixins: It is a compile-time error if a mixin is derived from a class\nwhose superclass is not Object.\n\nParameters:\n0: the name of the mixin that is invalid\n"
      },
      {
        "real_name": "mixin_instantiate",
        "display_name": "MixinInstantiate",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Mixins can't be instantiated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "A mixin declaration introduces a mixin and an interface, but not a class.\n"
      },
      {
        "real_name": "mixin_of_disallowed_class",
        "display_name": "MixinOfDisallowedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes can't mixin '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "12.2 Null: It is a compile-time error for a class to attempt to extend or\nimplement Null.\n\n12.3 Numbers: It is a compile-time error for a class to attempt to extend\nor implement int.\n\n12.3 Numbers: It is a compile-time error for a class to attempt to extend\nor implement double.\n\n12.3 Numbers: It is a compile-time error for any type other than the types\nint and double to attempt to extend or implement num.\n\n12.4 Booleans: It is a compile-time error for a class to attempt to extend\nor implement bool.\n\n12.5 Strings: It is a compile-time error for a class to attempt to extend\nor implement String.\n\nParameters:\n0: the name of the type that cannot be extended\n\nSee [IMPLEMENTS_DISALLOWED_CLASS].\n"
      },
      {
        "real_name": "mixin_of_non_class",
        "display_name": "MixinOfNonClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Classes can only mix in mixins and classes.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a name in a mixin clause is\ndefined to be something other than a mixin or a class.\n\n#### Examples\n\nThe following code produces this diagnostic because `F` is defined to be a\nfunction type:\n\n```dart\ntypedef F = int Function(String);\n\nclass C with [!F!] {}\n```\n\n#### Common fixes\n\nRemove the invalid name from the list, possibly replacing it with the name of the intended mixin or class:\n\n```dart\ntypedef F = int Function(String);\n\nclass C {}\n```"
      },
      {
        "real_name": "mixin_on_sealed_class",
        "display_name": "MixinOnSealedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' shouldn't be used as a mixin constraint because it is sealed",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try composing with this clas",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where a `@sealed` class is used as a\na superclass constraint of a mixin.\n\nParameters:\n0: the name of the sealed class\n#### Description\n\nThe analyzer produces this diagnostic when the superclass constraint of a\nmixin is a class from a different package that was marked as `@sealed`.\nClasses that are sealed can't be extended, implemented, mixed in, or used\nas a superclass constraint.\n\n#### Examples\n\nIf the package 'p' defines a sealed class:\n\n```dart\n%uri=\"package:p/p.dart\"\nimport 'package:meta/meta.dart';\n\n@sealed\nclass C {}\n```\n\nThen, the following code, when in a package other than 'p', produces this\ndiagnostic:\n\n```dart\nimport 'package:p/p.dart';\n\n[!mixin M on C {}!]\n```\n\n#### Common fixes\n\nIf the classes that use the mixin don't need to be subclasses of the sealed\nclass, then consider adding a field and delegating to the wrapped instance\nof the sealed class."
      },
      {
        "real_name": "mixin_references_super",
        "display_name": "MixinReferencesSuper",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' can't be used as a mixin because it references 'super'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "9 Mixins: It is a compile-time error if a declared or derived mixin refers\nto super.\n"
      },
      {
        "real_name": "mixin_super_class_constraint_deferred_class",
        "display_name": "MixinSuperClassConstraintDeferredClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixin super class constraint deferred class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixin super class constraint deferred class"
      },
      {
        "real_name": "mixin_super_class_constraint_disallowed_class",
        "display_name": "MixinSuperClassConstraintDisallowedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "mixin super class constraint disallowed class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "mixin super class constraint disallowed class"
      },
      {
        "real_name": "mixin_super_class_constraint_non_interface",
        "display_name": "MixinSuperClassConstraintNonInterface",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Only classes and mixins can be used as superclass constraints.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a type following the `on`\nkeyword in a mixin declaration is neither a class nor a mixin.\n\n#### Examples\n\nThe following code produces this diagnostic because `F` is neither a class\nnor a mixin:\n\n```dart\ntypedef F = void Function();\n\nmixin M on [!F!] {}\n```\n\n#### Common fixes\n\nIf the type was intended to be a class but was mistyped, then replace the\nname.\n\nOtherwise, remove the type from the on clause."
      },
      {
        "real_name": "mixin_with_non_class_superclass",
        "display_name": "MixinWithNonClassSuperclass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Mixin can only be applied to class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "9.1 Mixin Application: It is a compile-time error if <i>S</i> does not\ndenote a class available in the immediately enclosing scope.\n"
      },
      {
        "real_name": "modifier_out_of_order",
        "display_name": "ModifierOutOfOrder",
        "severity": "warning",
        "category": "convention",
        "rule_title": "modifier out of order",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "modifier out of order"
      },
      {
        "real_name": "multiple_extends_clauses",
        "display_name": "MultipleExtendsClauses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple extends clauses",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple extends clauses"
      },
      {
        "real_name": "multiple_implements_clauses",
        "display_name": "MultipleImplementsClauses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple implements clauses",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple implements clauses"
      },
      {
        "real_name": "multiple_library_directives",
        "display_name": "MultipleLibraryDirectives",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple library directives",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple library directives"
      },
      {
        "real_name": "multiple_named_parameter_groups",
        "display_name": "MultipleNamedParameterGroups",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple named parameter groups",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple named parameter groups"
      },
      {
        "real_name": "multiple_on_clauses",
        "display_name": "MultipleOnClauses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple on clauses",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple on clauses"
      },
      {
        "real_name": "multiple_part_of_directives",
        "display_name": "MultiplePartOfDirectives",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple part of directives",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple part of directives"
      },
      {
        "real_name": "multiple_positional_parameter_groups",
        "display_name": "MultiplePositionalParameterGroups",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple positional parameter groups",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple positional parameter groups"
      },
      {
        "real_name": "multiple_redirecting_constructor_invocations",
        "display_name": "MultipleRedirectingConstructorInvocations",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constructors can have at most one 'this' redirection.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one of the redirections.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: A generative constructor may be redirecting,\nin which case its only action is to invoke another generative constructor.\n"
      },
      {
        "real_name": "multiple_super_initializers",
        "display_name": "MultipleSuperInitializers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constructor may have at most one 'super' initializer.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one of the 'super' initializers.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Let <i>k</i> be a generative constructor.\nThen <i>k</i> may include at most one superinitializer in its initializer\nlist or a compile time error occurs.\n"
      },
      {
        "real_name": "multiple_variables_in_for_each",
        "display_name": "MultipleVariablesInForEach",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A single loop variable must be declared in a for-each loop before the 'in'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try moving all but one of the declarations inside the loop body.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the number of variables being declared\n"
      },
      {
        "real_name": "multiple_variance_modifiers",
        "display_name": "MultipleVarianceModifiers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple variance modifiers",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple variance modifiers"
      },
      {
        "real_name": "multiple_with_clauses",
        "display_name": "MultipleWithClauses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "multiple with clauses",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "multiple with clauses"
      },
      {
        "real_name": "must_be_a_native_function_type",
        "display_name": "MustBeANativeFunctionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try changing the type to only use members for 'dart:ffi'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "ffi'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type that should be a valid dart:ffi native type.\n1: the name of the function whose invocation depends on this relationship\n"
      },
      {
        "real_name": "must_be_a_subtype",
        "display_name": "MustBeASubtype",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try changing one or both of the type arguments.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing one or both of the type arguments.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type that should be a subtype\n1: the supertype that the subtype is compared to\n2: the name of the function whose invocation depends on this relationship\n"
      },
      {
        "real_name": "must_be_immutable",
        "display_name": "MustBeImmutable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This class or a class that this class inherits from) is marked as '@immutable'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Generate a hint for classes that inherit from classes annotated with\n`@immutable` but that are not immutable.\n#### Description\n\nThe analyzer produces this diagnostic when an immutable class defines one\nor more instance fields that aren't final. A class is immutable if it's\nmarked as being immutable using the annotation `@immutable` or if it's a\nsubclass of an immutable class.\n\n#### Examples\n\nThe following code produces this diagnostic because the field `x` isn't\nfinal:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass [!C!] {\nint x;\n\nC(this.x);\n}\n```\n\n#### Common fixes\n\nIf instances of the class should be immutable, then add the keyword `final`\nto all non-final field declarations:\n\n```dart\nimport 'package:meta/meta.dart';\n\n@immutable\nclass C {\nfinal int x;\n\nC(this.x);\n}\n```\n\nIf the instances of the class should be mutable, then remove the\nannotation, or choose a different superclass if the annotation is inherited:\n\n```dart\nclass C {\nint x;\n\nC(this.x);\n}\n```"
      },
      {
        "real_name": "must_call_super",
        "display_name": "MustCallSuper",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This method overrides a method annotated as '@mustCallSuper' in '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the class declaring the overridden method\n#### Description\n\nThe analyzer produces this diagnostic when a method that overrides a method\nthat is annotated as `@mustCallSuper` doesn't invoke the overridden method\nas required.\n\n#### Examples\n\nThe following code produces this diagnostic because the method `m` in `B`\ndoesn't invoke the overridden method `m` in `A`:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n@mustCallSuper\nm() {}\n}\n\nclass B extends A {\n@override\n[!m!]() {}\n}\n```\n\n#### Common fixes\n\nAdd an invocation of the overridden method in the overriding method:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass A {\n@mustCallSuper\nm() {}\n}\n\nclass B extends A {\n@override\nm() {\nsuper.m();\n}\n}\n```"
      },
      {
        "real_name": "named_function_expression",
        "display_name": "NamedFunctionExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "named function expression",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "named function expression"
      },
      {
        "real_name": "named_function_type",
        "display_name": "NamedFunctionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "named function type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "named function type"
      },
      {
        "real_name": "named_parameter_outside_group",
        "display_name": "NamedParameterOutsideGroup",
        "severity": "warning",
        "category": "convention",
        "rule_title": "named parameter outside group",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "named parameter outside group"
      },
      {
        "real_name": "native_clause_in_non_sdk_code",
        "display_name": "NativeClauseInNonSdkCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "native clause in non sdk code",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "native clause in non sdk code"
      },
      {
        "real_name": "native_clause_should_be_annotation",
        "display_name": "NativeClauseShouldBeAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "native clause should be annotation",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "native clause should be annotation"
      },
      {
        "real_name": "native_function_body_in_non_sdk_code",
        "display_name": "NativeFunctionBodyInNonSdkCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "native function body in non sdk code",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "native function body in non sdk code"
      },
      {
        "real_name": "new_with_abstract_class",
        "display_name": "NewWithAbstractClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "new with abstract class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "new with abstract class"
      },
      {
        "real_name": "new_with_non_type",
        "display_name": "NewWithNonType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing class.",
        "owner": null,
        "labels": [],
        "description": "12.11.1 New: It is a static warning if <i>T</i> is not a class accessible\nin the current scope, optionally followed by type arguments.\n\nParameters:\n0: the name of the non-type element\n"
      },
      {
        "real_name": "new_with_undefined_constructor",
        "display_name": "NewWithUndefinedConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' doesn't have a constructor named '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try invoking a different constructo",
        "owner": null,
        "labels": [],
        "description": "12.11.1 New: If <i>T</i> is a class or parameterized type accessible in the\ncurrent scope then:\n1. If <i>e</i> is of the form <i>new T.id(a<sub>1</sub>, &hellip;,\na<sub>n</sub>, x<sub>n+1</sub>: a<sub>n+1</sub>, &hellip;,\nx<sub>n+k</sub>: a<sub>n+k</sub>)</i> it is a static warning if\n<i>T.id</i> is not the name of a constructor declared by the type\n<i>T</i>.\nIf <i>e</i> of the form <i>new T(a<sub>1</sub>, &hellip;, a<sub>n</sub>,\nx<sub>n+1</sub>: a<sub>n+1</sub>, &hellip;, x<sub>n+k</sub>:\na<sub>n+kM/sub>)</i> it is a static warning if the type <i>T</i> does not\ndeclare a constructor with the same name as the declaration of <i>T</i>.\n"
      },
      {
        "real_name": "new_with_undefined_constructor_default",
        "display_name": "NewWithUndefinedConstructorDefault",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' doesn't have a default constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using one of the named constructors defined in '{0}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the class being instantiated\n#### Description\n\nThe analyzer produces this diagnostic when an unnamed constructor is\ninvoked on a class that defines named constructors but the class doesn’t\nhave an unnamed constructor.\n\n#### Examples\n\nThe following code produces this diagnostic because `A` doesn't define an\nunnamed constructor:\n\n```dart\nclass A {\nA.a();\n}\n\nA f() => [!A!]();\n```\n\n#### Common fixes\n\nIf one of the named constructors does what you need, then use it:\n\n```dart\nclass A {\nA.a();\n}\n\nA f() => A.a();\n```\n\nIf none of the named constructors does what you need, and you're able to\nadd an unnamed constructor, then add the constructor:\n\n```dart\nclass A {\nA();\nA.a();\n}\n\nA f() => A();\n```"
      },
      {
        "real_name": "no_annotation_constructor_arguments",
        "display_name": "NoAnnotationConstructorArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Annotation creation must have arguments.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an empty argument list.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an annotation consists of a\nsingle identifier, but that identifier is the name of a class rather than a\nvariable. To create an instance of the class, the identifier must be\nfollowed by an argument list.\n\n#### Examples\n\nThe following code produces this diagnostic because `C` is a class, and a\nclass can't be used as an annotation without invoking a `const` constructor\nfrom the class:\n\n```dart\nclass C {\nconst C();\n}\n\n[!@C!]\nvar x;\n```\n\n#### Common fixes\n\nAdd the missing argument list:\n\n```dart\nclass C {\nconst C();\n}\n\n@C()\nvar x;\n```"
      },
      {
        "real_name": "no_default_super_constructor_explicit",
        "display_name": "NoDefaultSuperConstructorExplicit",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The superclass '{0}' doesn't have a zero argument constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try declaring a zero argument constructor in '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the superclass that does not define an implicitly invoked\nconstructor\n"
      },
      {
        "real_name": "no_default_super_constructor_implicit",
        "display_name": "NoDefaultSuperConstructorImplicit",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The superclass '{0}' doesn't have a zero argument constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try declaring a zero argument constructor in '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the superclass that does not define an implicitly invoked\nconstructor\n1: the name of the subclass that does not contain any explicit constructors\n"
      },
      {
        "real_name": "no_touchscreen_feature",
        "display_name": "NoTouchscreenFeature",
        "severity": "warning",
        "category": "convention",
        "rule_title": "no touchscreen feature",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "no touchscreen feature"
      },
      {
        "real_name": "non_abstract_class_inherits_abstract_member_five_plus",
        "display_name": "NonAbstractClassInheritsAbstractMemberFivePlus",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Missing concrete implementations of '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try implementing the missing method",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the first member\n1: the name of the second member\n2: the name of the third member\n3: the name of the fourth member\n4: the number of additional missing members that aren't listed\n"
      },
      {
        "real_name": "non_abstract_class_inherits_abstract_member_four",
        "display_name": "NonAbstractClassInheritsAbstractMemberFour",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Missing concrete implementations of '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try implementing the missing method",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the first member\n1: the name of the second member\n2: the name of the third member\n3: the name of the fourth member\n"
      },
      {
        "real_name": "non_abstract_class_inherits_abstract_member_one",
        "display_name": "NonAbstractClassInheritsAbstractMemberOne",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Missing concrete implementation of '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try implementing the missing metho",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the member\n#### Description\n\nThe analyzer produces this diagnostic when a concrete class inherits one or\nmore abstract members, and doesn't provide or inherit an implementation for\nat least one of those abstract members.\n\n#### Examples\n\nThe following code produces this diagnostic because the class `B` doesn't\nhave a concrete implementation of `m`:\n\n```dart\nabstract class A {\nvoid m();\n}\n\nclass [!B!] extends A {}\n```\n\n#### Common fixes\n\nIf the subclass can provide a concrete implementation for some or all of\nthe abstract inherited members, then add the concrete implementations:\n\n```dart\nabstract class A {\nvoid m();\n}\n\nclass B extends A {\nvoid m() {}\n}\n```\n\nIf there is a mixin that provides an implementation of the inherited\nmethods, then apply the mixin to the subclass:\n\n```dart\nabstract class A {\nvoid m();\n}\n\nclass B extends A with M {}\n\nmixin M {\nvoid m() {}\n}\n```\n\nIf the subclass can't provide a concrete implementation for all of the\nabstract inherited members, then mark the subclass as being abstract:\n\n```dart\nabstract class A {\nvoid m();\n}\n\nabstract class B extends A {}\n```"
      },
      {
        "real_name": "non_abstract_class_inherits_abstract_member_three",
        "display_name": "NonAbstractClassInheritsAbstractMemberThree",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Missing concrete implementations of '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try implementing the missing method",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the first member\n1: the name of the second member\n2: the name of the third member\n"
      },
      {
        "real_name": "non_abstract_class_inherits_abstract_member_two",
        "display_name": "NonAbstractClassInheritsAbstractMemberTwo",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Missing concrete implementations of '{0}' and '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try implementing the missing method",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the first member\n1: the name of the second member\n"
      },
      {
        "real_name": "non_bool_condition",
        "display_name": "NonBoolCondition",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Conditions must have a static type of 'bool'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the condition.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a condition, such as an `if` or\n`while` loop, doesn't have the static type `bool`.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` has the static type\n`int`:\n\n```dart\nvoid f(int x) {\nif ([!x!]) {\n// ...\n}\n}\n```\n\n#### Common fixes\n\nChange the condition so that it produces a Boolean value:\n\n```dart\nvoid f(int x) {\nif (x == 0) {\n// ...\n}\n}\n```"
      },
      {
        "real_name": "non_bool_expression",
        "display_name": "NonBoolExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The expression in an assert must be of type 'bool'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the expression.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the first expression in an\nassert has a type other than `bool`.\n\n#### Examples\n\nThe following code produces this diagnostic because the type of `p` is\n`int`, but a `bool` is required:\n\n```dart\nvoid f(int p) {\nassert([!p!]);\n}\n```\n\n#### Common fixes\n\nChange the expression so that it has the type `bool`:\n\n```dart\nvoid f(int p) {\nassert(p > 0);\n}\n```"
      },
      {
        "real_name": "non_bool_negation_expression",
        "display_name": "NonBoolNegationExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A negation operand must have a static type of 'bool'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the operand to the '!' operator.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the operand of the unary\nnegation operator (`!`) doesn't have the type `bool`.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is an `int` when it\nmust be a `bool`:\n\n```dart\nint x = 0;\nbool y = ![!x!];\n```\n\n#### Common fixes\n\nReplace the operand with an expression that has the type `bool`:\n\n```dart\nint x = 0;\nbool y = !(x > 0);\n```"
      },
      {
        "real_name": "non_bool_operand",
        "display_name": "NonBoolOperand",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operands of the operator '{0}' must be assignable to 'bool'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the lexeme of the logical operator\n#### Description\n\nThe analyzer produces this diagnostic when one of the operands of either\nthe `&&` or `||` operator doesn't have the type `bool`.\n\n#### Examples\n\nThe following code produces this diagnostic because `a` isn't a Boolean\nvalue:\n\n```dart\nint a = 3;\nbool b = [!a!] || a > 1;\n```\n\n#### Common fixes\n\nChange the operand to a Boolean value:\n\n```dart\nint a = 3;\nbool b = a == 0 || a > 1;\n```"
      },
      {
        "real_name": "non_const_call_to_literal_constructor",
        "display_name": "NonConstCallToLiteralConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This instance creation must be 'const'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding a 'const' keyword.",
        "owner": null,
        "labels": [],
        "description": "Generate a hint for non-const instance creation using a constructor\nannotated with `@literal`.\n\nParameters:\n0: the name of the class defining the annotated constructor\n#### Description\n\nThe analyzer produces this diagnostic when a constructor that has the\n`@literal` annotation is invoked without using the `const` keyword, but all\nof the arguments to the constructor are constants. The annotation indicates\nthat the constructor should be used to create a constant value whenever\npossible.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n@literal\nconst C();\n}\n\nC f() => [!C()!];\n```\n\n#### Common fixes\n\nAdd the keyword `const` before the constructor invocation:\n\n```dart\nimport 'package:meta/meta.dart';\n\nclass C {\n@literal\nconst C();\n}\n\nvoid f() => const C();\n```"
      },
      {
        "real_name": "non_const_call_to_literal_constructor_using_new",
        "display_name": "NonConstCallToLiteralConstructorUsingNew",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This instance creation must be 'const'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the 'new' keyword with 'const'.",
        "owner": null,
        "labels": [],
        "description": "Generate a hint for non-const instance creation (with the `new` keyword)\nusing a constructor annotated with `@literal`.\n\nParameters:\n0: the name of the class defining the annotated constructor\n"
      },
      {
        "real_name": "non_const_map_as_expression_statement",
        "display_name": "NonConstMapAsExpressionStatement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A non-constant map or set literal without type arguments can't be used as an expression statement.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "13.2 Expression Statements: It is a compile-time error if a non-constant\nmap literal that has no explicit type arguments appears in a place where a\nstatement is expected.\n"
      },
      {
        "real_name": "non_constant_annotation_constructor",
        "display_name": "NonConstantAnnotationConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Annotation creation can only call a const constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "15 Metadata: Metadata consists of a series of annotations, each of which\nbegin with the character @, followed by a constant expression that must be\neither a reference to a compile-time constant variable, or a call to a\nconstant constructor.\n\n\"From deferred library\" case is covered by\n[CompileTimeErrorCode.INVALID_ANNOTATION_FROM_DEFERRED_LIBRARY].\n"
      },
      {
        "real_name": "non_constant_case_expression",
        "display_name": "NonConstantCaseExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Case expressions must be constant.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the expression in a case clause\nisn't a constant expression.\n\n#### Examples\n\nThe following code produces this diagnostic because `j` isn't a constant:\n\n```dart\nvoid f(int i, int j) {\nswitch (i) {\ncase [!j!]:\n// ...\nbreak;\n}\n}\n```\n\n#### Common fixes\n\nEither make the expression a constant expression, or rewrite the switch\nstatement as a sequence of if statements:\n\n```dart\nvoid f(int i, int j) {\nif (i == j) {\n// ...\n}\n}\n```"
      },
      {
        "real_name": "non_constant_case_expression_from_deferred_library",
        "display_name": "NonConstantCaseExpressionFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used as a case expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try re-writing the switch as a series of if statement",
        "owner": null,
        "labels": [],
        "description": "13.9 Switch: Given a switch statement of the form <i>switch (e) {\nlabel<sub>11</sub> &hellip; label<sub>1j1</sub> case e<sub>1</sub>:\ns<sub>1</sub> &hellip; label<sub>n1</sub> &hellip; label<sub>njn</sub> case\ne<sub>n</sub>: s<sub>n</sub> default: s<sub>n+1</sub>}</i> or the form\n<i>switch (e) { label<sub>11</sub> &hellip; label<sub>1j1</sub> case\ne<sub>1</sub>: s<sub>1</sub> &hellip; label<sub>n1</sub> &hellip;\nlabel<sub>njn</sub> case e<sub>n</sub>: s<sub>n</sub>}</i>, it is a\ncompile-time error if the expressions <i>e<sub>k</sub></i> are not\ncompile-time constants, for all <i>1 &lt;= k &lt;= n</i>.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "non_constant_default_value",
        "display_name": "NonConstantDefaultValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The default value of an optional parameter must be constant.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an optional parameter, either\nnamed or positional, has a default value that isn't a compile-time\nconstant.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nvar defaultValue = 3;\n\nvoid f([int value = [!defaultValue!]]) {}\n```\n\n#### Common fixes\n\nIf the default value can be converted to be a constant, then convert it:\n\n```dart\nconst defaultValue = 3;\n\nvoid f([int value = defaultValue]) {}\n```\n\nIf the default value needs to change over time, then apply the default\nvalue inside the function:\n\n```dart\nvar defaultValue = 3;\n\nvoid f([int value]) {\nvalue ??= defaultValue;\n}\n```"
      },
      {
        "real_name": "non_constant_default_value_from_deferred_library",
        "display_name": "NonConstantDefaultValueFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used as a default parameter value.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try leaving the default as null and initializing the parameter inside the function body.",
        "owner": null,
        "labels": [],
        "description": "6.2.2 Optional Formals: It is a compile-time error if the default value of\nan optional parameter is not a compile-time constant.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "non_constant_list_element",
        "display_name": "NonConstantListElement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The values in a const list literal must be constants.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the list literal.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an element in a constant list\nliteral isn't a constant value. The list literal can be constant either\nexplicitly (because it's prefixed by the `const` keyword) or implicitly\n(because it appears in a [constant context](#constant-context)).\n\n#### Examples\n\nThe following code produces this diagnostic because `x` isn't a constant,\neven though it appears in an implicitly constant list literal:\n\n```dart\nvar x = 2;\nvar y = const <int>[0, 1, [!x!]];\n```\n\n#### Common fixes\n\nIf the list needs to be a constant list, then convert the element to be a\nconstant. In the example above, you might add the `const` keyword to the\ndeclaration of `x`:\n\n```dart\nconst x = 2;\nvar y = const <int>[0, 1, x];\n```\n\nIf the expression can't be made a constant, then the list can't be a\nconstant either, so you must change the code so that the list isn't a\nconstant. In the example above this means removing the `const` keyword\nbefore the list literal:\n\n```dart\nvar x = 2;\nvar y = <int>[0, 1, x];\n```"
      },
      {
        "real_name": "non_constant_list_element_from_deferred_library",
        "display_name": "NonConstantListElementFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used as values in a 'const' list.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the list literal.",
        "owner": null,
        "labels": [],
        "description": "12.6 Lists: It is a compile time error if an element of a constant list\nliteral is not a compile-time constant.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "non_constant_map_element",
        "display_name": "NonConstantMapElement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The elements in a const map literal must be constant.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the map literal.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an if element or a spread\nelement in a constant map isn't a constant element.\n\n#### Examples\n\nThe following code produces this diagnostic because it is attempting to\nspread a non-constant map:\n\n```dart\nvar notConst = <int, int>{};\nvar map = const <int, int>{...[!notConst!]};\n```\n\nSimilarly, the following code produces this diagnostic because the\ncondition in the if element isn't a constant expression:\n\n```dart\nbool notConst = true;\nvar map = const <int, int>{if ([!notConst!]) 1 : 2};\n```\n\n#### Common fixes\n\nIf the map needs to be a constant map, then make the elements  constants.\nIn the spread example, you might do that by making the collection being\nspread a constant:\n\n```dart\nconst notConst = <int, int>{};\nvar map = const <int, int>{...notConst};\n```\n\nIf the map doesn't need to be a constant map, then remove the `const`\nkeyword:\n\n```dart\nbool notConst = true;\nvar map = <int, int>{if (notConst) 1 : 2};\n```"
      },
      {
        "real_name": "non_constant_map_key",
        "display_name": "NonConstantMapKey",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The keys in a const map literal must be constant.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the map literal.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a key in a constant map literal\nisn't a constant value.\n\n#### Examples\n\nThe following code produces this diagnostic beause `a` isn't a constant:\n\n```dart\nvar a = 'a';\nvar m = const {[!a!]: 0};\n```\n\n#### Common fixes\n\nIf the map needs to be a constant map, then make the key a constant:\n\n```dart\nconst a = 'a';\nvar m = const {a: 0};\n```\n\nIf the map doesn't need to be a constant map, then remove the `const`\nkeyword:\n\n```dart\nvar a = 'a';\nvar m = {a: 0};\n```"
      },
      {
        "real_name": "non_constant_map_key_from_deferred_library",
        "display_name": "NonConstantMapKeyFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used as keys in a const map literal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the map literal.",
        "owner": null,
        "labels": [],
        "description": "12.7 Maps: It is a compile time error if either a key or a value of an\nentry in a constant map literal is not a compile-time constant.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "non_constant_map_value",
        "display_name": "NonConstantMapValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The values in a const map literal must be constant.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the map literal.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a value in a constant map\nliteral isn't a constant value.\n\n#### Examples\n\nThe following code produces this diagnostic because `a` isn't a constant:\n\n```dart\nvar a = 'a';\nvar m = const {0: [!a!]};\n```\n\n#### Common fixes\n\nIf the map needs to be a constant map, then make the key a constant:\n\n```dart\nconst a = 'a';\nvar m = const {0: a};\n```\n\nIf the map doesn't need to be a constant map, then remove the `const`\nkeyword:\n\n```dart\nvar a = 'a';\nvar m = {0: a};\n```"
      },
      {
        "real_name": "non_constant_map_value_from_deferred_library",
        "display_name": "NonConstantMapValueFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant values from a deferred library can't be used as values in a const map literal.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the map literal.",
        "owner": null,
        "labels": [],
        "description": "12.7 Maps: It is a compile time error if either a key or a value of an\nentry in a constant map literal is not a compile-time constant.\n\n12.1 Constants: A qualified reference to a static constant variable that is\nnot qualified by a deferred prefix.\n"
      },
      {
        "real_name": "non_constant_set_element",
        "display_name": "NonConstantSetElement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The values in a const set literal must be constants.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the keyword 'const' from the set literal.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a constant set literal contains\nan element that isn't a compile-time constant.\n\n#### Examples\n\nThe following code produces this diagnostic because `i` isn't a constant:\n\n```dart\nvar i = 0;\n\nvar s = const {[!i!]};\n```\n\n#### Common fixes\n\nIf the element can be changed to be a constant, then change it:\n\n```dart\nconst i = 0;\n\nvar s = const {i};\n```\n\nIf the element can't be a constant, then remove the keyword `const`:\n\n```dart\nvar i = 0;\n\nvar s = {i};\n```"
      },
      {
        "real_name": "non_constant_type_argument",
        "display_name": "NonConstantTypeArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try changing the type argument to be a constant type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the type argument to be a constant type.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the function, method, or constructor having type arguments\n"
      },
      {
        "real_name": "non_constant_value_in_initializer",
        "display_name": "NonConstantValueInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Initializer expressions in constant constructors must be constants.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This error code is no longer being generated. It should be removed when the\nreference to it in the linter has been removed and rolled into the SDK.\n"
      },
      {
        "real_name": "non_constructor_factory",
        "display_name": "NonConstructorFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non constructor factory",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "non constructor factory"
      },
      {
        "real_name": "non_generative_constructor",
        "display_name": "NonGenerativeConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The generative constructor '{0}' expected",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try calling a different constructor in the superclas",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Let <i>C</i> be the class in which the\nsuperinitializer appears and let <i>S</i> be the superclass of <i>C</i>.\nLet <i>k</i> be a generative constructor. It is a compile-time error if\nclass <i>S</i> does not declare a generative constructor named <i>S</i>\n(respectively <i>S.id</i>)\n"
      },
      {
        "real_name": "non_identifier_library_name",
        "display_name": "NonIdentifierLibraryName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non identifier library name",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "non identifier library name"
      },
      {
        "real_name": "non_native_function_type_argument_to_pointer",
        "display_name": "NonNativeFunctionTypeArgumentToPointer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "correction: Try changing the type argument to be a 'NativeFunction'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the type argument to be a 'NativeFunction'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type that should be a valid dart:ffi native type.\n"
      },
      {
        "real_name": "non_part_of_directive_in_part",
        "display_name": "NonPartOfDirectiveInPart",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non part of directive in part",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "non part of directive in part"
      },
      {
        "real_name": "non_resizable_activity",
        "display_name": "NonResizableActivity",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non resizable activity",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "non resizable activity"
      },
      {
        "real_name": "non_string_literal_as_uri",
        "display_name": "NonStringLiteralAsUri",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non string literal as uri",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "non string literal as uri"
      },
      {
        "real_name": "non_sync_factory",
        "display_name": "NonSyncFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non sync factory",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "non sync factory"
      },
      {
        "real_name": "non_type_as_type_argument",
        "display_name": "NonTypeAsTypeArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a type so it can't be used as a type argument.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to an existing typ",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name appearing where a type is expected\n#### Description\n\nThe analyzer produces this diagnostic when an identifier that isn't a type\nis used as a type argument.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is a variable, not\na type:\n\n```dart\nvar x = 0;\nList<[!x!]> xList = [];\n```\n\n#### Common fixes\n\nChange the type argument to be a type:\n\n```dart\nvar x = 0;\nList<int> xList = [];\n```"
      },
      {
        "real_name": "non_type_in_catch_clause",
        "display_name": "NonTypeInCatchClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a type and can't be used in an on-catch clause.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing class.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the non-type element\n#### Description\n\nThe analyzer produces this diagnostic when the identifier following the\n`on` in a catch clause is defined to be something other than a type.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` is a function, not\na type:\n\n```dart\nvoid f() {\ntry {\n// ...\n} on [!f!] {\n// ...\n}\n}\n```\n\n#### Common fixes\n\nChange the name to the type of object that should be caught:\n\n```dart\nvoid f() {\ntry {\n// ...\n} on FormatException {\n// ...\n}\n}\n```"
      },
      {
        "real_name": "non_user_definable_operator",
        "display_name": "NonUserDefinableOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator '{0}' isn't user definable.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the operator that the user is trying to define\n"
      },
      {
        "real_name": "non_void_return_for_operator",
        "display_name": "NonVoidReturnForOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type of the operator []= must be 'void'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the return type to 'void'.",
        "owner": null,
        "labels": [],
        "description": "7.1.1 Operators: It is a static warning if the return type of the\nuser-declared operator []= is explicitly declared and not void.\n"
      },
      {
        "real_name": "non_void_return_for_setter",
        "display_name": "NonVoidReturnForSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type of the setter must be 'void' or absent.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the return typ",
        "owner": null,
        "labels": [],
        "description": "7.3 Setters: It is a static warning if a setter declares a return type\nother than void.\n"
      },
      {
        "real_name": "normal_before_optional_parameters",
        "display_name": "NormalBeforeOptionalParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "normal before optional parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "normal before optional parameters"
      },
      {
        "real_name": "not_a_type",
        "display_name": "NotAType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "{0} isn't a type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing type.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name that is not a type\n#### Description\n\nThe analyzer produces this diagnostic when a name is used as a type but\ndeclared to be something other than a type.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` is a function:\n\n```dart\nf() {}\ng([!f!] v) {}\n```\n\n#### Common fixes\n\nReplace the name with the name of a type."
      },
      {
        "real_name": "not_assigned_potentially_non_nullable_local_variable",
        "display_name": "NotAssignedPotentiallyNonNullableLocalVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The non-nullable local variable '{0}' must be assigned before it can be used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try giving it an initializer expressio",
        "owner": null,
        "labels": [],
        "description": "It is an error if a potentially non-nullable local variable which has no\ninitializer expression and is not marked `late` is used before it is\ndefinitely assigned.\n\nParameters:\n0: the name of the variable that is invalid\n"
      },
      {
        "real_name": "not_enough_positional_arguments",
        "display_name": "NotEnoughPositionalArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "{0} positional arguments) expected",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding the missing arguments.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the expected number of required arguments\n1: the actual number of positional arguments given\n#### Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas fewer positional arguments than the number of required positional\nparameters.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` declares two\nrequired parameters, but only one argument is provided:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\nf[!(0)!];\n}\n```\n\n#### Common fixes\n\nAdd arguments corresponding to the remaining parameters:\n\n```dart\nvoid f(int a, int b) {}\nvoid g() {\nf(0, 1);\n}\n```"
      },
      {
        "real_name": "not_enough_required_arguments",
        "display_name": "NotEnoughRequiredArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "not enough required arguments",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "not enough required arguments"
      },
      {
        "real_name": "not_initialized_non_nullable_instance_field",
        "display_name": "NotInitializedNonNullableInstanceField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Non-nullable instance field '{0}' must be initialized.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an initializer expressio",
        "owner": null,
        "labels": [],
        "description": "It is an error if an instance field with potentially non-nullable type has\nno initializer expression and is not initialized in a constructor via an\ninitializing formal or an initializer list entry, unless the field is\nmarked with the `late` modifier.\n\nParameters:\n0: the name of the field that is not initialized\n"
      },
      {
        "real_name": "not_initialized_non_nullable_instance_field_constructor",
        "display_name": "NotInitializedNonNullableInstanceFieldConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Non-nullable instance field '{0}' must be initialized.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an initializer expressio",
        "owner": null,
        "labels": [],
        "description": "It is an error if an instance field with potentially non-nullable type has\nno initializer expression and is not initialized in a constructor via an\ninitializing formal or an initializer list entry, unless the field is\nmarked with the `late` modifier.\n\nParameters:\n0: the name of the field that is not initialized\n"
      },
      {
        "real_name": "not_initialized_non_nullable_variable",
        "display_name": "NotInitializedNonNullableVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The non-nullable variable '{0}' must be initialized.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding an initializer expression.",
        "owner": null,
        "labels": [],
        "description": "It is an error if a static field or top-level variable with potentially\nnon-nullable type has no initializer expression.\n\nParameters:\n0: the name of the variable that is invalid\n"
      },
      {
        "real_name": "not_instantiated_bound",
        "display_name": "NotInstantiatedBound",
        "severity": "warning",
        "category": "convention",
        "rule_title": "not instantiated bound",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "not instantiated bound"
      },
      {
        "real_name": "not_iterable_spread",
        "display_name": "NotIterableSpread",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Spread elements in list or set literals must implement 'Iterable'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the static type of the\nexpression of a spread element that appears in either a list literal or a\nset literal doesn't implement the type `Iterable`.\n\n#### Examples\n\nThe following code produces this diagnostic:\n\n```dart\nvar m = <String, int>{'a': 0, 'b': 1};\nvar s = <String>{...[!m!]};\n```\n\n#### Common fixes\n\nThe most common fix is to replace the expression with one that produces an\niterable object:\n\n```dart\nvar m = <String, int>{'a': 0, 'b': 1};\nvar s = <String>{...m.keys};\n```"
      },
      {
        "real_name": "not_map_spread",
        "display_name": "NotMapSpread",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Spread elements in map literals must implement 'Map'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the static type of the\nexpression of a spread element that appears in a map literal doesn't\nimplement the type `Map`.\n\n#### Examples\n\nThe following code produces this diagnostic because `l` isn't a `Map`:\n\n```dart\nvar l =  <String>['a', 'b'];\nvar m = <int, String>{...[!l!]};\n```\n\n#### Common fixes\n\nThe most common fix is to replace the expression with one that produces a\nmap:\n\n```dart\nvar l =  <String>['a', 'b'];\nvar m = <int, String>{...l.asMap()};\n```"
      },
      {
        "real_name": "not_null_aware_null_spread",
        "display_name": "NotNullAwareNullSpread",
        "severity": "warning",
        "category": "convention",
        "rule_title": "not null aware null spread",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "not null aware null spread"
      },
      {
        "real_name": "null_aware_before_operator",
        "display_name": "NullAwareBeforeOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The left operand uses '?.'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "When the left operand of a binary expression uses '?.' operator, it can be\n`null`.\n"
      },
      {
        "real_name": "null_aware_cascade_out_of_order",
        "display_name": "NullAwareCascadeOutOfOrder",
        "severity": "warning",
        "category": "convention",
        "rule_title": "null aware cascade out of order",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "null aware cascade out of order"
      },
      {
        "real_name": "null_aware_in_condition",
        "display_name": "NullAwareInCondition",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The value of the '?.' operator can be 'null'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the '?.' with a '.",
        "owner": null,
        "labels": [],
        "description": "A condition in a control flow statement could evaluate to `null` because it\nuses the null-aware '?.' operator.\n"
      },
      {
        "real_name": "null_aware_in_logical_operator",
        "display_name": "NullAwareInLogicalOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The value of the '?.' operator can be 'null'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "A condition in operands of a logical operator could evaluate to `null`\nbecause it uses the null-aware '?.' operator.\n"
      },
      {
        "real_name": "nullable_type_in_extends_clause",
        "display_name": "NullableTypeInExtendsClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A class can't extend a nullable type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the question mark.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a class declaration uses an\nextends clause to specify a superclass, and the type that's specified is a\nnullable type.\n\nThe reason the supertype is a _type_ rather than a class name is to allow\nyou to control the signatures of the members to be inherited from the\nsupertype, such as by specifying type arguments. However, the nullability\nof a type doesn't change the signatures of any members, so there isn't any\nreason to allow the nullability to be specified when used in the extends\nclause.\n\n#### Examples\n\nThe following code generates this diagnostic:\n\n```dart\nclass Invalid extends [!Duration?!] {}\n```\n\n#### Common fixes\n\nThe most common fix is to remove the question mark:\n\n```dart\nclass Invalid extends Duration {}\n``` */"
      },
      {
        "real_name": "nullable_type_in_implements_clause",
        "display_name": "NullableTypeInImplementsClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A class or mixin can't implement a nullable type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the question mark.",
        "owner": null,
        "labels": [],
        "description": "It is a compile-time error for a class to extend, implement, or mixin a\ntype of the form T? for any T.\n"
      },
      {
        "real_name": "nullable_type_in_on_clause",
        "display_name": "NullableTypeInOnClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A mixin can't have a nullable type as a superclass constraint.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the question mark.",
        "owner": null,
        "labels": [],
        "description": "It is a compile-time error for a class to extend, implement, or mixin a\ntype of the form T? for any T.\n"
      },
      {
        "real_name": "nullable_type_in_with_clause",
        "display_name": "NullableTypeInWithClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A class or mixin can't mix in a nullable type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the question mark.",
        "owner": null,
        "labels": [],
        "description": "It is a compile-time error for a class to extend, implement, or mixin a\ntype of the form T? for any T.\n"
      },
      {
        "real_name": "object_cannot_extend_another_class",
        "display_name": "ObjectCannotExtendAnotherClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class 'Object' can't extend any other class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.9 Superclasses: It is a compile-time error to specify an extends clause\nfor class Object.\n"
      },
      {
        "real_name": "on_repeated",
        "display_name": "OnRepeated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can only be used in super-class constraints only once.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing all but one occurrence of the class name.",
        "owner": null,
        "labels": [],
        "description": "10.10 Superinterfaces: It is a compile-time error if two elements in the\ntype list of the implements clause of a class `C` specifies the same\ntype `T`.\n\nParameters:\n0: the name of the interface that is implemented more than once\n"
      },
      {
        "real_name": "optional_parameter_in_operator",
        "display_name": "OptionalParameterInOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Optional parameters aren't allowed when defining an operator.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the optional parameters.",
        "owner": null,
        "labels": [],
        "description": "7.1.1 Operators: It is a compile-time error to declare an optional\nparameter in an operator.\n"
      },
      {
        "real_name": "override_equals_but_not_hash_code",
        "display_name": "OverrideEqualsButNotHashCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' overrides 'operator=='",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try implementing 'hashCode'.",
        "owner": null,
        "labels": [],
        "description": "Hint for classes that override equals, but not hashCode.\n\nParameters:\n0: the name of the current class\nTODO(brianwilkerson) Decide whether we want to implement this check\n(possibly as a lint) or remove the hint code."
      },
      {
        "real_name": "override_on_non_overriding_field",
        "display_name": "OverrideOnNonOverridingField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The field doesn't override an inherited getter or setter.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating this class to match the superclas",
        "owner": null,
        "labels": [],
        "description": "A field with the override annotation does not override a getter or setter.\n\nNo parameters.\n"
      },
      {
        "real_name": "override_on_non_overriding_getter",
        "display_name": "OverrideOnNonOverridingGetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The getter doesn't override an inherited getter.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating this class to match the superclas",
        "owner": null,
        "labels": [],
        "description": "A getter with the override annotation does not override an existing getter.\n\nNo parameters.\n"
      },
      {
        "real_name": "override_on_non_overriding_method",
        "display_name": "OverrideOnNonOverridingMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The method doesn't override an inherited method.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating this class to match the superclas",
        "owner": null,
        "labels": [],
        "description": "A method with the override annotation does not override an existing method.\n\nNo parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a class member is annotated with\nthe `@override` annotation, but the member isn’t declared in any of the\nsupertypes of the class.\n\n#### Examples\n\nThe following code produces this diagnostic because `m` isn't declared in\nany of the supertypes of `C`:\n\n```dart\nclass C {\n@override\nString [!m!]() => '';\n}\n```\n\n#### Common fixes\n\nIf the member is intended to override a member with a different name, then\nupdate the member to have the same name:\n\n```dart\nclass C {\n@override\nString toString() => '';\n}\n```\n\nIf the member is intended to override a member that was removed from the\nsuperclass, then consider removing the member from the subclass.\n\nIf the member can't be removed, then remove the annotation."
      },
      {
        "real_name": "override_on_non_overriding_member",
        "display_name": "OverrideOnNonOverridingMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "override on non overriding member",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "override on non overriding member"
      },
      {
        "real_name": "override_on_non_overriding_setter",
        "display_name": "OverrideOnNonOverridingSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The setter doesn't override an inherited setter.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating this class to match the superclas",
        "owner": null,
        "labels": [],
        "description": "A setter with the override annotation does not override an existing setter.\n\nNo parameters.\n"
      },
      {
        "real_name": "package_import_contains_dot_dot",
        "display_name": "PackageImportContainsDotDot",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A package import shouldn't contain '..'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "It is a bad practice for a package import to reference anything outside the\ngiven package, or more generally, it is bad practice for a package import\nto contain a \"..\". For example, a source file should not contain a\ndirective such as `import 'package:foo/../some.dart'`.\n"
      },
      {
        "real_name": "parse_error",
        "display_name": "ParseError",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that there is a syntactic error in the file.\n\nParameters:\n0: the error message from the parse error\n"
      },
      {
        "real_name": "part_of_different_library",
        "display_name": "PartOfDifferentLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Expected this library to be part of '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try including a different par",
        "owner": null,
        "labels": [],
        "description": "14.3 Parts: It is a static warning if the referenced part declaration\n<i>p</i> names a library other than the current library as the library to\nwhich <i>p</i> belongs.\n\nParameters:\n0: the name of expected library name\n1: the non-matching actual library name from the \"part of\" declaration\n"
      },
      {
        "real_name": "part_of_non_part",
        "display_name": "PartOfNonPart",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The included part '{0}' must have a part-of directive.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding a part-of directive to '{0}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the uri pointing to a non-library declaration\n#### Description\n\nThe analyzer produces this diagnostic when a part directive is found and\nthe referenced file doesn't have a part-of directive.\n\n#### Examples\n\nGiven a file (`a.dart`) containing:\n\n```dart\n%uri=\"lib/a.dart\"\nclass A {}\n```\n\nThe following code produces this diagnostic because `a.dart` doesn't\ncontain a part-of directive:\n\n```dart\npart [!'a.dart'!];\n```\n\n#### Common fixes\n\nIf the referenced file is intended to be a part of another library, then\nadd a part-of directive to the file:\n\n```dart\npart of 'test.dart';\n\nclass A {}\n```\n\nIf the referenced file is intended to be a library, then replace the part\ndirective with an import directive:\n\n```dart\nimport 'a.dart';\n```"
      },
      {
        "real_name": "part_of_unnamed_library",
        "display_name": "PartOfUnnamedLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Library is unnamed. Expected a URI not a library name '{0}' in the part-of directive.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the part-of directive to a UR",
        "owner": null,
        "labels": [],
        "description": "\n/ Parts: It is a static warning if the referenced part declaration\n/ <i>p</i> names a library that does not have a library tag.\n/\n/ Parameters:\n/ 0: the URI of the expected library\n/ 1: the non-matching actual library name from the \"part of\" declaration"
      },
      {
        "real_name": "permission_implies_unsupported_hardware",
        "display_name": "PermissionImpliesUnsupportedHardware",
        "severity": "warning",
        "category": "convention",
        "rule_title": "permission implies unsupported hardware",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "permission implies unsupported hardware"
      },
      {
        "real_name": "positional_after_named_argument",
        "display_name": "PositionalAfterNamedArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "positional after named argument",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "positional after named argument"
      },
      {
        "real_name": "positional_parameter_outside_group",
        "display_name": "PositionalParameterOutsideGroup",
        "severity": "warning",
        "category": "convention",
        "rule_title": "positional parameter outside group",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "positional parameter outside group"
      },
      {
        "real_name": "prefix_after_combinator",
        "display_name": "PrefixAfterCombinator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefix after combinator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "prefix after combinator"
      },
      {
        "real_name": "prefix_collides_with_top_level_member",
        "display_name": "PrefixCollidesWithTopLevelMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' is already used as an import prefix and can't be used to name a top-level element.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming either the top-level element or the prefix.",
        "owner": null,
        "labels": [],
        "description": "14.1 Imports: It is a compile-time error if the current library declares a\ntop-level member named <i>p</i>.\n"
      },
      {
        "real_name": "prefix_identifier_not_followed_by_dot",
        "display_name": "PrefixIdentifierNotFollowedByDot",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' refers to an import prefix",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to refer to something other than a prefi",
        "owner": null,
        "labels": [],
        "description": "16.32 Identifier Reference: If d is a prefix p, a compile-time error\noccurs unless the token immediately following d is '.'.\n"
      },
      {
        "real_name": "preview_dart_2_setting_deprecated",
        "display_name": "PreviewDart2SettingDeprecated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The 'enablePreviewDart2' setting is deprecated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "It is no longer necessary to explicitly enable Dart 2.",
        "owner": null,
        "labels": [],
        "description": "An error code indicating that the enablePreviewDart2 setting is deprecated.\n"
      },
      {
        "real_name": "private_collision_in_mixin_application",
        "display_name": "PrivateCollisionInMixinApplication",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The private name '{0}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing '{1}' from the 'with' clause.",
        "owner": null,
        "labels": [],
        "description": "It is an error for a mixin to add a private name that conflicts with a\nprivate name added by a superclass or another mixin.\n"
      },
      {
        "real_name": "private_optional_parameter",
        "display_name": "PrivateOptionalParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Named optional parameters can't start with an underscore.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "6.2.2 Optional Formals: It is a compile-time error if the name of a named\noptional parameter begins with an '_' character.\n"
      },
      {
        "real_name": "receiver_of_type_never",
        "display_name": "ReceiverOfTypeNever",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'The receiver expression is of type Never",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "'Try checking for throw expressions or type errors in the' ' target expression",
        "owner": null,
        "labels": [],
        "description": "It is not an error to call or tear-off a method, setter, or getter, or to\nread or write a field, on a receiver of static type `Never`.\nImplementations that provide feedback about dead or unreachable code are\nencouraged to indicate that any arguments to the invocation are\nunreachable.\n\nIt is not an error to apply an expression of type `Never` in the function\nposition of a function call. Implementations that provide feedback about\ndead or unreachable code are encouraged to indicate that any arguments to\nthe call are unreachable.\n\nParameters: none\n"
      },
      {
        "real_name": "recursive_compile_time_constant",
        "display_name": "RecursiveCompileTimeConstant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Compile-time constant expression depends on itself.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "12.1 Constants: It is a compile-time error if the value of a compile-time\nconstant expression depends on itself.\n"
      },
      {
        "real_name": "recursive_constructor_redirect",
        "display_name": "RecursiveConstructorRedirect",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Cycle in redirecting generative constructors.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: A generative constructor may be redirecting,\nin which case its only action is to invoke another generative constructor.\n\nTODO(scheglov) review this later, there are no explicit \"it is a\ncompile-time error\" in specification. But it was added to the co19 and\nthere is same error for factories.\n\nhttps://code.google.com/p/dart/issues/detail?id=954\n"
      },
      {
        "real_name": "recursive_factory_redirect",
        "display_name": "RecursiveFactoryRedirect",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Cycle in redirecting factory constructors.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6.2 Factories: It is a compile-time error if a redirecting factory\nconstructor redirects to itself, either directly or indirectly via a\nsequence of redirections.\n"
      },
      {
        "real_name": "recursive_interface_inheritance",
        "display_name": "RecursiveInterfaceInheritance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be a superinterface of itself: {1}.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.10 Superinterfaces: It is a compile-time error if the interface of a\nclass <i>C</i> is a superinterface of itself.\n\n8.1 Superinterfaces: It is a compile-time error if an interface is a\nsuperinterface of itself.\n\n7.9 Superclasses: It is a compile-time error if a class <i>C</i> is a\nsuperclass of itself.\n\nParameters:\n0: the name of the class that implements itself recursively\n1: a string representation of the implements loop\n"
      },
      {
        "real_name": "recursive_interface_inheritance_extends",
        "display_name": "RecursiveInterfaceInheritanceExtends",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't extend itself.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.10 Superinterfaces: It is a compile-time error if the interface of a\nclass <i>C</i> is a superinterface of itself.\n\n8.1 Superinterfaces: It is a compile-time error if an interface is a\nsuperinterface of itself.\n\n7.9 Superclasses: It is a compile-time error if a class <i>C</i> is a\nsuperclass of itself.\n\nParameters:\n0: the name of the class that implements itself recursively\n"
      },
      {
        "real_name": "recursive_interface_inheritance_implements",
        "display_name": "RecursiveInterfaceInheritanceImplements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't implement itself.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.10 Superinterfaces: It is a compile-time error if the interface of a\nclass <i>C</i> is a superinterface of itself.\n\n8.1 Superinterfaces: It is a compile-time error if an interface is a\nsuperinterface of itself.\n\n7.9 Superclasses: It is a compile-time error if a class <i>C</i> is a\nsuperclass of itself.\n\nParameters:\n0: the name of the class that implements itself recursively\n"
      },
      {
        "real_name": "recursive_interface_inheritance_on",
        "display_name": "RecursiveInterfaceInheritanceOn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't use itself as a superclass constraint.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the mixin that constraints itself recursively\n"
      },
      {
        "real_name": "recursive_interface_inheritance_with",
        "display_name": "RecursiveInterfaceInheritanceWith",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't use itself as a mixin.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.10 Superinterfaces: It is a compile-time error if the interface of a\nclass <i>C</i> is a superinterface of itself.\n\n8.1 Superinterfaces: It is a compile-time error if an interface is a\nsuperinterface of itself.\n\n7.9 Superclasses: It is a compile-time error if a class <i>C</i> is a\nsuperclass of itself.\n\nParameters:\n0: the name of the class that implements itself recursively\n"
      },
      {
        "real_name": "redirect_generative_to_missing_constructor",
        "display_name": "RedirectGenerativeToMissingConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constructor '{0}' couldn't be found in '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructo",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative constructors: A generative constructor may be\n<i>redirecting</i>, in which case its only action is to invoke another\ngenerative constructor.\n"
      },
      {
        "real_name": "redirect_generative_to_non_generative_constructor",
        "display_name": "RedirectGenerativeToNonGenerativeConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Generative constructor can't redirect to a factory constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructor.",
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative constructors: A generative constructor may be\n<i>redirecting</i>, in which case its only action is to invoke another\ngenerative constructor.\n"
      },
      {
        "real_name": "redirect_to_invalid_function_type",
        "display_name": "RedirectToInvalidFunctionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The redirected constructor '{0}' has incompatible parameters with '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructor.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the redirected constructor\n1: the name of the redirecting constructor\n#### Description\n\nThe analyzer produces this diagnostic when a factory constructor attempts\nto redirect to another constructor, but the two have incompatible\nparameters. The parameters are compatible if all of the parameters of the\nredirecting constructor can be passed to the other constructor and if the\nother constructor doesn't require any parameters that aren't declared by\nthe redirecting constructor.\n\n#### Examples\n\nThe following code produces this diagnostic because the constructor for `A`\ndoesn't declare a parameter that the constructor for `B` requires:\n\n```dart\nabstract class A {\nfactory A() = [!B!];\n}\n\nclass B implements A {\nB(int x);\nB.zero();\n}\n```\n\nThe following code produces this diagnostic because the constructor for `A`\ndeclares a named parameter (`y`) that the constructor for `B` doesn't\nallow:\n\n```dart\nabstract class A {\nfactory A(int x, {int y}) = [!B!];\n}\n\nclass B implements A {\nB(int x);\n}\n```\n\n#### Common fixes\n\nIf there's a different constructor that is compatible with the redirecting\nconstructor, then redirect to that constructor:\n\n```dart\nabstract class A {\nfactory A() = B.zero;\n}\n\nclass B implements A {\nB(int x);\nB.zero();\n}\n```\n\nOtherwise, update the redirecting constructor to be compatible:\n\n```dart\nabstract class A {\nfactory A(int x) = B;\n}\n\nclass B implements A {\nB(int x);\n}\n```"
      },
      {
        "real_name": "redirect_to_invalid_return_type",
        "display_name": "RedirectToInvalidReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type '{0}' of the redirected constructor isn't assignable to '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructor.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the redirected constructor's return type\n1: the name of the redirecting constructor's return type\n#### Description\n\nThe analyzer produces this diagnostic when a factory constructor redirects\nto a constructor whose return type isn't a subtype of the type that the\nfactory constructor is declared to produce.\n\n#### Examples\n\nThe following code produces this diagnostic because `A` isn't a subclass\nof `C`, which means that the value returned by the constructor `A()`\ncouldn't be returned from the constructor `C()`:\n\n```dart\nclass A {}\n\nclass B implements C {}\n\nclass C {\nfactory C() = [!A!];\n}\n```\n\n#### Common fixes\n\nIf the factory constructor is redirecting to a constructor in the wrong\nclass, then update the factory constructor to redirect to the correct\nconstructor:\n\n```dart\nclass A {}\n\nclass B implements C {}\n\nclass C {\nfactory C() = B;\n}\n```\n\nIf the class defining the constructor being redirected to is the class that\nshould be returned, then make it a subtype of the factory's return type:\n\n```dart\nclass A implements C {}\n\nclass B implements C {}\n\nclass C {\nfactory C() = A;\n}\n```"
      },
      {
        "real_name": "redirect_to_missing_constructor",
        "display_name": "RedirectToMissingConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constructor '{0}' couldn't be found in '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructo",
        "owner": null,
        "labels": [],
        "description": "7.6.2 Factories: It is a compile-time error if <i>k</i> is prefixed with\nthe const modifier but <i>k'</i> is not a constant constructor.\n"
      },
      {
        "real_name": "redirect_to_non_class",
        "display_name": "RedirectToNonClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a type and can't be used in a redirected constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructor.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the non-type referenced in the redirect\n#### Description\n\nOne way to implement a factory constructor is to redirect to another\nconstructor by referencing the name of the constructor. The analyzer\nproduces this diagnostic when the redirect is to something other than a\nconstructor.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` is a function:\n\n```dart\nC f() => throw 0;\n\nclass C {\nfactory C() = [!f!];\n}\n```\n\n#### Common fixes\n\nIf the constructor isn't defined, then either define it or replace it with\na constructor that is defined.\n\nIf the constructor is defined but the class that defines it isn't visible,\nthen you probably need to add an import.\n\nIf you're trying to return the value returned by a function, then rewrite\nthe constructor to return the value from the constructor's body:\n\n```dart\nC f() => throw 0;\n\nclass C {\nfactory C() => f();\n}\n```"
      },
      {
        "real_name": "redirect_to_non_const_constructor",
        "display_name": "RedirectToNonConstConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constant redirecting constructor can't redirect to a non-constant constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try redirecting to a different constructor.",
        "owner": null,
        "labels": [],
        "description": "7.6.2 Factories: It is a compile-time error if <i>k</i> is prefixed with\nthe const modifier but <i>k'</i> is not a constant constructor.\n"
      },
      {
        "real_name": "redirecting_constructor_with_body",
        "display_name": "RedirectingConstructorWithBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "redirecting constructor with body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "redirecting constructor with body"
      },
      {
        "real_name": "redirection_in_non_factory_constructor",
        "display_name": "RedirectionInNonFactoryConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "redirection in non factory constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "redirection in non factory constructor"
      },
      {
        "real_name": "referenced_before_declaration",
        "display_name": "ReferencedBeforeDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Local variable '{0}' can't be referenced before it is declared.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try moving the declaration to before the first us",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a variable is referenced before\nit’s declared. In Dart, variables are visible everywhere in the block in\nwhich they are declared, but can only be referenced after they are\ndeclared.\n\nThe analyzer also produces a context message that indicates where the\ndeclaration is located.\n\n#### Examples\n\nThe following code produces this diagnostic because `i` is used before it\nis declared:\n\n```dart\nvoid f() {\nprint([!i!]);\nint i = 5;\n}\n```\n\n#### Common fixes\n\nIf you intended to reference the local variable, move the declaration\nbefore the first reference:\n\n```dart\nvoid f() {\nint i = 5;\nprint(i);\n}\n```\n\nIf you intended to reference a name from an outer scope, such as a\nparameter, instance field or top-level variable, then rename the local\ndeclaration so that it doesn't hide the outer variable.\n\n```dart\nvoid f(int i) {\nprint(i);\nint x = 5;\nprint(x);\n}\n```"
      },
      {
        "real_name": "rethrow_outside_catch",
        "display_name": "RethrowOutsideCatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Rethrow must be inside of catch clause.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try moving the expression into a catch claus",
        "owner": null,
        "labels": [],
        "description": "12.8.1 Rethrow: It is a compile-time error if an expression of the form\n<i>rethrow;</i> is not enclosed within a on-catch clause.\n"
      },
      {
        "real_name": "return_in_generative_constructor",
        "display_name": "ReturnInGenerativeConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Constructors can't return values.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the return statement or using a factory constructor.",
        "owner": null,
        "labels": [],
        "description": "13.12 Return: It is a compile-time error if a return statement of the form\n<i>return e;</i> appears in a generative constructor.\n"
      },
      {
        "real_name": "return_in_generator",
        "display_name": "ReturnInGenerator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Can't return a value from a generator function using the '{0}' modifier).",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the valu",
        "owner": null,
        "labels": [],
        "description": "13.12 Return: It is a compile-time error if a return statement of the form\n<i>return e;</i> appears in a generator function.\n"
      },
      {
        "real_name": "return_of_invalid_type",
        "display_name": "ReturnOfInvalidType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type '{0}' isn't a '{1}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the return type as declared in the return statement\n1: the expected return type as defined by the method\n2: the name of the method\n"
      },
      {
        "real_name": "return_of_invalid_type_from_closure",
        "display_name": "ReturnOfInvalidTypeFromClosure",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The return type '{0}' isn't a '{1}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the return type as declared in the return statement\n1: the expected return type as defined by the method\n#### Description\n\nThe analyzer produces this diagnostic when the static type of a returned\nexpression isn't assignable to the return type that the closure is required\nto have.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` is defined to be a\nfunction that returns a `String`, but the closure assigned to it returns an\n`int`:\n\n```dart\nString Function(String) f = (s) => [!3!];\n```\n\n#### Common fixes\n\nIf the return type is correct, then replace the returned value with a value\nof the correct type, possibly by converting the existing value:\n\n```dart\nString Function(String) f = (s) => 3.toString();\n```"
      },
      {
        "real_name": "return_of_invalid_type_from_function",
        "display_name": "ReturnOfInvalidTypeFromFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A value of type '{0}' can't be returned from function '{2}' because it has a return type of '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the return type as declared in the return statement\n1: the expected return type as defined by the method\n2: the name of the method\n#### Description\n\nThe analyzer produces this diagnostic when a method or function returns a\nvalue whose type isn't assignable to the declared return type.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` has a return type\nof `String` but is returning an `int`:\n\n```dart\nString f() => [!3!];\n```\n\n#### Common fixes\n\nIf the return type is correct, then replace the value being returned with a\nvalue of the correct type, possibly by converting the existing value:\n\n```dart\nString f() => 3.toString();\n```\n\nIf the value is correct, then change the return type to match:\n\n```dart\nint f() => 3;\n```"
      },
      {
        "real_name": "return_of_invalid_type_from_method",
        "display_name": "ReturnOfInvalidTypeFromMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A value of type '{0}' can't be returned from method '{2}' because it has a return type of '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the return type as declared in the return statement\n1: the expected return type as defined by the method\n2: the name of the method\n"
      },
      {
        "real_name": "return_without_value",
        "display_name": "ReturnWithoutValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The  return value is missing after 'return'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when it finds a return statement\nwithout an expression in a function that declares a return type.\n\n#### Examples\n\nThe following code produces this diagnostic because the function `f` is\nexpected to return an `int`, but no value is being returned:\n\n```dart\nint f() {\n[!return!];\n}\n```\n\n#### Common fixes\n\nAdd an expression that computes the value to be returned:\n\n```dart\nint f() {\nreturn 0;\n}\n```"
      },
      {
        "real_name": "sdk_version_as_expression_in_const_context",
        "display_name": "SdkVersionAsExpressionInConstContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The use of an as expression in a constant expression wasn't supported until version 2.3.2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an as expression inside a\n[constant context](#constant-context) is found in code that has an SDK\nconstraint whose lower bound is less than 2.3.2. Using an as expression in\na [constant context](#constant-context) wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nconst num n = 3;\nconst int i = [!n as int!];\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the expression to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use an as expression, or change the code so that the as\nexpression is not in a [constant context](#constant-context).:\n\n```dart\nnum x = 3;\nint y = x as int;\n```"
      },
      {
        "real_name": "sdk_version_async_exported_from_core",
        "display_name": "SdkVersionAsyncExportedFromCore",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' wasn't exported from 'dart:core' until version 2.1",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "async' or updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when either the class `Future` or\n`Stream` is referenced in a library that doesn't import `dart:async` in\ncode that has an SDK constraint whose lower bound is less than 2.1.0. In\nearlier versions, these classes weren't defined in `dart:core`, so the\nimport was necessary.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.1.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.0.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nvoid f([!Future!] f) {}\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the classes to be referenced:\n\n```yaml\nenvironment:\nsdk: '>=2.1.0 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then import the\n`dart:async` library.\n\n```dart\nimport 'dart:async';\n\nvoid f(Future f) {}\n```"
      },
      {
        "real_name": "sdk_version_bool_operator_in_const_context",
        "display_name": "SdkVersionBoolOperatorInConstContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The use of the operator '{0}' for 'bool' operands in a constant context wasn't supported until version 2.3.2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when any use of the `&`, `|` or `^`\noperators on the class `bool` inside a\n[constant context](#constant-context) is found in code that has an SDK\nconstraint whose lower bound is less than 2.3.2. Using these operators in a\n[constant context](#constant-context) wasn't supported in earlier versions,\nso this code won't be able to run against earlier versions of the SDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nconst bool a = true;\nconst bool b = false;\nconst bool c = a [!&!] b;\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operators to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use these operators, or change the code so that the expression\nis not in a [constant context](#constant-context).:\n\n```dart\nconst bool a = true;\nconst bool b = false;\nbool c = a & b;\n```"
      },
      {
        "real_name": "sdk_version_eq_eq_operator_in_const_context",
        "display_name": "SdkVersionEqEqOperatorInConstContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Using the operator '==' for non-primitive types wasn't supported until version 2.3.2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the operator `==` is used on a\nnon-primitive type inside a [constant context](#constant-context) is found\nin code that has an SDK constraint whose lower bound is less than 2.3.2.\nUsing this operator in a [constant context](#constant-context) wasn't\nsupported in earlier versions, so this code won't be able to run against\nearlier versions of the SDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nclass C {}\nconst C a = null;\nconst C b = null;\nconst bool same = a [!==!] b;\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operator to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use the `==` operator, or change the code so that the\nexpression is not in a [constant context](#constant-context).:\n\n```dart\nclass C {}\nconst C a = null;\nconst C b = null;\nbool same = a == b;\n```"
      },
      {
        "real_name": "sdk_version_extension_methods",
        "display_name": "SdkVersionExtensionMethods",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Extension methods weren't supported until version 2.6.0",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an extension declaration or an\nextension override is found in code that has an SDK constraint whose lower\nbound is less than 2.6.0. Using extensions wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.6.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.4.0 <2.7.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\n[!extension!] E on String {\nvoid sayHello() {\nprint('Hello $this');\n}\n}\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.6.0 <2.7.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot make use of extensions. The most common way to do this is to rewrite\nthe members of the extension as top-level functions (or methods) that take\nthe value that would have been bound to `this` as a parameter:\n\n```dart\nvoid sayHello(String s) {\nprint('Hello $s');\n}\n```"
      },
      {
        "real_name": "sdk_version_gt_gt_gt_operator",
        "display_name": "SdkVersionGtGtGtOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator '>>>' wasn't supported until version 2.3.2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n\nThe analyzer produces this diagnostic when the operator `>>>` is used in\ncode that has an SDK constraint whose lower bound is less than 2.X.0. This\noperator wasn't supported in earlier versions, so this code won't be able\nto run against earlier versions of the SDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.X.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.0.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nint x = 3 [!>>>!] 4;\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operator to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot use the `>>>` operator:\n\n```dart\nint x = logicalShiftRight(3, 4);\n\nint logicalShiftRight(int leftOperand, int rightOperand) {\nint divisor = 1 << rightOperand;\nif (divisor == 0) {\nreturn 0;\n}\nreturn leftOperand ~/ divisor;\n}\n``` */"
      },
      {
        "real_name": "sdk_version_is_expression_in_const_context",
        "display_name": "SdkVersionIsExpressionInConstContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The use of an is expression in a constant context wasn't supported until version 2.3.2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an is expression inside a\n[constant context](#constant-context) is found in code that has an SDK\nconstraint whose lower bound is less than 2.3.2. Using an is expression in\na [constant context](#constant-context) wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nconst x = 4;\nconst y = [!x is int!] ? 0 : 1;\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the expression to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.3.2 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then either rewrite the\ncode to not use the is operator, or, if that's not possible, change the\ncode so that the is expression is not in a\n[constant context](#constant-context).:\n\n```dart\nconst x = 4;\nvar y = x is int ? 0 : 1;\n```"
      },
      {
        "real_name": "sdk_version_never",
        "display_name": "SdkVersionNever",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type Never is not yet supported.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n\nThe analyzer produces this diagnostic when a reference to the class `Never`\nis found in code that has an SDK constraint whose lower bound is less than\n2.X.0. This class wasn't defined in earlier versions, so this code won't be\nable to run against earlier versions of the SDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.X.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.5.0 <2.6.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\n[!Never!] n;\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the type to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.X.0 <2.7.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot reference this class:\n\n```dart\ndynamic x;\n``` */\nTODO(brianwilkerson) Replace the message with the following when we know\nwhen this feature will ship:\nThe type 'Never' wasn't supported until version 2.X.0, but this code\nis required to be able to run on earlier versions."
      },
      {
        "real_name": "sdk_version_set_literal",
        "display_name": "SdkVersionSetLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Set literals weren't supported until version 2.2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a set literal is found in code\nthat has an SDK constraint whose lower bound is less than 2.2.0. Set\nliterals weren't supported in earlier versions, so this code won't be able\nto run against earlier versions of the SDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.2.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.1.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces this\ndiagnostic:\n\n```dart\nvar s = [!<int>{}!];\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.2.0 <2.4.0'\n```\n\nIf you do need to support older versions of the SDK, then replace the set\nliteral with code that creates the set without the use of a literal:\n\n```dart\nvar s = new Set<int>();\n```"
      },
      {
        "real_name": "sdk_version_ui_as_code",
        "display_name": "SdkVersionUiAsCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The for",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a for, if, or spread element is\nfound in code that has an SDK constraint whose lower bound is less than\n2.3.0. Using a for, if, or spread element wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.2.0 <2.4.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nvar digits = [[!for (int i = 0; i < 10; i++) i!]];\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.3.0 <2.4.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot make use of those elements:\n\n```dart\nvar digits = _initializeDigits();\n\nList<int> _initializeDigits() {\nvar digits = <int>[];\nfor (int i = 0; i < 10; i++) {\ndigits.add(i);\n}\nreturn digits;\n}\n```"
      },
      {
        "real_name": "sdk_version_ui_as_code_in_const_context",
        "display_name": "SdkVersionUiAsCodeInConstContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The if and spread elements weren't supported in constant expressions until version 2.5.0",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try updating the SDK constraints.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when an if or spread element inside\na [constant context](#constant-context) is found in code that has an\nSDK constraint whose lower bound is less than 2.5.0. Using an if or\nspread element inside a [constant context](#constant-context) wasn't\nsupported in earlier versions, so this code won't be able to run against\nearlier versions of the SDK.\n\n#### Examples\n\nHere's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.5.0:\n\n```yaml\n%uri=\"pubspec.yaml\"\nenvironment:\nsdk: '>=2.4.0 <2.6.0'\n```\n\nIn the package that has that pubspec, code like the following produces\nthis diagnostic:\n\n```dart\nconst a = [1, 2];\nconst b = [[!...a!]];\n```\n\n#### Common fixes\n\nIf you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:\n\n```yaml\nenvironment:\nsdk: '>=2.5.0 <2.6.0'\n```\n\nIf you need to support older versions of the SDK, then rewrite the code to\nnot make use of those elements:\n\n```dart\nconst a = [1, 2];\nconst b = [1, 2];\n```\n\nIf that's not possible, change the code so that the element is not in a\n[constant context](#constant-context).:\n\n```dart\nconst a = [1, 2];\nvar b = [...a];\n```"
      },
      {
        "real_name": "set_element_from_deferred_library",
        "display_name": "SetElementFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "set element from deferred library",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "set element from deferred library"
      },
      {
        "real_name": "set_element_type_not_assignable",
        "display_name": "SetElementTypeNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The element type '{0}' can't be assigned to the set type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the actual type of the set element\n1: the expected type of the set element\n"
      },
      {
        "real_name": "setter_constructor",
        "display_name": "SetterConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "setter constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "setter constructor"
      },
      {
        "real_name": "setter_in_function",
        "display_name": "SetterInFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "setter in function",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "setter in function"
      },
      {
        "real_name": "setting_orientation_on_activity",
        "display_name": "SettingOrientationOnActivity",
        "severity": "warning",
        "category": "convention",
        "rule_title": "setting orientation on activity",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "setting orientation on activity"
      },
      {
        "real_name": "shared_deferred_prefix",
        "display_name": "SharedDeferredPrefix",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The prefix of a deferred import can't be used in other import directives.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try renaming one of the prefixes.",
        "owner": null,
        "labels": [],
        "description": "14.1 Imports: It is a compile-time error if a prefix used in a deferred\nimport is used in another import clause.\n"
      },
      {
        "real_name": "spec_mode_removed",
        "display_name": "SpecModeRemoved",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The option 'strong-mode: false' is no longer supported.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "' setting and make your code Dart 2 compliant).",
        "owner": null,
        "labels": [],
        "description": "An error code indicating that strong-mode: false is has been removed.\n"
      },
      {
        "real_name": "spread_expression_from_deferred_library",
        "display_name": "SpreadExpressionFromDeferredLibrary",
        "severity": "warning",
        "category": "convention",
        "rule_title": "spread expression from deferred library",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "spread expression from deferred library"
      },
      {
        "real_name": "stack_overflow",
        "display_name": "StackOverflow",
        "severity": "warning",
        "category": "convention",
        "rule_title": "stack overflow",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "stack overflow"
      },
      {
        "real_name": "static_access_to_instance_member",
        "display_name": "StaticAccessToInstanceMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Instance member '{0}' can't be accessed using static access.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the instance member\n#### Description\n\nThe analyzer produces this diagnostic when a class name is used to access\nan instance field. Instance fields don't exist on a class; they exist only\non an instance of the class.\n\n#### Examples\n\nThe following code produces this diagnostic because `x` is an instance\nfield:\n\n```dart\nclass C {\nstatic int a;\n\nint b;\n}\n\nint f() => C.[!b!];\n```\n\n#### Common fixes\n\nIf you intend to access a static field, then change the name of the field\nto an existing static field:\n\n```dart\nclass C {\nstatic int a;\n\nint b;\n}\n\nint f() => C.a;\n```\n\nIf you intend to access the instance field, then use an instance of the\nclass to access the field:\n\n```dart\nclass C {\nstatic int a;\n\nint b;\n}\n\nint f(C c) => c.b;\n```"
      },
      {
        "real_name": "static_after_const",
        "display_name": "StaticAfterConst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static after const",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static after const"
      },
      {
        "real_name": "static_after_final",
        "display_name": "StaticAfterFinal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static after final",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static after final"
      },
      {
        "real_name": "static_after_var",
        "display_name": "StaticAfterVar",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static after var",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static after var"
      },
      {
        "real_name": "static_constructor",
        "display_name": "StaticConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static constructor"
      },
      {
        "real_name": "static_getter_without_body",
        "display_name": "StaticGetterWithoutBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static getter without body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static getter without body"
      },
      {
        "real_name": "static_operator",
        "display_name": "StaticOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static operator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static operator"
      },
      {
        "real_name": "static_setter_without_body",
        "display_name": "StaticSetterWithoutBody",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static setter without body",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static setter without body"
      },
      {
        "real_name": "static_top_level_declaration",
        "display_name": "StaticTopLevelDeclaration",
        "severity": "warning",
        "category": "convention",
        "rule_title": "static top level declaration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "static top level declaration"
      },
      {
        "real_name": "strict_raw_type",
        "display_name": "StrictRawType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The generic type '{0}' should have explicit type arguments but doesn't.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Use explicit type arguments for '{0}'.",
        "owner": null,
        "labels": [],
        "description": "When \"strict-raw-types\" is enabled, raw types must be inferred via the\ncontext type, or have type arguments.\n"
      },
      {
        "real_name": "strong_mode_setting_deprecated",
        "display_name": "StrongModeSettingDeprecated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The 'strong-mode: true' setting is deprecated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "It is no longer necessary to explicitly enable strong mode.",
        "owner": null,
        "labels": [],
        "description": "An error code indicating that strong-mode: true is deprecated.\n"
      },
      {
        "real_name": "subtype_of_ffi_class_in_extends",
        "display_name": "SubtypeOfFfiClassInExtends",
        "severity": "warning",
        "category": "convention",
        "rule_title": "message: The class '{0}' can't extend '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending 'Struct'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the subclass\n1: the name of the class being extended, implemented, or mixed in\n"
      },
      {
        "real_name": "subtype_of_ffi_class_in_implements",
        "display_name": "SubtypeOfFfiClassInImplements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "message: The class '{0}' can't implement '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending 'Struct'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the subclass\n1: the name of the class being extended, implemented, or mixed in\n"
      },
      {
        "real_name": "subtype_of_ffi_class_in_with",
        "display_name": "SubtypeOfFfiClassInWith",
        "severity": "warning",
        "category": "convention",
        "rule_title": "message: The class '{0}' can't mix in '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending 'Struct'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the subclass\n1: the name of the class being extended, implemented, or mixed in\n"
      },
      {
        "real_name": "subtype_of_sealed_class",
        "display_name": "SubtypeOfSealedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' shouldn't be extended",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try composing instead of inheritin",
        "owner": null,
        "labels": [],
        "description": "This hint is generated anywhere where a `@sealed` class or mixin is used as\na super-type of a class.\n"
      },
      {
        "real_name": "subtype_of_struct_class_in_extends",
        "display_name": "SubtypeOfStructClassInExtends",
        "severity": "warning",
        "category": "convention",
        "rule_title": "message: The class '{0}' can't extend '{1}' because '{1}' is a subtype of 'Struct'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending 'Struct' directly.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the subclass\n1: the name of the class being extended, implemented, or mixed in\n"
      },
      {
        "real_name": "subtype_of_struct_class_in_implements",
        "display_name": "SubtypeOfStructClassInImplements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "message: The class '{0}' can't implement '{1}' because '{1}' is a subtype of 'Struct'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending 'Struct' directly.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the subclass\n1: the name of the class being extended, implemented, or mixed in\n"
      },
      {
        "real_name": "subtype_of_struct_class_in_with",
        "display_name": "SubtypeOfStructClassInWith",
        "severity": "warning",
        "category": "convention",
        "rule_title": "message: The class '{0}' can't mix in '{1}' because '{1}' is a subtype of 'Struct'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try extending 'Struct' directly.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the subclass\n1: the name of the class being extended, implemented, or mixed in\n"
      },
      {
        "real_name": "super_in_extension",
        "display_name": "SuperInExtension",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The 'super' keyword can't be used in an extension because an extension doesn't have a superclass.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a member declared inside an\nextension uses the `super` keyword . Extensions aren't classes and don't\nhave superclasses, so the `super` keyword serves no purpose.\n\n#### Examples\n\nThe following code produces this diagnostic because `super` can't be used\nin an extension:\n\n```dart\nextension E on Object {\nString get displayString => [!super!].toString();\n}\n```\n\n#### Common fixes\n\nRemove the `super` keyword :\n\n```dart\nextension E on Object {\nString get displayString => toString();\n}\n```"
      },
      {
        "real_name": "super_in_invalid_context",
        "display_name": "SuperInInvalidContext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Invalid context for 'super' invocation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the keyword `super` is used\noutside of a instance method.\n\n#### Examples\n\nThe following code produces this diagnostic because `super` is used in a\ntop-level function:\n\n```dart\nvoid f() {\n[!super!].f();\n}\n```\n\n#### Common fixes\n\nRewrite the code to not use `super`."
      },
      {
        "real_name": "super_in_redirecting_constructor",
        "display_name": "SuperInRedirectingConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The redirecting constructor can't have a 'super' initializer.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: A generative constructor may be redirecting,\nin which case its only action is to invoke another generative constructor.\n"
      },
      {
        "real_name": "super_initializer_in_object",
        "display_name": "SuperInitializerInObject",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class 'Object' can't invoke a constructor from a superclass.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.6.1 Generative Constructors: Let <i>k</i> be a generative constructor. It\nis a compile-time error if a generative constructor of class Object\nincludes a superinitializer.\n"
      },
      {
        "real_name": "super_mixins_setting_deprecated",
        "display_name": "SuperMixinsSettingDeprecated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The 'enableSuperMixins' setting is deprecated.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Support has been added to the language for 'mixin' based mixins.",
        "owner": null,
        "labels": [],
        "description": "An error code indicating that the enablePreviewDart2 setting is deprecated.\n"
      },
      {
        "real_name": "switch_case_completes_normally",
        "display_name": "SwitchCaseCompletesNormally",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The 'case' should not complete normally.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding 'break",
        "owner": null,
        "labels": [],
        "description": "\n/ It is an error if any case of a switch statement except the last case\n/ (the default case if present) may complete normally. The previous\n/ syntactic restriction requiring the last statement of each case to be\n/ one of an enumerated list of statements (break, continue, return,\n/ throw, or rethrow) is removed."
      },
      {
        "real_name": "switch_expression_not_assignable",
        "display_name": "SwitchExpressionNotAssignable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Type '{0}' of the switch expression isn't assignable to the type '{1}' of case expressions.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "13.9 Switch: It is a static warning if the type of <i>e</i> may not be\nassigned to the type of <i>e<sub>k</sub></i>.\n"
      },
      {
        "real_name": "switch_has_case_after_default_case",
        "display_name": "SwitchHasCaseAfterDefaultCase",
        "severity": "warning",
        "category": "convention",
        "rule_title": "switch has case after default case",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "switch has case after default case"
      },
      {
        "real_name": "switch_has_multiple_default_cases",
        "display_name": "SwitchHasMultipleDefaultCases",
        "severity": "warning",
        "category": "convention",
        "rule_title": "switch has multiple default cases",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "switch has multiple default cases"
      },
      {
        "real_name": "throw_of_invalid_type",
        "display_name": "ThrowOfInvalidType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "throw of invalid type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "throw of invalid type"
      },
      {
        "real_name": "todo",
        "display_name": "Todo",
        "severity": "warning",
        "category": "convention",
        "rule_title": "todo",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "This matches the two common Dart task styles.\n* TODO:\n* TODO(username):\n\nAs well as\n* TODO\n\nBut not\n* todo\n* TODOS\n"
      },
      {
        "real_name": "top_level_cycle",
        "display_name": "TopLevelCycle",
        "severity": "warning",
        "category": "convention",
        "rule_title": "top level cycle",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "top level cycle"
      },
      {
        "real_name": "top_level_function_literal_block",
        "display_name": "TopLevelFunctionLiteralBlock",
        "severity": "warning",
        "category": "convention",
        "rule_title": "top level function literal block",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "top level function literal block"
      },
      {
        "real_name": "top_level_identifier_no_type",
        "display_name": "TopLevelIdentifierNoType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "top level identifier no type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "top level identifier no type"
      },
      {
        "real_name": "top_level_instance_getter",
        "display_name": "TopLevelInstanceGetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "top level instance getter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "top level instance getter"
      },
      {
        "real_name": "top_level_instance_method",
        "display_name": "TopLevelInstanceMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "top level instance method",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "top level instance method"
      },
      {
        "real_name": "top_level_operator",
        "display_name": "TopLevelOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "top level operator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "top level operator"
      },
      {
        "real_name": "type_alias_cannot_reference_itself",
        "display_name": "TypeAliasCannotReferenceItself",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Typedefs can't reference themselves directly or recursively via another typedef.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "15.3.1 Typedef: Any self reference, either directly, or recursively via\nanother typedef, is a compile time error.\n"
      },
      {
        "real_name": "type_annotation_deferred_class",
        "display_name": "TypeAnnotationDeferredClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The deferred type '{0}' can't be used in a declaration",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a different typ",
        "owner": null,
        "labels": [],
        "description": "15.1 Static Types: It is a static warning to use a deferred type in a type\nannotation.\n\nParameters:\n0: the name of the type that is deferred and being used in a type\nannotation\n"
      },
      {
        "real_name": "type_argument_not_matching_bounds",
        "display_name": "TypeArgumentNotMatchingBounds",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' doesn't extend '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a type that is or is a subclass of '{1}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the type used in the instance creation that should be\nlimited by the bound as specified in the class declaration\n1: the name of the bounding type\n#### Description\n\nThe analyzer produces this diagnostic when a type argument isn't the same\nas or a subclass of the bounds of the corresponding type parameter.\n\n#### Examples\n\nThe following code produces this diagnostic because `String` isn't a\nsubclass of `num`:\n\n```dart\nclass A<E extends num> {}\n\nvar a = A<[!String!]>();\n```\n\n#### Common fixes\n\nChange the type argument to be a subclass of the bounds:\n\n```dart\nclass A<E extends num> {}\n\nvar a = A<int>();\n```"
      },
      {
        "real_name": "type_arguments_on_type_variable",
        "display_name": "TypeArgumentsOnTypeVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "type arguments on type variable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "type arguments on type variable"
      },
      {
        "real_name": "type_before_factory",
        "display_name": "TypeBeforeFactory",
        "severity": "warning",
        "category": "convention",
        "rule_title": "type before factory",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "type before factory"
      },
      {
        "real_name": "type_check_is_not_null",
        "display_name": "TypeCheckIsNotNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Tests for non-null should be done with '!= null'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the 'is! Null' check with '!= null'.",
        "owner": null,
        "labels": [],
        "description": "Type checks of the type `x is! Null` should be done with `x != null`.\n"
      },
      {
        "real_name": "type_check_is_null",
        "display_name": "TypeCheckIsNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Tests for null should be done with '== null'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing the 'is Null' check with '== null'.",
        "owner": null,
        "labels": [],
        "description": "Type checks of the type `x is Null` should be done with `x == null`.\n"
      },
      {
        "real_name": "type_parameter_on_constructor",
        "display_name": "TypeParameterOnConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "type parameter on constructor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "type parameter on constructor"
      },
      {
        "real_name": "type_parameter_on_operator",
        "display_name": "TypeParameterOnOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Types parameters aren't allowed when defining an operator.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the type parameters.",
        "owner": null,
        "labels": [],
        "description": "7.1.1 Operators: Type parameters are not syntactically supported on an\noperator.\n"
      },
      {
        "real_name": "type_parameter_referenced_by_static",
        "display_name": "TypeParameterReferencedByStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Static members can't reference type parameters of the class.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the reference to the type paramete",
        "owner": null,
        "labels": [],
        "description": "10 Generics: However, a type parameter is considered to be a malformed type\nwhen referenced by a static member.\n\n15.1 Static Types: Any use of a malformed type gives rise to a static\nwarning. A malformed type is then interpreted as dynamic by the static type\nchecker and the runtime.\n"
      },
      {
        "real_name": "type_parameter_supertype_of_its_bound",
        "display_name": "TypeParameterSupertypeOfItsBound",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be a supertype of its upper bound.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using a type that is or is a subclass of '{1}'.",
        "owner": null,
        "labels": [],
        "description": "10 Generics: It is a static type warning if a type parameter is a supertype\nof its upper bound.\n\nParameters:\n0: the name of the type parameter\n1: the name of the bounding type\n\nSee [CompileTimeErrorCode.TYPE_ARGUMENT_NOT_MATCHING_BOUNDS].\n"
      },
      {
        "real_name": "type_test_with_non_type",
        "display_name": "TypeTestWithNonType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't a type and can't be used in an 'is' expression.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to match an existing type.",
        "owner": null,
        "labels": [],
        "description": "12.31 Type Test: It is a static warning if <i>T</i> does not denote a type\navailable in the current lexical scope.\n"
      },
      {
        "real_name": "type_test_with_undefined_name",
        "display_name": "TypeTestWithUndefinedName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' isn't defined",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the name to the name of an existing typ",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the name following the `is` in a\ntype test expression isn't defined.\n\n#### Examples\n\nThe following code produces this diagnostic because the name `Srting` isn't\ndefined:\n\n```dart\nvoid f(Object o) {\nif (o is [!Srting!]) {\n// ...\n}\n}\n```\n\n#### Common fixes\n\nReplace the name with the name of a type:\n\n```dart\nvoid f(Object o) {\nif (o is String) {\n// ...\n}\n}\n```"
      },
      {
        "real_name": "typedef_in_class",
        "display_name": "TypedefInClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "typedef in class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "typedef in class"
      },
      {
        "real_name": "unable_get_content",
        "display_name": "UnableGetContent",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unable get content",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unable get content"
      },
      {
        "real_name": "unchecked_use_of_nullable_value",
        "display_name": "UncheckedUseOfNullableValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The expression is nullable and must be null-checked before it can be used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try checking that the value isn't null before using it.",
        "owner": null,
        "labels": [],
        "description": "For the purposes of experimenting with potential non-null type semantics.\n\nNo parameters.\n"
      },
      {
        "real_name": "undefined_annotation",
        "display_name": "UndefinedAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Undefined name '{0}' used as an annotation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try defining the name or importing it from another library.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a name that isn't defined is\nused as an annotation.\n\n#### Examples\n\nThe following code produces this diagnostic because the name `undefined`\nisn't defined:\n\n```dart\n[!@undefined!]\nvoid f() {}\n```\n\n#### Common fixes\n\nIf the name is correct, but it isn’t declared yet, then declare the name as\na constant value:\n\n```dart\nconst undefined = 'undefined';\n\n@undefined\nvoid f() {}\n```\n\nIf the name is wrong, replace the name with the name of a valid constant:\n\n```dart\n@deprecated\nvoid f() {}\n```\n\nOtherwise, remove the annotation."
      },
      {
        "real_name": "undefined_class",
        "display_name": "UndefinedClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Undefined class '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try changing the name to the name of an existing clas",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the undefined class\n#### Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a class but either isn't defined or isn't visible\nin the scope in which it's being referenced.\n\n#### Examples\n\nThe following code produces this diagnostic because `Piont` isn't defined:\n\n```dart\nclass Point {}\n\nvoid f([!Piont!] p) {}\n```\n\n#### Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a class that is defined. The example above can be corrected by\nfixing the spelling of the class:\n\n```dart\nclass Point {}\n\nvoid f(Point p) {}\n```\n\nIf the class is defined but isn't visible, then you probably need to add an\nimport."
      },
      {
        "real_name": "undefined_class_boolean",
        "display_name": "UndefinedClassBoolean",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Undefined class 'boolean'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using the type 'bool'.",
        "owner": null,
        "labels": [],
        "description": "Same as [CompileTimeErrorCode.UNDEFINED_CLASS], but to catch using\n\"boolean\" instead of \"bool\".\n"
      },
      {
        "real_name": "undefined_constructor_in_initializer",
        "display_name": "UndefinedConstructorInInitializer",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' doesn't have a constructor named '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try defining a constructor named '{1}' in '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the superclass that does not define the invoked constructor\n1: the name of the constructor being invoked\n#### Description\n\nThe analyzer produces this diagnostic when a superclass constructor is\ninvoked in the initializer list of a constructor, but the superclass\ndoesn't define the constructor being invoked.\n\n#### Examples\n\nThe following code produces this diagnostic because `A` doesn't have an\nunnamed constructor:\n\n```dart\nclass A {\nA.n();\n}\nclass B extends A {\nB() : [!super()!];\n}\n```\n\nThe following code produces this diagnostic because `A` doesn't have a\nconstructor named `m`:\n\n```dart\nclass A {\nA.n();\n}\nclass B extends A {\nB() : [!super.m()!];\n}\n```\n\n#### Common fixes\n\nIf the superclass defines a constructor that should be invoked, then change\nthe constructor being invoked:\n\n```dart\nclass A {\nA.n();\n}\nclass B extends A {\nB() : super.n();\n}\n```\n\nIf the superclass doesn't define an appropriate constructor, then define\nthe constructor being invoked:\n\n```dart\nclass A {\nA.m();\nA.n();\n}\nclass B extends A {\nB() : super.m();\n}\n```"
      },
      {
        "real_name": "undefined_constructor_in_initializer_default",
        "display_name": "UndefinedConstructorInInitializerDefault",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The class '{0}' doesn't have an unnamed constructor.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try defining an unnamed constructor in '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the superclass that does not define the invoked constructor\n"
      },
      {
        "real_name": "undefined_enum_constant",
        "display_name": "UndefinedEnumConstant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "There is no constant named '{0}' in '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing constan",
        "owner": null,
        "labels": [],
        "description": "12.17 Getter Invocation: It is a static warning if there is no class\n<i>C</i> in the enclosing lexical scope of <i>i</i>, or if <i>C</i> does\nnot declare, implicitly or explicitly, a getter named <i>m</i>.\n\nParameters:\n0: the name of the enumeration constant that is not defined\n1: the name of the enumeration used to access the constant\n"
      },
      {
        "real_name": "undefined_extension_getter",
        "display_name": "UndefinedExtensionGetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The getter '{0}' isn't defined for the extension '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing gette",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the getter that is undefined\n1: the name of the extension that was explicitly specified\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a getter, but the getter isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static getter is\nreferenced but isn't defined by the specified extension.\n\n#### Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare an instance getter named `b`:\n\n```dart\nextension E on String {\nString get a => 'a';\n}\n\nextension F on String {\nString get b => 'b';\n}\n\nvoid f() {\nE('c').[!b!];\n}\n```\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare a static getter named `a`:\n\n```dart\nextension E on String {}\n\nvar x = E.[!a!];\n```\n\n#### Common fixes\n\nIf the name of the getter is incorrect, then change it to the name of an\nexisting getter:\n\n```dart\nextension E on String {\nString get a => 'a';\n}\n\nextension F on String {\nString get b => 'b';\n}\n\nvoid f() {\nE('c').a;\n}\n```\n\nIf the name of the getter is correct but the name of the extension is\nwrong, then change the name of the extension to the correct name:\n\n```dart\nextension E on String {\nString get a => 'a';\n}\n\nextension F on String {\nString get b => 'b';\n}\n\nvoid f() {\nF('c').b;\n}\n```\n\nIf the name of the getter and extension are both correct, but the getter\nisn't defined, then define the getter:\n\n```dart\nextension E on String {\nString get a => 'a';\nString get b => 'z';\n}\n\nextension F on String {\nString get b => 'b';\n}\n\nvoid f() {\nE('c').b;\n}\n```"
      },
      {
        "real_name": "undefined_extension_method",
        "display_name": "UndefinedExtensionMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The method '{0}' isn't defined for the extension '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing metho",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the method that is undefined\n1: the name of the extension that was explicitly specified\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a method, but the method isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static method is\nreferenced but isn't defined by the specified extension.\n\n#### Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare an instance method named `b`:\n\n```dart\nextension E on String {\nString a() => 'a';\n}\n\nextension F on String {\nString b() => 'b';\n}\n\nvoid f() {\nE('c').[!b!]();\n}\n```\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare a static method named `a`:\n\n```dart\nextension E on String {}\n\nvar x = E.[!a!]();\n```\n\n#### Common fixes\n\nIf the name of the method is incorrect, then change it to the name of an\nexisting method:\n\n```dart\nextension E on String {\nString a() => 'a';\n}\n\nextension F on String {\nString b() => 'b';\n}\n\nvoid f() {\nE('c').a();\n}\n```\n\nIf the name of the method is correct, but the name of the extension is\nwrong, then change the name of the extension to the correct name:\n\n```dart\nextension E on String {\nString a() => 'a';\n}\n\nextension F on String {\nString b() => 'b';\n}\n\nvoid f() {\nF('c').b();\n}\n```\n\nIf the name of the method and extension are both correct, but the method\nisn't defined, then define the method:\n\n```dart\nextension E on String {\nString a() => 'a';\nString b() => 'z';\n}\n\nextension F on String {\nString b() => 'b';\n}\n\nvoid f() {\nE('c').b();\n}\n```"
      },
      {
        "real_name": "undefined_extension_operator",
        "display_name": "UndefinedExtensionOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator '{0}' isn't defined for the extension '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try defining the operator '{0}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the operator that is undefined\n1: the name of the extension that was explicitly specified\n"
      },
      {
        "real_name": "undefined_extension_setter",
        "display_name": "UndefinedExtensionSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The setter '{0}' isn't defined for the extension '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing sette",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the setter that is undefined\n1: the name of the extension that was explicitly specified\n#### Description\n\nThe analyzer produces this diagnostic when an extension override is used to\ninvoke a setter, but the setter isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static setter is\nreferenced but isn't defined by the specified extension.\n\n#### Examples\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare an instance setter named `b`:\n\n```dart\nextension E on String {\nset a(String v) {}\n}\n\nextension F on String {\nset b(String v) {}\n}\n\nvoid f() {\nE('c').[!b!] = 'd';\n}\n```\n\nThe following code produces this diagnostic because the extension `E`\ndoesn't declare a static setter named `a`:\n\n```dart\nextension E on String {}\n\nvoid f() {\nE.[!a!] = 3;\n}\n```\n\n#### Common fixes\n\nIf the name of the setter is incorrect, then change it to the name of an\nexisting setter:\n\n```dart\nextension E on String {\nset a(String v) {}\n}\n\nextension F on String {\nset b(String v) {}\n}\n\nvoid f() {\nE('c').a = 'd';\n}\n```\n\nIf the name of the setter is correct, but the name of the extension is\nwrong, then change the name of the extension to the correct name:\n\n```dart\nextension E on String {\nset a(String v) {}\n}\n\nextension F on String {\nset b(String v) {}\n}\n\nvoid f() {\nF('c').b = 'd';\n}\n```\n\nIf the name of the setter and extension are both correct, but the setter\nisn't defined, then define the setter:\n\n```dart\nextension E on String {\nset a(String v) {}\nset b(String v) {}\n}\n\nextension F on String {\nset b(String v) {}\n}\n\nvoid f() {\nE('c').b = 'd';\n}\n```"
      },
      {
        "real_name": "undefined_function",
        "display_name": "UndefinedFunction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The function '{0}' isn't defined.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try importing the library that defines '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the method that is undefined\n#### Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a function but either isn't defined or isn't\nvisible in the scope in which it's being referenced.\n\n#### Examples\n\nThe following code produces this diagnostic because the name `emty` isn't\ndefined:\n\n```dart\nList<int> empty() => [];\n\nvoid main() {\nprint([!emty!]());\n}\n```\n\n#### Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a function that is defined. The example above can be corrected\nby fixing the spelling of the function:\n\n```dart\nList<int> empty() => [];\n\nvoid main() {\nprint(empty());\n}\n```\n\nIf the function is defined but isn't visible, then you probably need to add\nan import or re-arrange your code to make the function visible."
      },
      {
        "real_name": "undefined_getter",
        "display_name": "UndefinedGetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The getter '{0}' isn't defined for the type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try importing the library that defines '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the getter\n1: the name of the enclosing type where the getter is being looked for\n#### Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a getter but either isn't defined or isn't\nvisible in the scope in which it's being referenced.\n\n#### Examples\n\nThe following code produces this diagnostic because `String` has no member\nnamed `len`:\n\n```dart\nint f(String s) => s.[!len!];\n```\n\n#### Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a getter that is defined. The example above can be corrected by\nfixing the spelling of the getter:\n\n```dart\nint f(String s) => s.length;\n```"
      },
      {
        "real_name": "undefined_hidden_name",
        "display_name": "UndefinedHiddenName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The library '{0}' doesn't export a member with the hidden name '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the name from the list of hidden members.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the library being imported\n1: the name in the hide clause that isn't defined in the library\n#### Description\n\nThe analyzer produces this diagnostic when a hide combinator includes a\nname that isn't defined by the library being imported.\n\n#### Examples\n\nThe following code produces this diagnostic because `dart:math` doesn't\ndefine the name `String`:\n\n```dart\nimport 'dart:math' hide [!String!], max;\n\nvar x = min(0, 1);\n```\n\n#### Common fixes\n\nIf a different name should be hidden, then correct the name. Otherwise,\nremove the name from the list:\n\n```dart\nimport 'dart:math' hide max;\n\nvar x = min(0, 1);\n```"
      },
      {
        "real_name": "undefined_identifier",
        "display_name": "UndefinedIdentifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Undefined name '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to one that is define",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the identifier\n#### Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\neither isn't defined or isn't visible in the scope in which it's being\nreferenced.\n\n#### Examples\n\nThe following code produces this diagnostic because the name `rihgt` isn't\ndefined:\n\n```dart\nint min(int left, int right) => left <= [!rihgt!] ? left : right;\n```\n\n#### Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nan identifier that is defined. The example above can be corrected by\nfixing the spelling of the variable:\n\n```dart\nint min(int left, int right) => left <= right ? left : right;\n```\n\nIf the identifier is defined but isn't visible, then you probably need to\nadd an import or re-arrange your code to make the identifier visible."
      },
      {
        "real_name": "undefined_identifier_await",
        "display_name": "UndefinedIdentifierAwait",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Undefined name 'await' in function body not marked with 'async'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to one that is define",
        "owner": null,
        "labels": [],
        "description": "If the identifier is 'await', be helpful about it.\n"
      },
      {
        "real_name": "undefined_method",
        "display_name": "UndefinedMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The method '{0}' isn't defined for the type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing metho",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the method that is undefined\n1: the resolved type name that the method lookup is happening on\n#### Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a method but either isn't defined or isn't\nvisible in the scope in which it's being referenced.\n\n#### Examples\n\nThe following code produces this diagnostic because the identifier\n`removeMiddle` isn't defined:\n\n```dart\nint f(List<int> l) => l.[!removeMiddle!]();\n```\n\n#### Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a method that is defined. The example above can be corrected by\nfixing the spelling of the method:\n\n```dart\nint f(List<int> l) => l.removeLast();\n```"
      },
      {
        "real_name": "undefined_named_parameter",
        "display_name": "UndefinedNamedParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The named parameter '{0}' isn't defined.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to an existing named parameter's nam",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the requested named parameter\n#### Description\n\nThe analyzer produces this diagnostic when a method or function invocation\nhas a named argument, but the method or function being invoked doesn't\ndefine a parameter with the same name.\n\n#### Examples\n\nThe following code produces this diagnostic because `m` doesn't declare a\nnamed parameter named `a`:\n\n```dart\nclass C {\nm({int b}) {}\n}\n\nvoid f(C c) {\nc.m([!a!]: 1);\n}\n```\n\n#### Common fixes\n\nIf the argument name is mistyped, then replace it with the correct name.\nThe example above can be fixed by changing `a` to `b`:\n\n```dart\nclass C {\nm({int b}) {}\n}\n\nvoid f(C c) {\nc.m(b: 1);\n}\n```\n\nIf a subclass adds a parameter with the name in question, then cast the\ntarget to the subclass:\n\n```dart\nclass C {\nm({int b}) {}\n}\n\nclass D extends C {\nm({int a, int b}) {}\n}\n\nvoid f(C c) {\n(c as D).m(a: 1);\n}\n```\n\nIf the parameter should be added to the function, then add it:\n\n```dart\nclass C {\nm({int a, int b}) {}\n}\n\nvoid f(C c) {\nc.m(a: 1);\n}\n```"
      },
      {
        "real_name": "undefined_operator",
        "display_name": "UndefinedOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operator '{0}' isn't defined for the type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try defining the operator '{0}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the operator\n1: the name of the enclosing type where the operator is being looked for\n#### Description\n\nThe analyzer produces this diagnostic when a user-definable operator is\ninvoked on an object for which the operator isn't defined.\n\n#### Examples\n\nThe following code produces this diagnostic because the class `C` doesn't\ndefine the operator `+`:\n\n```dart\nclass C {}\n\nC f(C c) => c [!+!] 2;\n```\n\n#### Common fixes\n\nIf the operator should be defined for the class, then define it:\n\n```dart\nclass C {\nC operator +(int i) => this;\n}\n\nC f(C c) => c + 2;\n```"
      },
      {
        "real_name": "undefined_prefixed_name",
        "display_name": "UndefinedPrefixedName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name '{0}' is being referenced through the prefix '{1}'",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the prefix or importing the library that defines '{0}'.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a prefixed identifier is found\nwhere the prefix is valid, but the identifier isn't declared in any of the\nlibraries imported using that prefix.\n\n#### Examples\n\nThe following code produces this diagnostic because `dart:core` doesn't\ndefine anything named `a`:\n\n```dart\nimport 'dart:core' as p;\n\nvoid f() {\np.[!a!];\n}\n```\n\n#### Common fixes\n\nIf the library in which the name is declared isn't imported yet, add an\nimport for the library.\n\nIf the name is wrong, then change it to one of the names that's declared in\nthe imported libraries."
      },
      {
        "real_name": "undefined_setter",
        "display_name": "UndefinedSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The setter '{0}' isn't defined for the type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try importing the library that defines '{0}",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the setter\n1: the name of the enclosing type where the setter is being looked for\n#### Description\n\nThe analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a setter but either isn't defined or isn't\nvisible in the scope in which the identifier is being referenced.\n\n#### Examples\n\nThe following code produces this diagnostic because there isn't a setter\nnamed `z`:\n\n```dart\nclass C {\nint x = 0;\nvoid m(int y) {\nthis.[!z!] = y;\n}\n}\n```\n\n#### Common fixes\n\nIf the identifier isn't defined, then either define it or replace it with\nthe name of a setter that is defined. The example above can be corrected by\nfixing the spelling of the setter:\n\n```dart\nclass C {\nint x = 0;\nvoid m(int y) {\nthis.x = y;\n}\n}\n```"
      },
      {
        "real_name": "undefined_shown_name",
        "display_name": "UndefinedShownName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The library '{0}' doesn't export a member with the shown name '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the name from the list of shown members.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the library being imported\n1: the name in the show clause that isn't defined in the library\n#### Description\n\nThe analyzer produces this diagnostic when a show combinator includes a\nname that isn't defined by the library being imported.\n\n#### Examples\n\nThe following code produces this diagnostic because `dart:math` doesn't\ndefine the name `String`:\n\n```dart\nimport 'dart:math' show min, [!String!];\n\nvar x = min(0, 1);\n```\n\n#### Common fixes\n\nIf a different name should be shown, then correct the name. Otherwise,\nremove the name from the list:\n\n```dart\nimport 'dart:math' show min;\n\nvar x = min(0, 1);\n```"
      },
      {
        "real_name": "undefined_super_getter",
        "display_name": "UndefinedSuperGetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The getter '{0}' isn't defined in a superclass of '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing gette",
        "owner": null,
        "labels": [],
        "description": "12.17 Getter Invocation: Let <i>T</i> be the static type of <i>e</i>. It is\na static type warning if <i>T</i> does not have a getter named <i>m</i>.\n\nParameters:\n0: the name of the getter\n1: the name of the enclosing type where the getter is being looked for\n"
      },
      {
        "real_name": "undefined_super_method",
        "display_name": "UndefinedSuperMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The method '{0}' isn't defined in a superclass of '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing metho",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the method that is undefined\n1: the resolved type name that the method lookup is happening on\n#### Description\n\nThe analyzer produces this diagnostic when an inherited method is\nreferenced using `super`, but there’s no method with that name in the\nsuperclass chain.\n\n#### Examples\n\nThe following code produces this diagnostic because `Object` doesn't define\na member named `n`:\n\n```dart\nclass C {\nvoid m() {\nsuper.[!n!]();\n}\n}\n```\n\n#### Common fixes\n\nIf the inherited method you intend to invoke has a different name, then\nmake the name of the invoked method  match the inherited method.\n\nIf the method you intend to invoke is defined in the same class, then\nremove the `super.`.\n\nIf not, then either add the method to one of the superclasses or remove the\ninvocation."
      },
      {
        "real_name": "undefined_super_operator",
        "display_name": "UndefinedSuperOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "undefined super operator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "undefined super operator"
      },
      {
        "real_name": "undefined_super_setter",
        "display_name": "UndefinedSuperSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The setter '{0}' isn't defined in a superclass of '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the name to the name of an existing sette",
        "owner": null,
        "labels": [],
        "description": "12.18 Assignment: Let <i>T</i> be the static type of <i>e<sub>1</sub></i>.\nIt is a static type warning if <i>T</i> does not have an accessible\ninstance setter named <i>v=</i>.\n\nParameters:\n0: the name of the setter\n1: the name of the enclosing type where the setter is being looked for\n"
      },
      {
        "real_name": "unexpected_dollar_in_string",
        "display_name": "UnexpectedDollarInString",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unexpected dollar in string",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unexpected dollar in string"
      },
      {
        "real_name": "unexpected_terminator_for_parameter_group",
        "display_name": "UnexpectedTerminatorForParameterGroup",
        "severity": "warning",
        "category": "convention",
        "rule_title": "There is no '{0}' to open a parameter group.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try inserting the '{0}' at the appropriate location.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the starting character that was missing\n"
      },
      {
        "real_name": "unexpected_token",
        "display_name": "UnexpectedToken",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Unexpected text '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the text.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the unexpected text that was found\n"
      },
      {
        "real_name": "unnecessary_cast",
        "display_name": "UnnecessaryCast",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Unnecessary cast.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the cast.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when the value being cast is already\nknown to be of the type that it's being cast to.\n\n#### Examples\n\nThe following code produces this diagnostic because `n` is already known to\nbe an `int` as a result of the `is` test:\n\n```dart\nvoid f(num n) {\nif (n is int) {\n([!n as int!]).isEven;\n}\n}\n```\n\n#### Common fixes\n\nRemove the unnecessary cast:\n\n```dart\nvoid f(num n) {\nif (n is int) {\nn.isEven;\n}\n}\n```"
      },
      {
        "real_name": "unnecessary_no_such_method",
        "display_name": "UnnecessaryNoSuchMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Unnecessary 'noSuchMethod' declaration.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the declaration of 'noSuchMethod'.",
        "owner": null,
        "labels": [],
        "description": "Unnecessary `noSuchMethod` declaration.\n"
      },
      {
        "real_name": "unnecessary_non_null_assertion",
        "display_name": "UnnecessaryNonNullAssertion",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The '!' will have no effect because the target expression cannot be null.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the '!' operator here.",
        "owner": null,
        "labels": [],
        "description": "When the '!' operator is used on a value that we know to be non-null,\nit is unnecessary.\n"
      },
      {
        "real_name": "unnecessary_null_comparison_false",
        "display_name": "UnnecessaryNullComparisonFalse",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operand can't be null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the conditio",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "unnecessary_null_comparison_true",
        "display_name": "UnnecessaryNullComparisonTrue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The operand can't be null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Remove the condition.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n"
      },
      {
        "real_name": "unnecessary_type_check_false",
        "display_name": "UnnecessaryTypeCheckFalse",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Unnecessary type check",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the type chec",
        "owner": null,
        "labels": [],
        "description": "Unnecessary type checks, the result is always false.\n\nNo parameters.\n"
      },
      {
        "real_name": "unnecessary_type_check_true",
        "display_name": "UnnecessaryTypeCheckTrue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Unnecessary type check",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try correcting the type chec",
        "owner": null,
        "labels": [],
        "description": "Unnecessary type checks, the result is always true.\n\nNo parameters.\n"
      },
      {
        "real_name": "unqualified_reference_to_non_local_static_member",
        "display_name": "UnqualifiedReferenceToNonLocalStaticMember",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Static members from supertypes must be qualified by the name of the defining type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding '{0}.' before the name.",
        "owner": null,
        "labels": [],
        "description": "12.15.1 Ordinary Invocation: It is a static type warning if <i>T</i> does\nnot have an accessible (3.2) instance member named <i>m</i>.\n\nThis is a specialization of [INSTANCE_ACCESS_TO_STATIC_MEMBER] that is used\nwhen we are able to find the name defined in a supertype. It exists to\nprovide a more informative error message.\n\nParameters:\n0: the name of the defining type\n"
      },
      {
        "real_name": "unqualified_reference_to_static_member_of_extended_type",
        "display_name": "UnqualifiedReferenceToStaticMemberOfExtendedType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Static members from the extended type or one of its superclasses must be qualified by the name of the defining type.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding '{0}.' before the name.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the defining type\n#### Description\n\nThe analyzer produces this diagnostic when an undefined name is found, and\nthe name is the same as a static member of the extended type or one of its\nsuperclasses.\n\n#### Examples\n\nThe following code produces this diagnostic because `m` is a static member\nof the extended type `C`:\n\n```dart\nclass C {\nstatic void m() {}\n}\n\nextension E on C {\nvoid f() {\n[!m!]();\n}\n}\n```\n\n#### Common fixes\n\nIf you're trying to reference a static member that's declared outside the\nextension, then add the name of the class or extension before the reference\nto the member:\n\n```dart\nclass C {\nstatic void m() {}\n}\n\nextension E on C {\nvoid f() {\nC.m();\n}\n}\n```\n\nIf you're referencing a member that isn't declared yet, add a declaration:\n\n```dart\nclass C {\nstatic void m() {}\n}\n\nextension E on C {\nvoid f() {\nm();\n}\n\nvoid m() {}\n}\n```"
      },
      {
        "real_name": "unrecognized_error_code",
        "display_name": "UnrecognizedErrorCode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' isn't a recognized error code.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that an unrecognized error code is being used to\nspecify an error filter.\n\nParameters:\n0: the unrecognized error code\n"
      },
      {
        "real_name": "unsupported_chrome_os_feature",
        "display_name": "UnsupportedChromeOsFeature",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unsupported chrome os feature",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unsupported chrome os feature"
      },
      {
        "real_name": "unsupported_chrome_os_hardware",
        "display_name": "UnsupportedChromeOsHardware",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unsupported chrome os hardware",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unsupported chrome os hardware"
      },
      {
        "real_name": "unsupported_operator",
        "display_name": "UnsupportedOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unsupported operator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unsupported operator"
      },
      {
        "real_name": "unsupported_option_with_legal_value",
        "display_name": "UnsupportedOptionWithLegalValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The option '{1}' isn't supported by '{0}'. Try using the only supported option: '{2}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that a plugin is being configured with an\nunsupported option where there is just one legal value.\n\nParameters:\n0: the plugin name\n1: the unsupported option key\n2: the legal value\n"
      },
      {
        "real_name": "unsupported_option_with_legal_values",
        "display_name": "UnsupportedOptionWithLegalValues",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The option '{1}' isn't supported by '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "{2}.",
        "owner": null,
        "labels": [],
        "description": "An error code indicating that a plugin is being configured with an\nunsupported option and legal options are provided.\n\nParameters:\n0: the plugin name\n1: the unsupported option key\n2: legal values\n"
      },
      {
        "real_name": "unsupported_option_without_values",
        "display_name": "UnsupportedOptionWithoutValues",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The option '{1}' isn't supported by '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "An error code indicating that a plugin is being configured with an\nunsupported option and legal options are provided.\n\nParameters:\n0: the plugin name\n1: the unsupported option key\n"
      },
      {
        "real_name": "unsupported_value",
        "display_name": "UnsupportedValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The value '{1}' isn't supported by '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "{2}.",
        "owner": null,
        "labels": [],
        "description": "An error code indicating that an option entry is being configured with an\nunsupported value.\n\nParameters:\n0: the option name\n1: the unsupported value\n2: legal values\n"
      },
      {
        "real_name": "unterminated_multi_line_comment",
        "display_name": "UnterminatedMultiLineComment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unterminated multi line comment",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unterminated multi line comment"
      },
      {
        "real_name": "unterminated_string_literal",
        "display_name": "UnterminatedStringLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unterminated string literal",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "unterminated string literal"
      },
      {
        "real_name": "unused_catch_clause",
        "display_name": "UnusedCatchClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The exception variable '{0}' isn't used",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the catch clause.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the exception variable\n#### Description\n\nThe analyzer produces this diagnostic when a catch clause is found, and\nneither the exception parameter nor the optional stack trace parameter are\nused in the catch block.\n\n#### Examples\n\nThe following code produces this diagnostic because `e` isn't referenced:\n\n```dart\nvoid f() {\ntry {\nint.parse(';');\n} on FormatException catch ([!e!]) {\n// ignored\n}\n}\n```\n\n#### Common fixes\n\nRemove the unused catch clause:\n\n```dart\nvoid f() {\ntry {\nint.parse(';');\n} on FormatException {\n// ignored\n}\n}\n```\nTODO(brianwilkerson) Split this error code so that we can differentiate\nbetween removing the catch clause and replacing the catch clause with\nan on clause."
      },
      {
        "real_name": "unused_catch_stack",
        "display_name": "UnusedCatchStack",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The stack trace variable '{0}' isn't used and can be removed.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the stack trace variabl",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the stack trace variable\n#### Description\n\nThe analyzer produces this diagnostic when the stack trace parameter in a\ncatch clause isn't referenced within the body of the catch block.\n\n#### Examples\n\nThe following code produces this diagnostic because `stackTrace` isn't\nreferenced:\n\n```dart\nvoid f() {\ntry {\n// ...\n} catch (exception, [!stackTrace!]) {\n// ...\n}\n}\n```\n\n#### Common fixes\n\nIf you need to reference the stack trace parameter, then add a reference to\nit. Otherwise, remove it:\n\n```dart\nvoid f() {\ntry {\n// ...\n} catch (exception) {\n// ...\n}\n}\n```"
      },
      {
        "real_name": "unused_element",
        "display_name": "UnusedElement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The declaration '{0}' isn't referenced.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the declaration of '{0}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name that is declared but not referenced\n#### Description\n\nThe analyzer produces this diagnostic when a private class, enum, mixin,\ntypedef, top level variable, top level function, or method is declared but\nnever referenced.\n\n#### Examples\n\nAssuming that no code in the library references `_C`, the following code\nproduces this diagnostic:\n\n```dart\nclass [!_C!] {}\n```\n\n#### Common fixes\n\nIf the declaration isn't needed, then remove it.\n\nIf the declaration was intended to be used, then add the missing code."
      },
      {
        "real_name": "unused_field",
        "display_name": "UnusedField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The value of the field '{0}' isn't used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the fiel",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the unused field\n#### Description\n\nThe analyzer produces this diagnostic when a private field is declared but\nnever read, even if it's written in one or more places.\n\n#### Examples\n\nThe following code produces this diagnostic because `_x` isn't referenced\nanywhere in the library:\n\n```dart\nclass Point {\nint [!_x!];\n}\n```\n\n#### Common fixes\n\nIf the field isn't needed, then remove it.\n\nIf the field was intended to be used, then add the missing code."
      },
      {
        "real_name": "unused_import",
        "display_name": "UnusedImport",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Unused import: '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the import directive.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the content of the unused import's uri\n#### Description\n\nThe analyzer produces this diagnostic when an import isn't needed because\nnone of the names that are imported are referenced within the importing\nlibrary.\n\n#### Examples\n\nThe following code produces this diagnostic because nothing defined in\n`dart:async` is referenced in the library:\n\n```dart\nimport [!'dart:async'!];\n\nvoid main() {}\n```\n\n#### Common fixes\n\nIf the import isn't needed, then remove it.\n\nIf some of the imported names are intended to be used, then add the missing\ncode."
      },
      {
        "real_name": "unused_label",
        "display_name": "UnusedLabel",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The label '{0}' isn't used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the labe",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the label that isn't used\n#### Description\n\nThe analyzer produces this diagnostic when a label that isn't used is\nfound.\n\n#### Examples\n\nThe following code produces this diagnostic because the label `loop` isn't\nreferenced anywhere in the method:\n\n```dart\nvoid f(int limit) {\n[!loop:!] for (int i = 0; i < limit; i++) {\nprint(i);\n}\n}\n```\n\n#### Common fixes\n\nIf the label isn't needed, then remove it:\n\n```dart\nvoid f(int limit) {\nfor (int i = 0; i < limit; i++) {\nprint(i);\n}\n}\n```\n\nIf the label is needed, then use it:\n\n```dart\nvoid f(int limit) {\nloop: for (int i = 0; i < limit; i++) {\nprint(i);\nbreak loop;\n}\n}\n```\nTODO(brianwilkerson) Highlight the identifier without the colon."
      },
      {
        "real_name": "unused_local_variable",
        "display_name": "UnusedLocalVariable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The value of the local variable '{0}' isn't used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the variabl",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the unused variable\n#### Description\n\nThe analyzer produces this diagnostic when a local variable is declared but\nnever read, even if it's written in one or more places.\n\n#### Examples\n\nThe following code produces this diagnostic because the value of `count` is\nnever read:\n\n```dart\nvoid main() {\nint [!count!] = 0;\n}\n```\n\n#### Common fixes\n\nIf the variable isn't needed, then remove it.\n\nIf the variable was intended to be used, then add the missing code."
      },
      {
        "real_name": "unused_shown_name",
        "display_name": "UnusedShownName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The name {0} is shown",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the name from the list of shown members.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name that is shown but not used\n#### Description\n\nThe analyzer produces this diagnostic when a show combinator includes a\nname that isn't used within the library. Because it isn't referenced, the\nname can be removed.\n\n#### Examples\n\nThe following code produces this diagnostic because the function `max`\nisn't used:\n\n```dart\nimport 'dart:math' show min, [!max!];\n\nvar x = min(0, 1);\n```\n\n#### Common fixes\n\nEither use the name or remove it:\n\n```dart\nimport 'dart:math' show min;\n\nvar x = min(0, 1);\n```"
      },
      {
        "real_name": "uri_does_not_exist",
        "display_name": "UriDoesNotExist",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Target of URI doesn't exist: '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try creating the file referenced by the UR",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the URI pointing to a non-existent file\n#### Description\n\nThe analyzer produces this diagnostic when an import, export, or part\ndirective is found where the URI refers to a file that doesn't exist.\n\n#### Examples\n\nIf the file `lib.dart` doesn't exist, the following code produces this\ndiagnostic:\n\n```dart\nimport [!'lib.dart'!];\n```\n\n#### Common fixes\n\nIf the URI was mistyped or invalid, then correct the URI.\n\nIf the URI is correct, then create the file."
      },
      {
        "real_name": "uri_has_not_been_generated",
        "display_name": "UriHasNotBeenGenerated",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Target of URI hasn't been generated: '{0}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try running the generator that will generate the file referenced by the URI.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the URI pointing to a non-existent file\n#### Description\n\nThe analyzer produces this diagnostic when an import, export, or part\ndirective is found where the URI refers to a file that doesn't exist and\nthe name of the file ends with a pattern that's commonly produced by code\ngenerators, such as one of the following:\n- `.g.dart`\n- `.pb.dart`\n- `.pbenum.dart`\n- `.pbserver.dart`\n- `.pbjson.dart`\n- `.template.dart`\n\n#### Examples\n\nIf the file `lib.g.dart` doesn't exist, the following code produces this\ndiagnostic:\n\n```dart\nimport [!'lib.g.dart'!];\n```\n\n#### Common fixes\n\nIf the file is a generated file, then run the generator that generates the\nfile.\n\nIf the file isn't a generated file, then check the spelling of the URI or\ncreate the file."
      },
      {
        "real_name": "uri_with_interpolation",
        "display_name": "UriWithInterpolation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "URIs can't use string interpolation.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "14.1 Imports: It is a compile-time error if <i>x</i> is not a compile-time\nconstant, or if <i>x</i> involves string interpolation.\n\n14.3 Parts: It is a compile-time error if <i>s</i> is not a compile-time\nconstant, or if <i>s</i> involves string interpolation.\n\n14.5 URIs: It is a compile-time error if the string literal <i>x</i> that\ndescribes a URI is not a compile-time constant, or if <i>x</i> involves\nstring interpolation.\n"
      },
      {
        "real_name": "use_of_void_result",
        "display_name": "UseOfVoidResult",
        "severity": "warning",
        "category": "convention",
        "rule_title": "This expression has a type of 'void' so its value can't be used.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try checking to see if you're using the correct API; there might be a function or call that returns void you didn't expect. Also check type parameters and variables which might also be void.",
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when it finds an expression whose\ntype is `void`, and the expression is used in a place where a value is\nexpected, such as before a member access or on the right-hand side of an\nassignment.\n\n#### Examples\n\nThe following code produces this diagnostic because `f` doesn't produce an\nobject on which `toString` can be invoked:\n\n```dart\nvoid f() {}\n\nvoid g() {\n[!f()!].toString();\n}\n```\n\n#### Common fixes\n\nEither rewrite the code so that the expression has a value or rewrite the\ncode so that it doesn't depend on the value."
      },
      {
        "real_name": "var_and_type",
        "display_name": "VarAndType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "var and type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "var and type"
      },
      {
        "real_name": "var_as_type_name",
        "display_name": "VarAsTypeName",
        "severity": "warning",
        "category": "convention",
        "rule_title": "var as type name",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "var as type name"
      },
      {
        "real_name": "var_class",
        "display_name": "VarClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "var class",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "var class"
      },
      {
        "real_name": "var_enum",
        "display_name": "VarEnum",
        "severity": "warning",
        "category": "convention",
        "rule_title": "var enum",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "var enum"
      },
      {
        "real_name": "var_return_type",
        "display_name": "VarReturnType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "var return type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "var return type"
      },
      {
        "real_name": "var_typedef",
        "display_name": "VarTypedef",
        "severity": "warning",
        "category": "convention",
        "rule_title": "var typedef",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "var typedef"
      },
      {
        "real_name": "variable_type_mismatch",
        "display_name": "VariableTypeMismatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A value of type '{0}' can't be assigned to a variable of type '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the type of the object being assigned.\n1: the type of the variable being assigned to\n#### Description\n\nThe analyzer produces this diagnostic when the evaluation of a constant\nexpression would result in a `CastException`.\n\n#### Examples\n\nThe following code produces this diagnostic because the value of `x` is an\n`int`, which can't be assigned to `y` because an `int` isn't a `String`:\n\n```dart\nconst Object x = 0;\nconst String y = [!x!];\n```\n\n#### Common fixes\n\nIf the declaration of the constant is correct, then change the value being\nassigned to be of the correct type:\n\n```dart\nconst Object x = 0;\nconst String y = '$x';\n```\n\nIf the assigned value is correct, then change the declaration to have the\ncorrect type:\n\n```dart\nconst Object x = 0;\nconst int y = x;\n```"
      },
      {
        "real_name": "void_with_type_arguments",
        "display_name": "VoidWithTypeArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "void with type arguments",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "void with type arguments"
      },
      {
        "real_name": "with_before_extends",
        "display_name": "WithBeforeExtends",
        "severity": "warning",
        "category": "convention",
        "rule_title": "with before extends",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "with before extends"
      },
      {
        "real_name": "wrong_explicit_type_parameter_variance_in_superinterface",
        "display_name": "WrongExplicitTypeParameterVarianceInSuperinterface",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' is an '{1}' type parameter and can't be used in an '{2}' position in '{3}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try using 'in' type parameters in 'in' positions and 'out' type parameters in 'out' positions in the superinterface.",
        "owner": null,
        "labels": [],
        "description": "Let `C` be a generic class that declares a formal type parameter `X`, and\nassume that `T` is a direct superinterface of `C`.\n\nIt is a compile-time error if `X` is explicitly defined as a covariant or\n'in' type parameter and `X` occurs in a non-covariant position in `T`.\nIt is a compile-time error if `X` is explicitly defined as a contravariant\nor 'out' type parameter and `X` occurs in a non-contravariant position in\n`T`.\n\nParameters:\n0: the name of the type parameter\n1: the variance modifier defined for {0}\n2: the variance position of the type parameter {0} in the\nsuperinterface {3}\n3: the name of the superinterface\n"
      },
      {
        "real_name": "wrong_number_of_parameters_for_operator",
        "display_name": "WrongNumberOfParametersForOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Operator '{0}' should declare exactly {1} parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the declared operator\n1: the number of parameters expected\n2: the number of parameters found in the operator declaration\n#### Description\n\nThe analyzer produces this diagnostic when a declaration of an operator has\nthe wrong number of parameters.\n\n#### Examples\n\nThe following code produces this diagnostic because the operator `+` must\nhave a single parameter corresponding to the right operand:\n\n```dart\nclass C {\nint operator [!+!](a, b) => 0;\n}\n```\n\n#### Common fixes\n\nAdd or remove parameters to match the required number:\n\n```dart\nclass C {\nint operator +(a) => 0;\n}\n```\nTODO(brianwilkerson) It would be good to add a link to the spec or some\nother documentation that lists the number of parameters for each operator,\nbut I don't know what to link to."
      },
      {
        "real_name": "wrong_number_of_parameters_for_operator_minus",
        "display_name": "WrongNumberOfParametersForOperatorMinus",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Operator '-' should declare 0 or 1 parameter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "7.1.1 Operators: It is a compile time error if the arity of the\nuser-declared operator - is not 0 or 1.\n\nParameters:\n0: the number of parameters found in the operator declaration\n"
      },
      {
        "real_name": "wrong_number_of_parameters_for_setter",
        "display_name": "WrongNumberOfParametersForSetter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Setters must declare exactly one required positional parameter.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "No parameters.\n#### Description\n\nThe analyzer produces this diagnostic when a setter is found that doesn't\ndeclare exactly one required positional parameter.\n\n#### Examples\n\nThe following code produces this diagnostic because the setter `s` declares\ntwo required parameters:\n\n```dart\nclass C {\nset [!s!](int x, int y) {}\n}\n```\n\nThe following code produces this diagnostic because the setter `s` declares\none optional parameter:\n\n```dart\nclass C {\nset [!s!]([int x]) {}\n}\n```\n\n#### Common fixes\n\nChange the declaration so that there's exactly one required positional\nparameter:\n\n```dart\nclass C {\nset s(int x) {}\n}\n```"
      },
      {
        "real_name": "wrong_number_of_type_arguments",
        "display_name": "WrongNumberOfTypeArguments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type '{0}' is declared with {1} type parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adjusting the number of type arguments to match the number of type parameters.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the name of the type being referenced (<i>G</i>)\n1: the number of type parameters that were declared\n2: the number of type arguments provided\n#### Description\n\nThe analyzer produces this diagnostic when a type that has type parameters\nis used and type arguments are provided, but the number of type arguments\nisn't the same as the number of type parameters.\n\nThe analyzer also produces this diagnostic when a constructor is invoked\nand the number of type arguments doesn't match the number of type\nparameters declared for the class.\n\n#### Examples\n\nThe following code produces this diagnostic because `C` has one type\nparameter but two type arguments are provided when it is used as a type\nannotation:\n\n```dart\nclass C<E> {}\n\nvoid f([!C<int, int>!] x) {}\n```\n\nThe following code produces this diagnostic because `C` declares one type\nparameter, but two type arguments are provided when creating an instance:\n\n```dart\nclass C<E> {}\n\nvar c = [!C<int, int>!]();\n```\n\n#### Common fixes\n\nAdd or remove type arguments, as necessary, to match the number of type\nparameters defined for the type:\n\n```dart\nclass C<E> {}\n\nvoid f(C<int> x) {}\n```"
      },
      {
        "real_name": "wrong_number_of_type_arguments_constructor",
        "display_name": "WrongNumberOfTypeArgumentsConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The constructor '{0}.{1}' doesn't have type parameters.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try moving type arguments to after the type name.",
        "owner": null,
        "labels": [],
        "description": "It will be a static type warning if <i>m</i> is not a generic method with\nexactly <i>n</i> type parameters.\n\nParameters:\n0: the name of the class being instantiated\n1: the name of the constructor being invoked\n"
      },
      {
        "real_name": "wrong_number_of_type_arguments_method",
        "display_name": "WrongNumberOfTypeArgumentsMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The method '{0}' is declared with {1} type parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adjusting the number of type arguments.",
        "owner": null,
        "labels": [],
        "description": "It will be a static type warning if <i>m</i> is not a generic method with\nexactly <i>n</i> type parameters.\n\nParameters:\n0: the name of the method being referenced (<i>G</i>)\n1: the number of type parameters that were declared\n2: the number of type arguments provided\n"
      },
      {
        "real_name": "wrong_separator_for_positional_parameter",
        "display_name": "WrongSeparatorForPositionalParameter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "wrong separator for positional parameter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "wrong separator for positional parameter"
      },
      {
        "real_name": "wrong_terminator_for_parameter_group",
        "display_name": "WrongTerminatorForParameterGroup",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Expected '{0}' to close parameter group.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try replacing '{0}' with '{1}'.",
        "owner": null,
        "labels": [],
        "description": "Parameters:\n0: the terminator that was expected\n1: the terminator that was found\n"
      },
      {
        "real_name": "wrong_type_parameter_variance_in_superinterface",
        "display_name": "WrongTypeParameterVarianceInSuperinterface",
        "severity": "warning",
        "category": "convention",
        "rule_title": "'{0}' can't be used contravariantly or invariantly in '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try not using class type parameters in types of formal parameters of function type",
        "owner": null,
        "labels": [],
        "description": "Let `C` be a generic class that declares a formal type parameter `X`, and\nassume that `T` is a direct superinterface of `C`. It is a compile-time\nerror if `X` occurs contravariantly or invariantly in `T`.\n"
      },
      {
        "real_name": "wrong_type_parameter_variance_position",
        "display_name": "WrongTypeParameterVariancePosition",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The '{0}' type parameter '{1}' can't be used in an '{2}' position.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the type parameter or change the explicit variance modifier declaration for the type parameter to another one of 'in",
        "owner": null,
        "labels": [],
        "description": "Let `C` be a generic class that declares a formal type parameter `X`.\n\nIf `X` is explicitly contravariant then it is a compile-time error for\n`X` to occur in a non-contravariant position in a member signature in the\nbody of `C`, except when `X` is in a contravariant position in the type\nannotation of a covariant formal parameter.\n\nIf `X` is explicitly covariant then it is a compile-time error for\n`X` to occur in a non-covariant position in a member signature in the\nbody of `C`, except when `X` is in a covariant position in the type\nannotation of a covariant formal parameter.\n\nParameters:\n0: the variance modifier defined for {0}\n1: the name of the type parameter\n2: the variance position that the type parameter {1} is in\n"
      },
      {
        "real_name": "yield_each_in_non_generator",
        "display_name": "YieldEachInNonGenerator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Yield-each statements must be in a generator function one marked with either 'async*' or 'sync*').",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding 'async*' or 'sync*' to the enclosing function.",
        "owner": null,
        "labels": [],
        "description": "?? Yield: It is a compile-time error if a yield statement appears in a\nfunction that is not a generator function.\n"
      },
      {
        "real_name": "yield_in_non_generator",
        "display_name": "YieldInNonGenerator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Yield statements must be in a generator function one marked with either 'async*' or 'sync*').",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try adding 'async*' or 'sync*' to the enclosing function.",
        "owner": null,
        "labels": [],
        "description": "?? Yield: It is a compile-time error if a yield statement appears in a\nfunction that is not a generator function.\n"
      },
      {
        "real_name": "yield_of_invalid_type",
        "display_name": "YieldOfInvalidType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "The type '{0}' implied by the 'yield' expression must be assignable to '{1}'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "17.16.1 Yield: Let T be the static type of e [the expression to the right\nof \"yield\"] and let f be the immediately enclosing function.  It is a\nstatic type warning if either:\n\n- the body of f is marked async* and the type Stream<T> may not be\nassigned to the declared return type of f.\n\n- the body of f is marked sync* and the type Iterable<T> may not be\nassigned to the declared return type of f.\n\n17.16.2 Yield-Each: Let T be the static type of e [the expression to the\nright of \"yield*\"] and let f be the immediately enclosing function.  It is\na static type warning if T may not be assigned to the declared return type\nof f.  If f is synchronous it is a static type warning if T may not be\nassigned to Iterable.  If f is asynchronous it is a static type warning if\nT may not be assigned to Stream.\n"
      },
      {
        "real_name": "always_declare_return_types",
        "display_name": "AlwaysDeclareReturnTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "always declare return types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** declare method return types.\n\nWhen declaring a method or function **always** specify a return type.\nDeclaring return types for functions helps improve your codebase by allowing the\nanalyzer to more adequately check your code for errors that could occur during\nruntime.\n\n**BAD:**\n\n```\nmain() { }\n\n_bar() =&gt; _Foo();\n\nclass _Foo {\n  _foo() =&gt; 42;\n}\n\n```\n\n**GOOD:**\n\n```\nvoid main() { }\n\n_Foo _bar() =&gt; _Foo();\n\nclass _Foo {\n  int _foo() =&gt; 42;\n}\n\ntypedef bool predicate(Object o);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/always_declare_return_types.html)"
      },
      {
        "real_name": "always_put_control_body_on_new_line",
        "display_name": "AlwaysPutControlBodyOnNewLine",
        "severity": "warning",
        "category": "convention",
        "rule_title": "always put control body on new line",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [flutter style guide](https://flutter.dev/style-guide/):\n\n**DO** separate the control structure expression from its statement.\n\nDon't put the statement part of an `if`, `for`, `while`, `do` on the same line\nas the expression, even if it is short.  Doing so makes it unclear that there\nis relevant code there.  This is especially important for early returns.\n\n**GOOD:**\n\n```\nif (notReady)\n  return;\n\nif (notReady)\n  return;\nelse\n  print('ok')\n\nwhile (condition)\n  i += 1;\n\n```\n\n**BAD:**\n\n```\nif (notReady) return;\n\nif (notReady)\n  return;\nelse print('ok')\n\nwhile (condition) i += 1;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/always_put_control_body_on_new_line.html)"
      },
      {
        "real_name": "always_put_required_named_parameters_first",
        "display_name": "AlwaysPutRequiredNamedParametersFirst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "always put required named parameters first",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** specify `@required` on named parameter before other named parameters.\n\n**GOOD:**\n\n```\nm({@required a, b, c}) ;\n\n```\n\n**BAD:**\n\n```\nm({b, c, @required a}) ;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/always_put_required_named_parameters_first.html)"
      },
      {
        "real_name": "always_require_non_null_named_parameters",
        "display_name": "AlwaysRequireNonNullNamedParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "always require non null named parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** specify `@required` on named parameters without a default value on which \nan `assert(param != null)` is done.\n\n**GOOD:**\n\n```\nm1({@required a}) {\n  assert(a != null);\n}\n\nm2({a: 1}) {\n  assert(a != null);\n}\n\n```\n\n**BAD:**\n\n```\nm1({a}) {\n  assert(a != null);\n}\n\n```\n\nNOTE: Only asserts at the start of the bodies will be taken into account.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/always_require_non_null_named_parameters.html)"
      },
      {
        "real_name": "always_specify_types",
        "display_name": "AlwaysSpecifyTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "always specify types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [flutter style guide](https://flutter.dev/style-guide/):\n\n**DO** specify type annotations.\n\nAvoid `var` when specifying that a type is unknown and short-hands that elide\ntype annotations.  Use `dynamic` if you are being explicit that the type is\nunknown.  Use `Object` if you are being explicit that you want an object that\nimplements `==` and `hashCode`.\n\n**GOOD:**\n\n```\nint foo = 10;\nfinal Bar bar = Bar();\nString baz = 'hello';\nconst int quux = 20;\n\n```\n\n**BAD:**\n\n```\nvar foo = 10;\nfinal bar = Bar();\nconst quux = 20;\n\n```\n\nNOTE: Using the the `@optionalTypeArgs` annotation in the `meta` package, API\nauthors can special-case type variables whose type needs to by dynamic but whose\ndeclaration should be treated as optional.  For example, suppose you have a\n`Key` object whose type parameter you'd like to treat as optional.  Using the\n`@optionalTypeArgs` would look like this:\n\n```\nimport 'package:meta/meta.dart';\n\n@optionalTypeArgs\nclass Key&lt;T&gt; {\n ...\n}\n\nmain() {\n  Key s = Key(); // OK!\n}\n\n```\n\n\nIncompatible with: [omit_local_variable_types](omit_local_variable_types.html).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/always_specify_types.html)"
      },
      {
        "real_name": "annotate_overrides",
        "display_name": "AnnotateOverrides",
        "severity": "warning",
        "category": "convention",
        "rule_title": "annotate overrides",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** annotate overridden methods and fields.\n\nThis practice improves code readability and helps protect against\nunintentionally overriding superclass members.\n\n**GOOD:**\n\n```\nabstract class Dog {\n  String get breed;\n  void bark() {}\n}\n\nclass Husky extends Dog {\n  @override\n  final String breed = 'Husky';\n  @override\n  void bark() {}\n}\n\n```\n\n**BAD:**\n\n```\nclass Cat {\n  int get lives =&gt; 9;\n}\n\nclass Lucky extends Cat {\n  final int lives = 14;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/annotate_overrides.html)"
      },
      {
        "real_name": "avoid_annotating_with_dynamic",
        "display_name": "AvoidAnnotatingWithDynamic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid annotating with dynamic",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** annotating with dynamic when not required.\n\nAs `dynamic` is the assumed return value of a function or method, it is usually\nnot necessary to annotate it.\n\n**BAD:**\n\n```\ndynamic lookUpOrDefault(String name, Map map, dynamic defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n\n```\n\n**GOOD:**\n\n```\nlookUpOrDefault(String name, Map map, defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_annotating_with_dynamic.html)"
      },
      {
        "real_name": "avoid_as",
        "display_name": "AvoidAs",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid as",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using `as`.\n\nIf you know the type is correct, use an assertion or assign to a more\nnarrowly-typed variable (this avoids the type check in release mode; `as` is not\ncompiled out in release mode).  If you don't know whether the type is\ncorrect, check using `is` (this avoids the exception that `as` raises).\n\n**BAD:**\n\n```\n(pm as Person).firstName = 'Seth';\n\n```\n\n**GOOD:**\n\n```\nif (pm is Person)\n  pm.firstName = 'Seth';\n\n```\n\nbut certainly not\n\n**BAD:**\n\n```\ntry {\n   (pm as Person).firstName = 'Seth';\n} on CastError { }\n\n```\n\nNote that an exception is made in the case of `dynamic` since the cast has no\nperformance impact.\n\n**OK:**\n\n```\nHasScrollDirection scrollable = renderObject as dynamic;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_as.html)"
      },
      {
        "real_name": "avoid_bool_literals_in_conditional_expressions",
        "display_name": "AvoidBoolLiteralsInConditionalExpressions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid bool literals in conditional expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** bool literals in conditional expressions.\n\n**BAD:**\n\n```\ncondition ? true : boolExpression\ncondition ? false : boolExpression\ncondition ? boolExpression : true\ncondition ? boolExpression : false\n\n```\n\n**GOOD:**\n\n```\ncondition || boolExpression\n!condition &amp;&amp; boolExpression\n!condition || boolExpression\ncondition &amp;&amp; boolExpression\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_bool_literals_in_conditional_expressions.html)"
      },
      {
        "real_name": "avoid_catches_without_on_clauses",
        "display_name": "AvoidCatchesWithoutOnClauses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid catches without on clauses",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** catches without on clauses.\n\nUsing catch clauses without on clauses make your code prone to encountering\nunexpected errors that won't be thrown (and thus will go unnoticed).\n\n**BAD:**\n\n```\ntry {\n somethingRisky()\n}\ncatch(e) {\n  doSomething(e);\n}\n\n```\n\n**GOOD:**\n\n```\ntry {\n somethingRisky()\n}\non Exception catch(e) {\n  doSomething(e);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_catches_without_on_clauses.html)"
      },
      {
        "real_name": "avoid_catching_errors",
        "display_name": "AvoidCatchingErrors",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid catching errors",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** explicitly catch Error or types that implement it.\n\nErrors differ from Exceptions in that Errors can be analyzed and prevented prior\nto runtime.  It should almost never be necessary to catch an error at runtime.\n\n**BAD:**\n\n```\ntry {\n  somethingRisky();\n} on Error catch(e) {\n  doSomething(e);\n}\n\n```\n\n**GOOD:**\n\n```\ntry {\n  somethingRisky();\n} on Exception catch(e) {\n  doSomething(e);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_catching_errors.html)"
      },
      {
        "real_name": "avoid_classes_with_only_static_members",
        "display_name": "AvoidClassesWithOnlyStaticMembers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid classes with only static members",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** defining a class that contains only static members.\n\nCreating classes with the sole purpose of providing utility or otherwise static\nmethods is discouraged.  Dart allows functions to exist outside of classes for\nthis very reason.\n\n**BAD:**\n\n```\nclass DateUtils {\n  static DateTime mostRecent(List&lt;DateTime&gt; dates) {\n    return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);\n  }\n}\n\nclass _Favorites {\n  static const mammal = 'weasel';\n}\n\n```\n\n**GOOD:**\n\n```\nDateTime mostRecent(List&lt;DateTime&gt; dates) {\n  return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);\n}\n\nconst _favoriteMammal = 'weasel';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_classes_with_only_static_members.html)"
      },
      {
        "real_name": "avoid_double_and_int_checks",
        "display_name": "AvoidDoubleAndIntChecks",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid double and int checks",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** to check if type is double or int.\n\nWhen compiled to JS, integer values are represented as floats. That can lead to\nsome unexpected behavior when using either `is` or `is!` where the type is\neither `int` or `double`.\n\n**BAD:**\n\n```\nf(num x) {\n  if (x is double) {\n    ...\n  } else if (x is int) {\n    ...\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nf(dynamic x) {\n  if (x is num) {\n    ...\n  } else {\n    ...\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_double_and_int_checks.html)"
      },
      {
        "real_name": "avoid_empty_else",
        "display_name": "AvoidEmptyElse",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid empty else",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** empty else statements.\n\n**BAD:**\n\n```\nif (x &gt; y)\n  print(\"1\");\nelse ;\n  print(\"2\");\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_empty_else.html)"
      },
      {
        "real_name": "avoid_equals_and_hash_code_on_mutable_classes",
        "display_name": "AvoidEqualsAndHashCodeOnMutableClasses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid equals and hash code on mutable classes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** overloading operator == and hashCode on classes not marked `@immutable`.\n\nIf a class is not immutable, overloading operator == and hashCode can lead to\nunpredictable and undesirable behavior when used in collections. See\nhttps://dart.dev/guides/language/effective-dart/design#avoid-defining-custom-equality-for-mutable-classes\nfor more information.\n\n**GOOD:**\n\n```\n@immutable\nclass A {\n  final String key;\n  const A(this.key);\n  @override\n  operator ==(other) =&gt; other is A &amp;&amp; other.key == key;\n  @override\n  int hashCode() =&gt; key.hashCode;\n}\n\n```\n\n**BAD:**\n\n```\nclass B {\n  String key;\n  const B(this.key);\n  @override\n  operator ==(other) =&gt; other is B &amp;&amp; other.key == key;\n  @override\n  int hashCode() =&gt; key.hashCode;\n}\n\n```\n\nNOTE: The lint checks the use of the @immutable annotation, and will trigger\neven if the class is otherwise not mutable. Thus:\n\n**BAD:**\n\n```\nclass C {\n  final String key;\n  const C(this.key);\n  @override\n  operator ==(other) =&gt; other is B &amp;&amp; other.key == key;\n  @override\n  int hashCode() =&gt; key.hashCode;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_equals_and_hash_code_on_mutable_classes.html)"
      },
      {
        "real_name": "avoid_escaping_inner_quotes",
        "display_name": "AvoidEscapingInnerQuotes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid escaping inner quotes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Avoid escaping inner quotes by converting surrounding quotes.\n\n**BAD:**\n\n```\nvar s = 'It\\'s not fun';\n\n```\n\n**GOOD:**\n\n```\nvar s = \"It's not fun\";\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_escaping_inner_quotes.html)"
      },
      {
        "real_name": "avoid_field_initializers_in_const_classes",
        "display_name": "AvoidFieldInitializersInConstClasses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid field initializers in const classes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** field initializers in const classes.\n\nInstead of `final x = const expr;`, you should write `get x =&gt; const expr;` and\nnot allocate a useless field. As of April 2018 this is true for the VM, but not\nfor code that will be compiled to JS.\n\n**BAD:**\n\n```\nclass A {\n  final a = const [];\n  const A();\n}\n\n```\n\n**GOOD:**\n\n```\nclass A {\n  get a =&gt; const [];\n  const A();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_field_initializers_in_const_classes.html)"
      },
      {
        "real_name": "avoid_function_literals_in_foreach_calls",
        "display_name": "AvoidFunctionLiteralsInForeachCalls",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid function literals in foreach calls",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using `forEach` with a function literal.\n\n**BAD:**\n\n```\npeople.forEach((person) {\n  ...\n});\n\n```\n\n**GOOD:**\n\n```\nfor (var person in people) {\n  ...\n}\n\npeople.forEach(print);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_function_literals_in_foreach_calls.html)"
      },
      {
        "real_name": "avoid_implementing_value_types",
        "display_name": "AvoidImplementingValueTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid implementing value types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** implement classes that override `==`.\n\nThe `==` operator is contractually required to be an equivalence relation;\nthat is, symmetrically for all objects `o1` and `o2`, `o1 == o2` and `o2 == o1`\nmust either both be true, or both be false.\n\n> \n<p>**NOTE**: Dart does not have true **value types**, so instead we consider a class\nthat implements `==`  as a **proxy** for identifying value types.</p>\n\n\nWhen using `implements`, you do not inherit the method body of `==`, making it\nnearly impossible to follow the contract of `==`. Classes that override `==`\ntypically are usable directly in tests **without** creating mocks or fakes as\nwell. For example, for a given class `Size`:\n\n```\nclass Size {\n  final int inBytes;\n  const Size(this.inBytes);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Size &amp;&amp; other.inBytes == inBytes;\n\n  @override\n  int get hashCode =&gt; inBytes.hashCode;\n}\n\n```\n\n**BAD**:\n\n```\nclass CustomSize implements Size {\n  final int inBytes;\n  const CustomSize(this.inBytes);\n\n  int get inKilobytes =&gt; inBytes ~/ 1000;\n}\n\n```\n\n**BAD**:\n\n```\nimport 'package:test/test.dart';\nimport 'size.dart';\n\nclass FakeSize implements Size {\n  int inBytes = 0;\n}\n\nvoid main() {\n  test('should not throw on a size &gt;1Kb', () {\n    expect(() =&gt; someFunction(FakeSize()..inBytes = 1001), returnsNormally);\n  });\n}\n\n```\n\n**GOOD**:\n\n```\nclass ExtendedSize extends Size {\n  ExtendedSize(int inBytes) : super(inBytes);\n\n  int get inKilobytes =&gt; inBytes ~/ 1000;\n}\n\n```\n\n**GOOD**:\n\n```\nimport 'package:test/test.dart';\nimport 'size.dart';\n\nvoid main() {\n  test('should not throw on a size &gt;1Kb', () {\n    expect(() =&gt; someFunction(new Size(1001)), returnsNormally);\n  });\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_implementing_value_types.html)"
      },
      {
        "real_name": "avoid_init_to_null",
        "display_name": "AvoidInitToNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid init to null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From [effective dart](https://dart.dev/guides/language/effective-dart/usage#dont-explicitly-initialize-variables-to-null):\n\n**DON'T** explicitly initialize variables to null.\n\nIn Dart, a variable or field that is not explicitly initialized automatically\ngets initialized to null.  This is reliably specified by the language.  There's\nno concept of \"uninitialized memory\" in Dart.  Adding `= null` is redundant and\nunneeded.\n\n**GOOD:**\n\n```\nint _nextId;\n\nclass LazyId {\n  int _id;\n\n  int get id {\n    if (_nextId == null) _nextId = 0;\n    if (_id == null) _id = _nextId++;\n\n    return _id;\n  }\n}\n\n```\n\n**BAD:**\n\n```\nint _nextId = null;\n\nclass LazyId {\n  int _id = null;\n\n  int get id {\n    if (_nextId == null) _nextId = 0;\n    if (_id == null) _id = _nextId++;\n\n    return _id;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_init_to_null.html)"
      },
      {
        "real_name": "avoid_js_rounded_ints",
        "display_name": "AvoidJsRoundedInts",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid js rounded ints",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** integer literals that cannot be represented exactly when compiled to\nJavaScript.\n\nWhen a program is compiled to JavaScript `int` and `double` become JavaScript\nNumbers. Too large integers (`value &lt; Number.MIN_SAFE_INTEGER` or\n`value &gt; Number.MAX_SAFE_INTEGER`) may be rounded to the closest Number value.\n\nFor instance `1000000000000000001` cannot be represented exactly as a JavaScript\nNumber, so `1000000000000000000` will be used instead.\n\n**BAD:**\n\n```\nint value = 9007199254740995;\n\n```\n\n**GOOD:**\n\n```\nBigInt value = BigInt.parse('9007199254740995');\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_js_rounded_ints.html)"
      },
      {
        "real_name": "avoid_null_checks_in_equality_operators",
        "display_name": "AvoidNullChecksInEqualityOperators",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid null checks in equality operators",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** check for null in custom == operators.\n\nAs null is a special type, no class can be equivalent to it.  Thus, it is\nredundant to check whether the other instance is null. \n\n**BAD:**\n\n```\nclass Person {\n  final String name;\n\n  @override\n  operator ==(other) =&gt;\n      other != null &amp;&amp; other is Person &amp;&amp; name == other.name;\n}\n\n```\n\n**GOOD:**\n\n```\nclass Person {\n  final String name;\n\n  @override\n  operator ==(other) =&gt; other is Person &amp;&amp; name == other.name;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_null_checks_in_equality_operators.html)"
      },
      {
        "real_name": "avoid_positional_boolean_parameters",
        "display_name": "AvoidPositionalBooleanParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid positional boolean parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** positional boolean parameters.\n\nPositional boolean parameters are a bad practice because they are very\nambiguous.  Using named boolean parameters is much more readable because it\ninherently describes what the boolean value represents.\n\n**BAD:**\n\n```\nTask(true);\nTask(false);\nListBox(false, true, true);\nButton(false);\n\n```\n\n**GOOD:**\n\n```\nTask.oneShot();\nTask.repeating();\nListBox(scroll: true, showScrollbars: true);\nButton(ButtonState.enabled);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_positional_boolean_parameters.html)"
      },
      {
        "real_name": "avoid_print",
        "display_name": "AvoidPrint",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid print",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** avoid `print` calls in production code.\n\n**BAD:**\n\n```\nvoid f(int x) {\n  print('debug: $x');\n  ...\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_print.html)"
      },
      {
        "real_name": "avoid_private_typedef_functions",
        "display_name": "AvoidPrivateTypedefFunctions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid private typedef functions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** private typedef functions used only once. Prefer inline function\nsyntax.\n\n**BAD:**\n\n```\ntypedef void _F();\nm(_F f);\n\n```\n\n**GOOD:**\n\n```\nm(void Function() f);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_private_typedef_functions.html)"
      },
      {
        "real_name": "avoid_redundant_argument_values",
        "display_name": "AvoidRedundantArgumentValues",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid redundant argument values",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Avoid redundant argument values.\n\n**DON'T** declare arguments with values that match the defaults for the\ncorresponding parameter.\n\n**BAD:**\n\n```\nvoid f({bool valWithDefault = true, bool val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: true);\n}\n\n```\n\n**GOOD:**\n\n```\nvoid f({bool valWithDefault = true, bool val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: false);\n  f();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_redundant_argument_values.html)"
      },
      {
        "real_name": "avoid_relative_lib_imports",
        "display_name": "AvoidRelativeLibImports",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid relative lib imports",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** avoid relative imports for files in `lib/`.\n\nWhen mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways.  An easy way to avoid\nthat is to ensure you have no relative imports that include `lib/` in their\npaths.\n\n**GOOD:**\n\n```\nimport 'package:foo/bar.dart';\n\nimport 'baz.dart';\n\n...\n\n```\n\n**BAD:**\n\n```\nimport 'package:foo/bar.dart';\n\nimport '../lib/baz.dart';\n\n...\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_relative_lib_imports.html)"
      },
      {
        "real_name": "avoid_renaming_method_parameters",
        "display_name": "AvoidRenamingMethodParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid renaming method parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** rename parameters of overridden methods.\n\nMethods that override another method, but do not have their own documentation\ncomment, will inherit the overridden method's comment when dartdoc produces\ndocumentation. If the inherited method contains the name of the parameter (in\nsquare brackets), then dartdoc cannot link it correctly.\n\n**BAD:**\n\n```\nabstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(b);\n}\n\n```\n\n**GOOD:**\n\n```\nabstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(a);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_renaming_method_parameters.html)"
      },
      {
        "real_name": "avoid_return_types_on_setters",
        "display_name": "AvoidReturnTypesOnSetters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid return types on setters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** return types on setters.\n\nAs setters do not return a value, declaring the return type of one is redundant.\n\n**GOOD:**\n\n```\nset speed(int ms);\n\n```\n\n**BAD:**\n\n```\nvoid set speed(int ms);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_return_types_on_setters.html)"
      },
      {
        "real_name": "avoid_returning_null",
        "display_name": "AvoidReturningNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid returning null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** returning null from members whose return type is bool, double, int,\nor num.\n\nFunctions that return primitive types such as bool, double, int, and num are\ngenerally expected to return non-nullable values.  Thus, returning null where a\nprimitive type was expected can lead to runtime exceptions.\n\n**BAD:**\n\n```\nbool getBool() =&gt; null;\nnum getNum() =&gt; null;\nint getInt() =&gt; null;\ndouble getDouble() =&gt; null;\n\n```\n\n**GOOD:**\n\n```\nbool getBool() =&gt; false;\nnum getNum() =&gt; -1;\nint getInt() =&gt; -1;\ndouble getDouble() =&gt; -1.0;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_returning_null.html)"
      },
      {
        "real_name": "avoid_returning_null_for_future",
        "display_name": "AvoidReturningNullForFuture",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid returning null for future",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** returning null for Future.\n\nIt is almost always wrong to return `null` for a `Future`.  Most of the time the\ndeveloper simply forgot to put an `async` keyword on the function.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_returning_null_for_future.html)"
      },
      {
        "real_name": "avoid_returning_null_for_void",
        "display_name": "AvoidReturningNullForVoid",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid returning null for void",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** returning null for void.\n\nIn a large variety of languages `void` as return type is used to indicate that\na function doesn't return anything. Dart allows returning `null` in functions\nwith `void` return type but it also allow using `return;` without specifying any\nvalue. To have a consistent way you should not return `null` and only use an\nempty return.\n\n**BAD:**\n\n```\nvoid f1() {\n  return null;\n}\nFuture&lt;void&gt; f2() async {\n  return null;\n}\n\n```\n\n**GOOD:**\n\n```\nvoid f1() {\n  return;\n}\nFuture&lt;void&gt; f2() async {\n  return;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_returning_null_for_void.html)"
      },
      {
        "real_name": "avoid_returning_this",
        "display_name": "AvoidReturningThis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid returning this",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** returning this from methods just to enable a fluent interface.\n\nReturning `this` from a method is redundant; Dart has a cascade operator which\nallows method chaining universally.\n\nReturning `this` is allowed for:\n\n- operators\n- methods with a return type different of the current class\n- methods defined in parent classes / mixins or interfaces\n- methods defined in extensions\n\n**BAD:**\n\n```\nvar buffer = StringBuffer()\n  .write('one')\n  .write('two')\n  .write('three');\n\n```\n\n**GOOD:**\n\n```\nvar buffer = StringBuffer()\n  ..write('one')\n  ..write('two')\n  ..write('three');\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_returning_this.html)"
      },
      {
        "real_name": "avoid_setters_without_getters",
        "display_name": "AvoidSettersWithoutGetters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid setters without getters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** define a setter without a corresponding getter.\n\nDefining a setter without defining a corresponding getter can lead to logical\ninconsistencies.  Doing this could allow you to set a property to some value,\nbut then upon observing the property's value, it could easily be different.\n\n**BAD:**\n\n```\nclass Bad {\n  int l, r;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Good {\n  int l, r;\n\n  int get length =&gt; r - l;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_setters_without_getters.html)"
      },
      {
        "real_name": "avoid_shadowing_type_parameters",
        "display_name": "AvoidShadowingTypeParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid shadowing type parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** shadowing type parameters.\n\n**BAD:**\n\n```\nclass A&lt;T&gt; {\n  void fn&lt;T&gt;() {}\n}\n\n```\n\n**GOOD:**\n\n```\nclass A&lt;T&gt; {\n  void fn&lt;U&gt;() {}\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_shadowing_type_parameters.html)"
      },
      {
        "real_name": "avoid_single_cascade_in_expression_statements",
        "display_name": "AvoidSingleCascadeInExpressionStatements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid single cascade in expression statements",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** single cascade in expression statements.\n\n**BAD:**\n\n```\no..m();\n\n```\n\n**GOOD:**\n\n```\no.m();\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_single_cascade_in_expression_statements.html)"
      },
      {
        "real_name": "avoid_slow_async_io",
        "display_name": "AvoidSlowAsyncIo",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid slow async io",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using the following asynchronous file I/O methods because they are\nmuch slower than their synchronous counterparts.\n\n- `Directory.exists`\n- `Directory.stat`\n- `File.lastModified`\n- `File.exists`\n- `File.stat`\n- `FileSystemEntity.isDirectory`\n- `FileSystemEntity.isFile`\n- `FileSystemEntity.isLink`\n- `FileSystemEntity.type`\n\n**BAD:**\n\n```\nimport 'dart:io';\n\nFuture&lt;Null&gt; someFunction() async {\n  var file = new File('/path/to/my/file');\n  var now = new DateTime.now();\n  if ((await file.lastModified()).isBefore(now)) print('before'); // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nimport 'dart:io';\n\nFuture&lt;Null&gt; someFunction() async {\n  var file = new File('/path/to/my/file');\n  var now = new DateTime.now();\n  if (file.lastModifiedSync().isBefore(now)) print('before'); // OK\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_slow_async_io.html)"
      },
      {
        "real_name": "avoid_types_as_parameter_names",
        "display_name": "AvoidTypesAsParameterNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid types as parameter names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using a parameter name that is the same as an existing type.\n\n**BAD:**\n\n```\nm(f(int));\n\n```\n\n**GOOD:**\n\n```\nm(f(int v));\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_types_as_parameter_names.html)"
      },
      {
        "real_name": "avoid_types_on_closure_parameters",
        "display_name": "AvoidTypesOnClosureParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid types on closure parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** annotating types for function expression parameters.\n\nAnnotating types for function expression parameters is usually unnecessary\nbecause the parameter types can almost always be inferred from the context,\nthus making the practice redundant.\n\n**BAD:**\n\n```\nvar names = people.map((Person person) =&gt; person.name);\n\n```\n\n**GOOD:**\n\n```\nvar names = people.map((person) =&gt; person.name);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_types_on_closure_parameters.html)"
      },
      {
        "real_name": "avoid_unnecessary_containers",
        "display_name": "AvoidUnnecessaryContainers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid unnecessary containers",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Avoid wrapping widgets in unnecessary containers.\n\nWrapping a widget in `Container` with no other parameters set has no effect \nand makes code needlessly more complex.\n\n**BAD:**\n\n```\nWidget buildRow() {\n  return Container(\n      child: Row(\n        children: &lt;Widget&gt;[\n          const MyLogo(),\n          const Expanded(\n            child: Text('...'),\n          ),\n        ],\n      )\n  );\n}\n\n```\n\n**GOOD:**\n\n```\nWidget buildRow() {\n  return Row(\n    children: &lt;Widget&gt;[\n      const MyLogo(),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_unnecessary_containers.html)"
      },
      {
        "real_name": "avoid_unused_constructor_parameters",
        "display_name": "AvoidUnusedConstructorParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid unused constructor parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** defining unused parameters in constructors.\n\n**BAD:**\n\n```\nclass BadOne {\n  BadOne(int unusedParameter, [String unusedPositional]);\n}\n\nclass BadTwo {\n  int c;\n\n  BadTwo(int a, int b, int x) {\n    c = a + b;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_unused_constructor_parameters.html)"
      },
      {
        "real_name": "avoid_void_async",
        "display_name": "AvoidVoidAsync",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid void async",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** mark async functions to return Future<void>.</void>\n\nWhen declaring an async method or function which does not return a value,\ndeclare that it returns Future<void> and not just void.</void>\n\n**BAD:**\n\n```\nvoid f() async {}\nvoid f2() async =&gt; null;\n\n```\n\n**GOOD:**\n\n```\nFuture&lt;void&gt; f() async {}\nFuture&lt;void&gt; f2() async =&gt; null;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_void_async.html)"
      },
      {
        "real_name": "avoid_web_libraries_in_flutter",
        "display_name": "AvoidWebLibrariesInFlutter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "avoid web libraries in flutter",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Avoid using web libraries, `dart:html`, `dart:js` and \n`dart:js_util` in Flutter packages that are not web plugins. These libraries are \nnot supported outside a web context; functionality that depends on them will\nfail at runtime in Flutter mobile, and their use is generally discouraged in\nFlutter web.\n\nWeb library access **is** allowed in:\n\n- plugin packages that declare `web` as a supported context\n\notherwise, imports of `dart:html`, `dart:js` and  `dart:js_util` are disallowed.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/avoid_web_libraries_in_flutter.html)"
      },
      {
        "real_name": "await_only_futures",
        "display_name": "AwaitOnlyFutures",
        "severity": "warning",
        "category": "convention",
        "rule_title": "await only futures",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using await on anything other than a future.\n\n**BAD:**\n\n```\nmain() async {\n  print(await 23);\n}\n\n```\n\n**GOOD:**\n\n```\nmain() async {\n  print(await Future.value(23));\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/await_only_futures.html)"
      },
      {
        "real_name": "camel_case_extensions",
        "display_name": "CamelCaseExtensions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "camel case extensions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** name extensions using `UpperCamelCase`.\n\nExtensions should capitalize the first letter of each word (including\nthe first word), and use no separators.\n\n**GOOD:**\n\n```\nextension MyFancyList&lt;T&gt; on List&lt;T&gt; { \n  // ... \n}\n\nextension SmartIterable&lt;T&gt; on Iterable&lt;T&gt; {\n  // ...\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/camel_case_extensions.html)"
      },
      {
        "real_name": "camel_case_types",
        "display_name": "CamelCaseTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "camel case types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DO** name types using UpperCamelCase.\n\nClasses and typedefs should capitalize the first letter of each word (including\nthe first word), and use no separators.\n\n**GOOD:**\n\n```\nclass SliderMenu {\n  // ...\n}\n\nclass HttpRequest {\n  // ...\n}\n\ntypedef num Adder(num x, num y);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/camel_case_types.html)"
      },
      {
        "real_name": "cancel_subscriptions",
        "display_name": "CancelSubscriptions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "cancel subscriptions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** invoke `cancel` on instances of `dart.async.StreamSubscription`.\n\nCancelling instances of StreamSubscription prevents memory leaks and unexpected\nbehavior.\n\n**BAD:**\n\n```\nclass A {\n  StreamSubscription _subscriptionA; // LINT\n  void init(Stream stream) {\n    _subscriptionA = stream.listen((_) {});\n  }\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction() {\n  StreamSubscription _subscriptionF; // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nclass B {\n  StreamSubscription _subscriptionB; // OK\n  void init(Stream stream) {\n    _subscriptionB = stream.listen((_) {});\n  }\n\n  void dispose(filename) {\n    _subscriptionB.cancel();\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunctionOK() {\n  StreamSubscription _subscriptionB; // OK\n  _subscriptionB.cancel();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/cancel_subscriptions.html)"
      },
      {
        "real_name": "cascade_invocations",
        "display_name": "CascadeInvocations",
        "severity": "warning",
        "category": "convention",
        "rule_title": "cascade invocations",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** Use the cascading style when succesively invoking methods on the same\nreference.\n\n**BAD:**\n\n```\nSomeClass someReference = SomeClass();\nsomeReference.firstMethod();\nsomeReference.secondMethod();\n\n```\n\n**BAD:**\n\n```\nSomeClass someReference = SomeClass();\n...\nsomeReference.firstMethod();\nsomeReference.aProperty = value;\nsomeReference.secondMethod();\n\n```\n\n**GOOD:**\n\n```\nSomeClass someReference = SomeClass()\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n\n```\n\n**GOOD:**\n\n```\nSomeClass someReference = SomeClass();\n...\nsomeReference\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/cascade_invocations.html)"
      },
      {
        "real_name": "close_sinks",
        "display_name": "CloseSinks",
        "severity": "warning",
        "category": "convention",
        "rule_title": "close sinks",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** invoke `close` on instances of `dart.core.Sink`.\n\nClosing instances of Sink prevents memory leaks and unexpected behavior.\n\n**BAD:**\n\n```\nclass A {\n  IOSink _sinkA;\n  void init(filename) {\n    _sinkA = new File(filename).openWrite(); // LINT\n  }\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction() {\n  IOSink _sinkF; // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nclass B {\n  IOSink _sinkB;\n  void init(filename) {\n    _sinkB = new File(filename).openWrite(); // OK\n  }\n\n  void dispose(filename) {\n    _sinkB.close();\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunctionOK() {\n  IOSink _sinkFOK; // OK\n  _sinkFOK.close();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/close_sinks.html)"
      },
      {
        "real_name": "comment_references",
        "display_name": "CommentReferences",
        "severity": "warning",
        "category": "convention",
        "rule_title": "comment references",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** reference only in scope identifiers in doc comments.\n\nIf you surround things like variable, method, or type names in square brackets,\nthen [dartdoc](https://dart.dev/guides/language/effective-dart/documentation) will look\nup the name and link to its docs.  For this all to work, ensure that all\nidentifiers in docs wrapped in brackets are in scope.\n\nFor example,\n\n**GOOD:**\n\n```\n/// Return the larger of [a] or [b].\nint max_int(int a, int b) { ... }\n\n```\n\nOn the other hand, assuming `outOfScopeId` is out of scope:\n\n**BAD:**\n\n```\n/// Return true if [value] is larger than [outOfScopeId].\nbool isOutOfRange(int value) { ... }\n\n```\n\nNote that the square bracket comment format is designed to allow \ncomments to refer to declarations using a fairly natural format \nbut does not allow **arbitrary expressions**.  In particular, code \nreferences within square brackets can consist of either\n\n- a single identifier where the identifier is any identifier in scope for the comment (see the spec for what is in scope in doc comments),\n- two identifiers separated by a period where the first identifier is the name of a class that is in scope and the second is the name of a member declared in the class,\n- a single identifier followed by a pair of parentheses where the identifier is the name of a class that is in scope (used to refer to the unnamed constructor for the class), or\n- two identifiers separated by a period and followed by a pair of parentheses where the first identifier is the name of a class that is in scope and the second is the name of a named constructor (not strictly necessary, but allowed for consistency).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/comment_references.html)"
      },
      {
        "real_name": "constant_identifier_names",
        "display_name": "ConstantIdentifierNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "constant identifier names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** using lowerCamelCase for constant names.\n\nIn new code, use `lowerCamelCase` for constant variables, including enum values.\n\nIn existing code that uses `ALL_CAPS_WITH_UNDERSCORES` for constants, you may\ncontinue to use all caps to stay consistent.\n\n**GOOD:**\n\n```\nconst pi = 3.14;\nconst defaultTimeout = 1000;\nfinal urlScheme = new RegExp('^([a-z]+):');\n\nclass Dice {\n  static final numberGenerator = new Random();\n}\n\n```\n\n**BAD:**\n\n```\nconst PI = 3.14;\nconst kDefaultTimeout = 1000;\nfinal URL_SCHEME = new RegExp('^([a-z]+):');\n\nclass Dice {\n  static final NUMBER_GENERATOR = new Random();\n}\n\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/constant_identifier_names.html)"
      },
      {
        "real_name": "control_flow_in_finally",
        "display_name": "ControlFlowInFinally",
        "severity": "warning",
        "category": "convention",
        "rule_title": "control flow in finally",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** control flow leaving finally blocks.\n\nUsing control flow in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.\n\n**GOOD:**\n\n```\nclass Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n\n```\n\n**BAD:**\n\n```\nclass BadReturn {\n  double nonCompliantMethod() {\n    try {\n      return 1 / 0;\n    } catch (e) {\n      print(e);\n    } finally {\n      return 1.0; // LINT\n    }\n  }\n}\n\n```\n\n**BAD:**\n\n```\nclass BadContinue {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        continue; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n\n```\n\n**BAD:**\n\n```\nclass BadBreak {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        break; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/control_flow_in_finally.html)"
      },
      {
        "real_name": "curly_braces_in_flow_control_structures",
        "display_name": "CurlyBracesInFlowControlStructures",
        "severity": "warning",
        "category": "convention",
        "rule_title": "curly braces in flow control structures",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use curly braces for all flow control structures.\n\nDoing so avoids the [dangling else](http://en.wikipedia.org/wiki/Dangling_else)\nproblem.\n\n**GOOD:**\n\n```\nif (isWeekDay) {\n  print('Bike to work!');\n} else {\n  print('Go dancing or read a book!');\n}\n\n```\n\nThere is one exception to this: an `if` statement with no `else` clause where\nthe entire `if` statement and the then body all fit in one line. In that case,\nyou may leave off the braces if you prefer:\n\n**GOOD:**\n\n```\nif (arg == null) return defaultValue;\n\n```\n\nIf the body wraps to the next line, though, use braces:\n\n**GOOD:**\n\n```\nif (overflowChars != other.overflowChars) {\n  return overflowChars &lt; other.overflowChars;\n}\n\n```\n\n**BAD:**\n\n```\nif (overflowChars != other.overflowChars)\n  return overflowChars &lt; other.overflowChars;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/curly_braces_in_flow_control_structures.html)"
      },
      {
        "real_name": "diagnostic_describe_all_properties",
        "display_name": "DiagnosticDescribeAllProperties",
        "severity": "warning",
        "category": "convention",
        "rule_title": "diagnostic describe all properties",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** reference all public properties in `debug` method implementations.\n\nImplementers of `DiagnosticableMixin` should reference all public properties in\na `debugFillProperties(...)` or `debugDescribeChildren(...)` method\nimplementation to improve debuggability at runtime.\n\nPublic properties are defined as fields and getters that are\n\n- not package-private (e.g., prefixed with `_`)\n- not `static` or overriding\n- not themselves `Widget`s or collections of `Widget`s\n\nIn addition, the \"debug\" prefix is treated specially for properties in Flutter.\nFor the purposes of diagnostics, a property `foo` and a prefixed property\n`debugFoo` are treated as effectively describing the same property and it is\nsufficient to refer to one or the other.\n\n**BAD:**\n\n```\nclass Absorber extends Widget {\n  bool get absorbing =&gt; _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics =&gt; _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty&lt;bool&gt;('absorbing', absorbing));\n    // Missing reference to ignoringSemantics\n  }\n}  \n\n```\n\n**GOOD:**\n\n```\nclass Absorber extends Widget {\n  bool get absorbing =&gt; _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics =&gt; _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty&lt;bool&gt;('absorbing', absorbing));\n    properties.add(DiagnosticsProperty&lt;bool&gt;('ignoringSemantics', ignoringSemantics));\n  }\n}  \n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/diagnostic_describe_all_properties.html)"
      },
      {
        "real_name": "directives_ordering",
        "display_name": "DirectivesOrdering",
        "severity": "warning",
        "category": "convention",
        "rule_title": "directives ordering",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** follow the conventions in the \n[Effective Dart Guide](https://dart.dev/guides/language/effective-dart/style#ordering)\n\n**DO** place “dart:” imports before other imports.\n\n**BAD:**\n\n```\nimport 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n\nimport 'dart:async';  // LINT\nimport 'dart:html';  // LINT\n\n```\n\n**BAD:**\n\n```\nimport 'dart:html';  // OK\nimport 'package:bar/bar.dart';\n\nimport 'dart:async';  // LINT\nimport 'package:foo/foo.dart';\n\n```\n\n**GOOD:**\n\n```\nimport 'dart:async';  // OK\nimport 'dart:html';  // OK\n\nimport 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n\n```\n\n**DO** place “package:” imports before relative imports.\n\n**BAD:**\n\n```\nimport 'a.dart';\nimport 'b.dart';\n\nimport 'package:bar/bar.dart';  // LINT\nimport 'package:foo/foo.dart';  // LINT\n\n```\n\n**BAD:**\n\n```\nimport 'package:bar/bar.dart';  // OK\nimport 'a.dart';\n\nimport 'package:foo/foo.dart';  // LINT\nimport 'b.dart';\n\n```\n\n**GOOD:**\n\n```\nimport 'package:bar/bar.dart';  // OK\nimport 'package:foo/foo.dart';  // OK\n\nimport 'a.dart';\nimport 'b.dart';\n\n```\n\n**PREFER** placing “third-party” “package:” imports before other imports.\n\n**BAD:**\n\n```\nimport 'package:myapp/io.dart';\nimport 'package:myapp/util.dart';\n\nimport 'package:bar/bar.dart';  // LINT\nimport 'package:foo/foo.dart';  // LINT\n\n```\n\n**GOOD:**\n\n```\nimport 'package:bar/bar.dart';  // OK\nimport 'package:foo/foo.dart';  // OK\n\nimport 'package:myapp/io.dart';\nimport 'package:myapp/util.dart';\n\n```\n\n**DO** specify exports in a separate section after all imports.\n\n**BAD:**\n\n```\nimport 'src/error.dart';\nexport 'src/error.dart'; // LINT\nimport 'src/string_source.dart';\n\n```\n\n**GOOD:**\n\n```\nimport 'src/error.dart';\nimport 'src/string_source.dart';\n\nexport 'src/error.dart'; // OK\n\n```\n\n**DO** sort sections alphabetically.\n\n**BAD:**\n\n```\nimport 'package:foo/bar.dart'; // OK\nimport 'package:bar/bar.dart'; // LINT\n\nimport 'a/b.dart'; // OK\nimport 'a.dart'; // LINT\n\n```\n\n**GOOD:**\n\n```\nimport 'package:bar/bar.dart'; // OK\nimport 'package:foo/bar.dart'; // OK\n\nimport 'a.dart'; // OK\nimport 'a/b.dart'; // OK\n\n\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/directives_ordering.html)"
      },
      {
        "real_name": "empty_catches",
        "display_name": "EmptyCatches",
        "severity": "warning",
        "category": "convention",
        "rule_title": "empty catches",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** empty catch blocks.\n\nIn general, empty catch blocks should be avoided.  In cases where they are\nintended, a comment should be provided to explain why exceptions are being\ncaught and suppressed.  Alternatively, the exception identifier can be named with\nunderscores (e.g., `_`) to indicate that we intend to skip it.\n\n**BAD:**\n\n```\ntry {\n  ...\n} catch(exception) { }\n\n```\n\n**GOOD:**\n\n```\ntry {\n  ...\n} catch(e) {\n  // ignored, really.\n}\n\n// Alternatively:\ntry {\n  ...\n} catch(_) { }\n\n// Better still:\ntry {\n  ...\n} catch(e) {\n  doSomething(e);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/empty_catches.html)"
      },
      {
        "real_name": "empty_constructor_bodies",
        "display_name": "EmptyConstructorBodies",
        "severity": "warning",
        "category": "convention",
        "rule_title": "empty constructor bodies",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DO** use `;` instead of `{}` for empty constructor bodies.\n\nIn Dart, a constructor with an empty body can be terminated with just a\nsemicolon.  This is required for const constructors.  For consistency and\nbrevity, other constructors should also do this.\n\n**GOOD:**\n\n```\nclass Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n\n```\n\n**BAD:**\n\n```\nclass Point {\n  int x, y;\n  Point(this.x, this.y) {}\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/empty_constructor_bodies.html)"
      },
      {
        "real_name": "empty_statements",
        "display_name": "EmptyStatements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "empty statements",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** empty statements.\n\nEmpty statements almost always indicate a bug.\n\nFor example,\n\n**BAD:**\n\n```\nif (complicated.expression.foo());\n  bar();\n\n```\n\nFormatted with `dartfmt` the bug becomes obvious:\n\n```\nif (complicated.expression.foo()) ;\nbar();\n\n\n```\n\nBetter to avoid the empty statement altogether.\n\n**GOOD:**\n\n```\nif (complicated.expression.foo())\n  bar();\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/empty_statements.html)"
      },
      {
        "real_name": "file_names",
        "display_name": "FileNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "file names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** name source files using `lowercase_with_underscores`.\n\nSome file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.\n\n**GOOD:**\n\n- `slider_menu.dart`\n- `file_system.dart`\n\n**BAD:**\n\n- `SliderMenu.dart`\n- `filesystem.dart`\n- `file-system.dart`\n\nFiles without a strict `.dart` extension are ignored.  For example:\n\n**OK:**\n\n- `file-system.g.dart`\n- `SliderMenu.css.dart`\n\nThe lint `library_names` can be used to enforce the same kind of naming on the\nlibrary.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/file_names.html)"
      },
      {
        "real_name": "flutter_style_todos",
        "display_name": "FlutterStyleTodos",
        "severity": "warning",
        "category": "convention",
        "rule_title": "flutter style todos",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** Use Flutter TODO format.\n\n**GOOD:**\n\n```\n// TODO(username): message.\n// TODO(username): message, https://URL-to-issue.\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/flutter_style_todos.html)"
      },
      {
        "real_name": "hash_and_equals",
        "display_name": "HashAndEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "hash and equals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** override `hashCode` if overriding `==` and prefer overriding `==` if\noverriding `hashCode`.\n\nEvery object in Dart has a `hashCode`.  Both the `==` operator and the\n`hashCode` property of objects must be consistent in order for a common hash\nmap implementation to function properly.  Thus, when overriding `==`, the\n`hashCode` should also be overridden to maintain consistency. Similarly, if\n`hashCode` is overridden, `==` should be also.\n\n**BAD:**\n\n```\nclass Bad {\n  final int value;\n  Bad(this.value);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Bad &amp;&amp; other.value == value;\n}\n\n```\n\n**GOOD:**\n\n```\nclass Better {\n  final int value;\n  Better(this.value);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Better &amp;&amp; other.value == value;\n\n  @override\n  int get hashCode =&gt; value.hashCode;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/hash_and_equals.html)"
      },
      {
        "real_name": "implementation_imports",
        "display_name": "ImplementationImports",
        "severity": "warning",
        "category": "convention",
        "rule_title": "implementation imports",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the the [pub package layout doc](https://dart.dev/tools/pub/package-layout#implementation-files):\n\n**DON'T** import implementation files from another package.\n\nThe libraries inside `lib` are publicly visible: other packages are free to\nimport them.  But much of a package's code is internal implementation libraries\nthat should only be imported and used by the package itself.  Those go inside a\nsubdirectory of `lib` called `src`.  You can create subdirectories in there if\nit helps you organize things.\n\nYou are free to import libraries that live in `lib/src` from within other Dart\ncode in the same package (like other libraries in `lib`, scripts in `bin`,\nand tests) but you should never import from another package's `lib/src`\ndirectory.  Those files are not part of the package's public API, and they\nmight change in ways that could break your code.\n\n**BAD:**\n\n```\n// In 'road_runner'\nimport 'package:acme/lib/src/internals.dart;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/implementation_imports.html)"
      },
      {
        "real_name": "invariant_booleans",
        "display_name": "InvariantBooleans",
        "severity": "warning",
        "category": "convention",
        "rule_title": "invariant booleans",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** test for conditions that can be inferred at compile time or test the\nsame condition twice.\n\nConditional statements using a condition which cannot be anything but `false`\nhave the effect of making blocks of code non-functional.  If the condition\ncannot evaluate to anything but `true`, the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to `true` or `false` and does not perform redundant tests.\nThis rule will hint to the test conflicting with the linted one.\n\n**BAD:**\n\n```\n// foo can't be both equal and not equal to bar in the same expression\nif(foo == bar &amp;&amp; something &amp;&amp; foo != bar) {...}\n\n```\n\n**BAD:**\n\n```\nvoid compute(int foo) {\n  if (foo == 4) {\n    doSomething();\n    // we know foo is equal to 4 at this point, so the next condition is always false\n    if (foo &gt; 4) {...}\n    ...\n  }\n  ...\n}\n\n```\n\n**BAD:**\n\n```\nvoid compute(bool foo) {\n  if (foo) {\n    return;\n  }\n  doSomething();\n  // foo is always false here\n  if (foo){...}\n  ...\n}\n\n```\n\n**GOOD:**\n\n```\nvoid nestedOK() {\n  if (foo == bar) {\n    foo = baz;\n    if (foo != bar) {...}\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid nestedOk2() {\n  if (foo == bar) {\n    return;\n  }\n\n  foo = baz;\n  if (foo == bar) {...} // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid nestedOk5() {\n  if (foo != null) {\n    if (bar != null) {\n      return;\n    }\n  }\n\n  if (bar != null) {...} // OK\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/invariant_booleans.html)"
      },
      {
        "real_name": "iterable_contains_unrelated_type",
        "display_name": "IterableContainsUnrelatedType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "iterable contains unrelated type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** invoke `contains` on `Iterable` with an instance of different type\nthan the parameter type.\n\nDoing this will invoke `==` on its elements and most likely will return `false`.\n\n**BAD:**\n\n```\nvoid someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction3() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction3'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction8() {\n  List&lt;DerivedClass2&gt; list = &lt;DerivedClass2&gt;[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction8'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nabstract class SomeIterable&lt;E&gt; implements Iterable&lt;E&gt; {}\n\nabstract class MyClass implements SomeIterable&lt;int&gt; {\n  bool badMethod(String thing) =&gt; this.contains(thing); // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction10() {\n  var list = [];\n  if (list.contains(1)) print('someFunction10'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction1() {\n  var list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction1'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction4() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction4'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction5() {\n  List&lt;ClassBase&gt; list = &lt;ClassBase&gt;[];\n  DerivedClass1 instance;\n  if (list.contains(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction6() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass2 instance;\n  if (list.contains(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction7() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/iterable_contains_unrelated_type.html)"
      },
      {
        "real_name": "join_return_with_assignment",
        "display_name": "JoinReturnWithAssignment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "join return with assignment",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** join return statement with assignment when possible.\n\n**BAD:**\n\n```\nclass A {\n  B _lazyInstance;\n  static B get instance {\n    _lazyInstance ??= new B(); // LINT\n    return _lazyInstance;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass A {\n  B _lazyInstance;\n  static B get instance =&gt; _lazyInstance ??= new B();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/join_return_with_assignment.html)"
      },
      {
        "real_name": "leading_newlines_in_multiline_strings",
        "display_name": "LeadingNewlinesInMultilineStrings",
        "severity": "warning",
        "category": "convention",
        "rule_title": "leading newlines in multiline strings",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Multiline strings are easier to read when they start with a newline (a newline\nstarting a multiline string is ignored).\n\n**BAD:**\n\n```\nvar s1 = '''{\n  \"a\": 1,\n  \"b\": 2\n}''';\n\n```\n\n**GOOD:**\n\n```\nvar s1 = '''\n{\n  \"a\": 1,\n  \"b\": 2\n}''';\n\nvar s2 = '''This onliner multiline string is ok. It usually allows to escape both ' and \" in the string.''';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/leading_newlines_in_multiline_strings.html)"
      },
      {
        "real_name": "library_names",
        "display_name": "LibraryNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "library names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** name libraries using `lowercase_with_underscores`.\n\nSome file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.\n\n**GOOD:**\n\n- `library peg_parser;`\n\n**BAD:**\n\n- `library peg-parser;`\n\nThe lint `file_names` can be used to enforce the same kind of naming on the\nfile.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/library_names.html)"
      },
      {
        "real_name": "library_prefixes",
        "display_name": "LibraryPrefixes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "library prefixes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use `lowercase_with_underscores` when specifying a library prefix.\n\n**GOOD:**\n\n```\nimport 'dart:math' as math;\nimport 'dart:json' as json;\nimport 'package:js/js.dart' as js;\nimport 'package:javascript_utils/javascript_utils.dart' as js_utils;\n\n```\n\n**BAD:**\n\n```\nimport 'dart:math' as Math;\nimport 'dart:json' as JSON;\nimport 'package:js/js.dart' as JS;\nimport 'package:javascript_utils/javascript_utils.dart' as jsUtils;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/library_prefixes.html)"
      },
      {
        "real_name": "lines_longer_than_80_chars",
        "display_name": "LinesLongerThan80Chars",
        "severity": "warning",
        "category": "convention",
        "rule_title": "lines longer than 80 chars",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** lines longer than 80 characters\n\nReadability studies show that long lines of text are harder to read because your\neye has to travel farther when moving to the beginning of the next line. This is\nwhy newspapers and magazines use multiple columns of text.\n\nIf you really find yourself wanting lines longer than 80 characters, our\nexperience is that your code is likely too verbose and could be a little more\ncompact. The main offender is usually `VeryLongCamelCaseClassNames`. Ask\nyourself, “Does each word in that type name tell me something critical or\nprevent a name collision?” If not, consider omitting it.\n\nNote that dartfmt does 99% of this for you, but the last 1% is you. It does not\nsplit long string literals to fit in 80 columns, so you have to do that\nmanually.\n\nWe make an exception for URIs and file paths. When those occur in comments or\nstrings (usually in imports and exports), they may remain on a single line even\nif they go over the line limit. This makes it easier to search source files for\na given path.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/lines_longer_than_80_chars.html)"
      },
      {
        "real_name": "list_remove_unrelated_type",
        "display_name": "ListRemoveUnrelatedType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "list remove unrelated type",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** invoke `remove` on `List` with an instance of different type than\nthe parameter type.\n\nDoing this will invoke `==` on its elements and most likely will\nreturn `false`.\n\n**BAD:**\n\n```\nvoid someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.remove('1')) print('someFunction'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction3() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.remove('1')) print('someFunction3'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction8() {\n  List&lt;DerivedClass2&gt; list = &lt;DerivedClass2&gt;[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction8'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nabstract class SomeList&lt;E&gt; implements List&lt;E&gt; {}\n\nabstract class MyClass implements SomeList&lt;int&gt; {\n  bool badMethod(String thing) =&gt; this.remove(thing); // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction10() {\n  var list = [];\n  if (list.remove(1)) print('someFunction10'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction1() {\n  var list = &lt;int&gt;[];\n  if (list.remove(1)) print('someFunction1'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction4() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.remove(1)) print('someFunction4'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction5() {\n  List&lt;ClassBase&gt; list = &lt;ClassBase&gt;[];\n  DerivedClass1 instance;\n  if (list.remove(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction6() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass2 instance;\n  if (list.remove(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction7() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/list_remove_unrelated_type.html)"
      },
      {
        "real_name": "literal_only_boolean_expressions",
        "display_name": "LiteralOnlyBooleanExpressions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "literal only boolean expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** test for conditions composed only by literals, since the value can be\ninferred at compile time.\n\nConditional statements using a condition which cannot be anything but FALSE have\nthe effect of making blocks of code non-functional.  If the condition cannot\nevaluate to anything but `true`, the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to `true` or `false`.\n\n**BAD:**\n\n```\nvoid bad() {\n  if (true) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (true &amp;&amp; 1 != 0) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (1 != 0 &amp;&amp; true) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (1 &lt; 0 &amp;&amp; true) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (true &amp;&amp; false) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (1 != 0) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (true &amp;&amp; 1 != 0 || 3 &lt; 4) {} // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid bad() {\n  if (1 != 0 || 3 &lt; 4 &amp;&amp; true) {} // LINT\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/literal_only_boolean_expressions.html)"
      },
      {
        "real_name": "missing_whitespace_between_adjacent_strings",
        "display_name": "MissingWhitespaceBetweenAdjacentStrings",
        "severity": "warning",
        "category": "convention",
        "rule_title": "missing whitespace between adjacent strings",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Add a trailing whitespace to prevent missing whitespace between adjacent\nstrings.\n\nWith long text split accross adjacent strings it's easy to forget a whitespace\nbetween strings.\n\n**BAD:**\n\n```\nvar s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed'\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n\n```\n\n**GOOD:**\n\n```\nvar s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed '\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/missing_whitespace_between_adjacent_strings.html)"
      },
      {
        "real_name": "no_adjacent_strings_in_list",
        "display_name": "NoAdjacentStringsInList",
        "severity": "warning",
        "category": "convention",
        "rule_title": "no adjacent strings in list",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** use adjacent strings in list.\n\nThis can be sign of forgotten comma.\n\n**GOOD:**\n\n```\nList&lt;String&gt; list = &lt;String&gt;[\n  'a' +\n  'b',\n  'c',\n];\n\n```\n\n**BAD:**\n\n```\nList&lt;String&gt; list = &lt;String&gt;[\n  'a'\n  'b',\n  'c',\n];\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/no_adjacent_strings_in_list.html)"
      },
      {
        "real_name": "no_duplicate_case_values",
        "display_name": "NoDuplicateCaseValues",
        "severity": "warning",
        "category": "convention",
        "rule_title": "no duplicate case values",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** use more than one case with same value.\n\nThis is usually a typo or changed value of constant.\n\n**GOOD:**\n\n```\nconst int A = 1;\nswitch (v) {\n  case A:\n  case 2:\n}\n\n```\n\n**BAD:**\n\n```\nconst int A = 1;\nswitch (v) {\n  case 1:\n  case 2:\n  case A:\n  case 2:\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/no_duplicate_case_values.html)"
      },
      {
        "real_name": "no_logic_in_create_state",
        "display_name": "NoLogicInCreateState",
        "severity": "warning",
        "category": "convention",
        "rule_title": "no logic in create state",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** put any logic in `createState()`.\n\nImplementations of  `createState()` should return a new instance\nof a State object and do nothing more.  Since state access is preferred \nvia the `widget` field,  passing data to `State` objects using custom\nconstructor parameters should also be avoided and so further, the State\nconstructor is required to be passed no arguments.\n\n**BAD:**\n\n```\nMyState global;\n\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    global = MyState();\n    return global;\n  } \n}\n\n```\n\n```\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() =&gt; MyState()..field = 42;\n}\n\n```\n\n```\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() =&gt; MyState(42);\n}\n\n```\n\n**GOOD:**\n\n```\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    return MyState();\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/no_logic_in_create_state.html)"
      },
      {
        "real_name": "no_runtimeType_toString",
        "display_name": "NoRuntimetypeTostring",
        "severity": "warning",
        "category": "convention",
        "rule_title": "no runtimeType toString",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Calling `toString` on a runtime type is a non-trivial operation that can\nnegatively impact performance. It's better to avoid it.\n\n**BAD:**\n\n```\nclass A {\n  String toString() =&gt; '$runtimeType()';\n}\n\n```\n\n**GOOD:**\n\n```\nclass A {\n  String toString() =&gt; 'A()';\n}\n\n```\n\nThis lint has some exceptions where performance is not a problem or where real\ntype information is more important than performance:\n\n- in assertion\n- in throw expressions\n- in catch clauses\n- in mixin declaration\n- in abstract class\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/no_runtimeType_toString.html)"
      },
      {
        "real_name": "non_constant_identifier_names",
        "display_name": "NonConstantIdentifierNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "non constant identifier names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** name non-constant identifiers using lowerCamelCase.\n\nClass members, top-level definitions, variables, parameters, named parameters\nand named constructors should capitalize the first letter of each word\nexcept the first word, and use no separators.\n\n**GOOD:**\n\n```\nvar item;\n\nHttpRequest httpRequest;\n\nalign(clearItems) {\n  // ...\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/non_constant_identifier_names.html)"
      },
      {
        "real_name": "null_closures",
        "display_name": "NullClosures",
        "severity": "warning",
        "category": "convention",
        "rule_title": "null closures",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO NOT** pass null as an argument where a closure is expected.\n\nOften a closure that is passed to a method will only be called conditionally,\nso that tests and \"happy path\" production calls do not reveal that `null` will\nresult in an exception being thrown.\n\nThis rule only catches null literals being passed where closures are expected\nin the following locations:\n\n#### Constructors\n\n<li>From `dart:async`\n<ul>\n- `Future` at the 0th positional parameter\n- `Future.microtask` at the 0th positional parameter\n- `Future.sync` at the 0th positional parameter\n- `Timer` at the 0th positional parameter\n- `Timer.periodic` at the 1st positional parameter\n\n- `List.generate` at the 1st positional parameter\n\n#### Static functions\n\n<li>From `dart:async`\n<ul>\n- `scheduleMicrotask` at the 0th positional parameter\n- `Future.doWhile` at the 0th positional parameter\n- `Future.forEach` at the 0th positional parameter\n- `Future.wait` at the named parameter `cleanup`\n- `Timer.run` at the 0th positional parameter\n\n#### Instance methods\n\n<li>From `dart:async`\n<ul>\n- `Future.then` at the 0th positional parameter\n- `Future.complete` at the 0th positional parameter\n\n- `Queue.removeWhere` at the 0th positional parameter\n- `Queue.retain\n<li>`Iterable.firstWhere` at the 0th positional parameter, and the named\nparameter `orElse`</li>\n- `Iterable.forEach` at the 0th positional parameter\n- `Iterable.fold` at the 1st positional parameter\n<li>`Iterable.lastWhere` at the 0th positional parameter, and the named\nparameter `orElse`</li>\n- `Iterable.map` at the 0th positional parameter\n- `Iterable.reduce` at the 0th positional parameter\n<li>`Iterable.singleWhere` at the 0th positional parameter, and the named\nparameter `orElse`</li>\n- `Iterable.skipWhile` at the 0th positional parameter\n- `Iterable.takeWhile` at the 0th positional parameter\n- `Iterable.where` at the 0th positional parameter\n- `List.removeWhere` at the 0th positional parameter\n- `List.retainWhere` at the 0th positional parameter\n- `String.replaceAllMapped` at the 1st positional parameter\n- `String.replaceFirstMapped` at the 1st positional parameter\n- `String.splitMapJoin` at the named parameters `onMatch` and `onNonMatch`\n\n**BAD:**\n\n```\n[1, 3, 5].firstWhere((e) =&gt; e.isOdd, orElse: null);\n\n```\n\n**GOOD:**\n\n```\n[1, 3, 5].firstWhere((e) =&gt; e.isOdd, orElse: () =&gt; null);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/null_closures.html)"
      },
      {
        "real_name": "omit_local_variable_types",
        "display_name": "OmitLocalVariableTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "omit local variable types",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**CONSIDER** omitting type annotations for local variables.\n\nUsually, the types of local variables can be easily inferred, so it isn't\nnecessary to annotate them.\n\n**BAD:**\n\n```\nMap&lt;int, List&lt;Person&gt;&gt; groupByZip(Iterable&lt;Person&gt; people) {\n  Map&lt;int, List&lt;Person&gt;&gt; peopleByZip = &lt;int, List&lt;Person&gt;&gt;{};\n  for (Person person in people) {\n    peopleByZip.putIfAbsent(person.zip, () =&gt; &lt;Person&gt;[]);\n    peopleByZip[person.zip].add(person);\n  }\n  return peopleByZip;\n}\n\n```\n\n**GOOD:**\n\n```\nMap&lt;int, List&lt;Person&gt;&gt; groupByZip(Iterable&lt;Person&gt; people) {\n  var peopleByZip = &lt;int, List&lt;Person&gt;&gt;{};\n  for (var person in people) {\n    peopleByZip.putIfAbsent(person.zip, () =&gt; &lt;Person&gt;[]);\n    peopleByZip[person.zip].add(person);\n  }\n  return peopleByZip;\n}\n\n```\n\n\nIncompatible with: [always_specify_types](always_specify_types.html).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/omit_local_variable_types.html)"
      },
      {
        "real_name": "one_member_abstracts",
        "display_name": "OneMemberAbstracts",
        "severity": "warning",
        "category": "convention",
        "rule_title": "one member abstracts",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**AVOID** defining a one-member abstract class when a simple function will do.\n\nUnlike Java, Dart has first-class functions, closures, and a nice light syntax\nfor using them.  If all you need is something like a callback, just use a\nfunction.  If you're defining a class and it only has a single abstract member\nwith a meaningless name like `call` or `invoke`, there is a good chance\nyou just want a function.\n\n**GOOD:**\n\n```\ntypedef bool Predicate(item);\n\n```\n\n**BAD:**\n\n```\nabstract class Predicate {\n  bool test(item);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/one_member_abstracts.html)"
      },
      {
        "real_name": "only_throw_errors",
        "display_name": "OnlyThrowErrors",
        "severity": "warning",
        "category": "convention",
        "rule_title": "only throw errors",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** throw only instances of classes that extend `dart.core.Error` or\n`dart.core.Exception`.\n\nThrowing instances that do not extend `Error` or `Exception` is a bad practice;\ndoing this is usually a hack for something that should be implemented more\nthoroughly.\n\n**BAD:**\n\n```\nvoid throwString() {\n  throw 'hello world!'; // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nvoid throwArgumentError() {\n  Error error = new ArgumentError('oh!');\n  throw error; // OK\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/only_throw_errors.html)"
      },
      {
        "real_name": "overridden_fields",
        "display_name": "OverriddenFields",
        "severity": "warning",
        "category": "convention",
        "rule_title": "overridden fields",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** override fields.\n\nOverriding fields is almost always done unintentionally.  Regardless, it is a\nbad practice to do so.\n\n**BAD:**\n\n```\nclass Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Bad1 extends Base {\n  @override\n  final field = 'ipsum'; // LINT\n}\n\nclass Bad2 extends Base {\n  @override\n  Object something = 'done'; // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nclass Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Ok extends Base {\n  Object newField; // OK\n\n  final Object newFinal = 'ignore'; // OK\n}\n\n```\n\n**GOOD:**\n\n```\nabstract class BaseLoggingHandler {\n  Base transformer;\n}\n\nclass LogPrintHandler implements BaseLoggingHandler {\n  @override\n  Derived transformer; // OK\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/overridden_fields.html)"
      },
      {
        "real_name": "package_api_docs",
        "display_name": "PackageApiDocs",
        "severity": "warning",
        "category": "convention",
        "rule_title": "package api docs",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** provide doc comments for all public APIs.\n\nAs described in the [pub package layout doc](https://dart.dev/tools/pub/package-layout#implementation-files),\npublic APIs consist in everything in your package's `lib` folder, minus\nimplementation files in `lib/src`, adding elements explicitly exported with an\n`export` directive.\n\nFor example, given `lib/foo.dart`:\n\n```\nexport 'src/bar.dart' show Bar;\nexport 'src/baz.dart';\n\nclass Foo { }\n\nclass _Foo { }\n\n```\n\nits API includes:\n\n- `Foo` (but not `_Foo`)\n- `Bar` (exported) and\n- all **public** elements in `src/baz.dart`\n\nAll public API members should be documented with `///` doc-style comments.\n\n**GOOD:**\n\n```\n/// A Foo.\nabstract class Foo {\n  /// Start foo-ing.\n  void start() =&gt; _start();\n\n  _start();\n}\n\n```\n\n**BAD:**\n\n```\nclass Bar {\n  void bar();\n}\n\n```\n\nAdvice for writing good doc comments can be found in the\n[Doc Writing Guidelines](https://dart.dev/guides/language/effective-dart/documentation).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/package_api_docs.html)"
      },
      {
        "real_name": "package_names",
        "display_name": "PackageNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "package names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [Pubspec format description](https://dart.dev/tools/pub/pubspec):\n\n**DO** use `lowercase_with_underscores` for package names.\n\nPackage names should be all lowercase, with underscores to separate words,\n`just_like_this`.  Use only basic Latin letters and Arabic digits: [a-z0-9_].\nAlso, make sure the name is a valid Dart identifier -- that it doesn't start\nwith digits and isn't a reserved word.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/package_names.html)"
      },
      {
        "real_name": "package_prefixed_library_names",
        "display_name": "PackagePrefixedLibraryNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "package prefixed library names",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** prefix library names with the package name and a dot-separated path.\n\nThis guideline helps avoid the warnings you get when two libraries have the same\nname.  Here are the rules we recommend:\n\n- Prefix all library names with the package name.\n- Make the entry library have the same name as the package.\n<li>For all other libraries in a package, after the package name add the\ndot-separated path to the library's Dart file.</li>\n- For libraries under `lib`, omit the top directory name.\n\nFor example, say the package name is `my_package`.  Here are the library names\nfor various files in the package:\n\n**GOOD:**\n\n```\n// In lib/my_package.dart\nlibrary my_package;\n\n// In lib/other.dart\nlibrary my_package.other;\n\n// In lib/foo/bar.dart\nlibrary my_package.foo.bar;\n\n// In example/foo/bar.dart\nlibrary my_package.example.foo.bar;\n\n// In lib/src/private.dart\nlibrary my_package.src.private;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/package_prefixed_library_names.html)"
      },
      {
        "real_name": "parameter_assignments",
        "display_name": "ParameterAssignments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "parameter assignments",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** assign new values to parameters of methods or functions.\n\nAssigning new values to parameters is generally a bad practice unless an\noperator such as `??=` is used.  Otherwise, arbitrarily reassigning parameters\nis usually a mistake.\n\n**BAD:**\n\n```\nvoid badFunction(int parameter) { // LINT\n  parameter = 4;\n}\n\n```\n\n**BAD:**\n\n```\nvoid badFunction(int required, {int optional: 42}) { // LINT\n  optional ??= 8;\n}\n\n```\n\n**BAD:**\n\n```\nvoid badFunctionPositional(int required, [int optional = 42]) { // LINT\n  optional ??= 8;\n}\n\n```\n\n**BAD:**\n\n```\nclass A {\n    void badMethod(int parameter) { // LINT\n    parameter = 4;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid ok(String parameter) {\n  print(parameter);\n}\n\n```\n\n**GOOD:**\n\n```\nvoid actuallyGood(int required, {int optional}) { // OK\n  optional ??= ...;\n}\n\n```\n\n**GOOD:**\n\n```\nvoid actuallyGoodPositional(int required, [int optional]) { // OK\n  optional ??= ...;\n}\n\n```\n\n**GOOD:**\n\n```\nclass A {\n  void ok(String parameter) {\n    print(parameter);\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/parameter_assignments.html)"
      },
      {
        "real_name": "prefer_adjacent_string_concatenation",
        "display_name": "PreferAdjacentStringConcatenation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer adjacent string concatenation",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use adjacent strings to concatenate string literals.\n\n**BAD:**\n\n```\nraiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other ' +\n    'parts are overrun by martians. Unclear which are which.');\n\n```\n\n**GOOD:**\n\n```\nraiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other '\n    'parts are overrun by martians. Unclear which are which.');\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_adjacent_string_concatenation.html)"
      },
      {
        "real_name": "prefer_asserts_in_initializer_lists",
        "display_name": "PreferAssertsInInitializerLists",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer asserts in initializer lists",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** put asserts in initializer list for constructors with only asserts in\ntheir body.\n\n**GOOD:**\n\n```\nclass A {\n  A(int a) : assert(a != null);\n}\n\n```\n\n**BAD:**\n\n```\nclass A {\n  A(int a) {\n    assert(a != null);\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_asserts_in_initializer_lists.html)"
      },
      {
        "real_name": "prefer_asserts_with_message",
        "display_name": "PreferAssertsWithMessage",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer asserts with message",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "When assertions fail it's not always simple to understand why. Adding a message\nto the `assert` helps the developer to understand why the AssertionError occurs.\n\n**BAD:**\n\n```\nf(a) {\n  assert(a != null);\n}\n\nclass A {\n  A(a) : assert(a != null);\n}\n\n```\n\n**GOOD:**\n\n```\nf(a) {\n  assert(a != null, 'a must not be null');\n}\n\nclass A {\n  A(a) : assert(a != null, 'a must not be null');\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_asserts_with_message.html)"
      },
      {
        "real_name": "prefer_collection_literals",
        "display_name": "PreferCollectionLiterals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer collection literals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use collection literals when possible.\n\n**BAD:**\n\n```\nvar points = new List();\nvar addresses = new Map();\nvar uniqueNames = new Set();\nvar ids = new LinkedHashSet();\nvar coordinates = new LinkedHashMap();\n\n```\n\n**GOOD:**\n\n```\nvar points = [];\nvar addresses = &lt;String,String&gt;{};\nvar uniqueNames = &lt;String&gt;{};\nvar ids = &lt;int&gt;{};\nvar coordinates = &lt;int,int&gt;{};\n\n```\n\n**EXCEPTIONS:**\n\nThere are cases with `LinkedHashSet` or `LinkedHashMap` where a literal constructor\nwill trigger a type error so those will be excluded from the lint.\n\n```\nvoid main() {\n  LinkedHashSet&lt;int&gt; linkedHashSet =  LinkedHashSet.from([1, 2, 3]); // OK\n  LinkedHashMap linkedHashMap = LinkedHashMap(); // OK\n  \n  printSet(LinkedHashSet&lt;int&gt;()); // LINT\n  printHashSet(LinkedHashSet&lt;int&gt;()); // OK\n\n  printMap(LinkedHashMap&lt;int, int&gt;()); // LINT\n  printHashMap(LinkedHashMap&lt;int, int&gt;()); // OK\n}\n\nvoid printSet(Set&lt;int&gt; ids) =&gt; print('$ids!');\nvoid printHashSet(LinkedHashSet&lt;int&gt; ids) =&gt; printSet(ids);\nvoid printMap(Map map) =&gt; print('$map!');\nvoid printHashMap(LinkedHashMap map) =&gt; printMap(map);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_collection_literals.html)"
      },
      {
        "real_name": "prefer_conditional_assignment",
        "display_name": "PreferConditionalAssignment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer conditional assignment",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** using `??=` over testing for null.\n\nAs Dart has the `??=` operator, it is advisable to use it where applicable to\nimprove the brevity of your code.\n\n**BAD:**\n\n```\nString get fullName {\n  if (_fullName == null) {\n    _fullName = getFullUserName(this);\n  }\n  return _fullName;\n}\n\n```\n\n**GOOD:**\n\n```\nString get fullName {\n  return _fullName ??= getFullUserName(this);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_conditional_assignment.html)"
      },
      {
        "real_name": "prefer_const_constructors",
        "display_name": "PreferConstConstructors",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer const constructors",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** using `const` for instantiating constant constructors.\n\nIf a const constructor is available, it is preferable to use it.\n\n**GOOD:**\n\n```\nclass A {\n  const A();\n}\n\nvoid accessA() {\n  A a = const A();\n}\n\n```\n\n**GOOD:**\n\n```\nclass A {\n  final int x;\n\n  const A(this.x);\n}\n\nA foo(int x) =&gt; new A(x);\n\n```\n\n**BAD:**\n\n```\nclass A {\n  const A();\n}\n\nvoid accessA() {\n  A a = new A();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_const_constructors.html)"
      },
      {
        "real_name": "prefer_const_constructors_in_immutables",
        "display_name": "PreferConstConstructorsInImmutables",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer const constructors in immutables",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** declaring const constructors on `@immutable` classes.\n\nIf a class is immutable, it is usually a good idea to make its constructor a\nconst constructor.\n\n**GOOD:**\n\n```\n@immutable\nclass A {\n  final a;\n  const A(this.a);\n}\n\n```\n\n**BAD:**\n\n```\n@immutable\nclass A {\n  final a;\n  A(this.a);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_const_constructors_in_immutables.html)"
      },
      {
        "real_name": "prefer_const_declarations",
        "display_name": "PreferConstDeclarations",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer const declarations",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** using `const` for const declarations.\n\nConst declarations are more hot-reload friendly and allow to use const\nconstructors if an instantiation references this declaration.\n\n**GOOD:**\n\n```\nconst o = &lt;int&gt;[];\n\nclass A {\n  static const o = &lt;int&gt;[];\n}\n\n```\n\n**BAD:**\n\n```\nfinal o = const &lt;int&gt;[];\n\nclass A {\n  static final o = const &lt;int&gt;[];\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_const_declarations.html)"
      },
      {
        "real_name": "prefer_const_literals_to_create_immutables",
        "display_name": "PreferConstLiteralsToCreateImmutables",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer const literals to create immutables",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** using `const` for instantiating list, map and set literals used as\nparameters in immutable class instantiations.\n\n**BAD:**\n\n```\n@immutable\nclass A {\n  A(this.v);\n  final v;\n}\n\nA a1 = new A([1]);\nA a2 = new A({});\n\n```\n\n**GOOD:**\n\n```\nA a1 = new A(const [1]);\nA a2 = new A(const {});\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_const_literals_to_create_immutables.html)"
      },
      {
        "real_name": "prefer_constructors_over_static_methods",
        "display_name": "PreferConstructorsOverStaticMethods",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer constructors over static methods",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** defining constructors instead of static methods to create instances.\n\nIn most cases, it makes more sense to use a named constructor rather than a\nstatic method because it makes instantiation clearer.\n\n**BAD:**\n\n```\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n  static Point polar(num theta, num radius) {\n    return new Point(radius * math.cos(theta),\n        radius * math.sin(theta));\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n  Point.polar(num theta, num radius)\n      : x = radius * math.cos(theta),\n        y = radius * math.sin(theta);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_constructors_over_static_methods.html)"
      },
      {
        "real_name": "prefer_contains",
        "display_name": "PreferContains",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer contains",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** use `indexOf` to see if a collection contains an element.\n\nCalling `indexOf` to see if a collection contains something is difficult to read\nand may have poor performance.\n\nInstead, prefer `contains`.\n\n**GOOD:**\n\n```\nif (!lunchBox.contains('sandwich') return 'so hungry...';\n\n```\n\n**BAD:**\n\n```\nif (lunchBox.indexOf('sandwich') == -1 return 'so hungry...';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_contains.html)"
      },
      {
        "real_name": "prefer_double_quotes",
        "display_name": "PreferDoubleQuotes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer double quotes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use double quotes where they wouldn't require additional escapes.\n\nThat means strings with a double quote may use apostrophes so that the double\nquote isn't escaped (note: we don't lint the other way around, ie, a double\nquoted string with an escaped double quote is not flagged).\n\nIt's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a single quote somewhere.  So single\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.\n\n**BAD:**\n\n```\nuseStrings(\n    'should be double quote',\n    r'should be double quote',\n    r'''should be double quotes''')\n\n```\n\n**GOOD:**\n\n```\nuseStrings(\n    \"should be double quote\",\n    r\"should be double quote\",\n    r\"\"\"should be double quotes\"\"\",\n    'ok with \" inside',\n    'nested ${a ? \"strings\" : \"can\"} be wrapped by a double quote',\n    \"and nested ${a ? 'strings' : 'can be double quoted themselves'}\");\n\n```\n\n\nIncompatible with: [prefer_single_quotes](prefer_single_quotes.html).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_double_quotes.html)"
      },
      {
        "real_name": "prefer_equal_for_default_values",
        "display_name": "PreferEqualForDefaultValues",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer equal for default values",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/usage):\n\n**DO** Use `=` to separate a named parameter from its default value.\n\n**BAD:**\n\n```\nm({a: 1})\n\n```\n\n**GOOD:**\n\n```\nm({a = 1})\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_equal_for_default_values.html)"
      },
      {
        "real_name": "prefer_expression_function_bodies",
        "display_name": "PreferExpressionFunctionBodies",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer expression function bodies",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**CONSIDER** using =&gt; for short members whose body is a single return statement.\n\n**BAD:**\n\n```\nget width {\n  return right - left;\n}\n\n```\n\n**BAD:**\n\n```\nbool ready(num time) {\n  return minTime == null || minTime &lt;= time;\n}\n\n```\n\n**BAD:**\n\n```\ncontainsValue(String value) {\n  return getValues().contains(value);\n}\n\n```\n\n**GOOD:**\n\n```\nget width =&gt; right - left;\n\n```\n\n**GOOD:**\n\n```\nbool ready(num time) =&gt; minTime == null || minTime &lt;= time;\n\n```\n\n**GOOD:**\n\n```\ncontainsValue(String value) =&gt; getValues().contains(value);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_expression_function_bodies.html)"
      },
      {
        "real_name": "prefer_final_fields",
        "display_name": "PreferFinalFields",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer final fields",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** prefer declaring private fields as final if they are not reassigned later\nin the class.\n\nDeclaring fields as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.\n\n**BAD:**\n\n```\nclass BadImmutable {\n  var _label = 'hola mundo! BadImmutable'; // LINT\n  var label = 'hola mundo! BadImmutable'; // OK\n}\n\n```\n\n**BAD:**\n\n```\nclass MultipleMutable {\n  var _label = 'hola mundo! GoodMutable', _offender = 'mumble mumble!'; // LINT\n  var _someOther; // LINT\n\n  MultipleMutable() : _someOther = 5;\n\n  MultipleMutable(this._someOther);\n\n  void changeLabel() {\n    _label= 'hello world! GoodMutable';\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass GoodImmutable {\n  final label = 'hola mundo! BadImmutable', bla = 5; // OK\n  final _label = 'hola mundo! BadImmutable', _bla = 5; // OK\n}\n\n```\n\n**GOOD:**\n\n```\nclass GoodMutable {\n  var _label = 'hola mundo! GoodMutable';\n\n  void changeLabel() {\n    _label = 'hello world! GoodMutable';\n  }\n}\n\n```\n\n**BAD:**\n\n```\nclass AssignedInAllConstructors {\n  var _label; // LINT\n  AssignedInAllConstructors(this._label);\n  AssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n\n```\n\n**GOOD:**\n\n```\nclass NotAssignedInAllConstructors {\n  var _label; // OK\n  NotAssignedInAllConstructors();\n  NotAssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_final_fields.html)"
      },
      {
        "real_name": "prefer_final_in_for_each",
        "display_name": "PreferFinalInForEach",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer final in for each",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** prefer declaring for-each loop variables as final if they are not\nreassigned later in the code.\n\nDeclaring for-each loop variables as final when possible is a good practice\nbecause it helps avoid accidental reassignments and allows the compiler to do\noptimizations.\n\n**BAD:**\n\n```\nfor (var element in elements) { // LINT\n  print('Element: $element');\n}\n\n```\n\n**GOOD:**\n\n```\nfor (final element in elements) {\n  print('Element: $element');\n}\n\n```\n\n**GOOD:**\n\n```\nfor (var element in elements) {\n  element = element + element;\n  print('Element: $element');\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_final_in_for_each.html)"
      },
      {
        "real_name": "prefer_final_locals",
        "display_name": "PreferFinalLocals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer final locals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** prefer declaring variables as final if they are not reassigned later in\nthe code.\n\nDeclaring variables as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.\n\n**BAD:**\n\n```\nvoid badMethod() {\n  var label = 'hola mundo! badMethod'; // LINT\n  print(label);\n}\n\n```\n\n**GOOD:**\n\n```\nvoid goodMethod() {\n  final label = 'hola mundo! goodMethod';\n  print(label);\n}\n\n```\n\n**GOOD:**\n\n```\nvoid mutableCase() {\n  var label = 'hola mundo! mutableCase';\n  print(label);\n  label = 'hello world';\n  print(label);\n}\n\n```\n\n\nIncompatible with: [unnecessary_final](unnecessary_final.html).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_final_locals.html)"
      },
      {
        "real_name": "prefer_for_elements_to_map_fromIterable",
        "display_name": "PreferForElementsToMapFromiterable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer for elements to map fromIterable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "When building maps from iterables, it is preferable to use for elements.\n\n**BAD:**\n\n```\nMap&lt;String, WidgetBuilder&gt;.fromIterable(\n  kAllGalleryDemos,\n  key: (demo) =&gt; '${demo.routeName}',\n  value: (demo) =&gt; demo.buildRoute,\n);\n\n\n```\n\n**GOOD:**\n\n```\nreturn {\n  for (var demo in kAllGalleryDemos)\n    '${demo.routeName}': demo.buildRoute,\n};\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_for_elements_to_map_fromIterable.html)"
      },
      {
        "real_name": "prefer_foreach",
        "display_name": "PreferForeach",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer foreach",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use `forEach` if you are only going to apply a function or a method\nto all the elements of an iterable.\n\nUsing `forEach` when you are only going to apply a function or method to all\nelements of an iterable is a good practice because it makes your code more\nterse.\n\n**BAD:**\n\n```\nfor (final key in map.keys.toList()) {\n  map.remove(key);\n}\n\n```\n\n**GOOD:**\n\n```\nmap.keys.toList().forEach(map.remove);\n\n```\n\n**NOTE:** Replacing a for each statement with a forEach call may change the \nbehavior in the case where there are side-effects on the iterable itself.\n\n```\nfor (final v in myList) {\n  foo().f(v); // This code invokes foo() many times.\n}\n\nmyList.forEach(foo().f); // But this one invokes foo() just once.\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_foreach.html)"
      },
      {
        "real_name": "prefer_function_declarations_over_variables",
        "display_name": "PreferFunctionDeclarationsOverVariables",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer function declarations over variables",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use a function declaration to bind a function to a name.\n\nAs Dart allows local function declarations, it is a good practice to use them in\nthe place of function literals.\n\n**BAD:**\n\n```\nvoid main() {\n  var localFunction = () {\n    ...\n  };\n}\n\n```\n\n**GOOD:**\n\n```\nvoid main() {\n  localFunction() {\n    ...\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_function_declarations_over_variables.html)"
      },
      {
        "real_name": "prefer_generic_function_type_aliases",
        "display_name": "PreferGenericFunctionTypeAliases",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer generic function type aliases",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** generic function type aliases.\n\nWith the introduction of generic functions, function type aliases\n(`typedef void F()`) couldn't express all of the possible kinds of\nparameterization that users might want to express. Generic function type aliases\n(`typedef F = void Function()`) fixed that issue.\n\nFor consistency and readability reasons, it's better to only use one syntax and\nthus prefer generic function type aliases.\n\n**BAD:**\n\n```\ntypedef void F();\n\n```\n\n**GOOD:**\n\n```\ntypedef F = void Function();\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_generic_function_type_aliases.html)"
      },
      {
        "real_name": "prefer_if_elements_to_conditional_expressions",
        "display_name": "PreferIfElementsToConditionalExpressions",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer if elements to conditional expressions",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "When building collections, it is preferable to use `if` elements rather than\nconditionals.\n\n**BAD:**\n\n```\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      isAndroid ? IconButton(icon: Icon(Icons.search)) : null,\n    ].where((child) =&gt; child != null).toList(),\n  );\n}\n\n```\n\n**GOOD:**\n\n```\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      if (isAndroid) IconButton(icon: Icon(Icons.search)),\n    ]\n  );\n}\n\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_if_elements_to_conditional_expressions.html)"
      },
      {
        "real_name": "prefer_if_null_operators",
        "display_name": "PreferIfNullOperators",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer if null operators",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Prefer using if null operators instead of null checks in conditional\nexpressions.\n\n**BAD:**\n\n```\nv = a == null ? b : a;\n\n```\n\n**GOOD:**\n\n```\nv = a ?? b;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_if_null_operators.html)"
      },
      {
        "real_name": "prefer_initializing_formals",
        "display_name": "PreferInitializingFormals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer initializing formals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use initializing formals when possible.\n\nUsing initializing formals when possible makes your code more terse.\n\n**BAD:**\n\n```\nclass Point {\n  num x, y;\n  Point(num x, num y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n}\n\n```\n\n**BAD:**\n\n```\nclass Point {\n  num x, y;\n  Point({num x, num y}) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Point {\n  num x, y;\n  Point({this.x, this.y});\n}\n\n```\n\n**NOTE**\nThis rule will not generate a lint for named parameters unless the parameter\nname and the field name are the same. The reason for this is that resolving\nsuch a lint would require either renaming the field or renaming the parameter,\nand both of those actions would potentially be a breaking change. For example,\nthe following will not generate a lint:\n\n```\nclass Point {\n  bool isEnabled;\n  Point({bool enabled}) {\n    this.isEnabled = enable; // OK\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_initializing_formals.html)"
      },
      {
        "real_name": "prefer_inlined_adds",
        "display_name": "PreferInlinedAdds",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer inlined adds",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Declare elements in list literals inline, rather than using `add` and \n`addAll` methods where possible.\n\n**BAD:**\n\n```\nvar l = ['a']..add('b')..add('c');\nvar l2 = ['a']..addAll(['b', 'c'])\n\n```\n\n**GOOD:**\n\n```\nvar l = ['a', 'b', 'c'];\nvar 2 = ['a', 'b', 'c'];\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_inlined_adds.html)"
      },
      {
        "real_name": "prefer_int_literals",
        "display_name": "PreferIntLiterals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer int literals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use int literals rather than the corresponding double literal.\n\n**BAD:**\n\n```\nconst double myDouble = 8.0;\nfinal anotherDouble = myDouble + 7.0e2;\nmain() {\n  someMethod(6.0);\n}\n\n```\n\n**GOOD:**\n\n```\nconst double myDouble = 8;\nfinal anotherDouble = myDouble + 700;\nmain() {\n  someMethod(6);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_int_literals.html)"
      },
      {
        "real_name": "prefer_interpolation_to_compose_strings",
        "display_name": "PreferInterpolationToComposeStrings",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer interpolation to compose strings",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** using interpolation to compose strings and values.\n\nUsing interpolation when composing strings and values is usually easier to write\nand read than concatenation.\n\n**BAD:**\n\n```\n'Hello, ' + name + '! You are ' + (year - birth) + ' years old.';\n\n```\n\n**GOOD:**\n\n```\n'Hello, $name! You are ${year - birth} years old.';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_interpolation_to_compose_strings.html)"
      },
      {
        "real_name": "prefer_is_empty",
        "display_name": "PreferIsEmpty",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer is empty",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** use `length` to see if a collection is empty.\n\nThe `Iterable` contract does not require that a collection know its length or be\nable to provide it in constant time.  Calling `length` just to see if the\ncollection contains anything can be painfully slow.\n\nInstead, there are faster and more readable getters: `isEmpty` and\n`isNotEmpty`.  Use the one that doesn't require you to negate the result.\n\n**GOOD:**\n\n```\nif (lunchBox.isEmpty) return 'so hungry...';\nif (words.isNotEmpty) return words.join(' ');\n\n```\n\n**BAD:**\n\n```\nif (lunchBox.length == 0) return 'so hungry...';\nif (words.length != 0) return words.join(' ');\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_is_empty.html)"
      },
      {
        "real_name": "prefer_is_not_empty",
        "display_name": "PreferIsNotEmpty",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer is not empty",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** `x.isNotEmpty` to `!x.isEmpty` for `Iterable` and `Map` instances.\n\nWhen testing whether an iterable or map is empty, prefer `isNotEmpty` over\n`!isEmpty` to improve code readability.\n\n**GOOD:**\n\n```\nif (todo.isNotEmpty) {\n  sendResults(request, todo.isEmpty);\n}\n\n```\n\n**BAD:**\n\n```\nif (!sources.isEmpty) {\n  process(sources);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_is_not_empty.html)"
      },
      {
        "real_name": "prefer_is_not_operator",
        "display_name": "PreferIsNotOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer is not operator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "When checking if an object is not of a specified type, it is preferable to use the 'is!' operator.\n\n**BAD:**\n\n```\nif (!(foo is Foo)) {\n  ...\n}\n\n```\n\n**GOOD:**\n\n```\nif (foo is! Foo) {\n  ...\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_is_not_operator.html)"
      },
      {
        "real_name": "prefer_iterable_whereType",
        "display_name": "PreferIterableWheretype",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer iterable whereType",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** `iterable.whereType&lt;T&gt;()` over `iterable.where((e) =&gt; e is T)`.\n\n**BAD:**\n\n```\niterable.where((e) =&gt; e is MyClass)\n\n```\n\n**GOOD:**\n\n```\niterable.whereType&lt;MyClass&gt;()\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_iterable_whereType.html)"
      },
      {
        "real_name": "prefer_mixin",
        "display_name": "PreferMixin",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer mixin",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Dart 2.1 introduced a new syntax for mixins that provides a safe way for a mixin\nto invoke inherited members using `super`. The new style of mixins should always\nbe used for types that are to be mixed in. As a result, this lint will flag any\nuses of a class in a `with` clause.\n\n**BAD:**\n\n```\nclass A {}\nclass B extends Object with A {}\n\n```\n\n**OK:**\n\n```\nmixin M {}\nclass C with M {}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_mixin.html)"
      },
      {
        "real_name": "prefer_null_aware_operators",
        "display_name": "PreferNullAwareOperators",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer null aware operators",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Prefer using null aware operators instead of null checks in conditional\nexpressions.\n\n**BAD:**\n\n```\nv = a == null ? null : a.b;\n\n```\n\n**GOOD:**\n\n```\nv = a?.b;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_null_aware_operators.html)"
      },
      {
        "real_name": "prefer_relative_imports",
        "display_name": "PreferRelativeImports",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer relative imports",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Prefer relative imports for files in `lib/`.\n\nWhen mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use relative imports for files withing the\n`lib/` directory.\n\n**GOOD:**\n\n```\nimport 'bar.dart';\n\n```\n\n**BAD:**\n\n```\nimport 'package:my_package/bar.dart';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_relative_imports.html)"
      },
      {
        "real_name": "prefer_single_quotes",
        "display_name": "PreferSingleQuotes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer single quotes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use single quotes where they wouldn't require additional escapes.\n\nThat means strings with an apostrophe may use double quotes so that the\napostrophe isn't escaped (note: we don't lint the other way around, ie, a single\nquoted string with an escaped apostrophe is not flagged).\n\nIt's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a double quote somewhere.  So double\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.\n\n**BAD:**\n\n```\nuseStrings(\n    \"should be single quote\",\n    r\"should be single quote\",\n    r\"\"\"should be single quotes\"\"\")\n\n```\n\n**GOOD:**\n\n```\nuseStrings(\n    'should be single quote',\n    r'should be single quote',\n    r'''should be single quotes''',\n    \"here's ok\",\n    \"nested ${a ? 'strings' : 'can'} be wrapped by a double quote\",\n    'and nested ${a ? \"strings\" : \"can be double quoted themselves\"}');\n\n```\n\n\nIncompatible with: [prefer_double_quotes](prefer_double_quotes.html).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_single_quotes.html)"
      },
      {
        "real_name": "prefer_spread_collections",
        "display_name": "PreferSpreadCollections",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer spread collections",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Use spread collections when possible.\n\nCollection literals are excellent when you want to create a new collection out \nof individual items. But, when existing items are already stored in another \ncollection, spread collection syntax leads to simpler code.\n\n**BAD:**\n\n```\nWidget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n      ]..addAll(buildTab2Conversation()),\n    ),\n  );\n}\n\n```\n\n```\nvar ints = [1, 2, 3];\nprint(['a']..addAll(ints.map((i) =&gt; i.toString()))..addAll(['c']));\n\n```\n\n```\nvar things;\nvar l = ['a']..addAll(things ?? const []);\n\n```\n\n**GOOD:**\n\n```\nWidget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n        ...buildTab2Conversation(),\n      ],\n    ),\n  );\n}\n\n```\n\n```\nvar ints = [1, 2, 3];\nprint(['a', ...ints.map((i) =&gt; i.toString()), 'c');\n\n```\n\n```\nvar things;\nvar l = ['a', ...?things];\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_spread_collections.html)"
      },
      {
        "real_name": "prefer_typing_uninitialized_variables",
        "display_name": "PreferTypingUninitializedVariables",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer typing uninitialized variables",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**PREFER** specifying a type annotation for uninitialized variables and fields.\n\nForgoing type annotations for uninitialized variables is a bad practice because\nyou may accidentally assign them to a type that you didn't originally intend to.\n\n**BAD:**\n\n```\nclass BadClass {\n  static var bar; // LINT\n  var foo; // LINT\n\n  void method() {\n    var bar; // LINT\n    bar = 5;\n    print(bar);\n  }\n}\n\n```\n\n**BAD:**\n\n```\nvoid aFunction() {\n  var bar; // LINT\n  bar = 5;\n  ...\n}\n\n```\n\n**GOOD:**\n\n```\nclass GoodClass {\n  static var bar = 7;\n  var foo = 42;\n  int baz; // OK\n\n  void method() {\n    int baz;\n    var bar = 5;\n    ...\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_typing_uninitialized_variables.html)"
      },
      {
        "real_name": "prefer_void_to_null",
        "display_name": "PreferVoidToNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "prefer void to null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO NOT** use the type Null where void would work.\n\n**BAD:**\n\n```\nNull f() {}\nFuture&lt;Null&gt; f() {}\nStream&lt;Null&gt; f() {}\nf(Null x) {}\n\n```\n\n**GOOD:**\n\n```\nvoid f() {}\nFuture&lt;void&gt; f() {}\nStream&lt;void&gt; f() {}\nf(void x) {}\n\n```\n\nSome exceptions include formulating special function types:\n\n```\nNull Function(Null, Null);\n\n```\n\nand for making empty literals which are safe to pass into read-only locations\nfor any type of map or list:\n\n```\n&lt;Null&gt;[];\n&lt;int, Null&gt;{};\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/prefer_void_to_null.html)"
      },
      {
        "real_name": "provide_deprecation_message",
        "display_name": "ProvideDeprecationMessage",
        "severity": "warning",
        "category": "convention",
        "rule_title": "provide deprecation message",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** specify a deprecation message (with migration instructions and/or a\nremoval schedule) in the Deprecation constructor.\n\n**BAD:**\n\n```\n@deprecated\nvoid oldFunction(arg1, arg2) {}\n\n```\n\n**GOOD:**\n\n```\n@Deprecated(\"\"\"\n[oldFunction] is being deprecated in favor of [newFunction] (with slightly\ndifferent parameters; see [newFunction] for more information). [oldFunction]\nwill be removed on or after the 4.0.0 release.\n\"\"\")\nvoid oldFunction(arg1, arg2) {}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/provide_deprecation_message.html)"
      },
      {
        "real_name": "public_member_api_docs",
        "display_name": "PublicMemberApiDocs",
        "severity": "warning",
        "category": "convention",
        "rule_title": "public member api docs",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** document all public members.\n\nAll non-overriding public members should be documented with `///` doc-style\ncomments.\n\n**GOOD:**\n\n```\n/// A good thing.\nabstract class Good {\n  /// Start doing your thing.\n  void start() =&gt; _start();\n\n  _start();\n}\n\n```\n\n**BAD:**\n\n```\nclass Bad {\n  void meh() { }\n}\n\n```\n\nIn case a public member overrides a member it is up to the declaring member\nto provide documentation.  For example, in the following, `Sub` needn't\ndocument `init` (though it certainly may, if there's need).\n\n**GOOD:**\n\n```\n/// Base of all things.\nabstract class Base {\n  /// Initialize the base.\n  void init();\n}\n\n/// A sub base.\nclass Sub extends Base {\n  @override\n  void init() { ... }\n}\n\n```\n\nNote that consistent with `dartdoc`, an exception to the rule is made when\ndocumented getters have corresponding undocumented setters.  In this case the\nsetters inherit the docs from the getters.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/public_member_api_docs.html)"
      },
      {
        "real_name": "recursive_getters",
        "display_name": "RecursiveGetters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "recursive getters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** create recursive getters.\n\nRecursive getters are getters which return themselves as a value.  This is\nusually a typo.\n\n**BAD:**\n\n```\nint get field =&gt; field; // LINT\n\n```\n\n**BAD:**\n\n```\nint get otherField {\n  return otherField; // LINT\n}\n\n```\n\n**GOOD:**\n\n```\nint get field =&gt; _field;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/recursive_getters.html)"
      },
      {
        "real_name": "sized_box_for_whitespace",
        "display_name": "SizedBoxForWhitespace",
        "severity": "warning",
        "category": "convention",
        "rule_title": "sized box for whitespace",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Use SizedBox to add whitespace to a layout.\n\nA `Container` is a heavier Widget than a `SizedBox`, and as bonus, `SizedBox` \nhas a `const` constructor.\n\n**BAD:**\n\n```\nWidget buildRow() {\n  return Row(\n    children: &lt;Widget&gt;[\n      const MyLogo(),\n      Container(width: 4),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n\n```\n\n**GOOD:**\n\n```\nWidget buildRow() {\n  return Row(\n    children: const &lt;Widget&gt;[\n      MyLogo(),\n      SizedBox(width: 4),\n      Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/sized_box_for_whitespace.html)"
      },
      {
        "real_name": "slash_for_doc_comments",
        "display_name": "SlashForDocComments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "slash for doc comments",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style):\n\n**PREFER** using `///` for doc comments.\n\nAlthough Dart supports two syntaxes of doc comments (`///` and `/**`), we\nprefer using `///` for doc comments.\n\n**GOOD:**\n\n```\n/// Parses a set of option strings. For each option:\n///\n/// * If it is `null`, then it is ignored.\n/// * If it is a string, then [validate] is called on it.\n/// * If it is any other type, it is *not* validated.\nvoid parse(List options) {\n  // ...\n}\n\n```\n\nWithin a doc comment, you can use markdown for formatting.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/slash_for_doc_comments.html)"
      },
      {
        "real_name": "sort_child_properties_last",
        "display_name": "SortChildPropertiesLast",
        "severity": "warning",
        "category": "convention",
        "rule_title": "sort child properties last",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Sort child properties last in widget instance creations.  This improves\nreadability and plays nicest with UI as Code visualization in IDEs with UI as\nCode Guides in editors (such as IntelliJ) where Properties in the correct order \nappear clearly associated with the constructor call and separated from the \nchildren.\n\n**BAD:**\n\n```\nreturn Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    child: Column(\n      children: &lt;Widget&gt;[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n      mainAxisAlignment: MainAxisAlignment.center,\n    ),\n    widthFactor: 0.5,\n  ),\n  floatingActionButton: FloatingActionButton(\n    child: Icon(Icons.add),\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n  ),\n);\n\n```\n\n**GOOD:**\n\n```\nreturn Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    widthFactor: 0.5,\n    child: Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: &lt;Widget&gt;[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n    ),\n  ),\n  floatingActionButton: FloatingActionButton(\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n    child: Icon(Icons.add),\n  ),\n);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/sort_child_properties_last.html)"
      },
      {
        "real_name": "sort_constructors_first",
        "display_name": "SortConstructorsFirst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "sort constructors first",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** sort constructor declarations before other members.\n\n**GOOD:**\n\n```\nabstract class Animation&lt;T&gt; {\n  const Animation(this.value);\n  double value;\n  void addListener(VoidCallback listener);\n}\n\n```\n\n**BAD:**\n\n```\nabstract class Visitor {\n  double value;\n  visitSomething(Something s);\n  Visitor();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/sort_constructors_first.html)"
      },
      {
        "real_name": "sort_pub_dependencies",
        "display_name": "SortPubDependencies",
        "severity": "warning",
        "category": "convention",
        "rule_title": "sort pub dependencies",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** sort pub dependencies in `pubspec.yaml`.\n\nSorting list of pub dependencies makes maintenance easier.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/sort_pub_dependencies.html)"
      },
      {
        "real_name": "sort_unnamed_constructors_first",
        "display_name": "SortUnnamedConstructorsFirst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "sort unnamed constructors first",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** sort unnamed constructor declarations first, before named ones.\n\n**GOOD:**\n\n```\nabstract class CancelableFuture&lt;T&gt; implements Future&lt;T&gt;  {\n  factory CancelableFuture(computation()) =&gt; ...\n  factory CancelableFuture.delayed(Duration duration, [computation()]) =&gt; ...\n  ...\n}\n\n```\n\n**BAD:**\n\n```\nclass _PriorityItem {\n  factory _PriorityItem.forName(bool isStatic, String name, _MemberKind kind) =&gt; ...\n  _PriorityItem(this.isStatic, this.kind, this.isPrivate);\n  ...\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/sort_unnamed_constructors_first.html)"
      },
      {
        "real_name": "test_types_in_equals",
        "display_name": "TestTypesInEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "test types in equals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** test type arguments in operator ==(Object other).\n\nNot testing types might result in null pointer exceptions which will be\nunexpected for consumers of your class.\n\n**GOOD:**\n\n```\nclass Field {\n}\n\nclass Good {\n  final Field someField;\n\n  Good(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) {\n      return true;\n    }\n    return other is Good &amp;&amp;\n        this.someField == other.someField;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n\n```\n\n**BAD:**\n\n```\nclass Field {\n}\n\nclass Bad {\n  final Field someField;\n\n  Bad(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    Bad otherBad = other as Bad; // LINT\n    bool areEqual = otherBad != null &amp;&amp; otherBad.someField == someField;\n    return areEqual;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/test_types_in_equals.html)"
      },
      {
        "real_name": "throw_in_finally",
        "display_name": "ThrowInFinally",
        "severity": "warning",
        "category": "convention",
        "rule_title": "throw in finally",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** throwing exceptions in finally blocks.\n\nThrowing exceptions in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.\n\n**GOOD:**\n\n```\nclass Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n\n```\n\n**BAD:**\n\n```\nclass BadThrow {\n  double nonCompliantMethod() {\n    try {\n      print('hello world! ${1 / 0}');\n    } catch (e) {\n      print(e);\n    } finally {\n      throw 'Find the hidden error :P'; // LINT\n    }\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/throw_in_finally.html)"
      },
      {
        "real_name": "type_annotate_public_apis",
        "display_name": "TypeAnnotatePublicApis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "type annotate public apis",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From [effective dart](https://dart.dev/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious):\n\n**PREFER** type annotating public APIs.\n\nType annotations are important documentation for how a library should be used.\nAnnotating the parameter and return types of public methods and functions helps\nusers understand what the API expects and what it provides.\n\nNote that if a public API accepts a range of values that Dart's type system\ncannot express, then it is acceptable to leave that untyped.  In that case, the\nimplicit `dynamic` is the correct type for the API.\n\nFor code internal to a library (either private, or things like nested functions)\nannotate where you feel it helps, but don't feel that you **must** provide them.\n\n**BAD:**\n\n```\ninstall(id, destination) {\n  // ...\n}\n\n```\n\nHere, it's unclear what `id` is.  A string? And what is `destination`? A string\nor a `File` object? Is this method synchronous or asynchronous?\n\n**GOOD:**\n\n```\nFuture&lt;bool&gt; install(PackageId id, String destination) {\n  // ...\n}\n\n```\n\nWith types, all of this is clarified.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/type_annotate_public_apis.html)"
      },
      {
        "real_name": "type_init_formals",
        "display_name": "TypeInitFormals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "type init formals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DON'T** type annotate initializing formals.\n\nIf a constructor parameter is using `this.x` to initialize a field, then the\ntype of the parameter is understood to be the same type as the field.\n\n**GOOD:**\n\n```\nclass Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n\n```\n\n**BAD:**\n\n```\nclass Point {\n  int x, y;\n  Point(int this.x, int this.y);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/type_init_formals.html)"
      },
      {
        "real_name": "unawaited_futures",
        "display_name": "UnawaitedFutures",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unawaited futures",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** await functions that return a `Future` inside of an async function body.\n\nIt's easy to forget await in async methods as naming conventions usually don't\ntell us if a method is sync or async (except for some in `dart:io`).\n\nWhen you really **do** want to start a fire-and-forget `Future`, the recommended\nway is to use `unawaited` from `package:pedantic`. The `// ignore` and\n`// ignore_for_file` comments also work.\n\n**GOOD:**\n\n```\nFuture doSomething() =&gt; ...;\n\nvoid main() async {\n  await doSomething();\n\n  unawaited(doSomething()); // Explicitly-ignored fire-and-forget.\n}\n\n```\n\n**BAD:**\n\n```\nvoid main() async {\n  doSomething(); // Likely a bug.\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unawaited_futures.html)"
      },
      {
        "real_name": "unnecessary_await_in_return",
        "display_name": "UnnecessaryAwaitInReturn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary await in return",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Avoid returning an awaited expression when the expression type is assignable to\nthe function's return type.\n\n**BAD:**\n\n```\nFuture&lt;int&gt; future;\nFuture&lt;int&gt; f1() async =&gt; await future;\nFuture&lt;int&gt; f2() async {\n  return await future;\n}\n\n```\n\n**GOOD:**\n\n```\nFuture&lt;int&gt; future;\nFuture&lt;int&gt; f1() =&gt; future;\nFuture&lt;int&gt; f2() {\n  return future;\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_await_in_return.html)"
      },
      {
        "real_name": "unnecessary_brace_in_string_interps",
        "display_name": "UnnecessaryBraceInStringInterps",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary brace in string interps",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using braces in interpolation when not needed.\n\nIf you're just interpolating a simple identifier, and it's not immediately\nfollowed by more alphanumeric text, the `{}` can and should be omitted.\n\n**GOOD:**\n\n```\nprint(\"Hi, $name!\");\n\n```\n\n**BAD:**\n\n```\nprint(\"Hi, ${name}!\");\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_brace_in_string_interps.html)"
      },
      {
        "real_name": "unnecessary_const",
        "display_name": "UnnecessaryConst",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary const",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** repeating const keyword in a const context.\n\n**BAD:**\n\n```\nclass A { const A(); }\nm(){\n  const a = const A();\n  final b = const [const A()];\n}\n\n```\n\n**GOOD:**\n\n```\nclass A { const A(); }\nm(){\n  const a = A();\n  final b = const [A()];\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_const.html)"
      },
      {
        "real_name": "unnecessary_final",
        "display_name": "UnnecessaryFinal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary final",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** use `final` for local variables.\n\n`var` is shorter, and `final` does not change the meaning of the code.\n\n**BAD:**\n\n```\nvoid badMethod() {\n  final label = 'Final or var?';\n  for (final char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid goodMethod() {\n  var label = 'Final or var?';\n  for (var char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n\n```\n\n\nIncompatible with: [prefer_final_locals](prefer_final_locals.html).\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_final.html)"
      },
      {
        "real_name": "unnecessary_getters_setters",
        "display_name": "UnnecessaryGettersSetters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary getters setters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**AVOID** wrapping fields in getters and setters just to be \"safe\".\n\nIn Java and C#, it's common to hide all fields behind getters and setters (or\nproperties in C#), even if the implementation just forwards to the field.  That\nway, if you ever need to do more work in those members, you can without needing\nto touch the callsites.  This is because calling a getter method is different\nthan accessing a field in Java, and accessing a property isn't binary-compatible\nwith accessing a raw field in C#.\n\nDart doesn't have this limitation.  Fields and getters/setters are completely\nindistinguishable.  You can expose a field in a class and later wrap it in a\ngetter and setter without having to touch any code that uses that field.\n\n**GOOD:**\n\n```\nclass Box {\n  var contents;\n}\n\n```\n\n**BAD:**\n\n```\nclass Box {\n  var _contents;\n  get contents =&gt; _contents;\n  set contents(value) {\n    _contents = value;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_getters_setters.html)"
      },
      {
        "real_name": "unnecessary_lambdas",
        "display_name": "UnnecessaryLambdas",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary lambdas",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** create a lambda when a tear-off will do.\n\n**BAD:**\n\n```\nnames.forEach((name) {\n  print(name);\n});\n\n```\n\n**GOOD:**\n\n```\nnames.forEach(print);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_lambdas.html)"
      },
      {
        "real_name": "unnecessary_new",
        "display_name": "UnnecessaryNew",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary new",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** new keyword to create instances.\n\n**BAD:**\n\n```\nclass A { A(); }\nm(){\n  final a = new A();\n}\n\n```\n\n**GOOD:**\n\n```\nclass A { A(); }\nm(){\n  final a = A();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_new.html)"
      },
      {
        "real_name": "unnecessary_null_aware_assignments",
        "display_name": "UnnecessaryNullAwareAssignments",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary null aware assignments",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** `null` in null-aware assignment.\n\nUsing `null` on the right-hand side of a null-aware assignment effectively makes\nthe assignment redundant.\n\n**GOOD:**\n\n```\nvar x;\nx ??= 1;\n\n```\n\n**BAD:**\n\n```\nvar x;\nx ??= null;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_null_aware_assignments.html)"
      },
      {
        "real_name": "unnecessary_null_in_if_null_operators",
        "display_name": "UnnecessaryNullInIfNullOperators",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary null in if null operators",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using `null` as an operand in `if null` operators.\n\nUsing `null` in an `if null` operator is redundant, regardless of which side\n`null` is used on.\n\n**GOOD:**\n\n```\nvar x = a ?? 1;\n\n```\n\n**BAD:**\n\n```\nvar x = a ?? null;\nvar y = null ?? 1;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_null_in_if_null_operators.html)"
      },
      {
        "real_name": "unnecessary_overrides",
        "display_name": "UnnecessaryOverrides",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary overrides",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** override a method to do a super method invocation with same parameters.\n\n**BAD:**\n\n```\nclass A extends B {\n  @override\n  void foo() {\n    super.foo();\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass A extends B {\n  @override\n  void foo() {\n    doSomethingElse();\n  }\n}\n\n```\n\nIt's valid to override a member in the following cases:\n\n<li>if a type (return type or a parameter type) is not the exactly the same as the\nsuper method,</li>\n- if the `covariant` keyword is added to one of the parameters,\n- if documentation comments are present on the member,\n- if the member has annotations other than `@override`.\n\n`noSuchMethod` is a special method and is not checked by this rule.\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_overrides.html)"
      },
      {
        "real_name": "unnecessary_parenthesis",
        "display_name": "UnnecessaryParenthesis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary parenthesis",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using parenthesis when not needed.\n\n**GOOD:**\n\n```\na = b;\n\n```\n\n**BAD:**\n\n```\na = (b);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_parenthesis.html)"
      },
      {
        "real_name": "unnecessary_raw_strings",
        "display_name": "UnnecessaryRawStrings",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary raw strings",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Use raw string only when needed.\n\n**BAD:**\n\n```\nvar s1 = r'a';\n\n```\n\n**GOOD:**\n\n```\nvar s1 = 'a';\nvar s2 = r'$a';\nvar s3 = r'\\a';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_raw_strings.html)"
      },
      {
        "real_name": "unnecessary_statements",
        "display_name": "UnnecessaryStatements",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary statements",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID** using unnecessary statements.\n\nStatements which have no clear effect are usually unnecessary, or should be\nbroken up.\n\nFor example,\n\n**BAD:**\n\n```\nmyvar;\nlist.clear;\n1 + 2;\nmethodOne() + methodTwo();\nfoo ? bar : baz;\n\n```\n\nThough the added methods have a clear effect, the addition itself does not\nunless there is some magical overload of the + operator.\n\nUsually code like this indicates an incomplete thought, and is a bug.\n\n**GOOD:**\n\n```\nsome.method();\nnew SomeClass();\nmethodOne();\nmethodTwo();\nfoo ? bar() : baz();\nreturn myvar;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_statements.html)"
      },
      {
        "real_name": "unnecessary_string_escapes",
        "display_name": "UnnecessaryStringEscapes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary string escapes",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Remove unnecessary backslashes in strings.\n\n**BAD:**\n\n```\n'this string contains 2 \\\"double quotes\\\" ';\n\"this string contains 2 \\'single quotes\\' \";\n\n```\n\n**GOOD:**\n\n```\n'this string contains 2 \"double quotes\" ';\n\"this string contains 2 'single quotes' \";\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_string_escapes.html)"
      },
      {
        "real_name": "unnecessary_string_interpolations",
        "display_name": "UnnecessaryStringInterpolations",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary string interpolations",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Don't use string interpolation if there's only a string expression in it.\n\n**BAD:**\n\n```\nString message;\nString o = '$message';\n\n```\n\n**GOOD:**\n\n```\nString message;\nString o = message;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_string_interpolations.html)"
      },
      {
        "real_name": "unnecessary_this",
        "display_name": "UnnecessaryThis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unnecessary this",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [style guide](https://dart.dev/guides/language/effective-dart/style/):\n\n**DON'T** use `this` when not needed to avoid shadowing.\n\n**BAD:**\n\n```\nclass Box {\n  var value;\n  void update(new_value) {\n    this.value = new_value;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Box {\n  var value;\n  void update(new_value) {\n    value = new_value;\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Box {\n  var value;\n  void update(value) {\n    this.value = value;\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unnecessary_this.html)"
      },
      {
        "real_name": "unrelated_type_equality_checks",
        "display_name": "UnrelatedTypeEqualityChecks",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unrelated type equality checks",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DON'T** Compare references of unrelated types for equality.\n\nComparing references of a type where neither is a subtype of the other most\nlikely will return `false` and might not reflect programmer's intent.\n\n`Int64` and `Int32` from `package:fixnum` allow comparing to `int` provided\nthe `int` is on the right hand side. The lint allows this as a special case. \n\n**BAD:**\n\n```\nvoid someFunction() {\n  var x = '1';\n  if (x == 1) print('someFunction'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction1() {\n  String x = '1';\n  if (x == 1) print('someFunction1'); // LINT\n}\n\n```\n\n**BAD:**\n\n```\nvoid someFunction13(DerivedClass2 instance) {\n  var other = new DerivedClass3();\n\n  if (other == instance) print('someFunction13'); // LINT\n}\n\nclass ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction2() {\n  var x = '1';\n  var y = '2';\n  if (x == y) print(someFunction2); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction3() {\n  for (var i = 0; i &lt; 10; i++) {\n    if (i == 0) print(someFunction3); // OK\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction4() {\n  var x = '1';\n  if (x == null) print(someFunction4); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction7() {\n  List someList;\n\n  if (someList.length == 0) print('someFunction7'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction8(ClassBase instance) {\n  DerivedClass1 other;\n\n  if (other == instance) print('someFunction8'); // OK\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction10(unknown) {\n  var what = unknown - 1;\n  for (var index = 0; index &lt; unknown; index++) {\n    if (what == index) print('someFunction10'); // OK\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nvoid someFunction11(Mixin instance) {\n  var other = new DerivedClass2();\n\n  if (other == instance) print('someFunction11'); // OK\n  if (other != instance) print('!someFunction11'); // OK\n}\n\nclass ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unrelated_type_equality_checks.html)"
      },
      {
        "real_name": "unsafe_html",
        "display_name": "UnsafeHtml",
        "severity": "warning",
        "category": "convention",
        "rule_title": "unsafe html",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**AVOID**\n\n- assigning directly to the `href` field of an AnchorElement\n<li>assigning directly to the `src` field of an EmbedElement, IFrameElement,\nImageElement, or ScriptElement</li>\n- assigning directly to the `srcdoc` field of an IFrameElement\n- calling the `createFragment` method of Element\n- calling the `open` method of Window\n- calling the `setInnerHtml` method of Element\n- calling the `Element.html` constructor\n- calling the `DocumentFragment.html` constructor\n\n**BAD:**\n\n```\nvar script = ScriptElement()..src = 'foo.js';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/unsafe_html.html)"
      },
      {
        "real_name": "use_full_hex_values_for_flutter_colors",
        "display_name": "UseFullHexValuesForFlutterColors",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use full hex values for flutter colors",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Prefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color. Colors\nhave four 8-bit channels, which adds up to 32 bits, so Colors are described\nusing a 32 bit integer.\n\n**BAD:**\n\n```\nColor(1);\nColor(0x000001);\n\n```\n\n**GOOD:**\n\n```\nColor(0x00000001);\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_full_hex_values_for_flutter_colors.html)"
      },
      {
        "real_name": "use_function_type_syntax_for_parameters",
        "display_name": "UseFunctionTypeSyntaxForParameters",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use function type syntax for parameters",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Use generic function type syntax for parameters.\n\n**BAD:**\n\n```\nIterable&lt;T&gt; where(bool predicate(T element)) {}\n\n```\n\n**GOOD:**\n\n```\nIterable&lt;T&gt; where(bool Function(T) predicate) {}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_function_type_syntax_for_parameters.html)"
      },
      {
        "real_name": "use_key_in_widget_constructors",
        "display_name": "UseKeyInWidgetConstructors",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use key in widget constructors",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use key in widget constructors.\n\nIt's a good practice to expose the ability to provide a key when creating public\nwidgets.\n\n**BAD:**\n\n```\nclass MyPublicWidget extends StatelessWidget {\n}\n\n```\n\n**GOOD:**\n\n```\nclass MyPublicWidget extends StatelessWidget {\n  MyPublicWidget({Key key}) : super(key: key);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_key_in_widget_constructors.html)"
      },
      {
        "real_name": "use_raw_strings",
        "display_name": "UseRawStrings",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use raw strings",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "A raw string can be used to avoid escaping only backslashes and dollars.\n\n**BAD:**\n\n```\nvar s = 'A string with only \\\\ and \\$';\n\n```\n\n**GOOD:**\n\n```\nvar s = r'A string with only \\ and $';\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_raw_strings.html)"
      },
      {
        "real_name": "use_rethrow_when_possible",
        "display_name": "UseRethrowWhenPossible",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use rethrow when possible",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use rethrow to rethrow a caught exception.\n\nAs Dart provides rethrow as a feature, it should be used to improve terseness\nand readability.\n\n**BAD:**\n\n```\ntry {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) throw e;\n  handle(e);\n}\n\n```\n\n**GOOD:**\n\n```\ntry {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) rethrow;\n  handle(e);\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_rethrow_when_possible.html)"
      },
      {
        "real_name": "use_setters_to_change_properties",
        "display_name": "UseSettersToChangeProperties",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use setters to change properties",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use a setter for operations that conceptually change a property.\n\n**BAD:**\n\n```\nrectangle.setWidth(3);\nbutton.setVisible(false);\n\n```\n\n**GOOD:**\n\n```\nrectangle.width = 3;\nbutton.visible = false;\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_setters_to_change_properties.html)"
      },
      {
        "real_name": "use_string_buffers",
        "display_name": "UseStringBuffers",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use string buffers",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use string buffers to compose strings.\n\nIn most cases, using a string buffer is preferred for composing strings due to\nits improved performance.\n\n**BAD:**\n\n```\nString foo() {\n  final buffer = '';\n  for (int i = 0; i &lt; 10; i++) {\n    buffer += 'a'; // LINT\n  }\n  return buffer;\n}\n\n```\n\n**GOOD:**\n\n```\nString foo() {\n  final buffer = StringBuffer();\n  for (int i = 0; i &lt; 10; i++) {\n    buffer.write('a');\n  }\n  return buffer.toString();\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_string_buffers.html)"
      },
      {
        "real_name": "use_to_and_as_if_applicable",
        "display_name": "UseToAndAsIfApplicable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "use to and as if applicable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "From the [design guide](https://dart.dev/guides/language/effective-dart/design):\n\n**PREFER** naming a method to___() if it copies the object's state to a new object.\n\n**PREFER** naming a method as___() if it returns a different representation backed by the original object.\n\n**BAD:**\n\n```\nclass Bar {\n  Foo myMethod() {\n    return Foo.from(this);\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Bar {\n  Foo toFoo() {\n    return Foo.from(this);\n  }\n}\n\n```\n\n**GOOD:**\n\n```\nclass Bar {\n  Foo asFoo() {\n    return Foo.from(this);\n  }\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/use_to_and_as_if_applicable.html)"
      },
      {
        "real_name": "valid_regexps",
        "display_name": "ValidRegexps",
        "severity": "warning",
        "category": "convention",
        "rule_title": "valid regexps",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO** use valid regular expression syntax when creating regular expression\ninstances.\n\nRegular expressions created with invalid syntax will throw a `FormatException`\nat runtime so should be avoided.\n\n**BAD:**\n\n```\nprint(RegExp('(').hasMatch('foo()'));\n\n```\n\n**GOOD:**\n\n```\nprint(RegExp('[(]').hasMatch('foo()'));\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/valid_regexps.html)"
      },
      {
        "real_name": "void_checks",
        "display_name": "VoidChecks",
        "severity": "warning",
        "category": "convention",
        "rule_title": "void checks",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "**DO NOT** assign to void.\n\n**BAD:**\n\n```\nclass A&lt;T&gt; {\n  T value;\n  void test(T arg) { }\n}\n\nvoid main() {\n  A&lt;void&gt; a = A&lt;void&gt;();\n  a.value = 1; // LINT\n  a.test(1); // LINT\n}\n\n```\n参考[官方文档-规则描述及代码示例](https://dart-lang.github.io/linter/lints/void_checks.html)"
      },
      {
        "real_name": "nullable_type_in_catch_clause",
        "display_name": "NullableTypeInCatchClause",
        "severity": "warning",
        "category": "convention",
        "rule_title": "A nullable type can't be used in an 'on' clause because it isn't valid to throw 'null'.",
        "rule_params": null,
        "custom": false,
        "languages": [
          "dart"
        ],
        "solution": "Try removing the question mark.",
        "owner": null,
        "labels": [],
        "description": "It is an error if the type `T` in the on-catch clause `on T catch` is potentially nullable."
      }
    ]
  }
]