[
  {
    "name": "findbugs",
    "display_name": "Findbugs",
    "description": "java static analyzer（需要编译）",
    "license": "LGPL",
    "task_processes": [
      "analyze",
      "datahandle",
      "compile"
    ],
    "open_user": true,
    "open_saas": true,
    "scan_app": "codelint",
    "scm_url": null,
    "run_cmd": null,
    "envs": null,
    "build_flag": true,
    "checkrule_set": [
      {
        "real_name": "FL_MATH_USING_FLOAT_PRECISION",
        "display_name": "FlMathUsingFloatPrecision",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法使用浮点精度执行数学运算",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法使用浮点精度执行数学运算。\n   浮点精度非常不精确。例如，\n   16777216.0f + 1.0f = 16777216.0f。考虑使用双数学来代替。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FL_MATH_USING_FLOAT_PRECISION)"
      },
      {
        "real_name": "IMSE_DONT_CATCH_IMSE",
        "display_name": "ImseDontCatchImse",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可疑的捕捉IllegalMonitorStateException",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "IllegalMonitorStateException通常只是\n   抛出代码中的设计缺陷（调用wait或\n   通知一个你没有锁定的物体）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IMSE_DONT_CATCH_IMSE)"
      },
      {
        "real_name": "SKIPPED_CLASS_TOO_BIG",
        "display_name": "SkippedClassTooBig",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "分类太大",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类比可以有效处理的更大，并且没有完全分析错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SKIPPED_CLASS_TOO_BIG)"
      },
      {
        "real_name": "REC_CATCH_EXCEPTION",
        "display_name": "RecCatchException",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "当Exception不被抛出时捕获异常",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用捕获Exception对象的try-catch块，但Exception不是\n  在try块内引发，并且RuntimeException未被明确捕获。这是一个常见的错误模式\n  说try {{} catch（Exception e）{something}作为捕获一些类型异常的简写\n  每个catch块都是相同的，但是这个构造也意外捕获了RuntimeException，\n  掩盖潜在的错误。\n  \n   更好的方法是明确捕获抛出的特定异常，\n  或者显式捕获RuntimeException异常，重新抛出它，然后捕获所有非运行时异常，如下所示：\n  <PRE>\n  尝试{...\n  } catch（RuntimeException e）{throw e;\n  } catch（Exception e）{...处理所有非运行时异常...\n  } </ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#REC_CATCH_EXCEPTION)"
      },
      {
        "real_name": "DLS_OVERWRITTEN_INCREMENT",
        "display_name": "DlsOverwrittenIncrement",
        "severity": "warning",
        "category": "convention",
        "rule_title": "重写增量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码执行递增操作（例如，<code> i ++ </ code>），然后执行\n立即覆盖它。例如，立即<code> i = i ++ </ code>\n用原始值覆盖增加的值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_OVERWRITTEN_INCREMENT)"
      },
      {
        "real_name": "BC_NULL_INSTANCEOF",
        "display_name": "BcNullInstanceof",
        "severity": "warning",
        "category": "convention",
        "rule_title": "检查一个已知的空值是否是一个类型的实例",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个instanceof测试将总是返回false，因为被检查的值保证为null。\n虽然这是安全的，但确保它不是\n表明有一些误解或其他逻辑错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_NULL_INSTANCEOF)"
      },
      {
        "real_name": "NP_NULL_INSTANCEOF",
        "display_name": "NpNullInstanceof",
        "severity": "warning",
        "category": "convention",
        "rule_title": "检查一个已知的空值是否是一个类型的实例",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个instanceof测试将总是返回false，因为被检查的值保证为null。\n虽然这是安全的，但确保它不是\n表明有一些误解或其他逻辑错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_INSTANCEOF)"
      },
      {
        "real_name": "BC_UNCONFIRMED_CAST_OF_RETURN_VALUE",
        "display_name": "BcUnconfirmedCastOfReturnValue",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "未检查/未经确认的方法返回值转换",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码执行方法返回值的未经检查的转换。\n代码可能会调用该方法，以保证演员阵容\n安全，但FindBugs无法验证演员是否安全。检查你的程序逻辑确保这一点\n演员阵容不会失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_UNCONFIRMED_CAST_OF_RETURN_VALUE)"
      },
      {
        "real_name": "BC_UNCONFIRMED_CAST",
        "display_name": "BcUnconfirmedCast",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "未经检查/未经证实的转换",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个阵容没有被选中，并且并非所有类型的实例都可以投射到\n它正在投入的类型。检查你的程序逻辑确保这一点\n演员阵容不会失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_UNCONFIRMED_CAST)"
      },
      {
        "real_name": "BC_BAD_CAST_TO_CONCRETE_COLLECTION",
        "display_name": "BcBadCastToConcreteCollection",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "对混凝土收集有疑问",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将投射抽象集合（例如集合，列表或集合）\n到特定的具体实现（如ArrayList或HashSet）。\n这可能不正确，并且可能会使代码变得脆弱\n它使未来更难切换到其他具体实现\n点。除非你有特别的理由这样做，否则就使用摘要\n集合类。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_BAD_CAST_TO_CONCRETE_COLLECTION)"
      },
      {
        "real_name": "BC_IMPOSSIBLE_DOWNCAST",
        "display_name": "BcImpossibleDowncast",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "向下强制转换检查",
        "rule_params": "",
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个转换总是会抛出一个ClassCastException异常。\r\n分析认为它知道\r\n正在投射的价值的确切类型，以及尝试\r\n将其向下转换为子类型将始终因抛出ClassCastException而失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_IMPOSSIBLE_DOWNCAST)"
      },
      {
        "real_name": "RE_POSSIBLE_UNINTENDED_PATTERN",
        "display_name": "RePossibleUnintendedPattern",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "“”或“|”用于正则表达式",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "正在调用String函数，并且“。”或“|”正在通过\n转换为以正则表达式作为参数的参数。这是你的意图吗？\n例如\n<li> s.replaceAll（“。”，“/”）将返回一个字符串，其中<em>每个</ em>字符已被替换为“/”字符\n<li> s.split（“。”）<em>总是</ em>返回String的零长度数组\n<li>“ab | cd”.replaceAll（“|”，“/”）将返回“/ a / b / | / c / d /”\n<li>“ab | cd”.split（“|”）将返回包含六个（！）元素的数组：[，a，b，|，c，d]\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RE_POSSIBLE_UNINTENDED_PATTERN)"
      },
      {
        "real_name": "RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION",
        "display_name": "ReBadSyntaxForRegularExpression",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "正则表达式的语法无效",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这里的代码使用根据语法无效的正则表达式\n正则表达式。这个语句会在出现PatternSyntaxException时抛出\n执行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)"
      },
      {
        "real_name": "BC_IMPOSSIBLE_CAST",
        "display_name": "BcImpossibleCast",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不可能的演员",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个转换总是会抛出一个ClassCastException异常。\nFindBugs跟踪instanceof检查的类型信息，\n并且还使用关于类型的更精确的信息\n从方法返回并从字段加载的值。\n因此，它可能有更精确的信息\n一个变量的声明类型，并可以用它来确定\n演员将在运行时总是抛出异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_IMPOSSIBLE_CAST)"
      },
      {
        "real_name": "BC_IMPOSSIBLE_INSTANCEOF",
        "display_name": "BcImpossibleInstanceof",
        "severity": "warning",
        "category": "convention",
        "rule_title": "instanceof将始终返回false",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此instanceof测试将始终返回false。虽然这是安全的，但确保它不是\n表明有一些误解或其他逻辑错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_IMPOSSIBLE_INSTANCEOF)"
      },
      {
        "real_name": "BC_VACUOUS_INSTANCEOF",
        "display_name": "BcVacuousInstanceof",
        "severity": "warning",
        "category": "convention",
        "rule_title": "instanceof将始终返回true",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个instanceof测试将始终返回true（除非被测试的值为空）。\n虽然这是安全的，但确保它不是\n表明有一些误解或其他逻辑错误。\n如果你真的想测试它的值为null，那么可能会更清楚\n最好做一个空测试，而不是一个实例测试。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_VACUOUS_INSTANCEOF)"
      },
      {
        "real_name": "RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION",
        "display_name": "ReCantUseFileSeparatorAsRegularExpression",
        "severity": "warning",
        "category": "convention",
        "rule_title": "用于正则表达式的File.separator",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这里的代码使用<code> File.separator </ code>\n正则表达式是必需的。这将在Windows上失败\n平台，其中<code> File.separator </ code>是一个反斜杠，在一个解释中\n正则表达式作为转义字符。 Amoung的其他选项，你可以使用\n<code> File.separatorChar =='\\\\'？ “\\\\\\\\”：File.separator </ code>而不是\n<代码>文件分割符</代码>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)"
      },
      {
        "real_name": "JLM_JSR166_LOCK_MONITORENTER",
        "display_name": "JlmJsr166LockMonitorenter",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在Lock上执行同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法执行同步实现的对象\njava.util.concurrent.locks.Lock。这样的对象被锁定/解锁\n运用\n<code> acquire（）</ code> / <code> release（）</ code>\n比使用<code> synchronized（...）</ code>构造更有用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#JLM_JSR166_LOCK_MONITORENTER)"
      },
      {
        "real_name": "UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS",
        "display_name": "UmacUncallableMethodOfAnonymousClass",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "匿名类中定义的不可调用方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个匿名类定义了一个不直接调用并且不会覆盖的方法\n超类中的方法。由于其他类中的方法不能直接调用方法\n在一个匿名类中声明，似乎这种方法是不可撤销的。方法\n可能只是无用的代码，但也可能是该方法的目的\n重写在超类中声明的方法，并且由于错误或其他错误，该方法不会，\n实际上，重写它打算的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)"
      },
      {
        "real_name": "ODR_OPEN_DATABASE_RESOURCE",
        "display_name": "OdrOpenDatabaseResource",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法可能无法关闭数据库资源",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法创建数据库资源（例如数据库连接\n或行集），不分配给任何\n字段，将其传递给其他方法或返回，并且不会显示为关闭\n所有路径上的对象都不在方法中。＆nbsp;未能\n关闭方法中所有路径上的数据库资源\n导致性能差，并可能导致应用程序\n与数据库进行通信时遇到问题。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ODR_OPEN_DATABASE_RESOURCE)"
      },
      {
        "real_name": "ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH",
        "display_name": "OdrOpenDatabaseResourceExceptionPath",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法可能无法关闭异常情况下的数据库资源",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法创建数据库资源（例如数据库连接\n或行集），不分配给任何\n字段，将其传递给其他方法或返回，并且不会显示为关闭\n所有异常路径上的对象都不在该方法之外。＆nbsp;未能\n关闭方法中所有路径上的数据库资源\n导致性能差，并可能导致应用程序\n与数据库进行通信时遇到问题。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH)"
      },
      {
        "real_name": "JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT",
        "display_name": "JmlJsr166CallingWaitRatherThanAwait",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在util.concurrent抽象中使用监视器样式等待方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用\n<代码>等待（）</代码>，\n<code> notify（）</ code>或\n<代码> notifyAll的（）（）</代码>\n在一个对象上也提供了一个\n<代码>等待（）</代码>，\n<代码>信号（）</代码>，\n<code> signalAll（）</ code>方法（例如util.concurrent Condition对象）。\n这可能不是你想要的，即使你确实需要它，你也应该考虑改变\n您的设计，因为其他开发人员会发现它非常混乱。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT)"
      },
      {
        "real_name": "JLM_JSR166_UTILCONCURRENT_MONITORENTER",
        "display_name": "JlmJsr166UtilconcurrentMonitorenter",
        "severity": "warning",
        "category": "convention",
        "rule_title": "在util.concurrent实例上执行同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法执行同步作为一个实例的对象\n来自java.util.concurrent包（或其子类）的类。实例\n这些类有它们自己的并发控制机制，它们是正交的\n由Java关键字<code> synchronized </ code>提供的同步。例如，\n在<code> AtomicBoolean </ code>上同步不会阻止其他线程\n从修改<code> AtomicBoolean </ code>。\n 这样的代码可能是正确的，但应仔细审查和记录，\n并且可能会让那些在日后需要维护代码的人感到困惑。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#JLM_JSR166_UTILCONCURRENT_MONITORENTER)"
      },
      {
        "real_name": "UPM_UNCALLED_PRIVATE_METHOD",
        "display_name": "UpmUncalledPrivateMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "私人方法从未被调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这种私人方法从来没有被调用。虽然如此\n可能的方法将通过反思来调用，\n这种方法更可能从未被使用过，应该是\n除去。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UPM_UNCALLED_PRIVATE_METHOD)"
      },
      {
        "real_name": "DLS_DEAD_LOCAL_STORE_OF_NULL",
        "display_name": "DlsDeadLocalStoreOfNull",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "将null存储到局部变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码将null存储到本地变量中，并且存储的值不是\n读。这个商店可能已经被引入来协助垃圾收集器，但是\n从Java SE 6.0开始，这已不再需要或非常有用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_DEAD_LOCAL_STORE_OF_NULL)"
      },
      {
        "real_name": "MF_METHOD_MASKS_FIELD",
        "display_name": "MfMethodMasksField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法定义了一个模糊字段的变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法定义一个与字段名称相同的局部变量\n在这个类或一个超类。这可能会导致该方法\n从字段中读取未初始化的值，将该字段保留为未初始化状态，\n或两者。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MF_METHOD_MASKS_FIELD)"
      },
      {
        "real_name": "DMI_INVOKING_TOSTRING_ON_ARRAY",
        "display_name": "DmiInvokingTostringOnArray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在数组上调用toString",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码在数组上调用toString，这会产生一个相当无用的结果\n如[C @ 16f0472。考虑使用Arrays.toString将数组转换为可读\n给出数组内容的字符串。请参阅编程益智游戏，第3章，益智12。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_INVOKING_TOSTRING_ON_ARRAY)"
      },
      {
        "real_name": "DM_USELESS_THREAD",
        "display_name": "DmUselessThread",
        "severity": "warning",
        "category": "performance",
        "rule_title": "线程是使用默认的空运行方法创建的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法创建一个线程，而不是通过从Thread类派生或指定一个run方法\n  通过传递一个Runnable对象。然后，这个线程只会浪费时间。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_USELESS_THREAD)"
      },
      {
        "real_name": "DC_DOUBLECHECK",
        "display_name": "DcDoublecheck",
        "severity": "warning",
        "category": "performance",
        "rule_title": "可能的现场重复检查",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法可能包含一个双重检查锁定的实例。＆nbsp;\n  根据Java内存的语义，这个习语是不正确的\n  。模型＆NBSP;有关更多信息，请参阅网页\n  <a href =“http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html”\n  > http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html </A>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DC_DOUBLECHECK)"
      },
      {
        "real_name": "SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE",
        "display_name": "SqlNonconstantStringPassedToExecute",
        "severity": "warning",
        "category": "performance",
        "rule_title": "非常数字符串传递给SQL语句上的execute或addBatch方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在一个带有String的SQL语句上调用execute或addBatch方法\n被动态生成。考虑使用\n一个准备好的陈述。它效率更高，不易受到影响\nSQL注入攻击。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)"
      },
      {
        "real_name": "SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING",
        "display_name": "SqlPreparedStatementGeneratedFromNonconstantString",
        "severity": "warning",
        "category": "performance",
        "rule_title": "准备好的语句由非常量字符串生成",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码从非常量字符串中创建SQL准备语句。\n如果未选中，则在构建此String时将使用来自用户的受感染数据，SQL注入可能会\n被用来使准备好的陈述做一些意想不到的事情。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING)"
      },
      {
        "real_name": "NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER",
        "display_name": "NmFutureKeywordUsedAsIdentifier",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在更高版本的Java中使用作为关键字的标识符",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "标识符是在Java的更高版本中作为关键字保留的字，并且您的代码将需要更改\n以便在更高版本的Java中进行编译。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)"
      },
      {
        "real_name": "CN_IDIOM",
        "display_name": "CnIdiom",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类实现了Cloneable，但没有定义或使用克隆方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "类实现了Cloneable，但没有定义或\n   使用克隆方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CN_IDIOM)"
      },
      {
        "real_name": "CN_IDIOM_NO_SUPER_CALL",
        "display_name": "CnIdiomNoSuperCall",
        "severity": "warning",
        "category": "convention",
        "rule_title": "clone方法不会调用super.clone（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个非final类定义了一个不调用super.clone（）的clone（）方法。\n如果这个类（“<i> A </ i>”）由一个子类（“<i> B </ i>”）扩展，\n并且子类<i> B </ i>调用super.clone（），那么很可能是\n</ b>的clone（）方法将返回一个类型为<i> A </ i>的对象，\n这违反了clone（）的标准合约。\n\n  如果所有clone（）方法都调用super.clone（），那么它们是有保证的\n使用Object.clone（），它始终返回正确类型的对象。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CN_IDIOM_NO_SUPER_CALL)"
      },
      {
        "real_name": "CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE",
        "display_name": "CnImplementsCloneButNotCloneable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类定义clone（）但不实现Cloneable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个clone（）方法，但该类没有实现Cloneable。\n在某些情况下，这是可以的（例如，你想控制子类的方式\n可以克隆自己），但只要确保这是你的意图。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)"
      },
      {
        "real_name": "VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY",
        "display_name": "VaFormatStringBadConversionFromArray",
        "severity": "warning",
        "category": "convention",
        "rule_title": "数组使用格式字符串以无用的方式格式化",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "用格式字符串格式化的参数之一是一个数组。这将被格式化\n使用相当无用的格式，例如[I @ 304282，它实际上并不显示内容\n的阵列。\n在将它处理为格式化之前，请考虑使用<code> Arrays.asList（...）</ code>包装数组。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY)"
      },
      {
        "real_name": "PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS",
        "display_name": "PzDontReuseEntryObjectsInIterators",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不要在迭代器中重用条目对象",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "entrySet（）方法被允许返回底层Map中的一个Iterator和Map.Entry的视图。这个聪明的想法被用在几个Map实现中，但是引入了令人讨厌的编码错误的可能性。如果映射<code> m </ code>为一个entrySet返回这样一个迭代器，那么<​​code> c.addAll（m.entrySet（））</ code>将会出错。 OpenJDK 1.7中的所有Map实现都已被重写以避免这种情况，您应该这样做。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS)"
      },
      {
        "real_name": "CNT_ROUGH_CONSTANT_VALUE",
        "display_name": "CntRoughConstantValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "找到已知常数的粗略值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "建议使用预定义的库常量来实现代码清晰度和更高的精度。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CNT_ROUGH_CONSTANT_VALUE)"
      },
      {
        "real_name": "DE_MIGHT_DROP",
        "display_name": "DeMightDrop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法可能会抛出异常",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法可能会抛出异常。＆nbsp;一般来说，例外\n  应该以某种方式处理或报告，否则应该抛出\n  脱离方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DE_MIGHT_DROP)"
      },
      {
        "real_name": "DE_MIGHT_IGNORE",
        "display_name": "DeMightIgnore",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法可能会忽略异常",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法可能会忽略一个异常。＆nbsp;一般来说，例外\n  应该以某种方式处理或报告，否则应该抛出\n  脱离方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DE_MIGHT_IGNORE)"
      },
      {
        "real_name": "NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER",
        "display_name": "NmFutureKeywordUsedAsMemberIdentifier",
        "severity": "warning",
        "category": "convention",
        "rule_title": "在更高版本的Java中使用作为关键字的标识符",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此标识符在更高版本的Java中用作关键字。这段代码和\n任何引用这个API的代码，\n将需要进行更改，以便在更高版本的Java中进行编译。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)"
      },
      {
        "real_name": "COLLECTIONDELETE",
        "display_name": "CollectionDelete",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#COLLECTIONDELETE)"
      },
      {
        "real_name": "NS_NON_SHORT_CIRCUIT",
        "display_name": "NsNonShortCircuit",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可疑地使用非短路逻辑",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码似乎使用非短路逻辑（例如，＆amp;\n或|）\n而不是短路逻辑（＆amp;＆amp; or ||）。\n非短路逻辑会导致表达式的两端\n即使可以从中推断出结果也要进行评估\n知道左手边。这可能效率较低，而且\n如果左侧防护箱可能会导致错误\n当评估右侧可能会产生错误。\n\n 请参阅<a href=\"http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2\"> Java\n语言规范</a>了解详情\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NS_NON_SHORT_CIRCUIT)"
      },
      {
        "real_name": "ES_COMPARING_PARAMETER_STRING_WITH_EQ",
        "display_name": "EsComparingParameterStringWithEq",
        "severity": "warning",
        "category": "convention",
        "rule_title": "使用==或！=来比较字符串参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码比较<code> java.lang.String </ code>参数以供参考\n使用==或！=运算符进行平等。要求来电者\n仅将字符串常量或实际字符串传递给方法是不必要的\n脆弱，很少导致可衡量的性能收益。考虑\n改为使用<code> equals（Object）</ code>方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ES_COMPARING_PARAMETER_STRING_WITH_EQ)"
      },
      {
        "real_name": "ES_COMPARING_STRINGS_WITH_EQ",
        "display_name": "EsComparingStringsWithEq",
        "severity": "warning",
        "category": "convention",
        "rule_title": "使用==或！=比较字符串对象",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码比较<code> java.lang.String </ code>对象以供参考\n使用==或！=运算符进行平等。\n除非这两个字符串都是源文件中的常量，或者已经存在\n使用<code> String.intern（）</ code>方法实现相同的字符串\n值可能由两个不同的String对象表示。考虑\n改为使用<code> equals（Object）</ code>方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ES_COMPARING_STRINGS_WITH_EQ)"
      },
      {
        "real_name": "EQ_ABSTRACT_SELF",
        "display_name": "EqAbstractSelf",
        "severity": "warning",
        "category": "convention",
        "rule_title": "抽象类定义了covariant equals（）方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个<code> equals（）</ code>的协变版本。＆nbsp;\n  要正确覆盖<code>中的equals（）</ code>方法\n  <code> java.lang.Object </ code>，<code> equals（）</ code>的参数\n  必须有<code> java.lang.Object </ code>类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_ABSTRACT_SELF)"
      },
      {
        "real_name": "QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT",
        "display_name": "QbaQuestionableBooleanAssignment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法在布尔表达式中分配布尔文字",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法将一个文字布尔值（true或false）赋给if或while表达式中的布尔变量。很可能这是使用==的布尔比较，而不是使用=的赋值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)"
      },
      {
        "real_name": "VR_UNRESOLVABLE_REFERENCE",
        "display_name": "VrUnresolvableReference",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类引用了无法解析的类或方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类引用了一个无法用它分析的库来解决的类或方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VR_UNRESOLVABLE_REFERENCE)"
      },
      {
        "real_name": "EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC",
        "display_name": "EqOverridingEqualsNotSymmetric",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "equals方法在超类中覆盖equals，可能不是对称的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个覆盖超类中equals方法的equals方法。两者都等于方法\n方法使用<code> instanceof </ code>来确定两个对象是否相等。这是充满危险的，\n因为重要的是equals方法是对称的（换言之，<code> a.equals（b）== b.equals（a）</ code>）。\n如果B是A的子类型，并且A的equals方法检查该参数是A的实例，B的equals方法\n检查参数是B的一个实例，它很可能是由这些定义的等价关系\n方法不对称。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)"
      },
      {
        "real_name": "EQ_GETCLASS_AND_CLASS_CONSTANT",
        "display_name": "EqGetclassAndClassConstant",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "子类型的equals方法失败",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类有一个equals方法，如果它被子类继承，它将被破坏。\n它将类文字与参数类进行比较（例如，在类<code> Foo </ code>中）\n它可能会检查<code> Foo.class == o.getClass（）</ code>）。\n最好检查<code> this.getClass（）== o.getClass（）</ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_GETCLASS_AND_CLASS_CONSTANT)"
      },
      {
        "real_name": "DP_DO_INSIDE_DO_PRIVILEGED",
        "display_name": "DpDoInsideDoPrivileged",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用的方法应该只在doPrivileged块内被调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码调用需要安全权限检查的方法。\n  如果这个代码将被授予安全权限，但可能会被没有的代码调用\n  具有安全权限，那么调用需要在doPrivileged块内发生。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DP_DO_INSIDE_DO_PRIVILEGED)"
      },
      {
        "real_name": "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED",
        "display_name": "DpCreateClassloaderInsideDoPrivileged",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类加载器只应在doPrivileged块内创建",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码创建一个类加载器，如果安装了安全管理器，则该类需要权限。\n  如果这个代码可能会被没有的代码调用\n  具有安全权限，那么类加载器创建需要在doPrivileged块内发生。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)"
      },
      {
        "real_name": "MTIA_SUSPECT_STRUTS_INSTANCE_FIELD",
        "display_name": "MtiaSuspectStrutsInstanceField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类扩展了Struts Action类并使用了实例变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类从Struts Action类扩展而来，并使用一个实例成员变量。由于struts框架只创建了一个struts Action类的实例，并且以多线程方式使用，所以这种范例非常令人沮丧，并且很可能存在问题。考虑只使用方法局部变量。仅报告在监视器外写入的实例字段。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)"
      },
      {
        "real_name": "PS_PUBLIC_SEMAPHORES",
        "display_name": "PsPublicSemaphores",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类在其公共接口中公开同步和信号量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此类使用同步以及wait（），notify（）或notifyAll（）（本参考）。此外，使用此类的客户端类还可以使用此类的实例作为同步对象。因为两个类正在使用同一个对象进行同步，所以多线程正确性是可疑的。您不应该在公共参考上同步或调用信号量方法。考虑使用内部私有成员变量来控制同步。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#PS_PUBLIC_SEMAPHORES)"
      },
      {
        "real_name": "RI_REDUNDANT_INTERFACES",
        "display_name": "RiRedundantInterfaces",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类实现与超类相同的接口",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类声明它实现了一个也由超类实现的接口。这是多余的，因为一旦超类实现了一个接口，默认情况下所有的子类都实现了这个接口。它可能指出，自该类创建以来，继承层次结构发生了变化，应该考虑接口实现的所有权。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RI_REDUNDANT_INTERFACES)"
      },
      {
        "real_name": "ICAST_INT_2_LONG_AS_INSTANT",
        "display_name": "IcastInt2LongAsInstant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "int值转换为long并用作绝对时间",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将32位int值转换为64位long值，然后\n将该值传递给需要绝对时间值的方法参数。\n绝对时间值是数字\n自标准基准时间（即“时代”，即1970年1月1日，格林威治标准时间00:00:00）开始的毫秒数。\n例如，以下方法旨在将自纪元以来的秒数转换为日期，这是非常糟糕的\n破碎：\n<PRE>\nDate getDate（int seconds）{return new Date（seconds * 1000）; }\n</ PRE>\n 乘法使用32位算术完成，然后转换为64位数值。\n当一个32位值被转换为64位并用于表示一个绝对时间\n价值，只能在1969年12月和1970年1月的日期。\n\n 上述方法的正确实现是：\n\n<PRE>\n//在2037年之后失败\nDate getDate（int seconds）{return new Date（seconds * 1000L）; }\n\n//更好，适用于所有日期\nDate getDate（long seconds）{return new Date（seconds * 1000）; }\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_INT_2_LONG_AS_INSTANT)"
      },
      {
        "real_name": "ICAST_INTEGER_MULTIPLY_CAST_TO_LONG",
        "display_name": "IcastIntegerMultiplyCastToLong",
        "severity": "warning",
        "category": "convention",
        "rule_title": "整数乘法的结果强制转换为long",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码执行整数乘法，然后将结果转换为长整型，\n如下所示：\n<pre> long convertDaysToMilliseconds（int days）{return 1000 * 3600 * 24 * days; }\n</ PRE>\n \n如果乘法使用长算术完成，则可以避免\n结果溢出的可能性。例如，你\n可以修复上面的代码：\n<pre> long convertDaysToMilliseconds（int days）{return 1000L * 3600 * 24 * days; }\n</ PRE>\n要么\n<pre> static final long MILLISECONDS_PER_DAY = 24L * 3600 * 1000; long convertDaysToMilliseconds（int days）{return days * MILLISECONDS_PER_DAY; }\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)"
      },
      {
        "real_name": "MTIA_SUSPECT_SERVLET_INSTANCE_FIELD",
        "display_name": "MtiaSuspectServletInstanceField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类扩展Servlet类并使用实例变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类从一个Servlet类扩展而来，并使用一个实例成员变量。由于J2EE框架只创建了一个Servlet类的实例，并以多线程方式使用，所以这种范例非常令人沮丧，并且很可能存在问题。考虑只使用方法局部变量。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)"
      },
      {
        "real_name": "IM_MULTIPLYING_RESULT_OF_IREM",
        "display_name": "ImMultiplyingResultOfIrem",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "整数余数结果的整数乘法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码将一个整数常量的结果乘以一个整数常量。\n确保你没有让你的运营商优先权混淆。例如\ni％60 * 1000是（i％60）* 1000，而不是i％（60 * 1000）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IM_MULTIPLYING_RESULT_OF_IREM)"
      },
      {
        "real_name": "TLW_TWO_LOCK_NOTIFY",
        "display_name": "TlwTwoLockNotify",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "通知两个锁",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码在两个锁定时调用notify（）或notifyAll（）\n  举行。如果此通知旨在唤醒wait（）\n  那是持有相同的锁，它可能会死锁，因为等待\n  将只放弃一个锁，通知将无法获得两个锁，\n  因此通知将不会成功。\n   ＆NBSP;如果还有关于两次锁定等待的警告，那么\n   可能是一个bug相当高。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TLW_TWO_LOCK_NOTIFY)"
      },
      {
        "real_name": "UW_UNCOND_WAIT",
        "display_name": "UwUncondWait",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无条件等待",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法包含对<code> java.lang.Object.wait（）</ code>的调用\n  不受条件控制流程的保护。＆nbsp;代码应该在调用wait之前验证它打算等待的条件尚未满足;任何以前的通知都会被忽略。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UW_UNCOND_WAIT)"
      },
      {
        "real_name": "TLW_TWO_LOCK_WAIT",
        "display_name": "TlwTwoLockWait",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "等待两个锁定",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "在保持两个锁的同时等待显示器可能会导致\n  僵局。\n   ＆NBSP;\n   执行等待只会释放对象的锁定\n   正在等待，而不是任何其他的锁。\n   ＆NBSP;\n这不一定是一个错误，但值得研究\n  密切。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TLW_TWO_LOCK_WAIT)"
      },
      {
        "real_name": "UR_UNINIT_READ",
        "display_name": "UrUninitRead",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在构造函数中未初始化的字段读取",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个构造函数读取一个尚未赋值的字段。＆nbsp;\n  这通常是程序员错误地使用该字段时造成的\n  其中一个构造函数的参数。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UR_UNINIT_READ)"
      },
      {
        "real_name": "DM_CONVERT_CASE",
        "display_name": "DmConvertCase",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "考虑使用调用方法的区域设置参数化版本",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "字符串正在被转换为大写或小写，使用平台的默认编码。与国际字符一起使用时，这可能会导致不正确的转换。改为使用<ul> <li> String.toUpperCase（Locale l）</ li> <li> String.toLowerCase（Locale l）</ li> </ ul>版本。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_CONVERT_CASE)"
      },
      {
        "real_name": "EC_UNRELATED_TYPES_USING_POINTER_EQUALITY",
        "display_name": "EcUnrelatedTypesUsingPointerEquality",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "使用指针相等来比较不同的类型",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用指针相等来比较两个似乎是的引用\n不同种类。这种比较的结果在运行时始终是错误的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)"
      },
      {
        "real_name": "DB_DUPLICATE_BRANCHES",
        "display_name": "DbDuplicateBranches",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法对两个分支使用相同的代码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用相同的代码来实现条件分支的两个分支。检查以确保这不是编码错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DB_DUPLICATE_BRANCHES)"
      },
      {
        "real_name": "DM_RUN_FINALIZERS_ON_EXIT",
        "display_name": "DmRunFinalizersOnExit",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法调用危险方法runFinalizersOnExit",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "不要调用System.runFinalizersOnExit\n或Runtime.runFinalizersOnExit出于任何原因：他们是最多的\n危险的方法在Java库中。</ em>  -  Joshua Bloch\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_RUN_FINALIZERS_ON_EXIT)"
      },
      {
        "real_name": "DM_NUMBER_CTOR",
        "display_name": "DmNumberCtor",
        "severity": "warning",
        "category": "performance",
        "rule_title": "方法调用低效的Number构造函数;改为使用静态valueOf",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用<code> new Integer（int）</ code>保证总会产生一个新的对象，而<code> Integer.valueOf（int）</ code>允许缓存值由编译器，类库，或JVM。使用缓存值可避免对象分配，代码将更快。保证-128到127之间的值具有相应的缓存实例，使用<code> valueOf </ code>比使用构造函数快大约3.5倍。对于恒定范围以外的值，两种样式的性能都是相同的。除非类必须与Java 1.5之前的JVM兼容，否则在创建<code> Long </ code>，<code> Integer </ code>的实例时，请使用自动装箱或<code> valueOf（）</ code>方法。 <code> Short </ code>，<code> Character </ code>和<code> Byte </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_NUMBER_CTOR)"
      },
      {
        "real_name": "IMA_INEFFICIENT_MEMBER_ACCESS",
        "display_name": "ImaInefficientMemberAccess",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法访问拥有类的私有成员变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "内部类的这种方法读取或写入拥有类的私有成员变量，或者调用拥有类的私有方法。编译器必须生成一个特殊的方法来访问这个私有成员，导致效率降低。放宽成员变量或方法的保护将允许编译器将其视为正常访问。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IMA_INEFFICIENT_MEMBER_ACCESS)"
      },
      {
        "real_name": "TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED",
        "display_name": "TqUnknownValueUsedWhereAlwaysStrictlyRequired",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "没有使用类型限定符的值在需要具有该限定符的值时使用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "值的使用方式需要使用类型限定符进行注释。类型限定符是严格的，因此该工具会拒绝任何没有适当注释的值。\n           要强制一个值具有严格的注解，请定义一个标识函数，其中的返回值使用严格的注释进行注释。这是通过严格类型限定符注释将未注释的值转换为值的唯一方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED)"
      },
      {
        "real_name": "DM_FP_NUMBER_CTOR",
        "display_name": "DmFpNumberCtor",
        "severity": "warning",
        "category": "performance",
        "rule_title": "方法调用低效的浮点数构造函数;改为使用静态valueOf",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用<code> new Double（double）</ code>保证总会产生一个新的对象，而<code> Double.valueOf（double）</ code>允许缓存由编译器，类库，或JVM。使用缓存值可避免对象分配，代码将更快。除非类必须与Java 1.5之前的JVM兼容，否则在创建<code> Double </ code>和<code> Float </ code>的实例时，请使用自动装箱或<code> valueOf（）</ code>方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_FP_NUMBER_CTOR)"
      },
      {
        "real_name": "DM_STRING_VOID_CTOR",
        "display_name": "DmStringVoidCtor",
        "severity": "warning",
        "category": "security",
        "rule_title": "方法调用低效的新String（）构造函数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用。创建一个新的<code> java.lang.String </ code>对象\n  没有参数的构造函数会浪费内存，因为如此创建的对象会\n  在功能上与空字符串常量不可区分\n  <代码> “”</代码>＆NBSP; Java保证相同的字符串常量\n  将由相同的<code> String </ code>对象表示。＆nbsp;因此，\n  你应该直接使用空字符串常量。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_STRING_VOID_CTOR)"
      },
      {
        "real_name": "TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED",
        "display_name": "TqAlwaysValueUsedWhereNeverRequired",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "值注释为携带一个类型限定符，用于不能携带该限定符的值的情况",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "指定为携带类型限定符注释的值将在要求该值不带该注释的位置或位置消耗。\n           更确切地说，使用类型限定符注释的值指定when = ALWAYS被保证达到某个用途，或者使用相同类型限定符指定when = NEVER时使用的值。\n           例如，假设@NonNegative是类型限定符注释@Negative的昵称（when = When.NEVER）。以下代码将生成此警告，因为return语句需要@NonNegative值，但会收到标记为@Negative的值。 <BLOCKQUOTE>\n<PRE>\npublic @NonNegative整数示例（@Negative整数值）{返回值;\n}\n</ pre> </ blockquote>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED)"
      },
      {
        "real_name": "DM_STRING_TOSTRING",
        "display_name": "DmStringTostring",
        "severity": "warning",
        "category": "security",
        "rule_title": "方法在String上调用toString（）方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用<code> String.toString（）</ code>只是一个冗余操作。\n  只需使用字符串。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_STRING_TOSTRING)"
      },
      {
        "real_name": "STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE",
        "display_name": "StcalStaticSimpleDateFormatInstance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "静态DateFormat",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "正如JavaDoc所述，DateFormats对于多线程使用本质上是不安全的。\n在没有正确同步的情况下跨线程边界共享单个实例将导致错误的行为\n应用。\n 您也可能会遇到序列化问题。\n 建议使用实例字段。\n 有关详情，请参阅<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579\"> Sun Bug＃6231579 </a>\n和<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997\"> Sun Bug＃6178997 </a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)"
      },
      {
        "real_name": "DM_EXIT",
        "display_name": "DmExit",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法调用System.exit（...）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用System.exit会关闭整个Java虚拟机。这个\n   应该只在适当的时候完成。这样的电话使它\n   您的代码很难或不可能被其他代码调用。\n   考虑抛出一个RuntimeException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_EXIT)"
      },
      {
        "real_name": "SWL_SLEEP_WITH_LOCK_HELD",
        "display_name": "SwlSleepWithLockHeld",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法调用Thread.sleep（）并保持一个锁",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用Thread.sleep（）并保持一个锁。这可能会导致非常糟糕的性能和可伸缩性，或死锁，因为其他线程可能正在等待获取该锁。在锁上调用wait（）会更好，它释放锁并允许其他线程运行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SWL_SLEEP_WITH_LOCK_HELD)"
      },
      {
        "real_name": "DMI_HARDCODED_ABSOLUTE_FILENAME",
        "display_name": "DmiHardcodedAbsoluteFilename",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "代码包含对绝对路径名的硬编码引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码使用硬编码到绝对路径名构造File对象\n（例如，<code> new File（“/ home / dannyc / workspace / j2ee / src / share / com / sun / enterprise / deployment”）; </ code>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_HARDCODED_ABSOLUTE_FILENAME)"
      },
      {
        "real_name": "DMI_USELESS_SUBSTRING",
        "display_name": "DmiUselessSubstring",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "子字符串（0）的调用，它返回原始值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码调用String的substring（0），它返回原始值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_USELESS_SUBSTRING)"
      },
      {
        "real_name": "DMI_BAD_MONTH",
        "display_name": "DmiBadMonth",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "月份的值不稳定",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码传递一个固定的月份\n值超出预期范围0..11到一个方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_BAD_MONTH)"
      },
      {
        "real_name": "BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY",
        "display_name": "BcImpossibleDowncastOfToarray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不可能向下转换toArray（）结果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将集合上的<code> toArray（）</ code>转换为结果\n到比<code> Object [] </ code>更具体的类型，如下所示：\n<PRE>\nString [] getAsArray（Collection＆lt; String＆gt; c）{\n  return（String []）c.toArray（）;\n  }\n</ PRE>\n 抛出一个ClassCastException通常会失败。 <code> toArray（）</ code>\n几乎所有集合都返回一个<code> Object [] </ code>。他们无法做任何其他事情，\n因为Collection对象没有引用集合的声明通用类型。\n 从集合中获取特定类型的数组的正确方法是使用\n  <code> c.toArray（new String []）; </ code>\n  或<code> c.toArray（new String [c.size（）]）; </ code>（后者效率稍高）。\n 这有一个共同的/已知的异常例外。 <code> toArray（）</ code>\n由<code> Arrays.asList（...）</ code>返回的列表方法将返回一个协变\n类型数组。例如，<code> Arrays.asArray（new String [] {“a”}）。toArray（）</ code>\n将返回一个<code> String [] </ code>。 FindBugs试图检测和压制\n这种情况下，但可能会错过一些。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)"
      },
      {
        "real_name": "CI_CONFUSED_INHERITANCE",
        "display_name": "CiConfusedInheritance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类是最终的，但声明受保护的字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类声明为final，但声明了要保护的字段。由于这个类是最终的，所以它不能从派生而来，并且受保护的使用是令人困惑的。字段的访问修饰符应更改为私有或公共名称以表示该字段的真实用途。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CI_CONFUSED_INHERITANCE)"
      },
      {
        "real_name": "DM_STRING_CTOR",
        "display_name": "DmStringCtor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法调用低效的新的String（String）构造函数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用<code> java.lang.String（String）</ code>构造函数会浪费内存\n  因为如此构建的对象在功能上是无法区分的\n  从作为参数传递的<code> String </ code>。只需使用\n  参数<code> String </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_STRING_CTOR)"
      },
      {
        "real_name": "DM_BOOLEAN_CTOR",
        "display_name": "DmBooleanCtor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法调用低效布尔构造函数;改用Boolean.valueOf（...）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "创建<code> java.lang.Boolean </ code>浪费的新实例\n  内存，因为<code> Boolean </ code>对象是不可变的，并且存在\n  只有这种类型的两个有用值。＆nbsp;使用<code> Boolean.valueOf（）</ code>\n  方法（或Java 1.5自动装箱）来创建<code> Boolean </ code>对象。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_BOOLEAN_CTOR)"
      },
      {
        "real_name": "DM_GC",
        "display_name": "DmGc",
        "severity": "warning",
        "category": "convention",
        "rule_title": "显式垃圾收集;除了基准测试代码之外极其可疑",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码显式调用垃圾收集。\n  除了在基准测试中的具体用途，这是非常可疑的。\n   过去，人们明确援引的情况\n  例如close或finalize方法的例程中的垃圾收集器\n  导致了巨大的黑洞表现。垃圾收集\n   可能是昂贵的。任何迫使成千上万的情况\n   的垃圾收集将使机器爬行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_GC)"
      },
      {
        "real_name": "DB_DUPLICATE_SWITCH_CLAUSES",
        "display_name": "DbDuplicateSwitchClauses",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法为两个开关子句使用相同的代码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用相同的代码来实现switch语句的两个子句。这可能是重复代码的情况，但也可能表示编码错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DB_DUPLICATE_SWITCH_CLAUSES)"
      },
      {
        "real_name": "STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE",
        "display_name": "StcalInvokeOnStaticDateFormatInstance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用静态DateFormat",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "正如JavaDoc所述，DateFormats对于多线程使用本质上是不安全的。\n检测器发现了一个对通过静态获得的DateFormat实例的调用\n领域。这看起来很可疑。\n 有关详情，请参阅<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579\"> Sun Bug＃6231579 </a>\n和<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997\"> Sun Bug＃6178997 </a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)"
      },
      {
        "real_name": "DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION",
        "display_name": "DmiAnnotationIsNotVisibleToReflection",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无法使用反射来检查是否存在注释，而无需运行时保留",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "除非注释本身已使用@Retention（RetentionPolicy.RUNTIME）进行注释，否则无法使用反射来观察注释\n（例如，通过使用isAnnotationPresent方法）。\n   。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)"
      },
      {
        "real_name": "TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS",
        "display_name": "TqComparingValuesWithIncompatibleTypeQualifiers",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "将值与不兼容的类型限定符进行比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "指定为携带类型限定符注释的值与从未携带该限定符的值进行比较。\n           更确切地说，使用类型限定符注释的值指定when = ALWAYS与相同类型限定符指定when = NEVER时的值进行比较。\n           例如，假设@NonNegative是类型限定符注释@Negative的昵称（when = When.NEVER）。以下代码将生成此警告，因为return语句需要@NonNegative值，但会收到标记为@Negative的值。 <BLOCKQUOTE>\n<PRE>\n公共布尔示例（@Negative Integer value1，@NonNegative Integer value2）{return value1.equals（value2）;\n}\n</ pre> </ blockquote>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS)"
      },
      {
        "real_name": "DM_BOXED_PRIMITIVE_FOR_PARSING",
        "display_name": "DmBoxedPrimitiveForParsing",
        "severity": "warning",
        "category": "performance",
        "rule_title": "拳击/拆箱解析一个原语",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "从String创建盒装基元，仅用于提取未装箱的基元值。\n  只调用静态parseXXX方法会更高效。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_BOXED_PRIMITIVE_FOR_PARSING)"
      },
      {
        "real_name": "DM_NEXTINT_VIA_NEXTDOUBLE",
        "display_name": "DmNextintViaNextdouble",
        "severity": "warning",
        "category": "performance",
        "rule_title": "使用Random的nextInt方法而不是nextDouble来生成随机整数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "如果<code> r </ code>是一个<code> java.util.Random </ code>，您可以从<code> 0 </ code>生成一个随机数到<code> n-1 </ code>\n使用<code> r.nextInt（n）</ code>，而不是使用<code>（int）（r.nextDouble（）* n）</ code>。\n\n nextInt的论点必须是积极的。例如，如果你想生成一个随机数\n值从-99到0，请使用<code> -r.nextInt（100）</ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_NEXTINT_VIA_NEXTDOUBLE)"
      },
      {
        "real_name": "DM_INVALID_MIN_MAX",
        "display_name": "DmInvalidMinMax",
        "severity": "warning",
        "category": "performance",
        "rule_title": "Math.max和Math.min的组合不正确",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码尝试使用像Math.min（0，Math.max（100，value））这样的结构来限制值边界。但是，顺序\n  常数不正确：它应该是Math.min（100，Math.max（0，value））。结果这个代码总是产生相同的结果\n  （如果NaN，则为NaN）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_INVALID_MIN_MAX)"
      },
      {
        "real_name": "RV_01_TO_INT",
        "display_name": "Rv01ToInt",
        "severity": "warning",
        "category": "performance",
        "rule_title": "从0到1的随机值被强制为整数0",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "从0到1的随机值被强制为整数值0.您可能\n在将其强制为一个整数之前，或者使用<code> Random.nextInt（n）</ code>方法，通过别的东西来多重随机值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_01_TO_INT)"
      },
      {
        "real_name": "DM_MONITOR_WAIT_ON_CONDITION",
        "display_name": "DmMonitorWaitOnCondition",
        "severity": "warning",
        "category": "i18n",
        "rule_title": "在Condition上调用wait（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法在<code> java.util.concurrent.locks.Condition </ code>对象上调用<code> wait（）</ code>。＆nbsp;应该使用由<code> Condition </ code>接口定义的<code> await（）</ code>方法之一来等待<code> Condition </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_MONITOR_WAIT_ON_CONDITION)"
      },
      {
        "real_name": "DM_DEFAULT_ENCODING",
        "display_name": "DmDefaultEncoding",
        "severity": "warning",
        "category": "i18n",
        "rule_title": "依靠默认编码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "找到一个方法的调用，它将执行一个字节到字符串（或字符串到字节）的转换，并假定默认的平台编码是合适的。这会导致应用程序行为在不同平台之间变化。使用替代API并明确指定字符集名称或字符集对象。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_DEFAULT_ENCODING)"
      },
      {
        "real_name": "JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS",
        "display_name": "JcipFieldIsntFinalInImmutableClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不可变类的字段应该是最终的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类用net.jcip.annotations.Immutable或javax.annotation.concurrent.Immutable注释，\n  并且这些注释的规则要求所有字段都是最终的。\n   。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)"
      },
      {
        "real_name": "DM_NEW_FOR_GETCLASS",
        "display_name": "DmNewForGetclass",
        "severity": "warning",
        "category": "performance",
        "rule_title": "方法分配一个对象，仅用于获取类对象",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法分配一个对象只是为了调用getClass（）\n  为它检索Class对象。访问类的.class属性更简单。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_NEW_FOR_GETCLASS)"
      },
      {
        "real_name": "DM_BOXED_PRIMITIVE_TOSTRING",
        "display_name": "DmBoxedPrimitiveTostring",
        "severity": "warning",
        "category": "performance",
        "rule_title": "方法分配一个盒装原语来调用toString",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "分配一个盒装基元只是为了调用toString（）。仅使用静态就更有效\n  带有原始值的toString形式。所以，\n  新的整数（1）.toString（）</ tr> <tr> <th>替换... <th> td> <td> Integer.toString（1）</ td> </ tr> <tr> <td> new Long（1）.toString（）</ td> <td> Long.toString（1）</ td> （1.0）.toString（）</ td> <td> Float.toString（1.0）</ td> </ tr> <tr> <td> new Double 1.0）.toString（）</ td> <td> Double.toString（1.0）</ td>新字节（1）.toString（）</ td> <td>字节.toString（1）</ td> </ tr> <tr> <td> new Short（1）.toString（）</ td> <td> Short.toString（1）</ td> </ tr> < tr> <td> new Boolean（true）.toString（）<td> Boolean.toString（true）</ td> </ tr>\n  </ TABLE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_BOXED_PRIMITIVE_TOSTRING)"
      },
      {
        "real_name": "EQ_SELF_USE_OBJECT",
        "display_name": "EqSelfUseObject",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Covariant equals（）方法定义，Object.equals（Object）被继承",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类定义了<code> equals（）</ code>的协变版本\n  方法，但继承了正常的<code> equals（Object）</ code>方法\n  在基础<code> java.lang.Object </ code>类中定义。＆nbsp;\n  该类可能应该定义一个<code> boolean equals（Object）</ code>方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_SELF_USE_OBJECT)"
      },
      {
        "real_name": "FI_FINALIZER_NULLS_FIELDS",
        "display_name": "FiFinalizerNullsFields",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "终结者无效字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个终结者将场消除。这通常是一个错误，因为它不会帮助垃圾收集，\n  无论如何，该对象将被垃圾收集。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_FINALIZER_NULLS_FIELDS)"
      },
      {
        "real_name": "DC_PARTIALLY_CONSTRUCTED",
        "display_name": "DcPartiallyConstructed",
        "severity": "warning",
        "category": "performance",
        "rule_title": "可能暴露部分初始化对象",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "看起来像这种方法使用延迟字段初始化和双重检查锁定。\n  虽然该字段被正确地声明为volatile，但可能是内部结构\n  该对象在字段赋值之后被改变，因此另一个线程可能会看到部分被初始化的对象。\n   要解决此问题，请考虑先将对象存储到本地变量中\n  并且只有在完全构建后才将其保存到易失性字段。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DC_PARTIALLY_CONSTRUCTED)"
      },
      {
        "real_name": "EQ_OTHER_USE_OBJECT",
        "display_name": "EqOtherUseObject",
        "severity": "warning",
        "category": "performance",
        "rule_title": "定义的equals（）方法不覆盖Object.equals（Object）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个<code> equals（）</ code>\n  方法，它不覆盖正常的<code> equals（Object）</ code>方法\n  在基础<code> java.lang.Object </ code>类中定义。＆nbsp;\n  该类可能应该定义一个<code> boolean equals（Object）</ code>方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_OTHER_USE_OBJECT)"
      },
      {
        "real_name": "DM_BOXED_PRIMITIVE_FOR_COMPARE",
        "display_name": "DmBoxedPrimitiveForCompare",
        "severity": "warning",
        "category": "performance",
        "rule_title": "拳击比较原始",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "为了调用compareTo方法，创建了一个盒装基元。使用静态比较方法更有效率\n  （对于Java 1.4以后的double和float，对于自Java 1.7以来的其他基本类型），它直接在基元上工作。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DM_BOXED_PRIMITIVE_FOR_COMPARE)"
      },
      {
        "real_name": "BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR",
        "display_name": "BxUnboxedAndCoercedForTernaryOperator",
        "severity": "warning",
        "category": "convention",
        "rule_title": "三元运算符对原始值进行拆箱和强制",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "将包装的原始值解包并转换为其他基本类型作为其一部分\n评估条件三元运算符（<code> b？e1：e2 </ code>运算符）。该\nJava的语义要求如果<code> e1 </ code>和<code> e2 </ code>被封装\n数值，这些值被解除封装并转换/强制为它们的公共类型（例如，\n如果<code> e1 </ code>的类型是<code> Integer </ code>\n和<code> e2 </ code>是<code> Float </ code>类型，则<code> e1 </ code>将被解除装箱，\n转换为浮点值并装箱。参见JLS第15.25节。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)"
      },
      {
        "real_name": "BX_BOXING_IMMEDIATELY_UNBOXED",
        "display_name": "BxBoxingImmediatelyUnboxed",
        "severity": "warning",
        "category": "performance",
        "rule_title": "原始值已装箱，然后立即拆箱",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个原语被装箱，然后立即拆箱。这可能是由于在需要取消装箱值的地方进行手动装箱，从而强制编译器\n立即撤销拳击的工作。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BX_BOXING_IMMEDIATELY_UNBOXED)"
      },
      {
        "real_name": "BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION",
        "display_name": "BxBoxingImmediatelyUnboxedToPerformCoercion",
        "severity": "warning",
        "category": "performance",
        "rule_title": "原始值被装箱然后拆箱以执行原始强制",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "原始盒装值被构建，然后立即转换为不同的原始类型\n（例如，<code> new Double（d）.intValue（）</ code>）。只需执行直接原始强制（例如，<code>（int）d </ code>）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)"
      },
      {
        "real_name": "BX_UNBOXING_IMMEDIATELY_REBOXED",
        "display_name": "BxUnboxingImmediatelyReboxed",
        "severity": "warning",
        "category": "performance",
        "rule_title": "将装箱的值拆箱，然后立即重新装箱",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "盒装值将被拆箱，然后立即重新装箱。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BX_UNBOXING_IMMEDIATELY_REBOXED)"
      },
      {
        "real_name": "EQ_OTHER_NO_OBJECT",
        "display_name": "EqOtherNoObject",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "定义的equals（）方法不覆盖equals（Object）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个<code> equals（）</ code>\n  方法，它不覆盖正常的<code> equals（Object）</ code>方法\n  在基础<code> java.lang.Object </ code>类中定义。＆nbsp;相反，它\n  从超类继承<code> equals（Object）</ code>方法。\n  该类可能应该定义一个<code> boolean equals（Object）</ code>方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_OTHER_NO_OBJECT)"
      },
      {
        "real_name": "CAA_COVARIANT_ARRAY_LOCAL",
        "display_name": "CaaCovariantArrayLocal",
        "severity": "warning",
        "category": "security",
        "rule_title": "协变数组赋值给局部变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "协变类型的数组被分配给一个局部变量。这是令人困惑的，并可能在运行时导致ArrayStoreException\n如果其他类型的引用将在以后的代码中存储在此数组中：\n\n <code> Number [] arr = new Integer [10];\narr [0] = 1.0;\n</代码>\n 考虑改变创建的数组类型或局部变量类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CAA_COVARIANT_ARRAY_LOCAL)"
      },
      {
        "real_name": "CAA_COVARIANT_ARRAY_FIELD",
        "display_name": "CaaCovariantArrayField",
        "severity": "warning",
        "category": "security",
        "rule_title": "协变阵列分配到一个字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "协变类型的数组被分配给一个字段。这是令人困惑的，并可能在运行时导致ArrayStoreException\n如果其他类型的引用将在以后的代码中存储在此数组中：\n\n <code> Number [] arr = new Integer [10];\narr [0] = 1.0;\n</代码>\n 考虑改变创建的数组类型或字段类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CAA_COVARIANT_ARRAY_FIELD)"
      },
      {
        "real_name": "DUPLOG",
        "display_name": "DUPLOG",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DUPLOG)"
      },
      {
        "real_name": "INT_BAD_COMPARISON_WITH_INT_VALUE",
        "display_name": "IntBadComparisonWithIntValue",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "int值与长常量的比较不佳",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将int值与外部的长常量进行比较\n可以表示为int值的值范围。\n这种比较是空洞的，可能是不正确的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#INT_BAD_COMPARISON_WITH_INT_VALUE)"
      },
      {
        "real_name": "FE_FLOATING_POINT_EQUALITY",
        "display_name": "FeFloatingPointEquality",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "测试浮点相等",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该操作比较两个浮点值的相等性。由于浮点计算可能涉及四舍五入，\n   计算的浮点数和双精度值可能不准确。对于必须精确的值（例如货币值）\n   考虑使用诸如BigDecimal之类的固定精度类型。对于不需要精确的值，请考虑比较某个范围内的相等性，例如：<code> if（Math.abs（x-y）<.0000001）</ code>。\n   请参阅Java语言规范，第4.2.4节。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FE_FLOATING_POINT_EQUALITY)"
      },
      {
        "real_name": "FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER",
        "display_name": "FeTestIfEqualToNotANumber",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "注定要考虑与NaN平等",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码检查浮点值是否等于特殊的非A数值（例如，<code> if（x == Double.NaN）</ code>）。但是，由于<code> NaN </ code>的特殊语义，没有值等于<code> Nan </ code>，包括<code> NaN </ code>。因此，<code> x == Double.NaN </ code>总是计算为false。\n 要检查<code> x </ code>中包含的值是否为特殊的Not A Number值，请使用<code> Double.isNaN（x）</ code>（或<code> Float.isNaN（x） </ code>如果<code> x </ code>是浮点精度）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)"
      },
      {
        "real_name": "INT_VACUOUS_BIT_OPERATION",
        "display_name": "IntVacuousBitOperation",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "对整数值进行空白位掩码操作",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这是一个整数位操作（和，或，或排他或），不会做任何有用的工作\n（例如，<code> v＆0xffffffff </ code>）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#INT_VACUOUS_BIT_OPERATION)"
      },
      {
        "real_name": "INT_BAD_REM_BY_1",
        "display_name": "IntBadRemBy1",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "整数余数模1",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "任何表达式（exp％1）都保证始终返回零。\n你的意思是（exp＆amp; 1）或（exp％2）？\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#INT_BAD_REM_BY_1)"
      },
      {
        "real_name": "INT_VACUOUS_COMPARISON",
        "display_name": "IntVacuousComparison",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "整数值的空白比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "有一个总是返回的整数比较\n相同的值（例如，x <= Integer.MAX_VALUE）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#INT_VACUOUS_COMPARISON)"
      },
      {
        "real_name": "INT_BAD_COMPARISON_WITH_SIGNED_BYTE",
        "display_name": "IntBadComparisonWithSignedByte",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "有符号字节的错误比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "签名字节的值只能在-128到127之间。比较\n带有超出该范围的值的带符号字节是空的并且可能不正确。\n要将有符号字节<code> b </ code>转换为范围为0..255的无符号数值，\n使用<code> 0xff＆amp; B'/代码>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#INT_BAD_COMPARISON_WITH_SIGNED_BYTE)"
      },
      {
        "real_name": "INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE",
        "display_name": "IntBadComparisonWithNonnegativeValue",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "非负值与负常数或零的比较不好",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将保证为非负数的值与负常数或零进行比较。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)"
      },
      {
        "real_name": "DL_SYNCHRONIZATION_ON_BOOLEAN",
        "display_name": "DlSynchronizationOnBoolean",
        "severity": "warning",
        "category": "security",
        "rule_title": "同步布尔",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码在盒装原始常量（如布尔值）上同步。\n<PRE>\nprivate static Boolean inited = Boolean.FALSE;\n...\n  synchronized（ini​​ted）{if（！inited）{init（）; inited = Boolean.TRUE; }}\n...\n</ PRE>\n 由于通常只存在两个布尔对象，因此此代码可能与其他无关代码在同一对象上同步，从而导致无响应\n并可能发生死锁\n 请参阅CERT <a href=\"https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused\"> CON08 -J。请勿对可能重复使用的对象进行同步</a>以获取更多信息。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DL_SYNCHRONIZATION_ON_BOOLEAN)"
      },
      {
        "real_name": "DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE",
        "display_name": "DlSynchronizationOnUnsharedBoxedPrimitive",
        "severity": "warning",
        "category": "security",
        "rule_title": "在装箱的原始值上同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码在明显不共享的盒装原语上同步，\n如Integer。\n<PRE>\nprivate static final Integer fileLock = new Integer（1）;\n...\n  同步（fileLock）{..做某事..}\n...\n</ PRE>\n 在这段代码中，将重新声明fileLock为好得多\n<PRE>\nprivate static final Object fileLock = new Object（）;\n</ PRE>\n \n现有的代码可能没问题，但它令人困惑，而且\n未来的重构，如IntelliJ中的“移除拳击”重构，\n可能会将此替换为使用共享的实体Integer对象\n在整个JVM中，导致非常混乱的行为和潜在的死锁。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)"
      },
      {
        "real_name": "DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE",
        "display_name": "DlSynchronizationOnBoxedPrimitive",
        "severity": "warning",
        "category": "security",
        "rule_title": "在装箱原语上同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码在盒装原始常量（例如Integer）上同步。\n<PRE>\n私有静态整数计数= 0;\n...\n  synchronized（count）{count ++; }\n...\n</ PRE>\n 由于Integer对象可以被缓存和共享，\n此代码可能与其他无关代码在同一对象上同步，导致无响应\n并可能发生死锁\n 请参阅CERT <a href=\"https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused\"> CON08 -J。请勿对可能重复使用的对象进行同步</a>以获取更多信息。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)"
      },
      {
        "real_name": "NS_DANGEROUS_NON_SHORT_CIRCUIT",
        "display_name": "NsDangerousNonShortCircuit",
        "severity": "warning",
        "category": "convention",
        "rule_title": "潜在的危险使用非短路逻辑",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码似乎使用非短路逻辑（例如，＆amp;\n或|）\n而不是短路逻辑（＆amp;＆amp; or ||）。此外，\n看起来可能的是，根据左侧的值，你可能不会\n想要评估右侧（因为它会产生副作用，可能会导致异常\n或者可能是昂贵的。\n \n非短路逻辑会导致表达式的两端\n即使可以从中推断出结果也要进行评估\n知道左手边。这可能效率较低，而且\n如果左侧防护箱可能会导致错误\n当评估右侧可能会产生错误。\n\n\n 请参阅<a href=\"http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2\"> Java\n语言规范</a>了解详情\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NS_DANGEROUS_NON_SHORT_CIRCUIT)"
      },
      {
        "real_name": "HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS",
        "display_name": "HeSignatureDeclaresHashingOfUnhashableClass",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "签名声明在散列结构中使用不可相干的类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "方法，字段或类声明了一个不可散列类的通用签名\n用于需要可哈希类的上下文中。\n一个声明equals方法但继承hashCode（）方法的类\nfrom Object是不可能的，因为它不符合要求\n相等的对象具有相同的hashCode。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)"
      },
      {
        "real_name": "CO_SELF_NO_OBJECT",
        "display_name": "CoSelfNoObject",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "定义了Covariant compareTo（）方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类定义了<code> compareTo（）</ code>的协变版本。＆nbsp;\n  要正确覆盖。中的<code> compareTo（）</ code>方法\n  <code> Comparable </ code>接口，<code> compareTo（）</ code>的参数\n  必须有<code> java.lang.Object </ code>类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CO_SELF_NO_OBJECT)"
      },
      {
        "real_name": "NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT",
        "display_name": "NpEqualsShouldHandleNullArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "equals（）方法不检查空参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "equals（Object）的这种实现违反了由java.lang.Object.equals（）定义的契约，因为它不检查作为参数传递的null。如果传递一个空值，所有的equals（）方法应该返回false。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)"
      },
      {
        "real_name": "MS_EXPOSE_REP",
        "display_name": "MsExposeRep",
        "severity": "warning",
        "category": "convention",
        "rule_title": "公共静态方法可能通过返回数组来暴露内部表示",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "公共静态方法返回一个引用\n   一个数组，它是类的静态状态的一部分。\n   任何调用此方法的代码都可以自由修改\n   底层数组。\n   一种修复方法是返回数组的副本。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_EXPOSE_REP)"
      },
      {
        "real_name": "RV_NEGATING_RESULT_OF_COMPARETO",
        "display_name": "RvNegatingResultOfCompareto",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "否定compareTo（）/ compare（）的结果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码否定了compareTo或compare方法的返回值。\n这是一个有问题或不好的编程习惯，因为如果返回\n值是Integer.MIN_VALUE，否定返回值不会\n否定结果的标志。您可以达到相同的预期结果\n通过颠倒操作数的顺序而不是否定结果。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_NEGATING_RESULT_OF_COMPARETO)"
      },
      {
        "real_name": "HE_HASHCODE_USE_OBJECT_EQUALS",
        "display_name": "HeHashcodeUseObjectEquals",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类定义了hashCode（）并使用Object.equals（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个<code> hashCode（）</ code>方法，但是继承了它的方法\n  <code> java.lang.Object的equals（）</ code>方法</ code>\n  （通过比较对象引用来定义相等）。＆nbsp;虽然\n  这可能会满足平等对象必须具备的合同\n  相等的哈希码，它可能不是重写的目的\n  <code> hashCode（）</ code>方法。＆nbsp; （重写<code> hashCode（）</ code>\n  意味着对象的身份是基于更复杂的标准\n  比简单的参考平等。）\n 如果你不认为这个类的实例会被插入到HashMap / HashTable中，\n推荐使用的<code> hashCode </ code>实现是：\n<pre> public int hashCode（）{\n  assert false：“hashCode not designed”;\n  返回42; //任何任意常量都可以\n  } </ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_HASHCODE_USE_OBJECT_EQUALS)"
      },
      {
        "real_name": "EQ_COMPARETO_USE_OBJECT_EQUALS",
        "display_name": "EqComparetoUseObjectEquals",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类定义compareTo（...）并使用Object.equals（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类定义了一个<code> compareTo（...）</ code>方法，但继承了它的方法\n  <code> java.lang.Object的equals（）</ code>方法</ code>。通常，当且仅当equals返回true时，compareTo的值应该返回零。如果这被违反了，奇怪和不可预知的故障将发生在诸如PriorityQueue的类中。在Java 5中，PriorityQueue.remove方法使用compareTo方法，而在Java 6中，它使用equals方法。\n\n 从Comparable接口中的compareTo方法的JavaDoc中：\n<BLOCKQUOTE>\n强烈建议，但并非严格要求<code>（x.compareTo（y）== 0）==（x.equals（y））</ code>。\n一般来说，任何实现了Comparable接口的类都会违反这个条件\n应该清楚地表明这一事实。推荐的语言\n是“注意：这个类有一个自然的排序，与平等不一致。”\n</ BLOCKQUOTE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_COMPARETO_USE_OBJECT_EQUALS)"
      },
      {
        "real_name": "CO_COMPARETO_INCORRECT_FLOATING",
        "display_name": "CoComparetoIncorrectFloating",
        "severity": "warning",
        "category": "convention",
        "rule_title": "compareTo（）/ compare（）不正确地处理float或double值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法使用如下模式比较double或float值：val1＆gt; val2？ 1：val1 < val2？ -1：0。\n这种模式对-0.0和NaN值不正确，可能导致排序结果不正确或收集中断\n（如果比较值用作键）。考虑使用Double.compare或Float.compare静态方法处理所有\n正确的特殊情况。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CO_COMPARETO_INCORRECT_FLOATING)"
      },
      {
        "real_name": "HE_INHERITS_EQUALS_USE_HASHCODE",
        "display_name": "HeInheritsEqualsUseHashcode",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类继承equals（）并使用Object.hashCode（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类从摘要继承<code> equals（Object）</ code>\n  超类和<code> hashCode（）</ code>\n<code> java.lang.Object </ code>（它返回\n  身份哈希码，分配给对象的任意值\n  由VM）。＆nbsp;所以，这个班很有可能违反了\n  不变的是，相等的对象必须具有相同的哈希码。\n\n   如果你不想定义一个hashCode方法，和/或不需要\n   相信该对象将被放入HashMap / Hashtable中，\n   定义<code> hashCode（）</ code>方法\n   抛出<code> UnsupportedOperationException </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_INHERITS_EQUALS_USE_HASHCODE)"
      },
      {
        "real_name": "HE_EQUALS_USE_HASHCODE",
        "display_name": "HeEqualsUseHashcode",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类定义equals（）并使用Object.hashCode（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类覆盖了<code> equals（Object）</ code>，但没有\n  重写<code> hashCode（）</ code>，并继承执行\n  来自<code> java.lang.Object </ code>的<code> hashCode（）</ code>（它返回\n  身份哈希码，分配给对象的任意值\n  由VM）。＆nbsp;所以，这个班很有可能违反了\n  不变的是，相等的对象必须具有相同的哈希码。\n\n 如果你不认为这个类的实例会被插入到HashMap / HashTable中，\n推荐使用的<code> hashCode </ code>实现是：\n<pre> public int hashCode（）{\n  assert false：“hashCode not designed”;\n  返回42; //任何任意常量都可以\n  } </ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_EQUALS_USE_HASHCODE)"
      },
      {
        "real_name": "HE_USE_OF_UNHASHABLE_CLASS",
        "display_name": "HeUseOfUnhashableClass",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在哈希数据结构中使用没有hashCode（）方法的类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个类定义了一个equals（Object）方法，但不是一个hashCode（）方法，\n因此不能满足相等对象具有相同hashCode的要求。\n这个类的一个实例用在散列数据结构中，从而需要\n解决这个最重要的问题。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_USE_OF_UNHASHABLE_CLASS)"
      },
      {
        "real_name": "HE_EQUALS_NO_HASHCODE",
        "display_name": "HeEqualsNoHashcode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类定义equals（）而不是hashCode（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类覆盖了<code> equals（Object）</ code>，但没有\n  覆盖<code> hashCode（）</ code>。＆nbsp;因此，课堂可能会违反\n  不变的是，相等的对象必须具有相同的哈希码。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_EQUALS_NO_HASHCODE)"
      },
      {
        "real_name": "HE_HASHCODE_NO_EQUALS",
        "display_name": "HeHashcodeNoEquals",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类定义了hashCode（）而不是equals（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个<code> hashCode（）</ code>方法，但不是\n  <code> equals（）</ code>方法。＆nbsp;因此，班级可以\n  违反了平等对象必须具有相同的哈希码的不变量。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HE_HASHCODE_NO_EQUALS)"
      },
      {
        "real_name": "CO_COMPARETO_RESULTS_MIN_VALUE",
        "display_name": "CoComparetoResultsMinValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "compareTo（）/ compare（）返回Integer.MIN_VALUE",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "在某些情况下，此compareTo或compare方法返回\n常量Integer.MIN_VALUE，这是一个非常糟糕的做法。\n  关于compareTo的返回值唯一重要的是结果的符号。但是人们有时会否定compareTo的返回值，期望这会否定结果的符号。除了返回的值是Integer.MIN_VALUE的情况外，它会。所以只需返回-1而不是Integer.MIN_VALUE。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CO_COMPARETO_RESULTS_MIN_VALUE)"
      },
      {
        "real_name": "UG_SYNC_SET_UNSYNC_GET",
        "display_name": "UgSyncSetUnsyncGet",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "非同步get方法，同步set方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类包含同名的get和set\n  方法，其中set方法是同步的，get方法不是。＆nbsp;\n  这可能会导致运行时的错误行为，因为get的调用者\n  方法不一定会看到对象的一致状态。＆nbsp;\n  get方法应该被同步。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UG_SYNC_SET_UNSYNC_GET)"
      },
      {
        "real_name": "MSF_MUTABLE_SERVLET_FIELD",
        "display_name": "MsfMutableServletField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可变的servlet字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个web服务器通常只创建一个servlet或jsp类的实例（即对待\n作为Singleton的类），\n还会\n有多个线程调用该实例上的方法来为多个服务提供服务\n同时请求。\n因此，拥有一个可变实例字段通常会创建竞争条件。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MSF_MUTABLE_SERVLET_FIELD)"
      },
      {
        "real_name": "IS_FIELD_NOT_GUARDED",
        "display_name": "IsFieldNotGuarded",
        "severity": "warning",
        "category": "convention",
        "rule_title": "字段不能防止并发访问",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段用net.jcip.annotations.GuardedBy或javax.annotation.concurrent.GuardedBy注释，\n但可以通过似乎违反这些注释的方式进行访问。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IS_FIELD_NOT_GUARDED)"
      },
      {
        "real_name": "RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED",
        "display_name": "RvReturnValueOfPutifabsentIgnored",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "忽略putIfAbsent的返回值，传递给putIfAbsent的值被重用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "<code> putIfAbsent </ code>方法通常用于确保单个值与给定键（如果没有成功则放置第一个值）相关联。如果您忽略返回值并保留对传入值的引用，则可能会冒着保留与地图中的键关联的值的风险。如果您使用哪一个并且使用未存储在地图中的那个，则您的程序将表现不正确。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED)"
      },
      {
        "real_name": "FB_MISSING_EXPECTED_WARNING",
        "display_name": "FbMissingExpectedWarning",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "缺少来自FindBugs的预期或期望的警告",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "根据@ExpectedWarning注释，FindBugs未产生警告，预期或期望\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FB_MISSING_EXPECTED_WARNING)"
      },
      {
        "real_name": "VA_FORMAT_STRING_USES_NEWLINE",
        "display_name": "VaFormatStringUsesNewline",
        "severity": "warning",
        "category": "convention",
        "rule_title": "格式字符串应该使用％n而不是\\ n",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此格式字符串包含换行符（\\ n）。在格式字符串中，通常是这样\n 最好使用％n，这将生成平台特定的行分隔符。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_USES_NEWLINE)"
      },
      {
        "real_name": "VA_FORMAT_STRING_BAD_CONVERSION",
        "display_name": "VaFormatStringBadConversion",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "提供的参数的类型与格式说明符不匹配",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "其中一个参数与相应的格式字符串说明符不兼容。\n因此，这会在执行时生成运行时异常。\n例如，<code> String.format（“％d”，“1”）</ code>会产生一个异常，因为\n字符串“1”与格式说明符％d不兼容。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_BAD_CONVERSION)"
      },
      {
        "real_name": "EQ_COMPARING_CLASS_NAMES",
        "display_name": "EqComparingClassNames",
        "severity": "warning",
        "category": "convention",
        "rule_title": "equals方法比较类名而不是类对象",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法通过检查名称来检查两个对象是否属于同一个类\n他们的班级是平等的。如果加载的是相同的名称，则可以使用不同的类\n不同的类装载机。只需检查类对象是否相同。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_COMPARING_CLASS_NAMES)"
      },
      {
        "real_name": "NP_ARGUMENT_MIGHT_BE_NULL",
        "display_name": "NpArgumentMightBeNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法不检查空参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法的参数已被识别为一个值，应该始终检查它是否为空值，但是在没有先前的空值检查的情况下解除引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_ARGUMENT_MIGHT_BE_NULL)"
      },
      {
        "real_name": "IL_CONTAINER_ADDED_TO_ITSELF",
        "display_name": "IlContainerAddedToItself",
        "severity": "warning",
        "category": "convention",
        "rule_title": "一个集合被添加到它自己",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个集合被添加到它自己。结果，计算了这个hashCode\n设置将抛出一个StackOverflowException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IL_CONTAINER_ADDED_TO_ITSELF)"
      },
      {
        "real_name": "IL_INFINITE_RECURSIVE_LOOP",
        "display_name": "IlInfiniteRecursiveLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "一个明显的无限递归循环",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法无条件地调用它自己。这似乎表明\n一个无限的递归循环会导致堆栈溢出。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IL_INFINITE_RECURSIVE_LOOP)"
      },
      {
        "real_name": "HSC_HUGE_SHARED_STRING_CONSTANT",
        "display_name": "HscHugeSharedStringConstant",
        "severity": "warning",
        "category": "convention",
        "rule_title": "巨大的字符串常量跨多个类文件复制",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个大的String常量被复制到多个类文件中。这很可能是因为最终字段被初始化为一个String常量，并且Java语言规定所有对来自其他类的最终字段的引用都被内联到\n该类文件。请参阅<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475\"> JDK错误6447475 </a>，以获取有关JDK中发生此错误的说明以及如何解决它将JDK的大小减少了1兆字节。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HSC_HUGE_SHARED_STRING_CONSTANT)"
      },
      {
        "real_name": "EQ_ALWAYS_TRUE",
        "display_name": "EqAlwaysTrue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "equals方法总是返回true",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个总是返回true的equals方法。这是有想象力的，但不是很聪明。\n另外，这意味着等号方法不对称。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_ALWAYS_TRUE)"
      },
      {
        "real_name": "EQ_UNUSUAL",
        "display_name": "EqUnusual",
        "severity": "warning",
        "category": "security",
        "rule_title": "不寻常的等值方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类没有做任何我们认可的用于检查参数类型的模式\n与<code> this </ code>对象的类型兼容。可能没有任何问题\n这个代码，但值得回顾一下。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_UNUSUAL)"
      },
      {
        "real_name": "EQ_ALWAYS_FALSE",
        "display_name": "EqAlwaysFalse",
        "severity": "warning",
        "category": "convention",
        "rule_title": "equals方法总是返回false",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个总是返回false的equals方法。这意味着一个对象不等于它自己，并且不可能创建这个类的有用的地图或集合。意味着更基础的\n等于不是自反的，等于方法的要求之一。\n 可能的预期语义是对象标识：对象与自身相同。这是从<code> Object </ code>类继承的行为。如果您需要覆盖从另一个继承的等于\n超类，你可以使用use：\n<PRE>\npublic boolean equals（Object o）{return this == o; }\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_ALWAYS_FALSE)"
      },
      {
        "real_name": "CAA_COVARIANT_ARRAY_ELEMENT_STORE",
        "display_name": "CaaCovariantArrayElementStore",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "可能不兼容的元素存储在协变数组中",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "值存储在数组中，并且值类型与数组类型不匹配。\n从分析中可知，实际的数组类型比其变量或字段的声明类型更窄\n并且此分配不符合原始数组类型。此分配可能导致ArrayStoreException\n在运行时。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CAA_COVARIANT_ARRAY_ELEMENT_STORE)"
      },
      {
        "real_name": "FRAG_COMMIT_PROTECT",
        "display_name": "FragCcommitProtect",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FRAG_COMMIT_PROTECT)"
      },
      {
        "real_name": "DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION",
        "display_name": "DmiUsingRemoveallToClearCollection",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不要使用removeAll来清除集合",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "如果要从集合<code> c </ code>中删除所有元素，请使用<code> c.clear </ code>，\n不是<code> c.removeAll（c）</ code>。调用<code> c.removeAll（c）</ code>清除集合\n不太清楚，易受错别字错误影响，效率低下\n对于某些集合，可能会引发<code> ConcurrentModificationException </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)"
      },
      {
        "real_name": "STCAL_STATIC_CALENDAR_INSTANCE",
        "display_name": "StcalStaticCalendarInstance",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "静态日历字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "尽管JavaDoc没有提示它，但日历在多线程使用中本质上是不安全的。\n在没有正确同步的情况下跨线程边界共享单个实例将导致错误的行为\n应用。在1.4以下的问题看起来似乎比在Java 5下你可能会看到的要少\n在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate（）中随机ArrayIndexOutOfBoundsExceptions或IndexOutOfBoundsExceptions。\n 您也可能会遇到序列化问题。\n 建议使用实例字段。\n 有关详情，请参阅<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579\"> Sun Bug＃6231579 </a>\n和<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997\"> Sun Bug＃6178997 </a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STCAL_STATIC_CALENDAR_INSTANCE)"
      },
      {
        "real_name": "SP_SPIN_ON_FIELD",
        "display_name": "SpSpinOnField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法在字段上旋转",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法在读取字段的循环中旋转。＆nbsp;编译器\n  可以合法地提起读出的循环，将代码变成一个\n  无限循环。＆nbsp;班级应该改变，所以它使用适当的\n  同步（包括等待和通知呼叫）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SP_SPIN_ON_FIELD)"
      },
      {
        "real_name": "EI_EXPOSE_STATIC_REP2",
        "display_name": "EiExposeStaticRep2",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可以通过将可变对象存储到静态字段中来暴露内部静态状态",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将对外部可变对象的引用存储为静态\n   领域。\n   如果未选中更改为\n   可变对象会危及安全或其他\n   重要的属性，你需要做一些不同的事情。\n  在许多情况下存储对象的副本是更好的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EI_EXPOSE_STATIC_REP2)"
      },
      {
        "real_name": "EI_EXPOSE_REP2",
        "display_name": "EiExposeRep2",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可以通过引用可变对象来暴露内部表示",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将对外部可变对象的引用存储到\n  对象的内部表示。＆nbsp;\n   如果实例\n   由不受信任的代码访问，未经检查的更改\n   可变对象会危及安全或其他\n   重要的属性，你需要做一些不同的事情。\n  在许多情况下存储对象的副本是更好的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EI_EXPOSE_REP2)"
      },
      {
        "real_name": "EI_EXPOSE_REP",
        "display_name": "EiExposeRep",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可能通过返回对可变对象的引用来暴露内部表示",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "返回存储在对象字段之一中的可变对象值的引用\n  暴露了对象的内部表示。＆nbsp;\n   如果实例\n   由不受信任的代码访问，未经检查的更改\n   可变对象会危及安全或其他\n   重要的属性，你需要做一些不同的事情。\n  在许多情况下返回对象的新副本是更好的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EI_EXPOSE_REP)"
      },
      {
        "real_name": "RU_INVOKE_RUN",
        "display_name": "RuInvokeRun",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用在一个线程上运行（你的意思是开始它呢？）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法显式调用对象上的<code> run（）</ code>。＆nbsp;\n  通常，类实现<code> Runnable </ code>接口，因为\n  他们将在新线程中调用它们的<code> run（）</ code>方法，\n  在这种情况下，<code> Thread.start（）</ code>是正确的调用方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RU_INVOKE_RUN)"
      },
      {
        "real_name": "IS2_INCONSISTENT_SYNC",
        "display_name": "Is2InconsistentSync",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不一致的同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类的字段似乎与尊重不一致\n  进行同步。＆nbsp;这个错误报告表明错误模式检测器\n  判断\n  \n  <UL>\n  <li>该类包含锁定和解锁访问的混合，</ li>\n  <li>类是<b> not </ b>注释为javax.annotation.concurrent.NotThreadSafe，</ li>\n  <li>至少有一个锁定的访问是由该类自己的一个方法执行的，</ li>\n  <li>未同步的字段访问次数（读取和写入次数）不超过所有访问次数的三分之一，写入次数是读取次数的两倍。</ li>\n  </ UL>\n\n    与此错误模式相匹配的典型错误是忘记同步\n  类中的一种方法是为了线程安全的。\n\n    您可以选择标记为“不同步访问”的节点来显示\n  检测器认为某个字段被访问的代码位置\n  没有同步。\n\n    请注意，该探测器存在各种不准确的来源;\n  例如，检测器不能静态检测其中的所有情况\n  锁住了。＆nbsp;此外，即使探测器准确无误\n  区分锁定与未锁定的访问，所讨论的代码可能仍然存在\n  是正确的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IS2_INCONSISTENT_SYNC)"
      },
      {
        "real_name": "NN_NAKED_NOTIFY",
        "display_name": "NnNakedNotify",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "裸体通知",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "对<code> notify（）</ code>或<code> notifyAll（）</ code>的调用\n  没有任何（明显的）陪伴\n  修改可变对象状态。＆nbsp;一般来说，打电话通知\n  方法在监视器上完成，因为一些条件是另一个线程\n  等待已成为现实。＆nbsp;但是，为了使条件有意义，\n  它必须涉及两个线程都可见的堆对象。\n\n    此错误不一定表示错误，因为更改为\n  可变对象状态可能发生在随后调用的方法中\n  包含通知的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NN_NAKED_NOTIFY)"
      },
      {
        "real_name": "DMI_DOH",
        "display_name": "DmiDoh",
        "severity": "warning",
        "category": "security",
        "rule_title": "D'哦！无意义的方法调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这种部分方法调用没有意义，因为从检查中应该可以看出这一点。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_DOH)"
      },
      {
        "real_name": "DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE",
        "display_name": "DmiBigdecimalConstructedFromDouble",
        "severity": "warning",
        "category": "security",
        "rule_title": "BigDecimal由double构造，没有精确表示",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这段代码从一个不能很好地转化为a的double值创建一个BigDecimal\n十进制数。\n例如，可以假设在Java中编写新的BigDecimal（0.1）会创建一个精确等于0.1的BigDecimal（非缩放值为1，刻度为1），但实际上它等于0.1000000000000000055511151231257827021181583404541015625。\n您可能想要使用BigDecimal.valueOf（double d）方法，该方法使用字符串表示形式\n创建BigDecimal的double（例如，BigDecimal.valueOf（0.1）给出0.1）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE)"
      },
      {
        "real_name": "NP_OPTIONAL_RETURN_NULL",
        "display_name": "NpOptionalReturnNull",
        "severity": "warning",
        "category": "performance",
        "rule_title": "具有可选返回类型的方法返回显式为空",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可选返回类型（java.util.Optional或com.google.common.base.Optiona）的用法始终意味着设计不需要显式空返回。在这种情况下返回空值是违反合同并很可能破坏客户端代码。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_OPTIONAL_RETURN_NULL)"
      },
      {
        "real_name": "SF_SWITCH_FALLTHROUGH",
        "display_name": "SfSwitchFallthrough",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Switch语句发现一个案件落入下一个案件",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含一个switch语句，其中一个案例分支将落入下一个案例。\n  通常你需要休息或返回结束这种情况。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SF_SWITCH_FALLTHROUGH)"
      },
      {
        "real_name": "DMI_INVOKING_HASHCODE_ON_ARRAY",
        "display_name": "DmiInvokingHashcodeOnArray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在数组上调用hashCode",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码在数组上调用hashCode。调用hashCode\n一个数组返回与System.identityHashCode相同的值和ingores\n数组的内容和长度。如果你需要一个hashCode\n取决于数组<code> a </ code>的内容，\n使用<code> java.util.Arrays.hashCode（a）</ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_INVOKING_HASHCODE_ON_ARRAY)"
      },
      {
        "real_name": "VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG",
        "display_name": "VaPrimitiveArrayPassedToObjectVararg",
        "severity": "warning",
        "category": "convention",
        "rule_title": "传递给函数的基元数组需要可变数量的对象参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码将一个基本数组传递给一个接受可变数目的对象参数的函数。\n这将创建一个长度为1的数组来保存基本数组并将其传递给该函数。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG)"
      },
      {
        "real_name": "VA_FORMAT_STRING_BAD_ARGUMENT",
        "display_name": "VaFormatStringBadArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "格式化字符串占位符与传递的参数不兼容",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "格式字符串占位符与相应的格式不兼容\n论据。例如，\n<代码>\n  System.out.println（“％d \\ n”，“hello”）;\n</代码>\n ％d占位符需要数字参数，但字符串值为\n改为通过。\n运行时异常将发生时\n这条语句被执行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_BAD_ARGUMENT)"
      },
      {
        "real_name": "VA_FORMAT_STRING_MISSING_ARGUMENT",
        "display_name": "VaFormatStringMissingArgument",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "格式字符串引用缺少参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "没有足够的参数被传递来满足格式字符串中的占位符。\n运行时异常将发生时\n这条语句被执行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_MISSING_ARGUMENT)"
      },
      {
        "real_name": "BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS",
        "display_name": "BcEqualsMethodShouldWorkForAllObjects",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Equals方法不应该假定任何关于它的参数的类型",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "<code> equals（Object o）</ code>方法不应做任何假设\n关于<code> o </ code>的类型。它应该简单地返回\n如果<code> o </ code>与<code> this </ code>不是相同类型，则返回false。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)"
      },
      {
        "real_name": "BC_BAD_CAST_TO_ABSTRACT_COLLECTION",
        "display_name": "BcBadCastToAbstractCollection",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "可疑的转换为抽象收集",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将Collection集合转换为抽象集合\n（如<code> List </ code>，<code> Set </ code>或<code> Map </ code>）。\n确保您保证该对象属于该类型\n你正在铸造。如果你所需要的只是能够\n遍历一个集合，你不需要将它转换为Set或List。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_BAD_CAST_TO_ABSTRACT_COLLECTION)"
      },
      {
        "real_name": "DMI_CALLING_NEXT_FROM_HASNEXT",
        "display_name": "DmiCallingNextFromHasnext",
        "severity": "warning",
        "category": "convention",
        "rule_title": "hasNext方法接下来调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "hasNext（）方法调用next（）方法。这几乎肯定是错误的，\n由于hasNext（）方法不应该改变迭代器的状态，\n而下一个方法应该改变迭代器的状态。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_CALLING_NEXT_FROM_HASNEXT)"
      },
      {
        "real_name": "MS_MUTABLE_COLLECTION",
        "display_name": "MsMutableCollection",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Field是一个可变的集合",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可变集合实例被分配给最终的静态字段，\n   因此可以通过恶意代码或其他软件包意外更改。\n   考虑将此字段包装到Collections.unmodifiableSet / List / Map /等。\n   以避免此漏洞。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_MUTABLE_COLLECTION)"
      },
      {
        "real_name": "MS_MUTABLE_COLLECTION_PKGPROTECT",
        "display_name": "MsMutableCollectionPkgprotect",
        "severity": "warning",
        "category": "convention",
        "rule_title": "字段是一个可变的集合，应该被包装保护",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可变集合实例被分配给最终的静态字段，\n   因此可以通过恶意代码或其他软件包意外更改。\n   该字段可以进行包保护以避免此漏洞。\n   或者，您可以将此字段包装到Collections.unmodifiableSet / List / Map /等。\n   以避免此漏洞。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_MUTABLE_COLLECTION_PKGPROTECT)"
      },
      {
        "real_name": "SIO_SUPERFLUOUS_INSTANCEOF",
        "display_name": "SioSuperfluousInstanceof",
        "severity": "warning",
        "category": "performance",
        "rule_title": "使用instanceof运算符完成不必要的类型检查",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用instanceof操作符执行类型检查，可以在其中静态确定对象\n是所要求的类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SIO_SUPERFLUOUS_INSTANCEOF)"
      },
      {
        "real_name": "EC_ARRAY_AND_NONARRAY",
        "display_name": "EcArrayAndNonarray",
        "severity": "warning",
        "category": "performance",
        "rule_title": "equals（）用于比较数组和非数组",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法调用.equals（Object o）来比较一个看起来不似乎的数组和引用\n成为一个数组。如果比较的东西是不同类型的，那么它们保证是不平等的\n并且比较几乎肯定是一个错误。即使它们都是数组，equals方法也是如此\n在数组上只确定两个数组是同一个对象。\n比较\n数组的内容，请使用java.util.Arrays.equals（Object []，Object []）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_ARRAY_AND_NONARRAY)"
      },
      {
        "real_name": "EC_BAD_ARRAY_COMPARE",
        "display_name": "EcBadArrayCompare",
        "severity": "warning",
        "category": "performance",
        "rule_title": "在数组上调用equals（），相当于==",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用数组上的.equals（Object o）方法。由于数组不会覆盖等于\nObject的方法，在数组上调用equals与比较它们的地址是一样的。比较\n数组的内容，使用<code> java.util.Arrays.equals（Object []，Object []）</ code>。\n为了比较数组的地址，它会是\n使用<code> == </ code>显式检查指针相等性，不会造成混淆。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_BAD_ARRAY_COMPARE)"
      },
      {
        "real_name": "BAC_BAD_APPLET_CONSTRUCTOR",
        "display_name": "BacBadAppletConstructor",
        "severity": "warning",
        "category": "performance",
        "rule_title": "坏Applet构造函数依赖未初始化的AppletStub",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此构造函数在依赖AppletStub的父Applet中调用方法。自从AppletStub\n直到这个applet的init（）方法被调用才会被初始化，这些方法将不会执行\n正确。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BAC_BAD_APPLET_CONSTRUCTOR)"
      },
      {
        "real_name": "EC_INCOMPATIBLE_ARRAY_COMPARE",
        "display_name": "EcIncompatibleArrayCompare",
        "severity": "warning",
        "category": "performance",
        "rule_title": "等于（...）用于比较不兼容的数组",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用.equals（Object o）来比较两个数组，但是数组\n不兼容的类型（例如，String []和StringBuffer []或String []和int []）。\n他们永远不会平等。另外，当equals（...）用于比较数组时\n只检查它们是否是相同的数组，并忽略数组的内容。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_INCOMPATIBLE_ARRAY_COMPARE)"
      },
      {
        "real_name": "STI_INTERRUPTED_ON_CURRENTTHREAD",
        "display_name": "StiInterruptedOnCurrentthread",
        "severity": "warning",
        "category": "performance",
        "rule_title": "不需要使用currentThread（）调用，来调用中断（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用Thread.currentThread（）调用，仅调用interrupted（）方法。由于中断（）是一个\n静态方法，使用Thread.interrupted（）更简单明了。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STI_INTERRUPTED_ON_CURRENTTHREAD)"
      },
      {
        "real_name": "IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN",
        "display_name": "IpParameterIsDeadButOverwritten",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "一个参数在进入一个方法时死了，但被覆盖",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该参数的初始值被忽略，并且参数\n在这里被覆盖。这往往表明一个错误的信念\n写入参数将被传回\n呼叫者，召集者。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)"
      },
      {
        "real_name": "DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD",
        "display_name": "DlsDeadLocalStoreShadowsField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "死存储到阴影字段的局部变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这条指令给一个局部变量赋值，\n但该值不会在任何后续指令中读取或使用。\n通常，这表示出现错误，因为计算的值永远不会\n用过的。有一个与本地变量名称相同的字段。你是否\n是否意味着分配给该变量？\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD)"
      },
      {
        "real_name": "DLS_DEAD_STORE_OF_CLASS_LITERAL",
        "display_name": "DlsDeadStoreOfClassLiteral",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类文字的死存储",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该指令将类文字分配给变量，然后从不使用它。\n<a href=\"//java.sun.com/j2se/1.5.0/compatibility.html#literal\">这在Java 1.4和Java 5中的行为有所不同。</a>\n在Java 1.4及更早版本中，对<code> Foo.class </ code>的引用将强制静态初始化器\nfor <code> Foo </ code>被执行，如果它尚未被执行。\n在Java 5和更高版本中，它不会。\n\n 请参阅Sun的<a href=\"//java.sun.com/j2se/1.5.0/compatibility.html#literal\">有关Java SE兼容性的文章</a>\n了解更多细节和示例，以及如何在Java 5中强制进行类初始化的建议。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_DEAD_STORE_OF_CLASS_LITERAL)"
      },
      {
        "real_name": "DLS_DEAD_LOCAL_STORE",
        "display_name": "DlsDeadLocalStore",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "死存储到局部变量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这条指令给一个局部变量赋值，\n但该值不会在任何后续指令中读取或使用。\n通常，这表示出现错误，因为计算的值永远不会\n用过的。\n\n \n请注意，Sun的javac编译器通常会为其生成死锁存储\n最终的局部变量。由于FindBugs是一个基于字节码的工具，\n没有简单的方法来消除这些误报。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_DEAD_LOCAL_STORE)"
      },
      {
        "real_name": "DLS_DEAD_LOCAL_INCREMENT_IN_RETURN",
        "display_name": "DlsDeadLocalIncrementInReturn",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "返回语句中无用的增量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该语句具有返回值，例如<code> return x ++; </ code>。\n后缀递增/递减不会影响表达式的值，\n所以这个增量/减量不起作用。\n请确认这个陈述是否正确。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_DEAD_LOCAL_INCREMENT_IN_RETURN)"
      },
      {
        "real_name": "DLS_DEAD_LOCAL_STORE_IN_RETURN",
        "display_name": "DlsDeadLocalStoreInReturn",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "返回语句中无用的赋值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该语句在return语句中分配给本地变量。这个任务\n有效果。请确认这个陈述是否正确。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DLS_DEAD_LOCAL_STORE_IN_RETURN)"
      },
      {
        "real_name": "VO_VOLATILE_REFERENCE_TO_ARRAY",
        "display_name": "VoVolatileReferenceToArray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "对数组的volatile引用不会将数组元素视为volatile",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这声明了对一个数组的volatile参考，这可能不是什么\n你要。对一个数组的volatile参考，读写\n对数组的引用被视为易失性，但是是数组元素\n是非易失性的。要获得易变的数组元素，您需要使用\njava.util.concurrent中的一个原子数组类（提供\n在Java 5.0中）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VO_VOLATILE_REFERENCE_TO_ARRAY)"
      },
      {
        "real_name": "XSS_REQUEST_PARAMETER_TO_JSP_WRITER",
        "display_name": "XssRequestParameterToJspWriter",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "JSP反映了跨站脚本漏洞",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码直接将HTTP参数写入JSP输出，这允许跨站点脚本\n漏洞。请参阅<a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\"> http://en.wikipedia.org/wiki/Cross-site_scripting </a>\n了解更多信息。\n FindBugs只查找最明显，最明显的跨站点脚本案例。\n如果FindBugs找到<em>任何<em>，那么你几乎可以确定</ em>有更多跨站点脚本\nFindBugs不报告的漏洞。如果你担心跨站点脚本，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#XSS_REQUEST_PARAMETER_TO_JSP_WRITER)"
      },
      {
        "real_name": "IL_INFINITE_LOOP",
        "display_name": "IlInfiniteLoop",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "一个明显的无限循环",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个循环似乎没有办法终止（除了也许\n抛出异常）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IL_INFINITE_LOOP)"
      },
      {
        "real_name": "GC_UNCHECKED_TYPE_IN_GENERIC_CALL",
        "display_name": "GcUncheckedTypeInGenericCall",
        "severity": "warning",
        "category": "performance",
        "rule_title": "通用调用中未检查的类型",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "对泛型集合方法的这种调用传递一个参数，而编译类型为Object的地方需要来自泛型类型参数的特定类型。因此，标准Java类型系统和静态分析都不能提供有关作为参数传递的对象是否属于适当类型的有用信息。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#GC_UNCHECKED_TYPE_IN_GENERIC_CALL)"
      },
      {
        "real_name": "CAA_COVARIANT_ARRAY_RETURN",
        "display_name": "CaaCovariantArrayReturn",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Covariant数组是从方法返回的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法返回协变类型数组。这是令人困惑的，并可能在运行时导致ArrayStoreException\n如果调用代码将尝试在返回的数组中存储其他类型的引用。\n\n 考虑改变创建的数组类型或方法返回类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CAA_COVARIANT_ARRAY_RETURN)"
      },
      {
        "real_name": "IM_BAD_CHECK_FOR_ODD",
        "display_name": "ImBadCheckForOdd",
        "severity": "warning",
        "category": "convention",
        "rule_title": "检查对于负数不起作用的奇怪情况",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码使用x％2 == 1来检查值是否为奇数，但这不起作用\n对于负数（例如，（-5）％2 == -1）。如果这个代码打算检查\n奇怪的是，考虑使用x＆amp; 1 == 1，或者x％2！= 0。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IM_BAD_CHECK_FOR_ODD)"
      },
      {
        "real_name": "IM_AVERAGE_COMPUTATION_COULD_OVERFLOW",
        "display_name": "ImAverageComputationCouldOverflow",
        "severity": "warning",
        "category": "convention",
        "rule_title": "平均值的计算可能会溢出",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码使用除法或有符号右移计算两个整数的平均值，\n然后将结果用作数组的索引。\n如果平均值非常大，则可能溢出（导致计算\n的负平均值）。假设结果是非负的，你\n可以使用无符号的右移。换句话说，相反，使用<code>（low + high）/ 2 </ code>，\n使用<code>（low + high）＆gt;＆gt;＆gt; 1 </代码>\n\n 这个错误存在于许多二进制搜索和合并排序的早期实现中。\nMartin Buchholz <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541\">找到并修复了它</a>\nJDK库和Joshua Bloch\n<a href=\"http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\">广泛\n公布错误模式</a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)"
      },
      {
        "real_name": "DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY",
        "display_name": "DmiInvokingTostringOnAnonymousArray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在未命名的数组上调用toString",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码在（匿名）数组上调用toString。在数组上调用toString会产生相当无用的结果\n如[C @ 16f0472。考虑使用Arrays.toString将数组转换为可读\n给出数组内容的字符串。请参阅编程益智游戏，第3章，益智12。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)"
      },
      {
        "real_name": "BIT_SIGNED_CHECK_HIGH_BIT",
        "display_name": "BitSignedCheckHighBit",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "检查按位操作的符号",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法比较表达式，如\n（（event.detail＆amp; SWT.SELECTED）＆gt; 0）</ pre>。\n 使用位算术，然后与大于运算符进行比较即可\n导致意想不到的结果（当然取决于价值\nSWT.SELECTED）。如果SWT.SELECTED是一个负数，这是一个候选人\n为一个错误。即使SWT.SELECTED不是负面的，这似乎也是一种很好的做法\n使用'！= 0'而不是'＆gt; 0' 。\n\n \n鲍里斯Bokowski <em> </ em>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_SIGNED_CHECK_HIGH_BIT)"
      },
      {
        "real_name": "BIT_IOR",
        "display_name": "BitIor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不兼容的位掩码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法将表单（e | C）与表达式D进行比较。\n这总会比较不平等\n由于常数C和D的具体数值\n这可能表示逻辑错误或拼写错误。\n\n  通常，这个错误是因为代码想要执行而发生的\n一个位集的成员资格测试，但使用按位或\n运算符（“|”）而不是按位AND（“＆amp;”）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_IOR)"
      },
      {
        "real_name": "BIT_AND_ZZ",
        "display_name": "BitAndZz",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "检查是否（（...）＆0）== 0",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法将形式（e＆amp; 0）的表达式与0进行比较，\n它总会比较相等。\n这可能表示逻辑错误或拼写错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_AND_ZZ)"
      },
      {
        "real_name": "LI_LAZY_INIT_INSTANCE",
        "display_name": "LiLazyInitInstance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "实例字段的延迟初始化不正确",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含非易失性字段的非同步惰性初始化。\n由于编译器或处理器可能会重新排列指令，\n线程不保证看到完全初始化的对象，\n<em>如果该方法可以被多个线程调用</ em>。\n您可以将该字段设置为volatile以纠正问题。\n有关更多信息，请参阅\n<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/\"> Java Memory Model网站</a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#LI_LAZY_INIT_INSTANCE)"
      },
      {
        "real_name": "LI_LAZY_INIT_UPDATE_STATIC",
        "display_name": "LiLazyInitUpdateStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不正确的延迟初始化和静态字段的更新",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含静态字段的非同步惰性初始化。\n字段设置后，存储在该位置的对象将被更新或访问。\n该字段的设置只要设置就可以被其他线程看到。如果\n进一步访问设置字段的方法来初始化对象\n你有一个非常严重的</ em>多线程错误，除非有其他阻止\n任何其他线程访问存储的对象直到完全初始化。\n\n 即使你确信这种方法从来不会被多重调用\n线程，最好不要设置静态字段直到值\n您将其设置为完全填充/初始化。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#LI_LAZY_INIT_UPDATE_STATIC)"
      },
      {
        "real_name": "LI_LAZY_INIT_STATIC",
        "display_name": "LiLazyInitStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "静态字段的延迟初始化不正确",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含非易失性静态字段的非同步惰性初始化。\n由于编译器或处理器可能会重新排列指令，\n线程不保证看到完全初始化的对象，\n<em>如果该方法可以被多个线程调用</ em>。\n您可以将该字段设置为volatile以纠正问题。\n有关更多信息，请参阅\n<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/\"> Java Memory Model网站</a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#LI_LAZY_INIT_STATIC)"
      },
      {
        "real_name": "SW_SWING_METHODS_INVOKED_IN_SWING_THREAD",
        "display_name": "SwSwingMethodsInvokedInSwingThread",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "某些swing方法需要在Swing线程中调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "（<a href=\"http://web.archive.org/web/20090526170426/http://java.sun.com/developer/JDCTechTips/2003/tt1208.html\">来自JDC技术提示</a>） ：Swing方法\nshow（），setVisible（）和pack（）将为框架创建关联的对等体。\n通过创建对等体，系统创建事件分派线程。\n这使事情变得有问题，因为事件调度线程可能会通知\n听众，而包和验证仍在处理中。这种情况可能导致\n两个线程通过基于Swing组件的GUI  - 这是一个严重的缺陷\n可能导致死锁或其他相关的线程问题。打包电话会导致\n要实现的组件。当他们正在被实现时（即不一定\n可见），他们可以在事件派发线程上触发监听器通知。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SW_SWING_METHODS_INVOKED_IN_SWING_THREAD)"
      },
      {
        "real_name": "ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND",
        "display_name": "IcastIntCastToFloatPassedToRound",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "int值强制转换为float，然后传递给Math.round",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将int值转换为浮点精度\n浮点数然后\n将结果传递给Math.round（）函数，该函数返回最接近的int / long\n到论点。这个操作应该永远是没有操作的，\n因为将整数转换为浮点数应该给出一个没有小数部分的数字。\n生成该值的操作可能会被传递\nMath.round被打算使用\n浮点运算。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)"
      },
      {
        "real_name": "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION",
        "display_name": "IcSuperclassUsesSubclassDuringInitialization",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "超类在初始化过程中使用子类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "在类的初始化过程中，类会主动使用子类。\n该子类在使用时尚未初始化。\n例如，在以下代码中，<code> foo </ code>将为空。\n\n<PRE>\n公共类CircularClassInitialization {静态类InnerClassSingleton扩展CircularClassInitialization {静态InnerClassSingleton单身=新InnerClassSingleton（）; }\n static CircularClassInitialization foo = InnerClassSingleton.singleton;\n}\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)"
      },
      {
        "real_name": "DMI_NONSERIALIZABLE_OBJECT_WRITTEN",
        "display_name": "DmiNonserializableObjectWritten",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不可序列化的对象写入ObjectOutput",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码似乎将一个不可序列化的对象传递给ObjectOutput.writeObject方法。\n如果该对象确实是不可序列化的，则会导致错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_NONSERIALIZABLE_OBJECT_WRITTEN)"
      },
      {
        "real_name": "ME_ENUM_FIELD_SETTER",
        "display_name": "MeEnumFieldSetter",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "公共枚举方法无条件地设置其字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个公共方法在public enum中声明无条件地设置enum字段，因此这个字段可以被恶意代码改变\n  或从另一个包裹意外。虽然可变枚举字段可能用于延迟初始化，但将它们暴露给外部世界是一种不好的做法。\n  考虑删除此方法或将其声明为package-private。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ME_ENUM_FIELD_SETTER)"
      },
      {
        "real_name": "ME_MUTABLE_ENUM_FIELD",
        "display_name": "MeMutableEnumField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "枚举字段是公开的和可变的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可变的公共字段在公共枚举内部定义，因此可以通过恶意代码或其他包的意外更改。\n  虽然可变枚举字段可能用于延迟初始化，但将它们暴露给外部世界是一种不好的做法。\n  考虑宣布这个字段是final和/或package-private。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ME_MUTABLE_ENUM_FIELD)"
      },
      {
        "real_name": "STI_INTERRUPTED_ON_UNKNOWNTHREAD",
        "display_name": "StiInterruptedOnUnknownthread",
        "severity": "warning",
        "category": "performance",
        "rule_title": "线程实例上调用的静态Thread.interrupted（）方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用Thread对象中的Thread.interrupted（）方法，该对象看起来像是一个Thread对象\n不是当前线程。由于中断（）方法是静态的，被中断的方法将被调用一个不同的方法\n客体比作者所期望的更为客观。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STI_INTERRUPTED_ON_UNKNOWNTHREAD)"
      },
      {
        "real_name": "MS_CANNOT_BE_FINAL",
        "display_name": "MsCannotBeFinal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "字段不是最终的，并且不能被保护以防止恶意代码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可变的静态字段可能会被恶意代码或其他软件包意外更改。\n   不幸的是，该领域的使用方式是不允许的\n   任何简单的解决这个问题。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_CANNOT_BE_FINAL)"
      },
      {
        "real_name": "USM_USELESS_ABSTRACT_METHOD",
        "display_name": "UsmUselessAbstractMethod",
        "severity": "warning",
        "category": "convention",
        "rule_title": "抽象方法已经在实现的接口中定义",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个抽象方法已经在由这个抽象类实现的接口中定义。该方法可以被删除，因为它没有提供额外的值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#USM_USELESS_ABSTRACT_METHOD)"
      },
      {
        "real_name": "DMI_BLOCKING_METHODS_ON_URL",
        "display_name": "DmiBlockingMethodsOnUrl",
        "severity": "warning",
        "category": "convention",
        "rule_title": "URL的equals和hashCode方法是阻塞的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "equals和hashCode\nURL的方法执行域名解析，这可能会导致很大的性能下降。\n请参阅<a href=\"http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html\"> http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode -make.html </a>以获取更多信息。\n考虑使用<code> java.net.URI </ code>来代替。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_BLOCKING_METHODS_ON_URL)"
      },
      {
        "real_name": "IJU_BAD_SUITE_METHOD",
        "display_name": "IjuBadSuiteMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "TestCase声明了一个糟糕的套件方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Class是一个JUnit TestCase并定义了一个suite（）方法。\n但是，套件方法需要声明为\n<pre> public static junit.framework.Test suite（）</ pre>\n要么\n<pre> public static junit.framework.TestSuite suite（）</ pre>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IJU_BAD_SUITE_METHOD)"
      },
      {
        "real_name": "IJU_TEARDOWN_NO_SUPER",
        "display_name": "IjuTeardownNoSuper",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "TestCase定义了不调用super.tearDown（）的tearDown",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Class是一个JUnit TestCase并实现tearDown方法。 tearDown方法应该调用\nsuper.tearDown（），但没有。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IJU_TEARDOWN_NO_SUPER)"
      },
      {
        "real_name": "IJU_SUITE_NOT_STATIC",
        "display_name": "IjuSuiteNotStatic",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "TestCase实现了一个非静态套件方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Class是一个JUnit TestCase并实现了suite（）方法。\n 套件方法应该声明为静态的，但不是。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IJU_SUITE_NOT_STATIC)"
      },
      {
        "real_name": "AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION",
        "display_name": "AtOperationSequenceOnConcurrentAbstraction",
        "severity": "warning",
        "category": "convention",
        "rule_title": "并发抽象调用的顺序可能不是原子的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码包含对并发抽象（如并发哈希映射）的调用序列。这些调用不会自动执行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION)"
      },
      {
        "real_name": "ITA_INEFFICIENT_TO_ARRAY",
        "display_name": "ItaInefficientToArray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法使用具有零长度数组参数的toArray（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用集合派生类的toArray（）方法并通过\n在一个零长度的原型数组参数中。使用效率更高\n<code> myCollection.toArray（new Foo [myCollection.size（）]）</ code>\n如果传入的数组大小足以存储所有的数组\n集合的元素，然后它被填充并返回\n直。这避免了需要创建第二个数组\n（通过反思）作为结果返回。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ITA_INEFFICIENT_TO_ARRAY)"
      },
      {
        "real_name": "IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD",
        "display_name": "IjuAssertMethodInvokedFromRunMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "运行方法中的JUnit断言不会被JUnit注意到",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "JUnit断言在run方法中执行。 JUnit断言失败\n只会导致抛出异常。\n因此，如果此异常发生在调用的线程以外的线程中\n在测试方法中，异常会终止线程但不会导致结果\n在测试失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)"
      },
      {
        "real_name": "IJU_SETUP_NO_SUPER",
        "display_name": "IjuSetupNoSuper",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "TestCase定义了不调用super.setUp（）的setUp",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Class是一个JUnit TestCase并实现了setUp方法。 setUp方法应该调用\nsuper.setUp（），但不。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IJU_SETUP_NO_SUPER)"
      },
      {
        "real_name": "NM_LCASE_TOSTRING",
        "display_name": "NmLcaseTostring",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类定义了tostring（）;应该是toString（）？",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个叫做<code> tostring（）</ code>的方法。＆nbsp;这种方法\n  不会覆盖<code> java.lang.Object </ code>中的<code> toString（）</ code>方法，\n  这可能是预期的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_LCASE_TOSTRING)"
      },
      {
        "real_name": "NM_LCASE_HASHCODE",
        "display_name": "NmLcaseHashcode",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类定义了hashcode（）;应该是hashCode（）？",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个叫做<code> hashcode（）</ code>的方法。＆nbsp;这种方法\n  不会覆盖<code> java.lang.Object </ code>中的<code> hashCode（）</ code>方法，\n  这可能是预期的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_LCASE_HASHCODE)"
      },
      {
        "real_name": "ICAST_IDIV_CAST_TO_DOUBLE",
        "display_name": "IcastIdivCastToDouble",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "积分除法结果为双精度或浮点数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码将整数除法的结果（例如int或long除法）\n操作加倍或\n浮动。\n对整数进行除法可以截断结果\n到最接近零的整数值。结果的事实\n投了两倍，表明这个精度应该保留下来。\n可能意味着将一个或两个操作数转换为\n双击<em>之前</ em>执行分割。这里是一个例子：\n\n<BLOCKQUOTE>\n<PRE>\nint x = 2;\nint y = 5;\n//错误：产生结果0.0\ndouble value1 = x / y;\n\n//右：结果为0.4\ndouble value2 = x /（double）y;\n</ PRE>\n</ BLOCKQUOTE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_IDIV_CAST_TO_DOUBLE)"
      },
      {
        "real_name": "ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL",
        "display_name": "IcastIntCastToDoublePassedToCeil",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "积分值转换为double，然后传递给Math.ceil",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码将整数值（例如int或long）\n达到双精度\n浮点数然后\n将结果传递给Math.ceil（）函数，该函数将double加1\n下一个更高的整数值。这个操作应该永远是没有操作的，\n因为将一个整数转换为double应该给出一个没有小数部分的数字。\n生成该值的操作可能会被传递\nMath.ceil旨在使用双精度执行\n浮点运算。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)"
      },
      {
        "real_name": "IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD",
        "display_name": "IaAmbiguousInvocationOfInheritedOrOuterMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "对继承或外部方法的潜在模糊调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "内部类正在调用可以解析为外部类中定义的继承方法或方法的方法。\n例如，您可以调用在超类和外部方法中定义的<code> foo（17）</ code>。\n通过Java语义，\n它将被解析为调用继承的方法，但这可能不是必需的\n你打算。\n\n 如果你真的打算调用继承的方法，\n通过调用超级方法来调用它（例如，调用super.foo（17）），并且\n因此您的代码的其他读者以及FindBugs将会很清楚\n您要调用继承的方法，而不是外部类中的方法。\n\n 如果调用<code> this.foo（17）</ code>，则将调用继承的方法。但是，由于FindBugs只能查看\n类文件，它\n无法分辨<code> this.foo（17）</ code>和<code> foo（17）</ code>的调用之间的区别，它仍然会\n抱怨潜在的模糊调用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD)"
      },
      {
        "real_name": "NM_SAME_SIMPLE_NAME_AS_SUPERCLASS",
        "display_name": "NmSameSimpleNameAsSuperclass",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类名不应该影响超类的简单名称",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类有一个简单的名字，除了它的超类之外，其他名字都是一样的\n它的父类位于不同的包中（例如，<code> alpha.Foo </ code>扩展了<code> beta.Foo </ code>）。\n这可能会非常混乱，造成许多您必须查看导入语句的情况\n解决引用和创建许多\n意外定义不覆盖超类中方法的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)"
      },
      {
        "real_name": "IC_INIT_CIRCULARITY",
        "display_name": "IcInitCircularity",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "初始化循环",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "在两者的静态初始化器中检测到圆形\n  由bug实例引用的类。＆nbsp;多种意想不到的\n  行为可能来自这种循环。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IC_INIT_CIRCULARITY)"
      },
      {
        "real_name": "NM_METHOD_CONSTRUCTOR_CONFUSION",
        "display_name": "NmMethodConstructorConfusion",
        "severity": "warning",
        "category": "security",
        "rule_title": "明显的方法/构造器混淆",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个常规方法与它定义的类具有相同的名称。可能这是为了构造器。如果它打算成为构造函数，则删除void返回值的声明。如果你意外地定义了这个方法，意识到了错误，定义了一个合适的构造函数，但由于向后兼容性而无法摆脱这种方法，所以不要使用这个方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_METHOD_CONSTRUCTOR_CONFUSION)"
      },
      {
        "real_name": "DL_SYNCHRONIZATION_ON_SHARED_CONSTANT",
        "display_name": "DlSynchronizationOnSharedConstant",
        "severity": "warning",
        "category": "security",
        "rule_title": "实字符串同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码在interned字符串上同步。\n<PRE>\nprivate static String LOCK =“LOCK”;\n...\n  同步（LOCK）{...}\n...\n</ PRE>\n 常量字符串被JVM加载的所有其他类共享和共享。因此，这可以\n正在锁定其他代码也可能锁定的内容。这可能会导致非常奇怪和难以诊断\n阻塞和死锁行为。请参阅<a href=\"http://www.javalobby.org/java/forums/t96352.html\"> http://www.javalobby.org/java/forums/t96352.html </a>和<a href = “http://jira.codehaus.org/browse/JETTY-352”> http://jira.codehaus.org/browse/JETTY-352 </A>。\n\n 请参阅CERT <a href=\"https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused\"> CON08 -J。请勿对可能重复使用的对象进行同步</a>以获取更多信息。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)"
      },
      {
        "real_name": "NM_CLASS_NAMING_CONVENTION",
        "display_name": "NmClassNamingConvention",
        "severity": "warning",
        "category": "security",
        "rule_title": "类名应以大写字母开头",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "类名应该是名词，与大写的每个内部单词的首字母混合使用。尽量保持你的类名简单和描述性。使用整个单词 - 避免首字母缩略词和缩写（除非缩写比长表单要广泛得多，比如URL或HTML）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_CLASS_NAMING_CONVENTION)"
      },
      {
        "real_name": "NM_WRONG_PACKAGE",
        "display_name": "NmWrongPackage",
        "severity": "warning",
        "category": "security",
        "rule_title": "由于参数包不正确，方法不会覆盖超类中的方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "子类中的方法不会覆盖超类中的类似方法，因为参数的类型不完全匹配\n超类中相应参数的类型。例如，如果你有：\n\n<BLOCKQUOTE>\n<PRE>\nimport alpha.Foo;\n公开课A {\n  public int f（Foo x）{return 17; }\n}\n----\n导入beta.Foo;\n公共类B延伸A {\n  public int f（Foo x）{return 42; }\n}\n</ PRE>\n</ BLOCKQUOTE>\n\n 类<code> B </ code>中定义的<code> f（Foo）</ code>方法不会\n覆盖\n<code>在类<code> A </ code>中定义的f（Foo）</ code>方法，因为参数\n类型是来自不同包的<code> Foo </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_WRONG_PACKAGE)"
      },
      {
        "real_name": "NM_WRONG_PACKAGE_INTENTIONAL",
        "display_name": "NmWrongPackageIntentional",
        "severity": "warning",
        "category": "security",
        "rule_title": "由于参数包不正确，方法不会覆盖超类中的方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "子类中的方法不会覆盖超类中的类似方法，因为参数的类型不完全匹配\n超类中相应参数的类型。例如，如果你有：\n\n<BLOCKQUOTE>\n<PRE>\nimport alpha.Foo;\n公开课A {\n  public int f（Foo x）{return 17; }\n}\n----\n导入beta.Foo;\n公共类B延伸A {\n  public int f（Foo x）{return 42; }\n  public int f（alpha.Foo x）{return 27; }\n}\n</ PRE>\n</ BLOCKQUOTE>\n\n 类<code> B </ code>中定义的<code> f（Foo）</ code>方法不会\n覆盖\n<code>在类<code> A </ code>中定义的f（Foo）</ code>方法，因为参数\n类型是来自不同包的<code> Foo </ code>。\n\n\n 在这种情况下，子类确实定义了一个签名与超类中的方法相同的方法，\n所以这是可以理解的。但是，这种方法非常混乱。你应该强烈考虑\n删除或弃用具有相似但不相同签名的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_WRONG_PACKAGE_INTENTIONAL)"
      },
      {
        "real_name": "NM_CONFUSING",
        "display_name": "NmConfusing",
        "severity": "warning",
        "category": "security",
        "rule_title": "令人困惑的方法名称",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "引用的方法名称只有大小写不同。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_CONFUSING)"
      },
      {
        "real_name": "NM_VERY_CONFUSING_INTENTIONAL",
        "display_name": "NmVeryConfusingIntentional",
        "severity": "warning",
        "category": "security",
        "rule_title": "非常混乱的方法名称（但也许是故意的）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "引用的方法名称只有大小写不同。\n这是非常混乱的，因为如果大写字母是\n相同，那么其中一种方法会覆盖另一种方法。从其他方法的存在来看，它\n似乎这两种方法的存在都是故意的，但肯定是令人困惑的。\n你应该努力消除其中的一个，除非你被迫冻结了API。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_VERY_CONFUSING_INTENTIONAL)"
      },
      {
        "real_name": "NM_SAME_SIMPLE_NAME_AS_INTERFACE",
        "display_name": "NmSameSimpleNameAsInterface",
        "severity": "warning",
        "category": "security",
        "rule_title": "类名不应该影响实现接口的简单名称",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类/接口的名称与实现/扩展接口的名称完全相同，除了\n该接口位于不同的包中（例如，<code> alpha.Foo </ code>扩展了<code> beta.Foo </ code>）。\n这可能会非常混乱，造成许多您必须查看导入语句的情况\n解决引用和创建许多\n意外定义不覆盖超类中方法的方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_SAME_SIMPLE_NAME_AS_INTERFACE)"
      },
      {
        "real_name": "NM_VERY_CONFUSING",
        "display_name": "NmVeryConfusing",
        "severity": "warning",
        "category": "security",
        "rule_title": "非常混乱的方法名称",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "引用的方法名称只有大小写不同。\n这是非常混乱的，因为如果大写字母是\n相同，那么其中一种方法会覆盖另一种方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_VERY_CONFUSING)"
      },
      {
        "real_name": "NM_METHOD_NAMING_CONVENTION",
        "display_name": "NmMethodNamingConvention",
        "severity": "warning",
        "category": "security",
        "rule_title": "方法名称应以小写字母开头",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "方法应该是动词，大小写混合，首字母小写，每个内部单词的首字母大写。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_METHOD_NAMING_CONVENTION)"
      },
      {
        "real_name": "NM_FIELD_NAMING_CONVENTION",
        "display_name": "NmFieldNamingConvention",
        "severity": "warning",
        "category": "security",
        "rule_title": "字段名称应以小写字母开头",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "不是最终字段的名称应混合使用小写的第一个字母，后面的字的首字母大写。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_FIELD_NAMING_CONVENTION)"
      },
      {
        "real_name": "VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED",
        "display_name": "VaFormatStringExtraArgumentsPassed",
        "severity": "warning",
        "category": "convention",
        "rule_title": "传递的参数多于实际在格式字符串中使用的参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用具有可变数量参数的格式字符串方法，\n但传递的参数比格式字符串实际使用的多。\n这不会导致运行时异常，但代码可能会默默省略\n旨在包含在格式化字符串中的信息。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)"
      },
      {
        "real_name": "VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED",
        "display_name": "VaFormatStringExpectedMessageFormatSupplied",
        "severity": "warning",
        "category": "convention",
        "rule_title": "MessageFormat提供了printf风格的格式",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用的方法需要Java printf格式的字符串和参数列表。\n但是，格式字符串不包含任何格式说明符（例如，％s），但是\n确实包含消息格式元素（例如{0}）。这有可能\n该代码在提供printf样式格式字符串时提供MessageFormat字符串\n是必须的。在运行时，所有参数都将被忽略\n格式字符串将按照没有任何格式的准确返回。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)"
      },
      {
        "real_name": "BIT_ADD_OF_SIGNED_BYTE",
        "display_name": "BitAddOfSignedByte",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "按位添加有符号的字节值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "添加一个字节值和一个已知有8个低位清零的值。\n从字节数组加载的值将符号扩展为32位\n在对该值执行任何按位操作之前。\n因此，如果<code> b [0] </ code>包含值<code> 0xff </ code>和\n<code> x </ code>最初是0，然后是代码\n<code>（（x <8）+ b [0]）</ code>将符号扩展<code> 0xff </ code>\n获取<code> 0xffffffff </ code>，从而给出值\n结果是<code> 0xffffffff </ code>。\n\n\n 特别是，将字节数组打包为int的以下代码是错误的：\n<PRE>\nint result = 0;\nfor（int i = 0; i <4; i ++）\n  结果=（（结果<8）+ b [i]）;\n</ PRE>\n\n 下面的习语会改为：\n<PRE>\nint result = 0;\nfor（int i = 0; i <4; i ++）\n  结果=（（结果<8）+（b [i]＆amp; 0xff））;\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_ADD_OF_SIGNED_BYTE)"
      },
      {
        "real_name": "BIT_IOR_OF_SIGNED_BYTE",
        "display_name": "BitIorOfSignedByte",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "有符号字节值的按位或运算",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "加载一个字节值（例如，从字节数组加载或由方法返回的值\n与返回类型字节）并执行与按位或\n那个价值。字节值符号扩展为32位\n在对该值执行任何按位操作之前。\n因此，如果<code> b [0] </ code>包含值<code> 0xff </ code>和\n<code> x </ code>最初是0，然后是代码\n<code>（（x <8）| b [0]）</ code>将符号扩展<code> 0xff </ code>\n获取<code> 0xffffffff </ code>，从而给出值\n结果是<code> 0xffffffff </ code>。\n\n\n 特别是，将字节数组打包为int的以下代码是错误的：\n<PRE>\nint result = 0;\nfor（int i = 0; i <4; i ++）\n  结果=（（结果<| 8）| b [i]）;\n</ PRE>\n\n 下面的习语会改为：\n<PRE>\nint result = 0;\nfor（int i = 0; i <4; i ++）\n  结果=（（结果<| 8）|（b [i]＆amp; 0xff））;\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_IOR_OF_SIGNED_BYTE)"
      },
      {
        "real_name": "SE_COMPARATOR_SHOULD_BE_SERIALIZABLE",
        "display_name": "SeComparatorShouldBeSerializable",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "比较器没有实现Serializable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类实现了<code> Comparator </ code>接口。您\n应该考虑它是否也应该实现<code> Serializable </ code>\n接口。如果使用比较器来构造有序集合\n如<code> TreeMap </ code>，然后是<code> TreeMap </ code>\n只有在比较器也是可序列化的情况下才可序列化。\n由于大多数比较器只有很少或没有状态，所以它们是可序列化的\n一般来说简单和良好的防守编程。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)"
      },
      {
        "real_name": "SE_READ_RESOLVE_IS_STATIC",
        "display_name": "SeReadResolveIsStatic",
        "severity": "warning",
        "category": "convention",
        "rule_title": "readResolve方法不能声明为静态方法。",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "为了使readResolve方法被序列化识别\n机制，它不能被声明为静态方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_READ_RESOLVE_IS_STATIC)"
      },
      {
        "real_name": "SF_SWITCH_NO_DEFAULT",
        "display_name": "SfSwitchNoDefault",
        "severity": "warning",
        "category": "convention",
        "rule_title": "在缺省情况下找到Switch语句",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法包含一个缺省情况下的switch语句。\n  通常你需要提供一个默认情况。\n   由于分析仅查看生成的字节码，因此如果出现此警告可能会被错误触发\n缺省情况是在switch语句的结尾处，并且switch语句不包含其他语句的break语句\n案例。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SF_SWITCH_NO_DEFAULT)"
      },
      {
        "real_name": "SE_METHOD_MUST_BE_PRIVATE",
        "display_name": "SeMethodMustBePrivate",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法必须是私有的才能使序列化工作",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类实现了<code> Serializable </ code>接口，并定义了一个方法\n  用于自定义序列化/反序列化。但由于该方法未被宣布为私密，\n  它将被序列化/反序列化API默默忽略。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_METHOD_MUST_BE_PRIVATE)"
      },
      {
        "real_name": "NM_CLASS_NOT_EXCEPTION",
        "display_name": "NmClassNotException",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类不是从异常派生的，即使它是这样命名的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类不是从另一个异常派生的，而是以'Exception'结尾。这会\n让这个班的使用者感到困惑。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_CLASS_NOT_EXCEPTION)"
      },
      {
        "real_name": "DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED",
        "display_name": "DmiThreadPassedWhereRunnableExpected",
        "severity": "warning",
        "category": "convention",
        "rule_title": "线程在Runnable期望的地方传递",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个Thread对象作为参数传递给一个方法\n预计可运行。这很不寻常，并且可能表示逻辑错误\n或导致意外的行为。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED)"
      },
      {
        "real_name": "DMI_COLLECTION_OF_URLS",
        "display_name": "DmiCollectionOfUrls",
        "severity": "warning",
        "category": "convention",
        "rule_title": "地图和一组网址可能会导致性能下降",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法或字段是或使用一个Map或一组URL。既然是equals和hashCode\nURL的方法执行域名解析，这可能会导致很大的性能下降。\n请参阅<a href=\"http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html\"> http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode -make.html </a>以获取更多信息。\n考虑使用<code> java.net.URI </ code>来代替。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_COLLECTION_OF_URLS)"
      },
      {
        "real_name": "SE_NO_SUITABLE_CONSTRUCTOR",
        "display_name": "SeNoSuitableConstructor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类是可序列化的，但其超类没有定义无效构造函数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类实现了<code> Serializable </ code>接口\n   而它的超类没有。当这样的对象被反序列化时，\n   超类的字段需要被初始化\n   调用超类的无效构造函数。\n   由于超类没有一个，\n   序列化和反序列化将在运行时失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_NO_SUITABLE_CONSTRUCTOR)"
      },
      {
        "real_name": "SE_NO_SERIALVERSIONID",
        "display_name": "SeNoSerialversionid",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类是可序列化的，但不定义serialVersionUID",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类实现了<code> Serializable </ code>接口，但是\n  未定义<code> serialVersionUID </ code>字段。＆nbsp;\n  一个简单的改变就像添加一个.class对象的引用一样，将会为这个类添加合成域，\n   这将不幸地改变了隐含的\n   serialVersionUID（例如，添加对<code> String.class </ code>的引用\n   将生成一个静态字段<code> class $ java $ lang $ String </ code>）。\n   另外，字节码编译器的不同源代码可能会使用不同的\n   为生成的合成变量命名约定\n   对类对象或内部类的引用。\n   为确保不同版本的Serializable的互操作性，\n   考虑添加一个显式的serialVersionUID。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_NO_SERIALVERSIONID)"
      },
      {
        "real_name": "SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION",
        "display_name": "SeNoSuitableConstructorForExternalization",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类是Externalizable，但没有定义无效构造函数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类实现了<code> Externalizable </ code>接口，但是\n  没有定义一个无效的构造函数。当Externalizable对象被反序列化时，\n   他们首先需要通过援引虚空来构建\n   构造函数。由于这个班没有一个，\n   序列化和反序列化将在运行时失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)"
      },
      {
        "real_name": "NM_BAD_EQUAL",
        "display_name": "NmBadEqual",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类定义相等（Object）;它应该是等于（Object）吗？",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个方法<code> equal（Object）</ code>。＆nbsp;这种方法\n不覆盖<code> java.lang.Object </ code>中的<code> equals（Object）</ code>方法，\n这可能是预期的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NM_BAD_EQUAL)"
      },
      {
        "real_name": "RR_NOT_CHECKED",
        "display_name": "RrNotChecked",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法忽略InputStream.read（）的结果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法忽略其中一个变体的返回值\n  <code> java.io.InputStream.read（）</ code>它可以返回多个字节。＆nbsp;\n  如果未检查返回值，则调用者将无法正确进行\n  处理读取的字节数少于调用者所请求的字节数。＆nbsp;\n  这是一个特别隐秘的错误，因为在许多程序中，\n  从输入流中读取数据通常会读取所请求的全部数据量，\n  导致程序只能偶尔失败。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RR_NOT_CHECKED)"
      },
      {
        "real_name": "SR_NOT_CHECKED",
        "display_name": "SrNotChecked",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法忽略InputStream.skip（）的结果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法忽略了返回值\n  <code> java.io.InputStream.skip（）</ code>可以跳过多个字节。＆nbsp;\n  如果未检查返回值，则调用者将无法正确进行\n  处理比呼叫者请求跳过的字节更少的情况。＆nbsp;\n  这是一个特别隐秘的错误，因为在许多程序中，\n  来自输入流的跳过通常会跳过所请求的全部数据量，\n  导致程序只能偶尔失败。然而，对于缓冲流，\n  skip（）只会跳过缓冲区中的数据，并且通常不会跳过缓冲区中的数据\n  请求的字节数。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SR_NOT_CHECKED)"
      },
      {
        "real_name": "SE_PRIVATE_READ_RESOLVE_NOT_INHERITED",
        "display_name": "SePrivateReadResolveNotInherited",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "私有readResolve方法不被子类继承",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个私有的readResolve方法。由于它是私人的，它不会被子类继承。\n这可能是有意和确定的，但应该进行审查以确保它是预期的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)"
      },
      {
        "real_name": "SE_READ_RESOLVE_MUST_RETURN_OBJECT",
        "display_name": "SeReadResolveMustReturnObject",
        "severity": "warning",
        "category": "convention",
        "rule_title": "readResolve方法必须用返回类型Object声明。",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "为了使readResolve方法被序列化识别\n机制，它必须被声明为具有返回类型的Object。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_READ_RESOLVE_MUST_RETURN_OBJECT)"
      },
      {
        "real_name": "SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS",
        "display_name": "SeTransientFieldOfNonserializableClass",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不是可序列化的类的暂态字段。",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段被标记为暂时的，但该类不是可序列化的，因此将其标记为暂时的\n绝对没有效果。\n这可能是从类的暂时代码的以前版本中剩下的标记，或者\n这可能意味着对序列化如何工作的误解。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS)"
      },
      {
        "real_name": "SE_TRANSIENT_FIELD_NOT_RESTORED",
        "display_name": "SeTransientFieldNotRestored",
        "severity": "warning",
        "category": "convention",
        "rule_title": "暂态字段不是由反序列化设置的。",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类包含一个在类中多个地方更新的字段，因此它似乎是类的一部分。但是，由于该字段被标记为transient，并且未在readObject或readResolve中设置，所以它将包含默认值\n反序列化的类实例。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_TRANSIENT_FIELD_NOT_RESTORED)"
      },
      {
        "real_name": "IT_NO_SUCH_ELEMENT",
        "display_name": "ItNoSuchElement",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Iterator的next（）方法不能抛出NoSuchElementException异常",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类实现了<code> java.util.Iterator </ code>接口。＆nbsp;\n  但是，它的<code> next（）</ code>方法不能抛出\n  <代码> java.util.NoSuchElementException </代码>群组。 <code> next（）</ code>\n  方法应该被更改，以便引发<code> NoSuchElementException </ code>\n  如果在没有更多元素返回时调用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IT_NO_SUCH_ELEMENT)"
      },
      {
        "real_name": "Testing",
        "display_name": "Testing",
        "severity": "warning",
        "category": "convention",
        "rule_title": "测试",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个错误模式只是由新的，不完全实现的\n臭虫探测器。"
      },
      {
        "real_name": "RpC_REPEATED_CONDITIONAL_TEST",
        "display_name": "RpcRepeatedConditionalTest",
        "severity": "warning",
        "category": "convention",
        "rule_title": "重复的条件测试",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码包含一个条件测试执行两次，一个接一个地执行\n（例如，<code> x == 0 || x == 0 </ code>）。也许第二次出现是为了别的\n（例如，<code> x == 0 || y == 0 </ code>）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RpC_REPEATED_CONDITIONAL_TEST)"
      },
      {
        "real_name": "NP_SYNC_AND_NULL_CHECK_FIELD",
        "display_name": "NpSyncAndNullCheckField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "对同一个字段进行同步和空检查。",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "由于该字段已同步，因此似乎不可能为空。\n如果它是空的，然后同步NullPointerException将是\n抛出和检查将是毫无意义的。更好地同步\n另一个领域。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_SYNC_AND_NULL_CHECK_FIELD)"
      },
      {
        "real_name": "RV_CHECK_FOR_POSITIVE_INDEXOF",
        "display_name": "RvCheckForPositiveIndexof",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法检查String.indexOf的结果是否为正值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法调用String.indexOf并检查结果是肯定的还是非肯定的。\n   检查结果是否为阴性或非阴性更为典型。它是\n   只有在子字符串检查发生在除了开始处以外的某个位置时才为正数\n   字符串。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_CHECK_FOR_POSITIVE_INDEXOF)"
      },
      {
        "real_name": "NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS",
        "display_name": "NpNullParamDerefAllTargetsDangerous",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法调用为非null参数传递null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可能为空的值在所有已知目标方法要求参数为非空的调用站点处传递。要么参数被注释为一个始终为非空的参数，要么分析表明它始终被解除引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)"
      },
      {
        "real_name": "NP_NONNULL_RETURN_VIOLATION",
        "display_name": "NpNonnullReturnViolation",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法可以返回null，但声明为@Nonnull",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法可能返回空值，但该方法（或其覆盖的超类方法）被声明为返回@Nonnull。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NONNULL_RETURN_VIOLATION)"
      },
      {
        "real_name": "FI_FINALIZER_ONLY_NULLS_FIELDS",
        "display_name": "FiFinalizerOnlyNullsFields",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "终结者只允许空字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个终结器除了空字段外什么都不做。这完全没有意义，并且要求\n该对象被垃圾收集，最终确定，然后再次垃圾收集。你应该删除finalize\n方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_FINALIZER_ONLY_NULLS_FIELDS)"
      },
      {
        "real_name": "HRS_REQUEST_PARAMETER_TO_HTTP_HEADER",
        "display_name": "HrsRequestParameterToHttpHeader",
        "severity": "warning",
        "category": "convention",
        "rule_title": "HTTP响应分裂漏洞",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码直接将HTTP参数写入HTTP标头，该标头允许HTTP响应拆分\n漏洞。请参阅<a href=\"http://en.wikipedia.org/wiki/HTTP_response_splitting\"> http://en.wikipedia.org/wiki/HTTP_response_splitting </a>\n了解更多信息。\n FindBugs只查找最明显的HTTP响应分裂情况。\n如果FindBugs找到<em>任何<em>，那么你几乎可以肯定</ em>有更多\nFindBugs不报告的漏洞。如果你担心HTTP响应分裂，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)"
      },
      {
        "real_name": "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE",
        "display_name": "RcnRedundantNullcheckOfNullValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "值冗余空检查已知为空",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含对已知空值的冗余检查\n常量null。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE)"
      },
      {
        "real_name": "NP_NULL_PARAM_DEREF",
        "display_name": "NpNullParamDeref",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法调用为非null参数传递null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用为非null方法参数传递null值。要么参数被注释为一个始终为非空的参数，要么分析表明它始终被解除引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_PARAM_DEREF)"
      },
      {
        "real_name": "FI_EMPTY",
        "display_name": "FiEmpty",
        "severity": "warning",
        "category": "convention",
        "rule_title": "空结束符应该被删除",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "空<code> finalize（）</ code>方法没用，所以它们应该\n  被删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_EMPTY)"
      },
      {
        "real_name": "FI_PUBLIC_SHOULD_BE_PROTECTED",
        "display_name": "FiPublicShouldBeProtected",
        "severity": "warning",
        "category": "convention",
        "rule_title": "终结者应该受到保护，而不是公开的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个类的<code> finalize（）</ code>方法应该具有受保护的访问权限，\n   不公开。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_PUBLIC_SHOULD_BE_PROTECTED)"
      },
      {
        "real_name": "RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES",
        "display_name": "RcnRedundantComparisonTwoNullValues",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "两个空值的冗余比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含已知的两个参考的冗余比较\n都是绝对无效的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)"
      },
      {
        "real_name": "RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE",
        "display_name": "RcnRedundantComparisonOfNullAndNonnullValue",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "将非空值与空值进行冗余比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含已知与另一个引用非空的引用\n已知为空。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)"
      },
      {
        "real_name": "FI_NULLIFY_SUPER",
        "display_name": "FiNullifySuper",
        "severity": "warning",
        "category": "convention",
        "rule_title": "终结者无效超级终结器",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个空的<code> finalize（）</ code>方法明确地否定了\n  由超类定义的任何终结器的影响。＆nbsp;任何终结者\n  为超类定义的操作将不会执行。＆nbsp;\n  除非有意，否则请删除此方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_NULLIFY_SUPER)"
      },
      {
        "real_name": "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE",
        "display_name": "RcnRedundantNullcheckOfNonnullValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "已知值非冗余的冗余空检查",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含对已知非空值的冗余检查\n常量null。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)"
      },
      {
        "real_name": "NP_METHOD_PARAMETER_RELAXING_ANNOTATION",
        "display_name": "NpMethodParameterRelaxingAnnotation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法收紧参数的无效注解",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "一个方法应该总是执行它覆盖的方法的契约。因此，如果一个方法接受一个标记为@Nullable的参数，则不应该使用该参数为@Nonnull的方法在子类中重写该方法。这样做违反了该方法应该处理空参数的合约。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_METHOD_PARAMETER_RELAXING_ANNOTATION)"
      },
      {
        "real_name": "PT_ABSOLUTE_PATH_TRAVERSAL",
        "display_name": "PtAbsolutePathTraversal",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "servlet中的绝对路径遍历",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该软件使用HTTP请求参数来构建应该位于受限目录内的路径名，\n但它不能正确地中和绝对路径序列，如可以解析到该目录之外的位置的“/ abs / path”。\n\n请参阅<a href=\"http://cwe.mitre.org/data/definitions/36.html\"> http://cwe.mitre.org/data/definitions/36.html </a>\n了解更多信息。\n FindBugs只查找最明显，最明显的绝对路径遍历情况。\n如果FindBugs找到<em>任何<em>，那么你几乎可以肯定</ em>有更多\nFindBugs不报告的漏洞。如果你关心绝对路径遍历，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#PT_ABSOLUTE_PATH_TRAVERSAL)"
      },
      {
        "real_name": "UCF_USELESS_CONTROL_FLOW",
        "display_name": "UcfUselessControlFlow",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无用的控制流",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法包含一个无用的控制流程语句，其中\n无论是否控制流程继续到同一地点\n该分支被采取。例如，\n这是由于有一个空的语句造成的\n如果</ code>语句阻塞<code>：\n<pre> if（argv.length == 0）{// TODO：处理这种情况}\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UCF_USELESS_CONTROL_FLOW)"
      },
      {
        "real_name": "UCF_USELESS_CONTROL_FLOW_NEXT_LINE",
        "display_name": "UcfUselessControlFlowNextLine",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无用的控制流向下一行",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含一个无用的控制流程语句，其中包含控制\n无论是否跟随流量，都遵循相同或跟随的流水线\n该分支被采取。\n通常，这是由于无意中使用空语句而导致的\n<code> if </ code>语句的主体，例如：\n<pre> if（argv.length == 1）; System.out.println（“Hello，”+ argv [0]）;\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UCF_USELESS_CONTROL_FLOW_NEXT_LINE)"
      },
      {
        "real_name": "BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY",
        "display_name": "BcImpossibleCastPrimitiveArray",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "涉及原始数组的不可能投射",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个转换总是会抛出一个ClassCastException异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY)"
      },
      {
        "real_name": "NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH",
        "display_name": "NpGuaranteedDerefOnExceptionPath",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "值为空，并保证在异常路径上取消引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "在异常路径上有一条语句或分支，如果执行该语句或分支，则保证此时值为空，并且该值保证被解除引用（除了涉及运行时异常的前向路径）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)"
      },
      {
        "real_name": "SI_INSTANCE_BEFORE_FINALS_ASSIGNED",
        "display_name": "SiInstanceBeforeFinalsAssigned",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "静态初始化器在分配所有静态最终字段之前创建实例",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类的静态初始化器创建该类的一个实例\n在分配所有静态最终字段之前。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SI_INSTANCE_BEFORE_FINALS_ASSIGNED)"
      },
      {
        "real_name": "NP_TOSTRING_COULD_RETURN_NULL",
        "display_name": "NpTostringCouldReturnNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "toString方法可能会返回null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个toString方法似乎在某些情况下返回null。自由阅读规范可以被解释为允许这样做，但这可能是一个坏主意，并可能导致其他代码崩溃。返回空字符串或其他适当的字符串而不是null。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_TOSTRING_COULD_RETURN_NULL)"
      },
      {
        "real_name": "NP_GUARANTEED_DEREF",
        "display_name": "NpGuaranteedDeref",
        "severity": "warning",
        "category": "convention",
        "rule_title": "空值保证被解除引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "有一个语句或分支，如果执行该语句或分支，则确保此时值为空，并且该值保证被解除引用（除了涉及运行时异常的前向路径）。请注意，诸如<code> if（x == null）之类的检查会抛出新的NullPointerException（）; </ code>被视为<code> x </ code>的解引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_GUARANTEED_DEREF)"
      },
      {
        "real_name": "OS_OPEN_STREAM",
        "display_name": "OsOpenStream",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法可能无法关闭流",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法创建一个IO流对象，不会将其分配给任何\n将其传递给可能会关闭它的其他方法，\n或返回它，并没有出现关闭\n所有路径上的流不在该方法中。＆nbsp;这可能会导致\n一个文件descriptionriptor泄漏。＆nbsp;这通常是一件好事\n想法使用<code> finally </ code>块来确保流是\n关闭。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#OS_OPEN_STREAM)"
      },
      {
        "real_name": "PZLA_PREFER_ZERO_LENGTH_ARRAYS",
        "display_name": "PzlaPreferZeroLengthArrays",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "考虑返回一个零长度数组而不是null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "它通常是一个更好的设计\n返回一个长度为零的数组而不是空引用来表示那里\n没有结果（即结果为空列表）。\n这样，该方法的客户端不需要明确检查null。\n\n 另一方面，使用null来表示\n“这个问题没有答案”可能是合适的。\n例如，<code> File.listFiles（）</ code>返回一个空列表\n如果给定一个不包含文件的目录，并且如果该文件返回null\n不是一个目录。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#PZLA_PREFER_ZERO_LENGTH_ARRAYS)"
      },
      {
        "real_name": "OS_OPEN_STREAM_EXCEPTION_PATH",
        "display_name": "OsOpenStreamExceptionPath",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法可能无法在异常时关闭流",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法创建一个IO流对象，不会将其分配给任何\n字段，将其传递给其他方法或返回，并且不会显示为关闭\n它在所有可能的异常路径之外。＆nbsp;\n这可能会导致文件说明文件泄漏。＆nbsp;这通常是一件好事\n想法使用<code> finally </ code>块来确保流是\n关闭。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#OS_OPEN_STREAM_EXCEPTION_PATH)"
      },
      {
        "real_name": "PT_RELATIVE_PATH_TRAVERSAL",
        "display_name": "PtRelativePathTraversal",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "servlet中的相对路径遍历",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该软件使用HTTP请求参数来构建应位于受限目录内的路径名，但它不能正确地中和可以解析到该目录之外的位置的“..”之类的序列。\n\n请参阅<a href=\"http://cwe.mitre.org/data/definitions/23.html\"> http://cwe.mitre.org/data/definitions/23.html </a>\n了解更多信息。\n FindBugs仅查找最明显的相对路径遍历的明显情况。\n如果FindBugs找到<em>任何<em>，那么你几乎可以肯定</ em>有更多\nFindBugs不报告的漏洞。如果你关心相对路径遍历，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#PT_RELATIVE_PATH_TRAVERSAL)"
      },
      {
        "real_name": "NP_CLONE_COULD_RETURN_NULL",
        "display_name": "NpCloneCouldReturnNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "克隆方法可能会返回null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这种克隆方法在某些情况下似乎返回null，但克隆从不允许返回空值。如果您确信此路径无法访问，请改用AssertionError。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_CLONE_COULD_RETURN_NULL)"
      },
      {
        "real_name": "NP_NONNULL_PARAM_VIOLATION",
        "display_name": "NpNonnullParamViolation",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法调用将null传递给非空参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法传递一个空值作为必须为非空的方法的参数。这个参数被明确标记为@Nonnull，或者分析已经确定这个参数总是被解除引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NONNULL_PARAM_VIOLATION)"
      },
      {
        "real_name": "HRS_REQUEST_PARAMETER_TO_COOKIE",
        "display_name": "HrsRequestParameterToCookie",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "HTTP cookie由不可信输入组成",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码使用不可信的HTTP参数构建HTTP Cookie。如果将此cookie添加到HTTP响应中，它将允许HTTP响应分裂\n漏洞。请参阅<a href=\"http://en.wikipedia.org/wiki/HTTP_response_splitting\"> http://en.wikipedia.org/wiki/HTTP_response_splitting </a>\n了解更多信息。\n FindBugs只查找最明显的HTTP响应分裂情况。\n如果FindBugs找到<em>任何<em>，那么你几乎可以肯定</ em>有更多\nFindBugs不报告的漏洞。如果你担心HTTP响应分裂，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#HRS_REQUEST_PARAMETER_TO_COOKIE)"
      },
      {
        "real_name": "RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE",
        "display_name": "RcnRedundantNullcheckWouldHaveBeenANpe",
        "severity": "warning",
        "category": "convention",
        "rule_title": "以前取消了值的空值检查",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这里检查一个值是否为空，但是这个值不能\n为空，因为它先前被解除引用，如果它为空，则为空指针\n在先前的解除引用中会发生异常。\n基本上，这个代码和以前的解除引用\n不同意这个值是否被允许为空。这个支票是多余的\n或者之前的解除引用是错误的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE)"
      },
      {
        "real_name": "WA_NOT_IN_LOOP",
        "display_name": "WaNotInLoop",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不要等待循环",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含对<code> java.lang.Object.wait（）</ code>的调用\n  不在循环中。＆nbsp;如果监视器用于多种情况，\n  主叫方打算等待的状况可能不是那个状态\n  实际发生的情况。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#WA_NOT_IN_LOOP)"
      },
      {
        "real_name": "WA_AWAIT_NOT_IN_LOOP",
        "display_name": "WaAwaitNotInLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Condition.await（）不在循环中",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含对<code> java.util.concurrent.await（）</ code>的调用\n   （或变体）\n  不在循环中。＆nbsp;如果该对象用于多个条件，\n  主叫方打算等待的状况可能不是那个状态\n  实际发生的情况。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#WA_AWAIT_NOT_IN_LOOP)"
      },
      {
        "real_name": "ML_SYNC_ON_UPDATED_FIELD",
        "display_name": "MlSyncOnUpdatedField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法在更新的字段上进行同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在一个对象上同步\n   从一个可变字段引用。\n   由于不同，这不太可能具有有用的语义\n线程可能会在不同的对象上同步。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ML_SYNC_ON_UPDATED_FIELD)"
      },
      {
        "real_name": "ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD",
        "display_name": "MlSyncOnFieldToGuardChangingThatField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "同步现场无效尝试保护该领域",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这种方法在似乎是企图的领域同步\n以防止同时更新该字段。但守卫一个领域\n获取对引用对象的锁定，而不是在该字段上。这可能不会\n提供您需要的互斥，以及其他线程可能\n获取引用对象上的锁（用于其他目的）。一个例子\n这种模式将是：\n<PRE>\nprivate Long myNtfSeqNbrCounter = new Long（0）;\nprivate Long getNotificationSequenceNumber（）{Long result = null; synchronized（myNtfSeqNbrCounter）{result = new Long（myNtfSeqNbrCounter.longValue（）+ 1）; myNtfSeqNbrCounter = new Long（result.longValue（））; }返回结果;\n }\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD)"
      },
      {
        "real_name": "OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE",
        "display_name": "OblUnsatisfiedObligationExceptionEdge",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法可能无法清除检查到的异常时的流或资源",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法可能无法清理（关闭，处置）流，数据库对象或其他需要显式清理操作的资源。\n               通常，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前清理流或资源。\n               此错误模式与OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式基本相同，但是基于不同的（并希望更好）静态分析技术。我们感兴趣的是获得有关这种错误模式的有用性的反馈。发送反馈意见：<ul> <li>发送邮件至findbugs@cs.umd.edu </ li> <li>提交错误报告：<a href =“http://findbugs.sourceforge.net/reportingBugs .html“> http://findbugs.sourceforge.net/reportingBugs.html </a> </ li> </ ul>\n               特别是，这种错误模式的假阳性抑制启发式方法还没有得到广泛的调整，所以关于误报的报告对我们很有帮助。\n               关于分析技术的描述，请参阅Weimer和Necula，“发现并防止运行时错误处理错误”</ i>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE)"
      },
      {
        "real_name": "FB_UNEXPECTED_WARNING",
        "display_name": "FbUnexpectedWarning",
        "severity": "warning",
        "category": "convention",
        "rule_title": "来自FindBugs的意外/不需要的警告",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "FindBugs产生了一个警告，根据@NoWarning注释，这是一个意想不到的或不受欢迎的\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FB_UNEXPECTED_WARNING)"
      },
      {
        "real_name": "BRSA_BAD_RESULTSET_ACCESS",
        "display_name": "BrsaBadResultsetAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法尝试访问索引为0的结果集字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "对结果集的getXXX或updateXXX方法的调用是在\n字段索引为0.由于ResultSet字段从索引1开始，这总是一个错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BRSA_BAD_RESULTSET_ACCESS)"
      },
      {
        "real_name": "SQL_BAD_RESULTSET_ACCESS",
        "display_name": "SqlBadResultsetAccess",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法尝试访问索引为0的结果集字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "对结果集的getXXX或updateXXX方法的调用是在\n字段索引为0.由于ResultSet字段从索引1开始，这总是一个错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SQL_BAD_RESULTSET_ACCESS)"
      },
      {
        "real_name": "UL_UNRELEASED_LOCK",
        "display_name": "UlUnreleasedLock",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法不释放所有路径上的锁定",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法获取JSR-166（<code> java.util.concurrent </ code>）锁定，\n但不会在该方法的所有路径上释放它。一般来说，正确的习惯用法\n因为使用JSR-166锁定是：\n\n<pre>锁定l = ...; l.lock（）;尝试{//做一些事情} finally {l.unlock（）; }\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UL_UNRELEASED_LOCK)"
      },
      {
        "real_name": "UL_UNRELEASED_LOCK_EXCEPTION_PATH",
        "display_name": "UlUnreleasedLockExceptionPath",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法不释放对所有异常路径的锁定",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法获取JSR-166（<code> java.util.concurrent </ code>）锁定，\n但不会在方法外的所有异常路径上释放它。一般来说，正确的习惯用法\n因为使用JSR-166锁定是：\n\n<pre>锁定l = ...; l.lock（）;尝试{//做一些事情} finally {l.unlock（）; }\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UL_UNRELEASED_LOCK_EXCEPTION_PATH)"
      },
      {
        "real_name": "PARSE_MAYBENULL_STRING",
        "display_name": "PARSE_MAYBENULL_STRING",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#PARSE_MAYBENULL_STRING)"
      },
      {
        "real_name": "VA_FORMAT_STRING_ILLEGAL",
        "display_name": "VaFormatStringIllegal",
        "severity": "warning",
        "category": "convention",
        "rule_title": "非法格式字符串",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "格式字符串在语法上无效，\n并在运行时异常发生时\n这条语句被执行。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_ILLEGAL)"
      },
      {
        "real_name": "DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD",
        "display_name": "DmiVacuousCallToEasymockMethod",
        "severity": "warning",
        "category": "security",
        "rule_title": "对EasyMock方法无用/空的调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此调用不会将任何对象传递给EasyMock方法，因此该调用不会执行任何操作。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)"
      },
      {
        "real_name": "DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS",
        "display_name": "DmiScheduledThreadPoolExecutorWithZeroCoreThreads",
        "severity": "warning",
        "category": "security",
        "rule_title": "用零核心线程创建ScheduledThreadPoolExecutor",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "（<a href=\"http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)\"> Javadoc </a>）\n具有零核心线程的ScheduledThreadPoolExecutor永远不会执行任何操作;忽略对最大池大小的更改。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS)"
      },
      {
        "real_name": "RC_REF_COMPARISON",
        "display_name": "RcRefComparison",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可疑的参考比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法使用==或！=运算符比较两个参考值，\n其中正确比较这种类型实例的方式通常是\n用equals（）方法。\n有可能创建相同的独立实例，但不会像==那样比较\n他们是不同的对象。\n通常应该的类的例子\n不能通过引用来比较java.lang.Integer，java.lang.Float等\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RC_REF_COMPARISON)"
      },
      {
        "real_name": "STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE",
        "display_name": "StcalInvokeOnStaticCalendarInstance",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用静态日历",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "尽管JavaDoc没有提示它，但日历在多线程使用中本质上是不安全的。\n检测器已经找到了通过静态获得的日历实例的调用\n领域。这看起来很可疑。\n 有关详情，请参阅<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579\"> Sun Bug＃6231579 </a>\n和<a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997\"> Sun Bug＃6178997 </a>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)"
      },
      {
        "real_name": "DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS",
        "display_name": "DmiEntrySetsMayReuseEntryObjects",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "由于重新使用Entry对象，添加条目集的元素可能会失败",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "允许entrySet（）方法返回底层Map的视图，其中单个Entry对象在迭代过程中被重用并返回。从Java 1.6开始，IdentityHashMap和EnumMap都这样做了。在遍历这样的Map时，Entry值只有在进入下一次迭代之前才有效。例如，如果您尝试将这样的entrySet传递给addAll方法，那么事情就会发生严重错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS)"
      },
      {
        "real_name": "SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS",
        "display_name": "SicInnerShouldBeStaticNeedsThis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可以重构为静态内部类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类是一个内部类，但不使用它的嵌入式引用\n  除了在施工期间创造它的物体\n内部对象。＆nbsp;这个引用使得这些实例\n  的类更大，并且可以保持对创建者对象的引用\n  存活时间超过必要时间。＆nbsp;如果可能的话，班级应该是\n  制作成一个<em>静态</ em>内部类。既然参考了\n   在内部实例的构建期间需要外部对象，\n   内部类将需要重构以便\n   将对外部实例的引用传递给构造函数\n   为内心阶层。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS)"
      },
      {
        "real_name": "RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE",
        "display_name": "RvCheckComparetoForSpecificReturnValue",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "代码检查compareTo返回的特定值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码调用compareTo或compare方法，并检查返回值是否为特定值，\n如1或-1。在调用这些方法时，您应该只检查结果的符号，而不是针对任何特定的\n非零值。虽然许多或大多数compareTo和compare方法只返回-1,0或1，其中一些\n将返回其他值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE)"
      },
      {
        "real_name": "NP_ALWAYS_NULL",
        "display_name": "NpAlwaysNull",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "空指针解除引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "空指针在此处取消引用。＆nbsp;这将导致一个\n代码执行时的<code> NullPointerException </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_ALWAYS_NULL)"
      },
      {
        "real_name": "RV_EXCEPTION_NOT_THROWN",
        "display_name": "RvExceptionNotThrown",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "例外创建并丢弃而不是抛出",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码创建一个异常（或错误）对象，但不会对它执行任何操作。例如，\n就像是\n<BLOCKQUOTE>\n<PRE>\n如果（x <0）\n  新的IllegalArgumentException（“x必须是非负的”）;\n</ PRE>\n</ BLOCKQUOTE>\n 这可能是程序员抛出创建的异常的意图：\n<BLOCKQUOTE>\n<PRE>\n如果（x <0）\n  抛出新的IllegalArgumentException（“x必须是非负的”）;\n</ PRE>\n</ BLOCKQUOTE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_EXCEPTION_NOT_THROWN)"
      },
      {
        "real_name": "NP_CLOSING_NULL",
        "display_name": "NpClosingNull",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "close（）对始终为空的值进行调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "close（）被调用的值始终为空。如果这个陈述被执行，\n会发生空指针异常。但是这里的风险你永远不会接近\n应该关闭的东西。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_CLOSING_NULL)"
      },
      {
        "real_name": "MWN_MISMATCHED_WAIT",
        "display_name": "MwnMismatchedWait",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不匹配的等待（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法调用Object.wait（）时没有明显的锁定\n在物件上。＆nbsp;调用wait（）而不保持锁将导致\n抛出一个<code> IllegalMonitorStateException </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MWN_MISMATCHED_WAIT)"
      },
      {
        "real_name": "EC_NULL_ARG",
        "display_name": "EcNullArg",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用equals（null）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法调用equals（Object），传递一个空值为\n争论。根据equals（）方法的合同，\n这个调用应该总是返回<code> false </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_NULL_ARG)"
      },
      {
        "real_name": "EC_UNRELATED_CLASS_AND_INTERFACE",
        "display_name": "EcUnrelatedClassAndInterface",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用equals（）比较无关的类和接口",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法在两个引用上调用equals（Object），其中一个是类\n另一个是接口，既不是类也不是它的任何接口\n非抽象的子类实现接口。\n因此，被比较的对象\n在运行时不太可能成为同一类的成员\n（除非某些应用程序类没有被分析，或者动态类\n加载可以在运行时发生）。\n根据equals（）的合约，\n不同的对象\n类应该总是比较不平等;因此，根据\n由java.lang.Object.equals（Object）定义的契约，\n这种比较的结果在运行时始终是错误的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_UNRELATED_CLASS_AND_INTERFACE)"
      },
      {
        "real_name": "EC_UNRELATED_TYPES",
        "display_name": "EcUnrelatedTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "调用equals（）比较不同的类型",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法在两个不同的引用上调用equals（Object）\n班级类型和分析表明他们将是不同班级的对象\n在运行时。此外，审查将被调用的等值方法也暗示了这一点\n这个调用总是返回false，否则equals方法不是对称的（这是\n合同要求的财产\n对于类Object中的equals）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_UNRELATED_TYPES)"
      },
      {
        "real_name": "EC_UNRELATED_INTERFACES",
        "display_name": "EcUnrelatedInterfaces",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "调用equals（）比较不同的接口类型",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法在两个不相关的引用上调用equals（Object）\n接口类型，其中既不是另一个的子类型，\n并且没有已知的实现两个接口的非抽象类。\n因此，被比较的对象\n在运行时不太可能成为同一类的成员\n（除非某些应用程序类没有被分析，或者动态类\n加载可以在运行时发生）。\n根据equals（）的合约，\n不同的对象\n类应该总是比较不平等;因此，根据\n由java.lang.Object.equals（Object）定义的契约，\n这种比较的结果在运行时始终是错误的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EC_UNRELATED_INTERFACES)"
      },
      {
        "real_name": "SA_FIELD_DOUBLE_ASSIGNMENT",
        "display_name": "SaFieldDoubleAssignment",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "字段的双重分配",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法包含一个字段的双重分配;例如\n\n<PRE>\n  int x，y;\n  public void foo（）{x = x = 17;\n  }\n</ PRE>\n 分配给字段两次是无用的，可能表示逻辑错误或拼写错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_FIELD_DOUBLE_ASSIGNMENT)"
      },
      {
        "real_name": "SA_LOCAL_SELF_ASSIGNMENT",
        "display_name": "SaLocalSelfAssignment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "局部变量的自赋值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法包含一个局部变量的自赋值;例如\n<PRE>\n  public void foo（）{int x = 3; x = x;\n  }\n</ PRE>\n \n这样的分配毫无用处，可能表明逻辑错误或拼写错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_LOCAL_SELF_ASSIGNMENT)"
      },
      {
        "real_name": "SA_FIELD_SELF_ASSIGNMENT",
        "display_name": "SaFieldSelfAssignment",
        "severity": "warning",
        "category": "convention",
        "rule_title": "领域的自我分配",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法包含一个字段的自赋值;例如\n\n<PRE>\n  int x;\n  public void foo（）{x = x;\n  }\n</ PRE>\n 这样的分配毫无用处，可能表明逻辑错误或拼写错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_FIELD_SELF_ASSIGNMENT)"
      },
      {
        "real_name": "VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT",
        "display_name": "VaFormatStringNoPreviousArgument",
        "severity": "warning",
        "category": "convention",
        "rule_title": "格式字符串没有先前的参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "格式字符串指定一个相对索引来请求前一个格式说明符的参数\n被重用。但是，之前没有任何争论。\n例如，\n\n <code> formatter.format（“％＆lt; s％s”，“a”，“b”）</ code>\n\n 执行时会抛出MissingFormatArgumentException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)"
      },
      {
        "real_name": "BSHIFT_WRONG_ADD_PRIORITY",
        "display_name": "BshiftWrongAddPriority",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "可能对移位操作的分析不好",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码执行如（x <8 + y）的操作。虽然这可能是正确的，但可能是这个意思\n以执行（x <8）+ y，但移位操作具有\n较低的优先级，所以它实际上被解析为x＆lt;＆lt;＆lt; （8 + y）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BSHIFT_WRONG_ADD_PRIORITY)"
      },
      {
        "real_name": "ICAST_BAD_SHIFT_AMOUNT",
        "display_name": "IcastBadShiftAmount",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "32位整数移位的数量不在-31..31的范围内",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码执行一个32位整数的外部恒定量的移位\n范围-31..31。\n这样做的效果是使用整数的低5位\n值来决定移动多少（例如，移位40位与移位8位相同，\n并且移位32位与移位零位相同）。这可能不是预期的，\n至少令人困惑。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_BAD_SHIFT_AMOUNT)"
      },
      {
        "real_name": "ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT",
        "display_name": "IcastQuestionableUnsignedRightShift",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无符号右移转换为短/字节",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "代码执行无符号右移，其结果是\n转换为短或字节，丢弃结果的高位。\n由于高位被丢弃，两者之间可能没有区别\n有符号和无符号的右移（取决于移位的大小）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)"
      },
      {
        "real_name": "VA_FORMAT_STRING_ARG_MISMATCH",
        "display_name": "VaFormatStringArgMismatch",
        "severity": "warning",
        "category": "convention",
        "rule_title": "格式字符串参数的数量与占位符的数量不一致",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用具有可变数量参数的格式字符串方法，\n但传递的参数数量与数量不匹配\n％格式字符串中的占位符。这可能不是什么了\n作者的意图。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_ARG_MISMATCH)"
      },
      {
        "real_name": "NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "display_name": "NpNonnullFieldNotInitializedInConstructor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "非空字段未初始化",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段被标记为非空，但不被构造函数写入。该字段可能在构造函数的其他地方被初始化，或者可能在使用之前始终被初始化。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)"
      },
      {
        "real_name": "SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH",
        "display_name": "SfDeadStoreDueToSwitchFallthrough",
        "severity": "warning",
        "category": "convention",
        "rule_title": "由于转换语句而导致的死锁存在",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "由于开关掉落，此处将覆盖存储在前一个开关盒中的值。在前一种情况结束时，你很可能忘记休息或返回。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)"
      },
      {
        "real_name": "SS_SHOULD_BE_STATIC",
        "display_name": "SsShouldBeStatic",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "未读字段：该字段应该是静态的吗？",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类包含一个实例final字段\n   被初始化为编译时的静态值。\n   考虑让这个字段是静态的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SS_SHOULD_BE_STATIC)"
      },
      {
        "real_name": "ESync_EMPTY_SYNC",
        "display_name": "EsyncEmptySync",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "空同步块",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码包含一个空的同步块：\n<PRE>\nsynchronized（）{}\n</ PRE>\n 空同步块比较微妙，难以正确使用\n比大多数人认识到的还要空白同步块\n几乎从来都不是更好的解决方案\n比较少人为的解决方案。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ESync_EMPTY_SYNC)"
      },
      {
        "real_name": "EQ_DONT_DEFINE_EQUALS_FOR_ENUM",
        "display_name": "EqDontDefineEqualsForEnum",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Covariant等于（）为枚举定义的方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个枚举，并定义了枚举的等式\n使用对象标识。为枚举定义协变等于方法\n价值是非常糟糕的做法，因为它可能会导致\n有两个不同的枚举值，它们的比较等于使用\n协变枚举法，并且在正常比较时不相等。\n不要这样做。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_DONT_DEFINE_EQUALS_FOR_ENUM)"
      },
      {
        "real_name": "FI_MISSING_SUPER_CALL",
        "display_name": "FiMissingSuperCall",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Finalizer不会调用超类终结器",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个<code> finalize（）</ code>方法不会调用它的方法\n  超类的<code> finalize（）</ code>方法。＆nbsp;所以，任何终结者\n  为超类定义的操作将不会执行。＆nbsp;\n  添加对<code> super.finalize（）</ code>的调用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_MISSING_SUPER_CALL)"
      },
      {
        "real_name": "FI_USELESS",
        "display_name": "FiUseless",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Finalizer只会调用超类终结器",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个<code> finalize（）</ code>方法唯一做的就是调用\n  这是超类的<code> finalize（）</ code>方法\n  冗余群组。删除它。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_USELESS)"
      },
      {
        "real_name": "NP_NULL_ON_SOME_PATH_EXCEPTION",
        "display_name": "NpNullOnSomePathException",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "异常路径上的方法中可能的空指针取消引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "某个例外控制路径上的参考值为null\n在这里取消引用。＆nbsp;这可能会导致<code> NullPointerException </ code>\n当代码执行时。＆nbsp;\n请注意，由于FindBugs目前不修剪不可行的异常路径，\n这可能是一个错误的警告。\n\n  另请注意，FindBugs将switch语句的默认情况视为\n是一个例外路径，因为默认情况通常是不可行的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_ON_SOME_PATH_EXCEPTION)"
      },
      {
        "real_name": "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE",
        "display_name": "NpNullOnSomePathFromReturnValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "由于调用方法的返回值，可能的空指针解引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "来自方法的返回值在没有空检查的情况下被解引用，\n并且该方法的返回值是通常应该检查的值\n为null。当代码执行时，这可能会导致<code> NullPointerException </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)"
      },
      {
        "real_name": "NP_NULL_PARAM_DEREF_NONVIRTUAL",
        "display_name": "NpNullParamDerefNonvirtual",
        "severity": "warning",
        "category": "convention",
        "rule_title": "非虚方法调用为非null参数传递null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可能为null的值将传递给非空方法参数。要么参数被注释为一个始终为非空的参数，要么分析表明它始终被解除引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_PARAM_DEREF_NONVIRTUAL)"
      },
      {
        "real_name": "NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE",
        "display_name": "NpNullOnSomePathMightBeInfeasible",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "分支上可能的空指针解引用可能不可行",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "声明的一个分支是<em>，如果被执行，</ em>保证\n空值将被解除引用，其中\n将在代码执行时生成<code> NullPointerException </ code>。\n当然，问题可能是分支或陈述是不可行的\n空指针异常无法执行;决定超出FindBugs的能力。\n由于此值先前已经针对无效进行了测试，\n这是一个确定的可能性。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE)"
      },
      {
        "real_name": "CO_ABSTRACT_SELF",
        "display_name": "CoAbstractSelf",
        "severity": "warning",
        "category": "convention",
        "rule_title": "抽象类定义了covariant compareTo（）方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类定义了<code> compareTo（）</ code>的协变版本。＆nbsp;\n  要正确覆盖。中的<code> compareTo（）</ code>方法\n  <code> Comparable </ code>接口，<code> compareTo（）</ code>的参数\n  必须有<code> java.lang.Object </ code>类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CO_ABSTRACT_SELF)"
      },
      {
        "real_name": "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS",
        "display_name": "EqCheckForOperandNotCompatibleWithThis",
        "severity": "warning",
        "category": "convention",
        "rule_title": "等于检查不兼容的操作数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个equals方法检查是否参数是一些不兼容的类型\n（即，既不是超类型也不是定义类的子类型的类\n等于方法）。例如，Foo类可能有一个equals方法\n看起来像：\n\n<PRE>\npublic boolean equals（Object o）{\n  if（o instanceof Foo）返回name.equals（（（Foo）o）.name）;\n  否则如果（o instanceof String）返回name.equals（o）;\n  否则返回false;\n</ PRE>\n\n 这被认为是不好的做法，因为它很难实现一个equals方法\n是对称的，可传递的。没有这些属性，非常出人意料的行为是可能的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)"
      },
      {
        "real_name": "FI_EXPLICIT_INVOCATION",
        "display_name": "FiExplicitInvocation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "显式调用终结器",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法包含显式调用<code> finalize（）</ code>\n  方法在对象上。＆nbsp;因为终结器方法应该是\n  执行一次，只有虚拟机，这是一个坏主意。\n 如果连接的一组对象生成器可终结，则VM将调用该对象\n最终确定所有可终结对象的方法，可能同时在不同的线程中。\n因此，在类X的finalize方法中，调用finalize是一个特别糟糕的想法\n在X引用的对象上，因为它们可能已经在单独的线程中完成。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#FI_EXPLICIT_INVOCATION)"
      },
      {
        "real_name": "NP_STORE_INTO_NONNULL_FIELD",
        "display_name": "NpStoreIntoNonnullField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "将空值存储到带注释的@Nonnull字段中",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可能为空的值存储在已注释为@Nonnull的字段中。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_STORE_INTO_NONNULL_FIELD)"
      },
      {
        "real_name": "NP_NULL_ON_SOME_PATH",
        "display_name": "NpNullOnSomePath",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可能的空指针解引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "声明的一个分支是<em>，如果被执行，</ em>保证\n空值将被解除引用，其中\n将在代码执行时生成<code> NullPointerException </ code>。\n当然，问题可能是分支或陈述是不可行的\n空指针异常无法执行;决定超出FindBugs的能力。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_ON_SOME_PATH)"
      },
      {
        "real_name": "NP_ALWAYS_NULL_EXCEPTION",
        "display_name": "NpAlwaysNullException",
        "severity": "warning",
        "category": "convention",
        "rule_title": "异常路径上方法中的空指针取消引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "在这里取消引用异常路径上为空的指针。＆nbsp;\n当代码执行时，这将导致<code> NullPointerException </ code>。＆nbsp;\n请注意，由于FindBugs目前不修剪不可行的异常路径，\n这可能是一个错误的警告。\n\n  另请注意，FindBugs将switch语句的默认情况视为\n是一个例外路径，因为默认情况通常是不可行的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_ALWAYS_NULL_EXCEPTION)"
      },
      {
        "real_name": "NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE",
        "display_name": "NpParameterMustBeNonnullButMarkedAsNullable",
        "severity": "warning",
        "category": "convention",
        "rule_title": "参数必须非空，但标记为可空",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此参数始终以非空的方式使用，\n但该参数明确注释为可空。要么使用\n参数或注释是错误的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)"
      },
      {
        "real_name": "LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE",
        "display_name": "LgLostLoggerDueToWeakReference",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "由于OpenJDK中参考文件较弱，可能会丢失记录器更改",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "OpenJDK引入了潜在的不兼容性。\n 特别是，java.util.logging.Logger行为具有\n  改变。现在不使用强引用，而是使用弱引用\n  内部。这是一个合理的改变，但不幸的是一些代码依赖\n  旧的行为 - 当改变记录器配置时，它会简单地删除记录器配置\n  记录器参考。这意味着垃圾回收器可以自由回收\n  该内存，这意味着记录器配置丢失。例如，\n考虑：\n\n\n<pre>公共静态无效initLogging（）抛出异常{\n Logger logger = Logger.getLogger（“edu.umd.cs”）;\n logger.addHandler（new FileHandler（））; //调用改变记录器配置\n logger.setUseParentHandlers（假）; //另一个电话来改变记录器配置\n} </ PRE>\n\n 记录器参考在方法结束时丢失（它不会\n转义方法），所以如果你有一个垃圾收集周期\n在调用initLogging之后，记录器配置将丢失\n（因为记录器只保留弱引用）。\n\n<pre> public static void main（String [] args）throws Exception {\n initLogging（）; //向记录器添加文件处理程序\n 的System.gc（）; //记录器配置丢失\n Logger.getLogger（“edu.umd.cs”）。info（“Some message”）;按预期方式，这不会被记录到文件中\n} </ PRE>\n Ulf Ochsenfahrt和Eric Fellheimer </ em>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)"
      },
      {
        "real_name": "IIL_ELEMENTS_GET_LENGTH_IN_LOOP",
        "display_name": "IilElementsGetLengthInLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "NodeList.getLength（）在循环中调用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在循环内调用NodeList.getLength（），NodeList由getElementsByTagName调用产生。\n这个NodeList不存储它的长度，但每次都不是以最优的方式计算它。\n考虑在循环之前将长度存储到变量中。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IIL_ELEMENTS_GET_LENGTH_IN_LOOP)"
      },
      {
        "real_name": "SBSC_USE_STRINGBUFFER_CONCATENATION",
        "display_name": "SbscUseStringbufferConcatenation",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法在循环中使用+连接字符串",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法似乎是在一个循环中使用串联构建一个字符串。\n在每次迭代中，String都被转换为一个StringBuffer / StringBuilder，\n   附加到并转换回字符串。\n   这可能导致迭代次数的成本为二次方，\n   因为不断增长的字符串会在每次迭代中重新出现。\n\n 通过使用可以获得更好的性能\n一个StringBuffer（或者Java 1.5中的StringBuilder）。\n\n  例如：\n<PRE>\n  // 这不好\n  String s =“”;\n  for（int i = 0; i＆lt; field.length; ++ i）{s = s + field [i];\n  }\n\n  // 这个更好\n  StringBuffer buf = new StringBuffer（）;\n  for（int i = 0; i＆lt; field.length; ++ i）{buf.append（field [i]）;\n  }\n  String s = buf.toString（）;\n</ PRE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SBSC_USE_STRINGBUFFER_CONCATENATION)"
      },
      {
        "real_name": "IIO_INEFFICIENT_INDEX_OF",
        "display_name": "IioInefficientIndexOf",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无效的使用String.indexOf（String）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码将一个长度为1的常量字符串传递给String.indexOf（）。\n使用String.indexOf（）的整数实现更有效。\nF。即调用<code> myString.indexOf（'。'）</ code>而不是<code> myString.indexOf（“。”）</ code>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IIO_INEFFICIENT_INDEX_OF)"
      },
      {
        "real_name": "IIL_PATTERN_COMPILE_IN_LOOP",
        "display_name": "IilPatternCompileInLoop",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法在一个循环中调用Pattern.compile",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在传递常量参数的循环内调用Pattern.compile。\n如果模式应该被多次使用，那么没有理由为每个循环迭代进行编译。\n将此调用移到循环外或甚至移到静态最终字段中。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IIL_PATTERN_COMPILE_IN_LOOP)"
      },
      {
        "real_name": "IIL_PREPARE_STATEMENT_IN_LOOP",
        "display_name": "IilPrepareStatementInLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法在循环中调用preparedStatement",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在传递常量参数的循环内调用Connection.prepareStatement。\n如果PreparedStatement应该被执行多次，那么没有理由为每个循环迭代重新创建它。\n将此呼叫转移到循环之外。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IIL_PREPARE_STATEMENT_IN_LOOP)"
      },
      {
        "real_name": "BIT_AND",
        "display_name": "BitAnd",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不兼容的位掩码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法将形式（e＆amp; C）的表达式与D进行比较，\n这总会比较不平等\n由于常数C和D的具体数值\n这可能表示逻辑错误或拼写错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_AND)"
      },
      {
        "real_name": "BIT_SIGNED_CHECK",
        "display_name": "BitSignedCheck",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "检查按位操作的符号",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法比较表达式，如\n（（event.detail＆amp; SWT.SELECTED）＆gt; 0）</ pre>。\n 使用位算术，然后与大于运算符进行比较即可\n导致意想不到的结果（当然取决于价值\nSWT.SELECTED）。如果SWT.SELECTED是一个负数，这是一个候选人\n为一个错误。即使SWT.SELECTED不是负面的，这似乎也是一种很好的做法\n使用'！= 0'而不是'＆gt; 0' 。\n\n \n鲍里斯Bokowski <em> </ em>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BIT_SIGNED_CHECK)"
      },
      {
        "real_name": "IIO_INEFFICIENT_LAST_INDEX_OF",
        "display_name": "IioInefficientLastIndexOf",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "对String.lastIndexOf（String）的低效使用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码将长度为1的常量字符串传递给String.lastIndexOf（）。\n使用String.lastIndexOf（）的整数实现更有效。\nF。即调用<code> myString.lastIndexOf（'。'）</ code>，而不是<code> myString.lastIndexOf（“。”）</ code>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IIO_INEFFICIENT_LAST_INDEX_OF)"
      },
      {
        "real_name": "IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT",
        "display_name": "IilPatternCompileInLoopIndirect",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法在循环中编译正则表达式",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在循环内创建相同的正则表达式，因此它将在每次迭代中编译。\n在循环之外使用Pattern.compile预编译这个正则表达式会更加优化。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT)"
      },
      {
        "real_name": "SQL_BAD_PREPARED_STATEMENT_ACCESS",
        "display_name": "SqlBadPreparedStatementAccess",
        "severity": "warning",
        "category": "performance",
        "rule_title": "方法尝试访问索引为0的预准备语句参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用准备好的语句的setXXX方法，\n参数索引为0.由于参数索引从索引1开始，这总是一个错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SQL_BAD_PREPARED_STATEMENT_ACCESS)"
      },
      {
        "real_name": "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",
        "display_name": "StWriteToStaticFromInstanceMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "从实例方法写入静态字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个实例方法写入一个静态字段。这很难得到\n纠正多个实例是否被操纵，\n并且通常不好的做法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD)"
      },
      {
        "real_name": "QF_QUESTIONABLE_FOR_LOOP",
        "display_name": "QfQuestionableForLoop",
        "severity": "warning",
        "category": "convention",
        "rule_title": "for-loop中复杂，细微或错误的增量",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "你确定这个循环是递增正确的变量吗？\n   看起来另一个变量正在被初始化和检查\n   通过for循环。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#QF_QUESTIONABLE_FOR_LOOP)"
      },
      {
        "real_name": "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD",
        "display_name": "UwfUnwrittenPublicOrProtectedField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "未成文的公共或受保护的领域",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "没有人看到这个公共/受保护的字段。它的所有读取将返回默认值\n值。检查错误（是否应该初始化？），或者如果无用，请将其删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD)"
      },
      {
        "real_name": "UWF_UNWRITTEN_FIELD",
        "display_name": "UwfUnwrittenField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "未成文的领域",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段永远不会写入。＆nbsp;它的所有读取将返回默认值\n值。检查错误（是否应该初始化？），或者如果无用，请将其删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_UNWRITTEN_FIELD)"
      },
      {
        "real_name": "SE_BAD_FIELD",
        "display_name": "SeBadField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可序列化类中的非暂时性不可序列化实例字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个Serializable类定义了一个非原始的实例字段，它既不是瞬态的，\nSerializable或<code> java.lang.Object </ code>，并且看起来并不实现\n<code> Externalizable </ code>接口或\n<code> readObject（）</ code>和<code> writeObject（）</ code>方法。＆nbsp;\n如果不可序列化，则此类的对象将不会正确反序列化\n对象存储在此字段中。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_BAD_FIELD)"
      },
      {
        "real_name": "UWF_NULL_FIELD",
        "display_name": "UwfNullField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "字段只能设置为空",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "所有写入此字段的值都是常量值null，因此\n该字段的所有读取都将返回空值。\n检查错误，如果无用，请将其删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_NULL_FIELD)"
      },
      {
        "real_name": "URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD",
        "display_name": "UrfUnreadPublicOrProtectedField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "未读的公共/受保护字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段永远不会被读取。＆nbsp;\n该字段是公开的或受保护的，因此它可能被用于未被视为分析的一部分的类。如果不，\n考虑从课堂上删除它。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD)"
      },
      {
        "real_name": "UUF_UNUSED_FIELD",
        "display_name": "UufUnusedField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "未使用的字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此字段从未使用。＆nbsp;考虑从班级中删除它。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UUF_UNUSED_FIELD)"
      },
      {
        "real_name": "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD",
        "display_name": "UufUnusedPublicOrProtectedField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "未使用的公共或受保护的字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此字段从未使用。＆nbsp;\n该字段是公开的或受保护的，因此它可能被用于未被视为分析的一部分的类。如果不，\n考虑从课堂上删除它。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD)"
      },
      {
        "real_name": "URF_UNREAD_FIELD",
        "display_name": "UrfUnreadField",
        "severity": "warning",
        "category": "convention",
        "rule_title": "未读字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段永远不会被读取。＆nbsp;考虑从班级中删除它。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#URF_UNREAD_FIELD)"
      },
      {
        "real_name": "SE_BAD_FIELD_INNER_CLASS",
        "display_name": "SeBadFieldInnerClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不可序列化的类有一个可序列化的内部类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个Serializable类是一个不可序列化的类的内部类。\n因此，尝试序列化它也会尝试关联外部的实例\n与它关联的类，从而导致运行时错误。\n\n 如果可能的话，让内部类成为静态内部类应该解决这个问题\n问题。使外部类可序列化也可能工作，但那会\n意味着序列化内部类的一个实例总是会序列化实例\n外面的班级，这往往不是你真正想要的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_BAD_FIELD_INNER_CLASS)"
      },
      {
        "real_name": "SE_NONFINAL_SERIALVERSIONID",
        "display_name": "SeNonfinalSerialversionid",
        "severity": "warning",
        "category": "convention",
        "rule_title": "serialVersionUID不是最终的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类定义了一个不是final的<code> serialVersionUID </ code>字段。＆nbsp;\n  该领域应该是最终的\n   如果打算说明的话\n   用于序列化的版本UID。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_NONFINAL_SERIALVERSIONID)"
      },
      {
        "real_name": "SE_NONLONG_SERIALVERSIONID",
        "display_name": "SeNonlongSerialversionid",
        "severity": "warning",
        "category": "convention",
        "rule_title": "serialVersionUID不长",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类定义了一个不长的<code> serialVersionUID </ code>字段。＆nbsp;\n  该领域应该很长\n   如果打算说明的话\n   用于序列化的版本UID。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_NONLONG_SERIALVERSIONID)"
      },
      {
        "real_name": "RS_READOBJECT_SYNC",
        "display_name": "RsReadobjectSync",
        "severity": "warning",
        "category": "convention",
        "rule_title": "类的readObject（）方法是同步的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个可序列化的类定义了一个<code> readObject（）</ code>\n  。同步＆NBSP;根据定义，通过反序列化创建一个对象\n  只能由一个线程访问，因此不需要\n  要同步<code> readObject（）</ code>。＆nbsp;如果<code> readObject（）</ code>\n  方法本身导致对象变为对另一个线程可见，\n  这是一个非常可疑的编码风格的例子。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RS_READOBJECT_SYNC)"
      },
      {
        "real_name": "WS_WRITEOBJECT_SYNC",
        "display_name": "WsWriteobjectSync",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类的writeObject（）方法是同步的，但没有别的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类有一个同步的<code> writeObject（）</ code>方法;\n  但是，没有其他类的方法是同步的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#WS_WRITEOBJECT_SYNC)"
      },
      {
        "real_name": "SE_INNER_CLASS",
        "display_name": "SeInnerClass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可序列化的内部类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个Serializable类是一个内部类。任何尝试序列化\n它也会序列化关联的外部实例。外部实例是可序列化的，\n所以这不会失败，但它可能序列化比预期更多的数据。\n如果可能，使内部类为静态内部类（也称为嵌套类）应该解决这个问题\n问题。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_INNER_CLASS)"
      },
      {
        "real_name": "SE_BAD_FIELD_STORE",
        "display_name": "SeBadFieldStore",
        "severity": "warning",
        "category": "convention",
        "rule_title": "不可序列化的值存储在可序列化类的实例字段中",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "不可序列化的值被存储到非瞬态字段中\n一个可序列化的类。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_BAD_FIELD_STORE)"
      },
      {
        "real_name": "SE_NONSTATIC_SERIALVERSIONID",
        "display_name": "SeNonstaticSerialversionid",
        "severity": "warning",
        "category": "convention",
        "rule_title": "serialVersionUID不是静态的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个非静态的<code> serialVersionUID </ code>字段。＆nbsp;\n  该字段应该是静态的\n   如果打算说明的话\n   用于序列化的版本UID。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SE_NONSTATIC_SERIALVERSIONID)"
      },
      {
        "real_name": "NP_IMMEDIATE_DEREFERENCE_OF_READLINE",
        "display_name": "NpImmediateDereferenceOfReadline",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "立即解引用readLine（）的结果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用readLine（）的结果立即解除引用。如果没有更多的文字行\nreadLine（）将返回null和解引用，它将生成一个空指针异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_IMMEDIATE_DEREFERENCE_OF_READLINE)"
      },
      {
        "real_name": "NP_UNWRITTEN_FIELD",
        "display_name": "NpUnwrittenField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "阅读未成文的领域",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该程序正在取消引用一个字段，该字段似乎没有写入非空值。\n除非通过分析未发现的某种机制来初始化该字段，\n取消引用此值将生成空指针异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_UNWRITTEN_FIELD)"
      },
      {
        "real_name": "NP_LOAD_OF_KNOWN_NULL_VALUE",
        "display_name": "NpLoadOfKnownNullValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "加载已知的空值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "由于较早，已知此时引用的变量为空\n   检查null。虽然这是有效的，但这可能是一个错误（也许是你\n打算引用一个不同的变量，或者也许是更早的检查，看看是否\n变量为空应该是一个检查，看看它是否为非空）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_LOAD_OF_KNOWN_NULL_VALUE)"
      },
      {
        "real_name": "NP_DEREFERENCE_OF_READLINE_VALUE",
        "display_name": "NpDereferenceOfReadlineValue",
        "severity": "warning",
        "category": "convention",
        "rule_title": "readLine（）的结果取消引用，而没有nullcheck",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用readLine（）的结果被解引用而不检查结果是否为空。如果没有更多的文字行\nreadLine（）将返回null和解引用，它将生成一个空指针异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_DEREFERENCE_OF_READLINE_VALUE)"
      },
      {
        "real_name": "UC_USELESS_OBJECT_STACK",
        "display_name": "UcUselessObjectStack",
        "severity": "warning",
        "category": "performance",
        "rule_title": "在堆栈上创建无用对象",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "创建该对象只是为了执行一些没有任何副作用的修改。\n可能还有别的意思，或者该对象可以被删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UC_USELESS_OBJECT_STACK)"
      },
      {
        "real_name": "RANGE_ARRAY_OFFSET",
        "display_name": "RangeArrayOffset",
        "severity": "warning",
        "category": "performance",
        "rule_title": "数组偏移量超出范围",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用数组参数和偏移量参数调用方法，但偏移量超出范围。这将在运行时导致IndexOutOfBoundsException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RANGE_ARRAY_OFFSET)"
      },
      {
        "real_name": "RANGE_ARRAY_INDEX",
        "display_name": "RangeArrayIndex",
        "severity": "warning",
        "category": "performance",
        "rule_title": "数组索引超出范围",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "执行数组操作，但数组索引超出范围，这将在运行时导致ArrayIndexOutOfBoundsException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RANGE_ARRAY_INDEX)"
      },
      {
        "real_name": "UC_USELESS_OBJECT",
        "display_name": "UcUselessObject",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无用的对象创建",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "我们的分析表明这个对象是无用的。\n它的创建和修改，但其价值永远不会超出方法或产生任何副作用。\n要么出现错误，要么使用对象，要么可以将其删除。\n 这种分析很少产生误报。常见的假阳性病例包括：\n  - 这个对象用来隐式抛出一些模糊的异常。\n  - 这个对象用作存根来概括代码。\n  - 该对象用于保存对弱/软引用对象的强引用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UC_USELESS_OBJECT)"
      },
      {
        "real_name": "ISC_INSTANTIATE_STATIC_CLASS",
        "display_name": "IscInstantiateStaticClass",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不需要实例化只提供静态方法的类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此类将分配一个基于仅提供静态方法的类的对象。这个对象\n不需要创建，直接使用类名称作为限定符访问静态方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#ISC_INSTANTIATE_STATIC_CLASS)"
      },
      {
        "real_name": "MS_MUTABLE_ARRAY",
        "display_name": "MsMutableArray",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Field是一个可变数组",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "最终的静态字段引用一个数组\n   并可以通过恶意代码或其他软件包意外访问。\n   该代码可以自由修改数组的内容。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_MUTABLE_ARRAY)"
      },
      {
        "real_name": "NOISE_METHOD_CALL",
        "display_name": "NoiseMethodCall",
        "severity": "warning",
        "category": "convention",
        "rule_title": "关于方法调用的虚假警告",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "虚假警告。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NOISE_METHOD_CALL)"
      },
      {
        "real_name": "IS_INCONSISTENT_SYNC",
        "display_name": "IsInconsistentSync",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不一致的同步",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类的字段似乎与尊重不一致\n  进行同步。＆nbsp;这个错误报告表明错误模式检测器\n  判断\n  \n  <UL>\n  <li>该类包含锁定和解锁访问的混合，</ li>\n  <li>至少有一个锁定的访问是由该类自己的一个方法执行的，</ li>\n  <li>未同步的字段访问次数（读取和写入次数）不超过所有访问次数的三分之一，写入次数是读取次数的两倍。</ li>\n  </ UL>\n\n    与此错误模式相匹配的典型错误是忘记同步\n  类中的一种方法是为了线程安全的。\n\n    请注意，该探测器存在各种不准确的来源;\n  例如，检测器不能静态检测其中的所有情况\n  锁住了。＆nbsp;此外，即使探测器准确无误\n  区分锁定与未锁定的访问，所讨论的代码可能仍然存在\n  是正确的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IS_INCONSISTENT_SYNC)"
      },
      {
        "real_name": "WMI_WRONG_MAP_ITERATOR",
        "display_name": "WmiWrongMapIterator",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无效的使用keySet迭代器而不是entrySet迭代器",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用从中检索的键来访问Map条目的值\n一个keySet迭代器。在地图的entrySet上使用迭代器会更有效率，以避免使用迭代器\nMap.get（键）查找。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#WMI_WRONG_MAP_ITERATOR)"
      },
      {
        "real_name": "MF_CLASS_MASKS_FIELD",
        "display_name": "MfClassMasksField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "类定义掩盖超类字段的字段",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个与可见性名称相同的字段\n超类中的实例字段。这令人困惑，而且\n如果方法更新或访问其中的一个，则可能会指示错误\n当他们想要另一个领域时。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MF_CLASS_MASKS_FIELD)"
      },
      {
        "real_name": "EQ_DOESNT_OVERRIDE_EQUALS",
        "display_name": "EqDoesntOverrideEquals",
        "severity": "warning",
        "category": "security",
        "rule_title": "类不会覆盖超类中的equals",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类扩展了一个类，它定义了一个equals方法并添加了字段，但没有\n自己定义一个equals方法。因此，这个阶级的平等将会\n忽略子类的标识和添加的字段。确保这是预期的，\n并且你不需要重写equals方法。即使你不需要重写\n等于方法，无论如何考虑覆盖它来记录事实\n子类的equals方法只返回结果\n调用super.equals（o）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_DOESNT_OVERRIDE_EQUALS)"
      },
      {
        "real_name": "EQ_SELF_NO_OBJECT",
        "display_name": "EqSelfNoObject",
        "severity": "warning",
        "category": "security",
        "rule_title": "协变等于（）方法定义",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类定义了一个<code> equals（）</ code>的协变版本。＆nbsp;\n  要正确覆盖<code>中的equals（）</ code>方法\n  <code> java.lang.Object </ code>，<code> equals（）</ code>的参数\n  必须有<code> java.lang.Object </ code>类型。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#EQ_SELF_NO_OBJECT)"
      },
      {
        "real_name": "SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW",
        "display_name": "SfDeadStoreDueToSwitchFallthroughToThrow",
        "severity": "warning",
        "category": "convention",
        "rule_title": "由于转换语句而导致的死锁存储丢失",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "存储在前一个开关情况下的值在此处被忽略，因为开关会落入发生异常的位置。在前一种情况结束时，你很可能忘记休息或返回。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)"
      },
      {
        "real_name": "NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD",
        "display_name": "NpUnwrittenPublicOrProtectedField",
        "severity": "warning",
        "category": "performance",
        "rule_title": "阅读未成文的公共或受保护领域",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该计划正在取消引用公众或受保护的内容\n字段似乎没有写入非空值的字段。\n除非通过分析未发现的某种机制来初始化该字段，\n取消引用此值将生成空指针异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD)"
      },
      {
        "real_name": "STATIC_ACTIVITY",
        "display_name": "STATIC_ACTIVITY",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STATIC_ACTIVITY)"
      },
      {
        "real_name": "STATIC_BITMAP",
        "display_name": "STATIC_BITMAP",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#STATIC_BITMAP)"
      },
      {
        "real_name": "DMI_EMPTY_DB_PASSWORD",
        "display_name": "DmiEmptyDbPassword",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "清空数据库密码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码使用空白或空密码创建数据库连接。这表明数据库不受密码保护。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_EMPTY_DB_PASSWORD)"
      },
      {
        "real_name": "DMI_CONSTANT_DB_PASSWORD",
        "display_name": "DmiConstantDbPassword",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "硬编码常数数据库密码",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码使用硬编码的常量密码创建数据库连接。任何有权访问源代码或编译代码的人都可以轻松获知密码。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_CONSTANT_DB_PASSWORD)"
      },
      {
        "real_name": "DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR",
        "display_name": "DmiFutileAttemptToChangeMaxpoolSizeOfScheduledThreadPoolExecutor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "徒劳地尝试更改ScheduledThreadPoolExecutor的最大池大小",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "（<a href=\"http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html\"> Javadoc </a>）\n虽然ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，但一些继承的调整方法对它没有用处。特别是，由于它充当使用corePoolSize线程和无限队列的固定大小的池，因此对maximumPoolSize的调整无效。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR)"
      },
      {
        "real_name": "DMI_UNSUPPORTED_METHOD",
        "display_name": "DmiUnsupportedMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "调用不支持的方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用的所有目标都抛出UnsupportedOperationException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_UNSUPPORTED_METHOD)"
      },
      {
        "real_name": "UM_UNNECESSARY_MATH",
        "display_name": "UmUnnecessaryMath",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法在一个常量值上调用静态数学类方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法使用来自java.lang.Math的静态方法，其值为常量。这个方法\n结果在这种情况下，可以静态确定，并且更快，有时更准确\n只是使用常量。检测到的方法是：\n\n<表>\n<TR>\n   <th>方法</ th> <th>参数</ th>\n</ TR>\n<TR>\n   <td> abs </ td> <td> -any  -  </ td>\n</ TR>\n<TR>\n   <td> acos </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> asin </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> atan </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> atan2 </ td> <td> 0.0 </ td>\n</ TR>\n<TR>\n   <td> cbrt </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> ceil </ td> <td> -any  -  </ td>\n</ TR>\n<TR>\n   <td> cos </ td> <0.0> </ td>\n</ TR>\n<TR>\n   <td> cosh </ td> <td> 0.0 </ td>\n</ TR>\n<TR>\n   <td> exp </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> expm1 </ td> <0.0> 0.0 </ td>\n</ TR>\n<TR>\n   <td> floor </ td> <td> -any  -  </ td>\n</ TR>\n<TR>\n   <td> log </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> log10 </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> rint </ td> <td> -any  -  </ td>\n</ TR>\n<TR>\n   <td> round </ td> <td> -any  -  </ td>\n</ TR>\n<TR>\n   <td> sin </ td> <0.0> </ td>\n</ TR>\n<TR>\n   <td> sinh </ td> <0.0> </ td>\n</ TR>\n<TR>\n   <td> sqrt </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> tan </ td> <td> 0.0 </ td>\n</ TR>\n<TR>\n   <td> tanh </ td> <td> 0.0 </ td>\n</ TR>\n<TR>\n   <td> toDegrees </ td> <td> 0.0或1.0 </ td>\n</ TR>\n<TR>\n   <td> toRadians </ td> <td> 0.0 </ td>\n</ TR>\n</ TABLE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UM_UNNECESSARY_MATH)"
      },
      {
        "real_name": "CD_CIRCULAR_DEPENDENCY",
        "display_name": "CdCircularDependency",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "测试类之间的循环依赖关系",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该类与其他类具有循环依赖关系。这使得构建这些类很困难，因为每个类都依赖于另一个来正确构建。考虑使用接口来打破硬依赖。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#CD_CIRCULAR_DEPENDENCY)"
      },
      {
        "real_name": "XFB_XML_FACTORY_BYPASS",
        "display_name": "XfbXmlFactoryBypass",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法直接分配一个特定的xml接口实现",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法分配一个xml接口的特定实现。最好使用提供的工厂类来创建这些对象，以便可以在运行时更改实现。请参阅<ul> <li> javax.xml.parsers.DocumentBuilderFactory </ li> <li> javax.xml.parsers.SAXParserFactory </ li> <li> javax.xml.transform.TransformerFactory </ li> <li> org .w3c.dom.Document.create <i> XXXX </ i> </ li> </ ul>了解详情。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#XFB_XML_FACTORY_BYPASS)"
      },
      {
        "real_name": "USM_USELESS_SUBCLASS_METHOD",
        "display_name": "UsmUselessSubclassMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "方法不必要地委托给父类方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这种派生的方法只是调用相同的超类方法传入所接收的确切参数。该方法可以被删除，因为它没有提供额外的值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#USM_USELESS_SUBCLASS_METHOD)"
      },
      {
        "real_name": "XSS_REQUEST_PARAMETER_TO_SEND_ERROR",
        "display_name": "XssRequestParameterToSendError",
        "severity": "warning",
        "category": "convention",
        "rule_title": "Servlet反映了错误页面中的跨站点脚本漏洞",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码直接将HTTP参数写入服务器错误页面（使用HttpServletResponse.sendError）。回应这个不受信任的输入允许\n为反映跨站点脚本\n漏洞。请参阅<a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\"> http://en.wikipedia.org/wiki/Cross-site_scripting </a>\n了解更多信息。\n FindBugs只查找最明显，最明显的跨站点脚本案例。\n如果FindBugs找到<em>任何<em>，那么你几乎可以确定</ em>有更多跨站点脚本\nFindBugs不报告的漏洞。如果你担心跨站点脚本，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#XSS_REQUEST_PARAMETER_TO_SEND_ERROR)"
      },
      {
        "real_name": "UNKNOWN",
        "display_name": "Unknown",
        "severity": "warning",
        "category": "convention",
        "rule_title": "未知的错误模式",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "记录了一条警告，但findbugs找不到这个错误模式的描述\n所以不能描述它。这只会发生在FindBugs或其配置中的一个bug中，\n或者如果使用插件生成分析，但该插件当前未加载。\n。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UNKNOWN)"
      },
      {
        "real_name": "AM_CREATES_EMPTY_ZIP_FILE_ENTRY",
        "display_name": "AmCreatesEmptyZipFileEntry",
        "severity": "warning",
        "category": "convention",
        "rule_title": "创建一个空的zip文件条目",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码立即调用<code> putNextEntry（）</ code>\n然后调用<code> closeEntry（）</ code>。结果\n在一个空的ZipFile条目中。条目的内容\n应该写入调用之间的ZipFile\n<code> putNextEntry（）</ code>和\n<代码> closeEntry（）</代码>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#AM_CREATES_EMPTY_ZIP_FILE_ENTRY)"
      },
      {
        "real_name": "AM_CREATES_EMPTY_JAR_FILE_ENTRY",
        "display_name": "AmCreatesEmptyJarFileEntry",
        "severity": "warning",
        "category": "convention",
        "rule_title": "创建一个空的jar文件条目",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码立即调用<code> putNextEntry（）</ code>\n然后调用<code> closeEntry（）</ code>。结果\n在一个空的JarFile条目中。条目的内容\n应该在调用之间写入JarFile\n<code> putNextEntry（）</ code>和\n<代码> closeEntry（）</代码>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#AM_CREATES_EMPTY_JAR_FILE_ENTRY)"
      },
      {
        "real_name": "THREAD_MANAGER_ON_THREAD",
        "display_name": "THREAD_MANAGER_ON_THREAD",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#THREAD_MANAGER_ON_THREAD)"
      },
      {
        "real_name": "MS_FINAL_PKGPROTECT",
        "display_name": "MsFinalPkgprotect",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "现场应该是最终的和包装保护的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可变的静态字段可能会被恶意代码或其他软件包意外更改。该领域可以被包装保护和/或作出最终决定\n   以避免此漏洞。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_FINAL_PKGPROTECT)"
      },
      {
        "real_name": "MS_OOI_PKGPROTECT",
        "display_name": "MsOoiPkgprotect",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "应该将字段移出界面并保护包装",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "最后的静态字段是\n在一个接口中定义引用一个mutable\n   对象，如数组或哈希表。\n   这个可变对象可以\n   被恶意代码或其他软件包意外更改。\n   为了解决这个问题，该领域需要转移到一个班级\n   并保护包装\n   以避免此漏洞。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_OOI_PKGPROTECT)"
      },
      {
        "real_name": "TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK",
        "display_name": "TqMaybeSourceValueReachesNeverSink",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "可能携带类型限定符的值始终以禁止具有该类型限定符的方式使用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "被注释为可能性的值是由类型限定符表示的值的实例，并且该值可以保证以禁止该类型限定符所表示的值的方式使用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK)"
      },
      {
        "real_name": "TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK",
        "display_name": "TqMaybeSourceValueReachesAlwaysSink",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "可能不带有类型限定符的值始终以需要该类型限定符的方式使用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "被注释为可能性的值不是由类型限定符表示的值的实例，并且该值被保证以需要由该类型限定符表示的值的方式使用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK)"
      },
      {
        "real_name": "OBL_UNSATISFIED_OBLIGATION",
        "display_name": "OblUnsatisfiedObligation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法可能无法清理流或资源",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法可能无法清理（关闭，处置）流，数据库对象或其他需要显式清理操作的资源。\n               通常，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前清理流或资源。\n               此错误模式与OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式基本相同，但是基于不同的（并希望更好）静态分析技术。我们感兴趣的是获得有关这种错误模式的有用性的反馈。发送反馈意见：<ul> <li>发送邮件至findbugs@cs.umd.edu </ li> <li>提交错误报告：<a href =“http://findbugs.sourceforge.net/reportingBugs .html“> http://findbugs.sourceforge.net/reportingBugs.html </a> </ li> </ ul>\n               特别是，这种错误模式的假阳性抑制启发式方法还没有得到广泛的调整，所以关于误报的报告对我们很有帮助。\n               关于分析技术的描述，请参阅Weimer和Necula，“发现并防止运行时错误处理错误”</ i>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#OBL_UNSATISFIED_OBLIGATION)"
      },
      {
        "real_name": "WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL",
        "display_name": "WlUsingGetclassRatherThanClassLiteral",
        "severity": "warning",
        "category": "convention",
        "rule_title": "在getClass上进行同步而不是类文字",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个实例方法在<code> this.getClass（）</ code>上进行同步。如果这个类是子类的，子类将在子类的类对象上进行同步，这不可能是预期的。例如，考虑来自java.awt.Label的这段代码：<pre> private static final String base =“label”; private static int nameCounter = 0; String constructComponentName（）{synchronized（getClass（））{return base + nameCounter ++; }} </ pre> <code> Label </ code>的子类不会在同一个子类上同步，从而产生一个datarace。相反，这段代码应该在<code> Label.class </ code> <pre> private static final base =“label”上同步。 private static int nameCounter = 0; String constructComponentName（）{synchronized（Label.class）{return base + nameCounter ++; }} </ pre>由Jason Mehrens贡献的Bug模式\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)"
      },
      {
        "real_name": "TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK",
        "display_name": "TqExplicitUnknownSourceValueReachesAlwaysSink",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "具有类型限定符所需的值，但标记为未知",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "值的使用方式要求它始终是一个由类型限定符表示的值，但有一个明确的注释表明不知道该值需要具有该类型限定符的位置。用法或注释不正确。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK)"
      },
      {
        "real_name": "IO_APPENDING_TO_OBJECT_OUTPUT_STREAM",
        "display_name": "IoAppendingToObjectOutputStream",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "注定尝试追加到对象输出流",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码以追加模式打开文件，然后将结果封装在对象输出流中。这将不允许您追加到存储在文件中的现有对象输出流。如果您希望能够附加到对象输出流，则需要保持对象输出流处于打开状态。在追加模式下打开文件和编写对象输出流的唯一情况是，如果在读取文件时打算以随机访问模式打开文件并寻找附加文件开始处的字节偏移量。\n       TODO：例子。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)"
      },
      {
        "real_name": "TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK",
        "display_name": "TqExplicitUnknownSourceValueReachesNeverSink",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不具有类型限定符的值，但标记为未知",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "值的使用方式要求它永远不会是由类型限定符表示的值，但有一个明确的注释表明不知道该值在何处被禁止具有该类型限定符。用法或注释不正确。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK)"
      },
      {
        "real_name": "TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED",
        "display_name": "TqNeverValueUsedWhereAlwaysRequired",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "值注释为从不带有在需要携带该限定符的值时使用的类型限定符",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "指定为不携带类型限定符注释的值保证在要求该值携带该注释的位置或位置消耗。\n           更确切地说，使用类型限定符注释的值指定when = NEVER将保证达到某个用途，或者在相同类型限定符指定when = ALWAYS时使用该值。\n           TODO：例子\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED)"
      },
      {
        "real_name": "RC_REF_COMPARISON_BAD_PRACTICE",
        "display_name": "RcRefComparisonBadPractice",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可疑的参考比较常数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法使用==或！=运算符将参考值与常量进行比较，\n其中正确比较这种类型实例的方式通常是\n用equals（）方法。\n有可能创建相同的独立实例，但不会像==那样比较\n他们是不同的对象。\n通常应该的类的例子\n不能通过引用来比较java.lang.Integer，java.lang.Float等\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RC_REF_COMPARISON_BAD_PRACTICE)"
      },
      {
        "real_name": "RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN",
        "display_name": "RcRefComparisonBadPracticeBoolean",
        "severity": "warning",
        "category": "convention",
        "rule_title": "布尔值的可疑引用比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法使用==或！=运算符比较两个布尔值。\n通常，只有两个布尔值（Boolean.TRUE和Boolean.FALSE），\n但可以使用<code> new Boolean（b）</ code>创建其他布尔对象\n构造函数。最好避免这样的对象，但如果它们确实存在，\n那么使用==或！=来检查布尔对象是否相等会给出结果\n比你使用的<code> .equals（...）</ code>不同\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)"
      },
      {
        "real_name": "RV_RETURN_VALUE_IGNORED_INFERRED",
        "display_name": "RvReturnValueIgnoredInferred",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法忽略返回值，这是行吗？",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码调用一个方法并忽略返回值。返回值\n与该方法被调用的类型相同，从我们的分析中可以看出\n像返回值可能是重要的（例如，像忽略\n返回值为<code> String.toLowerCase（）</ code>）。\n\n 我们猜测，忽略返回值可能仅仅是一个糟糕的主意\n对方法的主体进行简单的分析。您可以使用@CheckReturnValue注释\n指示FindBugs是否忽略此方法的返回值\n是重要的或可接受的。\n\n 请仔细研究以确定是否可以忽略返回值。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_RETURN_VALUE_IGNORED_INFERRED)"
      },
      {
        "real_name": "RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT",
        "display_name": "RvReturnValueIgnoredNoSideEffect",
        "severity": "warning",
        "category": "convention",
        "rule_title": "无副作用的方法的返回值被忽略",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该代码调用一个方法并忽略返回值。但是我们的分析表明\n该方法（包括其在子类中的实现，如果有的话）不会产生任何影响\n除了返回值。因此这个呼叫可以被删除。\n\n 我们尽量减少误报，但在某些情况下，这种警告可能是错误的。\n常见的假阳性病例包括：\n  - 该方法被设计为被覆盖，并在超出分析范围的其他项目中产生副作用。\n  - 调用该方法来触发可能有副作用的类加载。\n  - 该方法被称为只是为了得到一些例外。\n 如果您认为我们的假设不正确，则可以使用@CheckReturnValue注释\n指示FindBugs忽略此方法的返回值是可以接受的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT)"
      },
      {
        "real_name": "RV_RETURN_VALUE_IGNORED",
        "display_name": "RvReturnValueIgnored",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法忽略返回值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "应该检查这个方法的返回值。一个共同点\n这个警告的原因是调用一个不可变对象的方法，\n认为它更新了对象。例如，在下面的代码中\n分段，\n<BLOCKQUOTE>\n<PRE>\nString dateString = getHeaderField（name）;\ndateString.trim（）;\n</ PRE>\n</ BLOCKQUOTE>\n 程序员似乎认为trim（）方法会更新\n由dateString引用的String。但由于字符串是不可变的，trim（）\n函数返回一个新的字符串值，在这里被忽略。代码\n应该纠正为：\n<BLOCKQUOTE>\n<PRE>\nString dateString = getHeaderField（name）;\ndateString = dateString.trim（）;\n</ PRE>\n</ BLOCKQUOTE>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_RETURN_VALUE_IGNORED)"
      },
      {
        "real_name": "RV_RETURN_VALUE_IGNORED_BAD_PRACTICE",
        "display_name": "RvReturnValueIgnoredBadPractice",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法忽略了异常的返回值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法返回未检查的值。应该检查返回值\n因为它可以指示不寻常或意外的功能执行。对于\n例如，<code> File.delete（）</ code>方法返回false\n如果文件无法成功删除（而不是\n抛出一个例外）。\n如果你没有检查结果，你不会注意到方法的调用\n通过返回非典型返回值来标示意外行为。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)"
      },
      {
        "real_name": "RV_DONT_JUST_NULL_CHECK_READLINE",
        "display_name": "RvDontJustNullCheckReadline",
        "severity": "warning",
        "category": "convention",
        "rule_title": "方法在检查它是否非空之后丢弃readLine的结果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "readLine返回的值在检查返回值后被丢弃\n值非空。在几乎所有情况下，如果结果非空，你会想要\n使用该非空值。再次调用readLine会给你一个不同的路线。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_DONT_JUST_NULL_CHECK_READLINE)"
      },
      {
        "real_name": "MS_MUTABLE_HASHTABLE",
        "display_name": "MsMutableHashtable",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Field是一个可变的Hashtable",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "最终的静态字段引用一个Hashtable\n   并可以通过恶意代码或其他软件包意外访问。\n   此代码可以自由修改Hashtable的内容。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_MUTABLE_HASHTABLE)"
      },
      {
        "real_name": "NP_BOOLEAN_RETURN_NULL",
        "display_name": "NpBooleanReturnNull",
        "severity": "warning",
        "category": "convention",
        "rule_title": "使用布尔返回类型的方法返回显式为null",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "返回Boolean.TRUE，Boolean.FALSE或null的方法是一个等待发生的事故。可以调用此方法，就像它返回布尔类型的值一样，编译器将插入布尔值的自动拆箱。如果返回空值，这将导致NullPointerException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NP_BOOLEAN_RETURN_NULL)"
      },
      {
        "real_name": "MWN_MISMATCHED_NOTIFY",
        "display_name": "MwnMismatchedNotify",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "不匹配的通知（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用Object.notify（）或Object.notifyAll（），但没有明显地持有锁\n在物件上。＆nbsp;在没有锁定的情况下调用notify（）或notifyAll（）会导致\n抛出一个<code> IllegalMonitorStateException </ code>。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MWN_MISMATCHED_NOTIFY)"
      },
      {
        "real_name": "SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD",
        "display_name": "SaLocalSelfAssignmentInsteadOfField",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "本地分配，而不是分配给现场",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法包含一个局部变量的自赋值，并在那里\n是一个具有相同名称的字段。\n任务似乎已经;例如\n<PRE>\n  int foo;\n  public void setFoo（int foo）{foo = foo;\n  }\n</ PRE>\n 这项任务毫无用处。你的意思是分配给现场吗？\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD)"
      },
      {
        "real_name": "BOA_BADLY_OVERRIDDEN_ADAPTER",
        "display_name": "BoaBadlyOverriddenAdapter",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "错误地覆盖超类适配器中实现的方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法覆盖在父类中找到的方法，其中该类是实现的Adapter\n一个在java.awt.event或javax.swing.event包中定义的侦听器。因此，这种方法不会\n当事件发生时被调用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#BOA_BADLY_OVERRIDDEN_ADAPTER)"
      },
      {
        "real_name": "VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN",
        "display_name": "VaFormatStringBadConversionToBoolean",
        "severity": "warning",
        "category": "performance",
        "rule_title": "使用％b格式说明符格式化的非布尔参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "不是布尔类型的参数正在使用％b格式说明符进行格式化。这不会抛出一个\n例外;相反，它将为任何非空值打印true，并为false打印false。\n格式字符串的这种特性很奇怪，可能并不是你想要的。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)"
      },
      {
        "real_name": "TESTING2",
        "display_name": "Testing2",
        "severity": "warning",
        "category": "convention",
        "rule_title": "测试2",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个错误模式只是由新的，不完全实现的\n臭虫探测器。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#TESTING2)"
      },
      {
        "real_name": "IJU_NO_TESTS",
        "display_name": "IjuNoTests",
        "severity": "warning",
        "category": "performance",
        "rule_title": "TestCase没有测试",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Class是一个JUnit TestCase，但没有实现任何测试方法\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#IJU_NO_TESTS)"
      },
      {
        "real_name": "SIC_INNER_SHOULD_BE_STATIC",
        "display_name": "SicInnerShouldBeStatic",
        "severity": "warning",
        "category": "performance",
        "rule_title": "应该是一个静态的内部类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类是一个内部类，但不使用它的嵌入式引用\n  到创建它的对象。＆nbsp;这个引用使得这些实例\n  的类更大，并且可以保持对创建者对象的引用\n  存活时间超过必要时间。＆nbsp;如果可能的话，班级应该是\n   制成静态。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SIC_INNER_SHOULD_BE_STATIC)"
      },
      {
        "real_name": "SIC_INNER_SHOULD_BE_STATIC_ANON",
        "display_name": "SicInnerShouldBeStaticAnon",
        "severity": "warning",
        "category": "convention",
        "rule_title": "可以重构为一个命名的静态内部类",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类是一个内部类，但不使用它的嵌入式引用\n  到创建它的对象。＆nbsp;这个引用使得这些实例\n  的类更大，并且可以保持对创建者对象的引用\n  存活时间超过必要时间。＆nbsp;如果可能的话，班级应该是\n  制作成一个<em>静态</ em>内部类。由于匿名内在\n类不能被标记为静态，这样做需要重构\n内部类，以便它是一个命名的内部类。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SIC_INNER_SHOULD_BE_STATIC_ANON)"
      },
      {
        "real_name": "MS_SHOULD_BE_FINAL",
        "display_name": "MsShouldBeFinal",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "球场不是最终的，但应该是",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个静态字段公开但不是最终的，而且\n可能会被恶意代码或其他软件包意外更改。该字段可以做成最终的以避免此漏洞。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_SHOULD_BE_FINAL)"
      },
      {
        "real_name": "MS_PKGPROTECT",
        "display_name": "MsPkgprotect",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "领域应该被包装保护",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "可变的静态字段可能会被恶意代码或更改\n   意外地。\n   该字段可以被封装保护以避免\n   这个漏洞。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_PKGPROTECT)"
      },
      {
        "real_name": "DMI_VACUOUS_SELF_COLLECTION_CALL",
        "display_name": "DmiVacuousSelfCollectionCall",
        "severity": "warning",
        "category": "convention",
        "rule_title": "对收藏的肯定呼叫",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个电话没有意义。对于任何集合<code> c </ code>，调用<code> c.containsAll（c）</ code>应该\n始终为真，<code> c.retainAll（c）</ code>应该没有任何作用。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_VACUOUS_SELF_COLLECTION_CALL)"
      },
      {
        "real_name": "DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES",
        "display_name": "DmiCollectionsShouldNotContainThemselves",
        "severity": "warning",
        "category": "convention",
        "rule_title": "集合不应包含自己",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个对泛型集合的方法的调用只有在包含集合时才有意义\n本身（例如，如果<code> s.contains（s）</ code>为真）。这不太可能是真实的，并且会导致\n问题是否属实（如计算散列码导致无限递归）。\n很可能错误的值被作为参数传递。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)"
      },
      {
        "real_name": "SIC_THREADLOCAL_DEADLY_EMBRACE",
        "display_name": "SicThreadlocalDeadlyEmbrace",
        "severity": "warning",
        "category": "performance",
        "rule_title": "致命的非静态内部类和线程局部的拥抱",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个类是一个内部类，但应该是一个静态的内部类。\n  事实上，内心阶层之间存在着致命的拥抱的严重危险\n  和外部类中的本地线程。由于内部类不是静态的，\n  它保留了对外部类的引用。\n  如果线程本地包含对内部实例的引用\n  类，内部和外部实例都将可到达\n  并没有资格进行垃圾回收。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SIC_THREADLOCAL_DEADLY_EMBRACE)"
      },
      {
        "real_name": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "display_name": "UwfFieldNotInitializedInConstructor",
        "severity": "warning",
        "category": "convention",
        "rule_title": "字段未在构造函数中初始化，但未经空值检查解除引用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该字段在任何构造函数中都不会被初始化，因此可能在之后为空\n该对象被构造。在其他地方，它没有空检查就被加载和解除引用。\n这可能是一个错误或一个可疑的设计，因为\n这意味着如果该字段被解除引用，则会生成空指针异常\n在被初始化之前。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)"
      },
      {
        "real_name": "NO_NOTIFY_NOT_NOTIFYALL",
        "display_name": "NoNotifyNotNotifyall",
        "severity": "warning",
        "category": "convention",
        "rule_title": "使用notify（）而不是notifyAll（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法调用<code> notify（）</ code>而不是<code> notifyAll（）</ code>。\n  Java监视器通常用于多种情况。＆nbsp;调用<code> notify（）</ code>\n  只唤醒一个线程，这意味着线程唤醒可能不是\n  一个等待主叫方满意的条件。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NO_NOTIFY_NOT_NOTIFYALL)"
      },
      {
        "real_name": "UC_USELESS_VOID_METHOD",
        "display_name": "UcUselessVoidMethod",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "无用的非空void方法",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "我们的分析表明，这种非空的无效方法实际上并没有执行任何有用的工作。\n请检查它：代码中可能有错误，或者它的主体可以完全删除。\n\n 我们尽量减少误报，但在某些情况下，这种警告可能是错误的。\n常见的假阳性病例包括：\n  - 该方法旨在触发某些可能有副作用的类的加载。\n  - 该方法旨在隐式抛出一些模糊的异常。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UC_USELESS_VOID_METHOD)"
      },
      {
        "real_name": "UC_USELESS_CONDITION",
        "display_name": "UcUselessCondition",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "条件没有效果",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这种情况总是会产生与之前缩小涉及变量的值相同的结果。\n可能是其他意思或条件可以删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UC_USELESS_CONDITION)"
      },
      {
        "real_name": "UC_USELESS_CONDITION_TYPE",
        "display_name": "UcUselessConditionType",
        "severity": "warning",
        "category": "convention",
        "rule_title": "由于变量类型，条件不起作用",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "由于涉及变量的类型范围，此条件始终会产生相同的结果。\n可能是其他意思或条件可以删除。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UC_USELESS_CONDITION_TYPE)"
      },
      {
        "real_name": "MS_SHOULD_BE_REFACTORED_TO_BE_FINAL",
        "display_name": "MsShouldBeRefactoredToBeFinal",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "场不是最终的，但应该被重构为如此",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个静态字段公开但不是最终的，而且\n可能会被恶意代码或更改\n不小心从另一个包裹。\n该领域可以做最后的避免\n这个漏洞。但是，静态初始化程序包含多个写入\n到现场，这样做需要一些重构。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#MS_SHOULD_BE_REFACTORED_TO_BE_FINAL)"
      },
      {
        "real_name": "DMI_ARGUMENTS_WRONG_ORDER",
        "display_name": "DmiArgumentsWrongOrder",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "反转的方法参数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这个方法调用的参数似乎错误的顺序。\n例如，调用<code> Preconditions.checkNotNull（“message”，message）</ code>\n保留了参数：要检查的值是第一个参数。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_ARGUMENTS_WRONG_ORDER)"
      },
      {
        "real_name": "DMI_RANDOM_USED_ONLY_ONCE",
        "display_name": "DmiRandomUsedOnlyOnce",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "随机对象只能创建和使用一次",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码创建一个java.util.Random对象，使用它来生成一个随机数，然后丢弃\n随机对象。这产生平庸质量的随机数并且效率低下。\n如果可能的话，重写代码，以便Random对象创建一次并保存，并且每次都有一个新的随机数\n需要在现有的Random对象上调用一个方法来获取它。\n\n\n 如果生成的随机数字不可猜测是重要的，那么您必须为每个随机数字创建一个新的随机数字\n数;这些值太容易猜测了。您应该强烈考虑使用java.security.SecureRandom来代替\n（并且避免为每个需要的随机数分配一个新的SecureRandom）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_RANDOM_USED_ONLY_ONCE)"
      },
      {
        "real_name": "SA_LOCAL_SELF_COMPUTATION",
        "display_name": "SaLocalSelfComputation",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "涉及变量的无意义自我计算（例如，x和x）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法执行与另一个局部变量的无意义计算\n引用相同的变量（例如，x＆x或x-x）。由于性质\n的计算，这个操作似乎没有意义，\n并可能指示错字或\n一个逻辑错误。仔细检查计算。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_LOCAL_SELF_COMPUTATION)"
      },
      {
        "real_name": "SA_LOCAL_SELF_COMPARISON",
        "display_name": "SaLocalSelfComparison",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "价值与自身的自我比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此方法将本地变量与自身进行比较，并可能指示拼写错误或\n一个逻辑错误。确保你比较正确的东西。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_LOCAL_SELF_COMPARISON)"
      },
      {
        "real_name": "SA_FIELD_SELF_COMPARISON",
        "display_name": "SaFieldSelfComparison",
        "severity": "warning",
        "category": "convention",
        "rule_title": "领域与自身的自我比较",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法将字段与自身进行比较，并可能指示拼写错误或\n一个逻辑错误。确保你比较正确的东西。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_FIELD_SELF_COMPARISON)"
      },
      {
        "real_name": "RV_REM_OF_HASHCODE",
        "display_name": "RvRemOfHashcode",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "hashCode的剩余部分可能是负数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这段代码计算一个hashCode，然后计算\n该值的其余部分以另一个值为模。由于hashCode\n可以是负数，剩余操作的结果\n也可以是负面的。\n  假设你想确保你的计算结果是非负的，\n您可能需要更改您的代码。\n如果你知道除数是2的幂，\n你可以使用一个按位和运算符代替（即，而不是\n使用<code> x.hashCode（）％n </ code>，使用<code> x.hashCode（）＆amp;（n-1）</ code>。\n这可能比计算其余部分要快。\n如果你不知道除数是2的幂，则取绝对值\n剩余操作结果的值（即使用\n<代码> Math.abs（x.hashCode（）％N）</代码>\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_REM_OF_HASHCODE)"
      },
      {
        "real_name": "RV_REM_OF_RANDOM_INT",
        "display_name": "RvRemOfRandomInt",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "剩余的32位有符号随机整数",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码会生成一个随机有符号整数，然后进行计算\n该值的其余部分以另一个值为模。由于随机\n数字可以是负数，剩余操作的结果\n也可以是负面的。确保这是有意的，并强烈\n考虑使用Random.nextInt（int）方法。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_REM_OF_RANDOM_INT)"
      },
      {
        "real_name": "RV_ABSOLUTE_VALUE_OF_HASHCODE",
        "display_name": "RvAbsoluteValueOfHashcode",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "错误的尝试计算有符号的32位散列码的绝对值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码生成一个哈希码，然后计算\n该哈希码的绝对值。如果哈希码\n是<code> Integer.MIN_VALUE </ code>，那么结果也是负的（因为\n<code> Math.abs（Integer.MIN_VALUE）== Integer.MIN_VALUE </ code>）。\n\n 2 ^ 32字符串中的一个具有Integer.MIN_VALUE的hashCode，\n包括“polygenelubricants”“GydZG_”和“”设计工作室“。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_ABSOLUTE_VALUE_OF_HASHCODE)"
      },
      {
        "real_name": "RV_ABSOLUTE_VALUE_OF_RANDOM_INT",
        "display_name": "RvAbsoluteValueOfRandomInt",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "错误的尝试计算带符号的随机整数的绝对值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码会生成一个随机有符号整数，然后进行计算\n该随机整数的绝对值。如果该号码返回的号码\n生成器是<code> Integer.MIN_VALUE </ code>，那么结果也是负的（因为\n<code> Math.abs（Integer.MIN_VALUE）== Integer.MIN_VALUE </ code>）。 （同样的问题也出现在较长的价值观上）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RV_ABSOLUTE_VALUE_OF_RANDOM_INT)"
      },
      {
        "real_name": "DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT",
        "display_name": "DmiLongBitsToDoubleInvokedOnInt",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "在int上调用Double.longBitsToDouble",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "Double.longBitsToDouble方法被调用，但是一个32位的int值被作为参数传递。这几乎肯定不是有意的，也不可能达到预期的结果。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)"
      },
      {
        "real_name": "SA_FIELD_SELF_COMPUTATION",
        "display_name": "SaFieldSelfComputation",
        "severity": "warning",
        "category": "convention",
        "rule_title": "涉及字段的无意义自我计算（例如，x和x）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法执行与另一个字段的无意义的计算\n引用相同的字段（例如，x＆x或x-x）。由于性质\n的计算，这个操作似乎没有意义，\n并可能指示错字或\n一个逻辑错误。仔细检查计算。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_FIELD_SELF_COMPUTATION)"
      },
      {
        "real_name": "SA_LOCAL_DOUBLE_ASSIGNMENT",
        "display_name": "SaLocalDoubleAssignment",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "局部变量的双重赋值",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法包含一个局部变量的双重赋值;例如\n\n<PRE>\n  public void foo（）{int x，y; x = x = 17;\n  }\n</ PRE>\n 给变量分配两次相同的值是无用的，可能表示逻辑错误或拼写错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SA_LOCAL_DOUBLE_ASSIGNMENT)"
      },
      {
        "real_name": "UI_INHERITANCE_UNSAFE_GETRESOURCE",
        "display_name": "UiInheritanceUnsafeGetresource",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "如果扩展了类，GetResource的使用可能不安全",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "调用<code> this.getClass（）。getResource（...）</ code>可以给\n如果这个类是由一个类扩展的，结果不是预期的结果\n另一个包。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UI_INHERITANCE_UNSAFE_GETRESOURCE)"
      },
      {
        "real_name": "VO_VOLATILE_INCREMENT",
        "display_name": "VoVolatileIncrement",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "对易失性字段的增量不是原子的",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码会增加一个易失性字段。不稳定的字段的增量不是\n原子。如果多个线程同时递增字段，\n增量可能会丢失。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#VO_VOLATILE_INCREMENT)"
      },
      {
        "real_name": "XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER",
        "display_name": "XssRequestParameterToServletWriter",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "Servlet反映了跨站点脚本漏洞",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "此代码直接将HTTP参数写入Servlet输出，这允许反映跨站点脚本\n漏洞。请参阅<a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\"> http://en.wikipedia.org/wiki/Cross-site_scripting </a>\n了解更多信息。\n FindBugs只查找最明显，最明显的跨站点脚本案例。\n如果FindBugs找到<em>任何<em>，那么你几乎可以确定</ em>有更多跨站点脚本\nFindBugs不报告的漏洞。如果你担心跨站点脚本，你应该认真对待\n考虑使用商业静态分析或笔测试工具。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)"
      },
      {
        "real_name": "WakeLockUsage",
        "display_name": "WakeLockUsage",
        "severity": "info",
        "category": "other",
        "rule_title": null,
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#WakeLockUsage)"
      },
      {
        "real_name": "RANGE_STRING_INDEX",
        "display_name": "RangeStringIndex",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "字符串索引超出范围",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "String方法被调用并且指定的字符串索引超出范围。这将在运行时导致StringIndexOutOfBoundsException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RANGE_STRING_INDEX)"
      },
      {
        "real_name": "RANGE_ARRAY_LENGTH",
        "display_name": "RangeArrayLength",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "数组长度超出范围",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "使用数组参数和长度参数调用方法，但长度超出范围。这将在运行时导致IndexOutOfBoundsException。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#RANGE_ARRAY_LENGTH)"
      },
      {
        "real_name": "UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR",
        "display_name": "UrUninitReadCalledFromSuperConstructor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "未初始化从超类的构造函数中调用的字段方法的读取",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "该方法在超类的构造函数中调用。此时，该类的字段尚未初始化。\n 为了使这更具体，请考虑以下类别：\n<pre>抽象类A {\n  int hashCode;\n  抽象对象getValue（）;\n  A（）{hashCode = getValue（）。hashCode（）; }\n  }\nB类延伸A {\n  对象值;\n  B（Object v）{this.value = v; }\n  Object getValue（）{return value;\n  }\n  } </ PRE>\n 当构建<code> B </ code>时，\n调用<code> A </ code>类的构造函数\n<em> </ em>之前的<code> B </ code>的构造函数设置<code> value </ code>。\n因此，当<code> A </ code>的构造函数调用<code> getValue </ code>时，\n为<code> value </ code>读取未初始化的值\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)"
      },
      {
        "real_name": "J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION",
        "display_name": "J2EeStoreOfNonSerializableObjectIntoSession",
        "severity": "warning",
        "category": "performance",
        "rule_title": "将不可序列化的对象存储到HttpSession中",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "这段代码似乎将一个不可序列化的对象存储到HttpSession中。\n如果此会话被钝化或迁移，则会导致错误。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)"
      },
      {
        "real_name": "SC_START_IN_CTOR",
        "display_name": "ScStartInCtor",
        "severity": "warning",
        "category": "correctness",
        "rule_title": "构造函数调用Thread.start（）",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "构造函数启动一个线程。这可能是错误的，如果\n   该类将被扩展/子类化，因为该线程将被启动\n   在子类构造函数启动之前。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#SC_START_IN_CTOR)"
      },
      {
        "real_name": "GC_UNRELATED_TYPES",
        "display_name": "GcUnrelatedTypes",
        "severity": "warning",
        "category": "convention",
        "rule_title": "泛型参数和方法参数之间没有关系",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "对泛型集合方法的这种调用包含一个参数，该参数的集合参数的类不兼容（即参数的类型既不是超类型也不是相应泛型类型参数的子类型）。因此，集合不太可能包含与此处使用的方法参数相同的任何对象。很可能，错误的价值正在传递给该方法。一般来说，两个不相关类的实例是不相等的。例如，如果<code> Foo </ code>和<code> Bar </ code>类通过子类型不相关，那么<code> Foo </ code>的一个实例不应该等于<代码>酒吧</代码>。在其他问题中，这样做可能会导致不对称的等价方法。例如，如果您定义<code> Foo </ code>类以使<code> Foo </ code>等于<code> String </ code>，那么您的equals方法不是对称的，因为<code> String </ code>只能等于一个<code> String </ code>。在极少数情况下，人们确实定义了非对称等值方法，并仍然设法使其代码正常工作。虽然没有任何API文档或保证它，但通常情况下，如果您检查<code> Collection <String>＆gt; </ code>是否包含<code> Foo </ code>，则参数的equals方法（例如，用于执行相等性检查的<code> Foo </ code>类的equals方法）。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#GC_UNRELATED_TYPES)"
      },
      {
        "real_name": "NoiseOperation",
        "display_name": "NoiseOperation",
        "severity": "warning",
        "category": "security",
        "rule_title": "虚假的操作警告",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "虚假警告。"
      },
      {
        "real_name": "NOISE_NULL_DEREFERENCE",
        "display_name": "NoiseNullDereference",
        "severity": "warning",
        "category": "security",
        "rule_title": "关于空指针解引用的虚假警告",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "虚假警告。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NOISE_NULL_DEREFERENCE)"
      },
      {
        "real_name": "NOISE_FIELD_REFERENCE",
        "display_name": "NoiseFieldReference",
        "severity": "warning",
        "category": "security",
        "rule_title": "关于字段参考的虚假警告",
        "rule_params": null,
        "custom": false,
        "languages": [
          "java"
        ],
        "solution": null,
        "owner": null,
        "labels": [],
        "description": "虚假警告。\n[参考官方文档](http://findbugs.sourceforge.net/bugDescriptions.html#NOISE_FIELD_REFERENCE)"
      }
    ]
  }
]