[
    {
        "name": "eslint_typescript",
        "display_name": "EslintTypeScript",
        "description": "TypeScript静态扫描工具，并支持扫描基于TypeScript写的React代码，默认扫描后缀为 .ts .tsx 的代码文件。",
        "license": "MIT",
        "task_processes": [
            "analyze",
            "datahandle"
        ],
        "scan_app": "codelint",
        "scm_url": null,
        "run_cmd": null,
        "envs": null,
        "build_flag": false,
        "checkrule_set": [
            {
                "real_name": "accessor-pairs",
                "display_name": "accessor-pairs",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制getter/setter成对出现在对象中 (accessor-pairs)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforces getter/setter pairs in objects (accessor-pairs)\n强制getter/setter成对出现在对象中 (accessor-pairs)\nIt’s a common mistake in JavaScript to create an object with just a setter for a property but never have a corresponding getter defined for it. Without a getter, you cannot read the property, so it ends up not being used.\n创建一个对象，其某个属性只有 setter 而没有对应的 getter，这在 Javascript 中 是个常犯的错误。没有 getter ，你不能读取这个属性，该属性也就不会被用到。（译者注： Javascript 中不一定非要同时指定 getter 和 setter ，原文将此表述为”错误”并非是指语法上的错误）\nHere are some examples:\n例如：\n// Bad\nvar o = {\n    set a(value) {\n        this.val = value;\n    }\n};\n\n// Good\nvar o = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\n\n\nThis rule warns if setters are defined without getters. Using an option getWithoutSet, it will warn if you have a getter without a setter also.\n如果只定义 setter 而没有定义 getter，该规则会发出警告。设置了 getWithoutSet 选项，如果只有 getter 而没有 setter，该规则同样会发出警告。\nRule Details\nThis rule enforces a style where it requires to have a getter for every property which has a setter defined.\n该规则强制一种编码风格：对于每个属性，如果定义了setter，也必须定义相应的 getter。\nBy activating the option getWithoutSet it enforces the presence of a setter for every property which has a getter defined.\n通过激活 getWithoutSet 选项，强制为每个定义了 getter 的属性提供对应的 setter。\nOptions\n\nsetWithoutGet set to true will warn for setters without getters (Default true).\n当 setWithoutGet  设置为true时，如果只定义 setter 而不定义 getter，该规则将发出警告（默认为 true）。\ngetWithoutSet set to true will warn for getters without setters (Default false).\n当 getWithoutSet 设置为true时，如果只定义 getter 而不定义 setter，该规则将发出警告（默认为 false）。\n\nsetWithoutGet\nExamples of incorrect code for the default { \"setWithoutGet\": true } option:\n默认选项{ \"setWithoutGet\": true }的 错误 代码示例：\n/*eslint accessor-pairs: \"error\"*/\n\nvar o = {\n    set a(value) {\n        this.val = value;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    }\n});\n\n\nExamples of correct code for the default { \"setWithoutGet\": true } option:\n默认选项{ \"setWithoutGet\": true }的 正确 代码示例：\n/*eslint accessor-pairs: \"error\"*/\n\nvar o = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    },\n    get: function() {\n        return this.val;\n    }\n});\n\n\n\ngetWithoutSet\nExamples of incorrect code for the { \"getWithoutSet\": true } option:\n{ \"getWithoutSet\": true }选项的 错误 代码示例：\n/*eslint accessor-pairs: [\"error\", { \"getWithoutSet\": true }]*/\n\nvar o = {\n    set a(value) {\n        this.val = value;\n    }\n};\n\nvar o = {\n    get a() {\n        return this.val;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    }\n});\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    get: function() {\n        return this.val;\n    }\n});\n\n\nExamples of correct code for the { \"getWithoutSet\": true } option:\n{ \"getWithoutSet\": true }选项的 正确 代码示例：\n/*eslint accessor-pairs: [\"error\", { \"getWithoutSet\": true }]*/\nvar o = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nvar o = {d: 1};\nObject.defineProperty(o, 'c', {\n    set: function(value) {\n        this.val = value;\n    },\n    get: function() {\n        return this.val;\n    }\n});\n\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the simultaneous presence of setters and getters on objects.\n如果你不关心对象里同时出现 setter 和 getter，你可以关闭这个规则。\nFurther Reading\n\nObject Setters\nObject Getters\nWorking with Objects\n\nVersion\nThis rule was introduced in ESLint 0.22.0.\n该规则在 ESLint 0.22.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/accessor-pairs",
                "disable": false
            },
            {
                "real_name": "array-bracket-newline",
                "display_name": "array-bracket-newline",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce line breaks after opening and before closing array brackets (array-bracket-newline)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce line breaks after opening and before closing array brackets (array-bracket-newline)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nA number of style guides require or disallow line breaks inside of array brackets.\nRule Details\nThis rule enforces line breaks after opening and before closing array brackets.\nOptions\nThis rule has either a string option:\n\n\"always\" requires line breaks inside braces\n\"never\" disallows line breaks inside braces\n\nOr an object option (Requires line breaks if any of properties is satisfied. Otherwise, disallows line breaks):\n\n\"multiline\": true (default) requires line breaks if there are line breaks inside elements or between elements. If this is false, this condition is disabled.\n\"minItems\": null (default) requires line breaks if the number of elements is at least the given integer. If this is 0, this condition will act the same as the option \"always\". If this is null (the default), this condition is disabled.\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n/*eslint array-bracket-newline: [\"error\", \"always\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];\n\n\nExamples of correct code for this rule with the \"always\" option:\n/*eslint array-bracket-newline: [\"error\", \"always\"]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n/*eslint array-bracket-newline: [\"error\", \"never\"]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];\n\n\nExamples of correct code for this rule with the \"never\" option:\n/*eslint array-bracket-newline: [\"error\", \"never\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];\n\n\nmultiline\nExamples of incorrect code for this rule with the default { \"multiline\": true } option:\n/*eslint array-bracket-newline: [\"error\", { \"multiline\": true }]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [\n    1, 2\n];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];\n\n\nExamples of correct code for this rule with the default { \"multiline\": true } option:\n/*eslint array-bracket-newline: [\"error\", { \"multiline\": true }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];\n\n\nminItems\nExamples of incorrect code for this rule with the { \"minItems\": 2 } option:\n/*eslint array-bracket-newline: [\"error\", { \"minItems\": 2 }]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [\n  function foo() {\n    dosomething();\n  }\n];\n\n\nExamples of correct code for this rule with the { \"minItems\": 2 } option:\n/*eslint array-bracket-newline: [\"error\", { \"minItems\": 2 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [function foo() {\n    dosomething();\n}];\n\n\nmultiline and minItems\nExamples of incorrect code for this rule with the { \"multiline\": true, \"minItems\": 2 } options:\n/*eslint array-bracket-newline: [\"error\", { \"multiline\": true, \"minItems\": 2 }]*/\n\nvar a = [\n];\nvar b = [\n    1\n];\nvar c = [1, 2];\nvar d = [1,\n    2];\nvar e = [function foo() {\n    dosomething();\n}];\n\n\nExamples of correct code for this rule with the { \"multiline\": true, \"minItems\": 2 } options:\n/*eslint array-bracket-newline: [\"error\", { \"multiline\": true, \"minItems\": 2 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [\n    1, 2\n];\nvar d = [\n    1,\n    2\n];\nvar e = [\n    function foo() {\n        dosomething();\n    }\n];\n\n\nWhen Not To Use It\nIf you don’t want to enforce line breaks after opening and before closing array brackets, don’t enable this rule.\nCompatibility\n\nJSCS: validateNewlineAfterArrayElements\n\nRelated Rules\n\narray-bracket-spacing\n\nVersion\nThis rule was introduced in ESLint 4.0.0-alpha.1.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/array-bracket-newline",
                "disable": false
            },
            {
                "real_name": "array-bracket-spacing",
                "display_name": "array-bracket-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止或强制在括号内使用空格 (array-bracket-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow or enforce spaces inside of brackets (array-bracket-spacing)\n禁止或强制在括号内使用空格 (array-bracket-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nA number of style guides require or disallow spaces between array brackets and other tokens. This rule\napplies to both array literals and destructuring assignments (ECMAScript 6).\n一些代码风格指南要求或禁止在数组的方括号内留有空格。该规则适用于数组和数组的解构赋值 (EcmaScript 6)。\n/*eslint-env es6*/\n\nvar arr = [ 'foo', 'bar' ];\nvar [ x, y ] = z;\n\nvar arr = ['foo', 'bar'];\nvar [x,y] = z;\n\n\nRule Details\nThis rule enforces consistent spacing inside array brackets.\n该规则强制数组括号内的空格的一致性。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"never\" (default) disallows spaces inside array brackets\n\"never\" (默认) 禁止在数组括号内出现空格\n\"always\" requires one or more spaces or newlines inside array brackets\n\"always\" 要求在数组括号内使用一个或多个空格、或折行\n\nThis rule has an object option for exceptions to the \"never\" option:\n对于\"never\"选项，可以有例外情况，用一个对象表示：\n\n\"singleValue\": true requires one or more spaces or newlines inside brackets of array literals that contain a single element\n\"singleValue\": true 要求在只包含一个元素的数组的括号内使用一个或多个空格、或折行\n\"objectsInArrays\": true requires one or more spaces or newlines between brackets of array literals and braces of their object literal elements [ { or } ]\n\"objectsInArrays\": true 要求在数组的方括号和数组内的对象元素的大括号之间，即[ { 或 } ]，使用一个或多个空格、或折行\n\"arraysInArrays\": true requires one or more spaces or newlines between brackets of array literals and brackets of their array literal elements [ [ or ] ]\n\"arraysInArrays\": true 要求在数组的方括号和数组内的数组元素的方括号之间，即[ [ 或 ] ]，使用一个或多个空格、或折行\n\nThis rule has an object option for exceptions to the \"always\" option:\n对于\"always\"选项，可以有例外情况，用一个对象表示：\n\n\"singleValue\": false disallows spaces inside brackets of array literals that contain a single element\n\"singleValue\": false 禁止在只包含一个元素的数组的括号内使用空格\n\"objectsInArrays\": false disallows spaces between brackets of array literals and braces of their object literal elements [{ or }]\n\"objectsInArrays\": false 禁止在数组的方括号和数组内的对象元素的大括号之间，即 [{ 或 }]出现空格\n\"arraysInArrays\": false disallows spaces between brackets of array literals and brackets of their array literal elements [[ or ]]\n\"arraysInArrays\": false 禁止在数组的方括号和数组内的数组元素的方括号之间，即 [[ 或 ]]出现空格\n\nThis rule has built-in exceptions:\n该规则有两个内置的例外情况：\n\n\"never\" (and also the exceptions to the \"always\" option) allows newlines inside array brackets, because this is a common pattern\n\"never\" (和 \"always\" 选项的例外情况) 允许在数组内出现折行，因为这是一种常见的模式\n\"always\" does not require spaces or newlines in empty array literals []\n\"always\" 在空数组中[]不要求出现空格或折行\n\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n默认选项\"never\"的 错误 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nvar arr = [ 'foo', 'bar' ];\nvar arr = ['foo', 'bar' ];\nvar arr = [ ['foo'], 'bar'];\nvar arr = [[ 'foo' ], 'bar'];\nvar arr = [ 'foo',\n  'bar'\n];\nvar [ x, y ] = z;\nvar [ x,y ] = z;\nvar [ x, ...y ] = z;\nvar [ ,,x, ] = z;\n\n\nExamples of correct code for this rule with the default \"never\" option:\n默认选项\"never\"的 正确代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nvar arr = [];\nvar arr = ['foo', 'bar', 'baz'];\nvar arr = [['foo'], 'bar', 'baz'];\nvar arr = [\n  'foo',\n  'bar',\n  'baz'\n];\nvar arr = ['foo',\n  'bar'\n];\nvar arr = [\n  'foo',\n  'bar'];\n\nvar [x, y] = z;\nvar [x,y] = z;\nvar [x, ...y] = z;\nvar [,,x,] = z;\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar arr = ['foo', 'bar'];\nvar arr = ['foo', 'bar' ];\nvar arr = [ ['foo'], 'bar' ];\nvar arr = ['foo',\n  'bar'\n];\nvar arr = [\n  'foo',\n  'bar'];\n\nvar [x, y] = z;\nvar [x,y] = z;\nvar [x, ...y] = z;\nvar [,,x,] = z;\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar arr = [];\nvar arr = [ 'foo', 'bar', 'baz' ];\nvar arr = [ [ 'foo' ], 'bar', 'baz' ];\nvar arr = [ 'foo',\n  'bar'\n];\nvar arr = [\n  'foo',\n  'bar' ];\nvar arr = [\n  'foo',\n  'bar',\n  'baz'\n];\n\nvar [ x, y ] = z;\nvar [ x,y ] = z;\nvar [ x, ...y ] = z;\nvar [ ,,x, ] = z;\n\n\nsingleValue\nExamples of incorrect code for this rule with the \"always\", { \"singleValue\": false } options:\n选项 \"always\", { \"singleValue\": false } 的 错误 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\", { \"singleValue\": false }]*/\n\nvar foo = [ 'foo' ];\nvar foo = [ 'foo'];\nvar foo = ['foo' ];\nvar foo = [ 1 ];\nvar foo = [ 1];\nvar foo = [1 ];\nvar foo = [ [ 1, 2 ] ];\nvar foo = [ { 'foo': 'bar' } ];\n\n\nExamples of correct code for this rule with the \"always\", { \"singleValue\": false } options:\n选项 \"always\", { \"singleValue\": false } 的 正确 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\", { \"singleValue\": false }]*/\n\nvar foo = ['foo'];\nvar foo = [1];\nvar foo = [[ 1, 1 ]];\nvar foo = [{ 'foo': 'bar' }];\n\n\nobjectsInArrays\nExamples of incorrect code for this rule with the \"always\", { \"objectsInArrays\": false } options:\n选项 \"always\", { \"objectsInArrays\": false } 的 错误 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\", { \"objectsInArrays\": false }]*/\n\nvar arr = [ { 'foo': 'bar' } ];\nvar arr = [ {\n  'foo': 'bar'\n} ]\n\n\nExamples of correct code for this rule with the \"always\", { \"objectsInArrays\": false } options:\n选项 \"always\", { \"objectsInArrays\": false } 的 正确 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\", { \"objectsInArrays\": false }]*/\n\nvar arr = [{ 'foo': 'bar' }];\nvar arr = [{\n  'foo': 'bar'\n}];\n\n\narraysInArrays\nExamples of incorrect code for this rule with the \"always\", { \"arraysInArrays\": false } options:\n选项 \"always\", { \"arraysInArrays\": false } 的 错误 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\", { \"arraysInArrays\": false }]*/\n\nvar arr = [ [ 1, 2 ], 2, 3, 4 ];\nvar arr = [ [ 1, 2 ], 2, [ 3, 4 ] ];\n\n\nExamples of correct code for this rule with the \"always\", { \"arraysInArrays\": false } options:\n选项 \"always\", { \"arraysInArrays\": false } 的 正确 代码示例：\n/*eslint array-bracket-spacing: [\"error\", \"always\", { \"arraysInArrays\": false }]*/\n\nvar arr = [[ 1, 2 ], 2, 3, 4 ];\nvar arr = [[ 1, 2 ], 2, [ 3, 4 ]];\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of spacing between array brackets.\n如果你并不关心数组括号内间距的一致性，可以关闭此规则。\nRelated Rules\n\nspace-in-parens\nobject-curly-spacing\ncomputed-property-spacing\n\nVersion\nThis rule was introduced in ESLint 0.24.0.\n该规则在 ESLint 0.24.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/array-bracket-spacing",
                "disable": false
            },
            {
                "real_name": "array-callback-return",
                "display_name": "array-callback-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制数组方法的回调函数中有 return 语句 (array-callback-return)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforces return statements in callbacks of array’s methods (array-callback-return)\n强制数组方法的回调函数中有 return 语句 (array-callback-return)\nArray has several methods for filtering, mapping, and folding.\nIf we forget to write return statement in a callback of those, it’s probably a mistake.\nArray有一些方法用来过滤、映射和折叠。如果你忘记了在它们的回调函数中写return语句，这种情况可能是个错误。\n// example: convert ['a', 'b', 'c'] --> {a: 0, b: 1, c: 2}\nvar indexMap = myArray.reduce(function(memo, item, index) {\n  memo[item] = index;\n}, {}); // Error: cannot set property 'b' of undefined\n\n\nThis rule enforces usage of return statement in callbacks of array’s methods.\n该规则强制数组方法的回调函数中的return语句的使用。\nRule Details\nThis rule finds callback functions of the following methods, then checks usage of return statement.\n该规则发现以下方法的回调函数，然后检查return语句的使用。\n\nArray.from\nArray.from\nArray.prototype.every\nArray.prototype.every\nArray.prototype.filter\nArray.prototype.filter\nArray.prototype.find\nArray.prototype.find\nArray.prototype.findIndex\nArray.prototype.findIndex\nArray.prototype.map\nArray.prototype.map\nArray.prototype.reduce\nArray.prototype.reduce\nArray.prototype.reduceRight\nArray.prototype.reduceRight\nArray.prototype.some\nArray.prototype.some\nArray.prototype.sort\nArray.prototype.sort\nAnd above of typed arrays.\n以上类型的数据。\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint array-callback-return: \"error\"*/\n\nvar indexMap = myArray.reduce(function(memo, item, index) {\n    memo[item] = index;\n}, {});\n\nvar foo = Array.from(nodes, function(node) {\n    if (node.tagName === \"DIV\") {\n        return true;\n    }\n});\n\nvar bar = foo.filter(function(x) {\n    if (x) {\n        return true;\n    } else {\n        return;\n    }\n});\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint array-callback-return: \"error\"*/\n\nvar indexMap = myArray.reduce(function(memo, item, index) {\n    memo[item] = index;\n    return memo;\n}, {});\n\nvar foo = Array.from(nodes, function(node) {\n    if (node.tagName === \"DIV\") {\n        return true;\n    }\n    return false;\n});\n\nvar bar = foo.map(node => node.getAttribute(\"id\"));\n\n\nKnown Limitations\nThis rule checks callback functions of methods with the given names, even if the object which has the method is not an array.\n该规则检查给定名称的方法中的回调函数，即使该对象中的方法 不是一个数组。\nWhen Not To Use It\nIf you don’t want to warn about usage of return statement in callbacks of array’s methods, then it’s safe to disable this rule.\n如果你不想收到关于强制数组方法的回调函数中return语句的使用情况的警告，你可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-1.\n该规则在 ESLint 2.0.0-alpha-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/array-callback-return",
                "disable": false
            },
            {
                "real_name": "array-element-newline",
                "display_name": "array-element-newline",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce line breaks between array elements (array-element-newline)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce line breaks between array elements (array-element-newline)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nA number of style guides require or disallow line breaks between array elements.\nRule Details\nThis rule enforces line breaks between array elements.\nOptions\nThis rule has either a string option:\n\n\"always\" (default) requires line breaks between array elements\n\"never\" disallows line breaks between array elements\n\nOr an object option (Requires line breaks if any of properties is satisfied. Otherwise, disallows line breaks):\n\n\"multiline\": <boolean> requires line breaks if there are line breaks inside elements. If this is false, this condition is disabled.\n\"minItems\": <number> requires line breaks if the number of elements is at least the given integer. If this is 0, this condition will act the same as the option \"always\". If this is null (the default), this condition is disabled.\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n/*eslint array-element-newline: [\"error\", \"always\"]*/\n\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];\n\n\nExamples of correct code for this rule with the default \"always\" option:\n/*eslint array-element-newline: [\"error\", \"always\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1,\n    2];\nvar d = [1,\n    2,\n    3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];\n\n\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n/*eslint array-element-newline: [\"error\", \"never\"]*/\n\nvar c = [\n    1,\n    2\n];\nvar d = [\n    1,\n    2,\n    3\n];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];\n\n\nExamples of correct code for this rule with the \"never\" option:\n/*eslint array-element-newline: [\"error\", \"never\"]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];\n\n\nmultiline\nExamples of incorrect code for this rule with the { \"multiline\": true } option:\n/*eslint array-element-newline: [\"error\", { \"multiline\": true }]*/\n\nvar d = [1,\n    2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];\n\n\nExamples of correct code for this rule with the { \"multiline\": true } option:\n/*eslint array-element-newline: [\"error\", { \"multiline\": true }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];\n\n\nminItems\nExamples of incorrect code for this rule with the { \"minItems\": 3 } option:\n/*eslint array-element-newline: [\"error\", { \"minItems\": 3 }]*/\n\nvar c = [1,\n    2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];\n\n\nExamples of correct code for this rule with the { \"minItems\": 3 } option:\n/*eslint array-element-newline: [\"error\", { \"minItems\": 3 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2,\n    3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];\n\n\nmultiline and minItems\nExamples of incorrect code for this rule with the { \"multiline\": true, \"minItems\": 3 } options:\n/*eslint array-element-newline: [\"error\", { \"multiline\": true, \"minItems\": 3 }]*/\n\nvar c = [1,\n2];\nvar d = [1, 2, 3];\nvar e = [\n    function foo() {\n        dosomething();\n    }, function bar() {\n        dosomething();\n    }\n];\n\n\nExamples of correct code for this rule with the { \"multiline\": true, \"minItems\": 3 } options:\n/*eslint array-element-newline: [\"error\", { \"multiline\": true, \"minItems\": 3 }]*/\n\nvar a = [];\nvar b = [1];\nvar c = [1, 2];\nvar d = [1,\n    2,\n    3];\nvar e = [\n    function foo() {\n        dosomething();\n    },\n    function bar() {\n        dosomething();\n    }\n];\n\n\nWhen Not To Use It\nIf you don’t want to enforce linebreaks between array elements, don’t enable this rule.\nCompatibility\n\nJSCS: validateNewlineAfterArrayElements\n\nRelated Rules\n\narray-bracket-spacing\narray-bracket-newline\nobject-property-newline\nobject-curly-spacing\nobject-curly-newline\nmax-statements-per-line\nblock-spacing\nbrace-style\n\nVersion\nThis rule was introduced in ESLint 4.0.0-rc.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/array-element-newline",
                "disable": false
            },
            {
                "real_name": "arrow-body-style",
                "display_name": "arrow-body-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求箭头函数体使用大括号 (arrow-body-style)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require braces in arrow function body (arrow-body-style)\n要求箭头函数体使用大括号 (arrow-body-style)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nArrow functions have two syntactic forms for their function bodies.  They may be defined with a block body (denoted by curly braces) () => { ... } or with a single expression () => ..., whose value is implicitly returned.\n箭头函数的主题有两种语法格式。它们可以被定义为一个 块(用大括号)() => { ... } 或只用单一的表达式() => ...，隐式返回值。\nRule Details\nThis rule can enforce or disallow the use of braces around arrow function body.\n该规则可以强制或禁止箭头函数体使用大括号。\nOptions\nThe rule takes one or two options. The first is a string, which can be:\n该规则有一到两个选项。第一个选项是个字符串，可以是：\n\n\"always\" enforces braces around the function body\n\"always\" 强制在箭头函数体周围使用大括号\n\"as-needed\" enforces no braces where they can be omitted (default)\n\"as-needed\" 当大括号是可以省略的，强制不使用它们 (默认)\n\"never\" enforces no braces around the function body (constrains arrow functions to the role of returning an expression)\n\"never\" 禁止在函数体周围出现大括号 (将箭头函数限制为返回结果的表达式)\n\nThe second one is an object for more fine-grained configuration when the first option is \"as-needed\". Currently, the only available option is requireReturnForObjectLiteral, a boolean property. It’s false by default. If set to true, it requires braces and an explicit return for object literals.\n第二个选项是个对象，当第一个选项是 \"as-needed\"，可以进行更加细粒度的配置。目前，唯一有效的选项是一个布尔属性 requireReturnForObjectLiteral。默认为 false。如果设置为 true，它要求使用大括号，并且显示返回对象字面量。\n\"arrow-body-style\": [\"error\", \"always\"]\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint arrow-body-style: [\"error\", \"always\"]*/\n/*eslint-env es6*/\nlet foo = () => 0;\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\nlet foo = () => {\n    return 0;\n};\nlet foo = (retv, name) => {\n    retv[name] = true;\n    return retv;\n};\n\n\nas-needed\nExamples of incorrect code for this rule with the default \"as-needed\" option:\n默认选项 \"as-needed\" 的 错误 代码示例：\n/*eslint arrow-body-style: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\nlet foo = () => {\n    return 0;\n};\nlet foo = () => {\n    return {\n       bar: {\n            foo: 1,\n            bar: 2,\n        }\n    };\n};\n\n\nExamples of correct code for this rule with the default \"as-needed\" option:\n默认选项 \"as-needed\" 的 正确 代码示例：\n/*eslint arrow-body-style: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\nlet foo = () => 0;\nlet foo = (retv, name) => {\n    retv[name] = true;\n    return retv;\n};\nlet foo = () => ({\n    bar: {\n        foo: 1,\n        bar: 2,\n    }\n});\nlet foo = () => { bar(); };\nlet foo = () => {};\nlet foo = () => { /* do nothing */ };\nlet foo = () => {\n    // do nothing.\n};\nlet foo = () => ({ bar: 0 });\n\n\nrequireReturnForObjectLiteral\n\nThis option is only applicable when used in conjunction with the \"as-needed\" option.\n\n\n该选项只适合与`“as-needed”配合使用。\n\nExamples of incorrect code for this rule with the { \"requireReturnForObjectLiteral\": true } option:\n选项 { \"requireReturnForObjectLiteral\": true } 的 错误 代码示例：\n/*eslint arrow-body-style: [\"error\", \"as-needed\", { \"requireReturnForObjectLiteral\": true }]*/\n/*eslint-env es6*/\nlet foo = () => ({});\nlet foo = () => ({ bar: 0 });\n\n\nExamples of correct code for this rule with the { \"requireReturnForObjectLiteral\": true } option:\n选项 { \"requireReturnForObjectLiteral\": true } 的 正确 代码示例：\n/*eslint arrow-body-style: [\"error\", \"as-needed\", { \"requireReturnForObjectLiteral\": true }]*/\n/*eslint-env es6*/\n\nlet foo = () => {};\nlet foo = () => { return { bar: 0 }; };\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint arrow-body-style: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet foo = () => {\n    return 0;\n};\nlet foo = (retv, name) => {\n    retv[name] = true;\n    return retv;\n};\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint arrow-body-style: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet foo = () => 0;\nlet foo = () => ({ foo: 0 });\n\n\nVersion\nThis rule was introduced in ESLint 1.8.0.\n该规则在 ESLint 1.8.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/arrow-body-style",
                "disable": false
            },
            {
                "real_name": "arrow-parens",
                "display_name": "arrow-parens",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求箭头函数的参数使用圆括号 (arrow-parens)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require parens in arrow function arguments (arrow-parens)\n要求箭头函数的参数使用圆括号 (arrow-parens)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nArrow functions can omit parentheses when they have exactly one parameter. In all other cases the parameter(s) must\nbe wrapped in parentheses. This rule enforces the consistent use of parentheses in arrow functions.\n箭头函数体只有一个参数时，可以省略圆括号。其它任何情况，参数都应被圆括号括起来。该规则强制箭头函数中圆括号的使用的一致性。\nRule Details\nThis rule enforces parentheses around arrow function parameters regardless of arity. For example:\n该规则强制箭头函数的参数使用圆括号括起来，不论参数数量如何。例如：\n/*eslint-env es6*/\n\n// Bad\na => {}\n\n// Good\n(a) => {}\n\n\nFollowing this style will help you find arrow functions (=>) which may be mistakenly included in a condition\nwhen a comparison such as >= was the intent.\n这种风格将帮助你找到被错误地包含到条件语句中的箭头函数(=>)，其本意是想使用比较语句的，比如>=\n/*eslint-env es6*/\n\n// Bad\nif (a => 2) {\n}\n\n// Good\nif (a >= 2) {\n}\n\n\nThe rule can also be configured to discourage the use of parens when they are not required:\n该规则可以配置在不需要使用圆括号时，阻止圆括号的使用。\n/*eslint-env es6*/\n\n// Bad\n(a) => {}\n\n// Good\na => {}\n\n\nOptions\nThis rule has a string option and an object one.\n该规则有一个字符串选项和一个对象选项。\nString options are:\n字符串选项：\n\n\"always\" (default) requires parens around arguments in all cases.\n\"always\" (默认) 要求在所有情况下使用圆括号将参数括起来。\n\"as-needed\" allows omitting parens when there is only one argument.\n\"as-needed\" 当只有一个参数时允许省略圆括号。\n\nObject properties for variants of the \"as-needed\" option:\n\"as-needed\" 选项的对象属性：\n\n\"requireForBlockBody\": true modifies the as-needed rule in order to require parens if the function body is in an intructions block (surrounded by braces).\n\"requireForBlockBody\": true 修改 as-needed 规则以便如果函数体在一个指令块中（被花括号括起来）要求使用圆括号把参数括起来。\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint arrow-parens: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\na => {};\na => a;\na => {'\\n'};\na.then(foo => {});\na.then(foo => a);\na(foo => { if (true) {}; });\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint arrow-parens: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\n() => {};\n(a) => {};\n(a) => a;\n(a) => {'\\n'}\na.then((foo) => {});\na.then((foo) => { if (true) {}; });\n\n\nIf Statements\nOne of benefits of this option is that it prevents the incorrect use of arrow functions in conditionals:\n该选项的一个好处是，它阻止了在条件语句中不正确地使用箭头函数。\n/*eslint-env es6*/\n\nvar a = 1;\nvar b = 2;\n// ...\nif (a => b) {\n console.log('bigger');\n} else {\n console.log('smaller');\n};\n// outputs 'bigger', not smaller as expected\n\n\nThe contents of the if statement is an arrow function, not a comparison.\nif语句的内容是个箭头函数，不是比较语句。\nIf the arrow function is intentional, it should be wrapped in parens to remove ambiguity.\n如果需要使用箭头函数，它需要被圆括号括起来以消除歧义。\n/*eslint-env es6*/\n\nvar a = 1;\nvar b = 0;\n// ...\nif ((a) => b) {\n console.log('truthy value returned');\n} else {\n console.log('falsey value returned');\n};\n// outputs 'truthy value returned'\n\n\nThe following is another example of this behavior:\n下面是另一个示例：\n/*eslint-env es6*/\n\nvar a = 1, b = 2, c = 3, d = 4;\nvar f = a => b ? c: d;\n// f = ?\n\n\nf is an arrow function which takes a as an argument and returns the result of b ? c: d.\nf 是个箭头函数，a 是其参数，返回的结果是 b ? c: d。\nThis should be rewritten like so:\n应该被重写为：\n/*eslint-env es6*/\n\nvar a = 1, b = 2, c = 3, d = 4;\nvar f = (a) => b ? c: d;\n\n\nas-needed\nExamples of incorrect code for this rule with the \"as-needed\" option:\n选项 \"as-needed\" 的 错误 代码示例：\n/*eslint arrow-parens: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\n(a) => {};\n(a) => a;\n(a) => {'\\n'};\na.then((foo) => {});\na.then((foo) => a);\na((foo) => { if (true) {}; });\n\n\nExamples of correct code for this rule with the \"as-needed\" option:\n选项 \"as-needed\" 的 正确 代码示例：\n/*eslint arrow-parens: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\n() => {};\na => {};\na => a;\na => {'\\n'};\na.then(foo => {});\na.then(foo => { if (true) {}; });\n(a, b, c) => a;\n(a = 10) => a;\n([a, b]) => a;\n({a, b}) => a;\n\n\nrequireForBlockBody\nExamples of incorrect code for the { \"requireForBlockBody\": true } option:\n选项 { \"requireForBlockBody\": true } 的 错误 代码示例：\n/*eslint arrow-parens: [2, \"as-needed\", { \"requireForBlockBody\": true }]*/\n/*eslint-env es6*/\n\n(a) => a;\na => {};\na => {'\\n'};\na.map((x) => x * x);\na.map(x => {\n  return x * x;\n});\na.then(foo => {});\n\n\nExamples of correct code for the { \"requireForBlockBody\": true } option:\n选项 { \"requireForBlockBody\": true } 的 正确 代码示例：\n/*eslint arrow-parens: [2, \"as-needed\", { \"requireForBlockBody\": true }]*/\n/*eslint-env es6*/\n\n(a) => {};\n(a) => {'\\n'};\na => ({});\n() => {};\na => a;\na.then((foo) => {});\na.then((foo) => { if (true) {}; });\na((foo) => { if (true) {}; });\n(a, b, c) => a;\n(a = 10) => a;\n([a, b]) => a;\n({a, b}) => a;\n\n\nFurther Reading\n\nThe \"as-needed\", { \"requireForBlockBody\": true } rule is directly inspired by the Airbnb\n JS Style Guide.\n\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/arrow-parens",
                "disable": false
            },
            {
                "real_name": "arrow-spacing",
                "display_name": "arrow-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求箭头函数的箭头之前或之后有空格 (arrow-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require space before/after arrow function’s arrow (arrow-spacing)\n要求箭头函数的箭头之前或之后有空格 (arrow-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThis rule normalize style of spacing before/after an arrow function’s arrow(=>).\n该该规则规范化箭头函数的箭头(=>)之前或之后的空格风格。\n/*eslint-env es6*/\n\n// { \"before\": true, \"after\": true }\n(a) => {}\n\n// { \"before\": false, \"after\": false }\n(a)=>{}\n\n\nRule Details\nThis rule takes an object argument with before and after properties, each with a Boolean value.\n该规则有一个对象参数，属性为before 和 after，对应的值为布尔类型的值。\nThe default configuration is { \"before\": true, \"after\": true }.\n默认配置为 { \"before\": true, \"after\": true }。\ntrue means there should be one or more spaces and false means no spaces.\ntrue 意味着应该有 一个或多个空格，false意味着 没有空格。\nExamples of incorrect code for this rule with the default { \"before\": true, \"after\": true } option:\n默认选项 { \"before\": true, \"after\": true } 的 错误 代码示例：\n/*eslint arrow-spacing: \"error\"*/\n/*eslint-env es6*/\n\n()=> {};\n() =>{};\n(a)=> {};\n(a) =>{};\na =>a;\na=> a;\n()=> {'\\n'};\n() =>{'\\n'};\n\n\nExamples of correct code for this rule with the default { \"before\": true, \"after\": true } option:\n默认选项 { \"before\": true, \"after\": true } 的 正确 代码示例：\n/*eslint arrow-spacing: \"error\"*/\n/*eslint-env es6*/\n\n() => {};\n(a) => {};\na => a;\n() => {'\\n'};\n\n\nExamples of incorrect code for this rule with the { \"before\": false, \"after\": false } option:\n选项 { \"before\": false, \"after\": false } 的 错误 代码示例：\n/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": false }]*/\n/*eslint-env es6*/\n\n() =>{};\n(a) => {};\n()=> {'\\n'};\n\n\nExamples of correct code for this rule with the { \"before\": false, \"after\": false } option:\n选项 { \"before\": false, \"after\": false } 的 正确 代码示例：\n/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": false }]*/\n/*eslint-env es6*/\n\n()=>{};\n(a)=>{};\n()=>{'\\n'};\n\n\nExamples of incorrect code for this rule with the { \"before\": false, \"after\": true } option:\n选项 { \"before\": false, \"after\": true } 的 错误 代码示例：\n/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n/*eslint-env es6*/\n\n() =>{};\n(a) => {};\n()=>{'\\n'};\n\n\nExamples of correct code for this rule with the { \"before\": false, \"after\": true } option:\n选项 { \"before\": false, \"after\": true } 的 正确 代码示例：\n/*eslint arrow-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n/*eslint-env es6*/\n\n()=> {};\n(a)=> {};\n()=> {'\\n'};\n\n\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/arrow-spacing",
                "disable": false
            },
            {
                "real_name": "block-scoped-var",
                "display_name": "block-scoped-var",
                "severity": "error",
                "category": "correctness",
                "rule_title": "把 var 语句看作是在块级作用域范围之内 (block-scoped-var)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Treat var as Block Scoped (block-scoped-var)\n把 var 语句看作是在块级作用域范围之内 (block-scoped-var)\nThe block-scoped-var rule generates warnings when variables are used outside of the block in which they were defined. This emulates C-style block scope.\n当变量在其被定义的范围之外被使用时，该规则会发出警告。这种解析方式模拟了 C 语言中的块级作用域。\nRule Details\nThis rule aims to reduce the usage of variables outside of their binding context and emulate traditional block scope from other languages. This is to help newcomers to the language avoid difficult bugs with variable hoisting.\n此规则借鉴其他语言的块级作用域概念，旨在用来减少变量跨作用域使用情况的发生。此规则可帮助语言初学者避免因变量声明提升而产生的 bug。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint block-scoped-var: \"error\"*/\n\nfunction doIf() {\n    if (true) {\n        var build = true;\n    }\n\n    console.log(build);\n}\n\nfunction doIfElse() {\n    if (true) {\n        var build = true;\n    } else {\n        var build = false;\n    }\n}\n\nfunction doTryCatch() {\n    try {\n        var build = 1;\n    } catch (e) {\n        var f = build;\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint block-scoped-var: \"error\"*/\n\nfunction doIf() {\n    var build;\n\n    if (true) {\n        build = true;\n    }\n\n    console.log(build);\n}\n\nfunction doIfElse() {\n    var build;\n\n    if (true) {\n        build = true;\n    } else {\n        build = false;\n    }\n}\n\nfunction doTryCatch() {\n    var build;\n    var f;\n\n    try {\n        build = 1;\n    } catch (e) {\n        f = build;\n    }\n}\n\n\nFurther Reading\n\nJavaScript Scoping and Hoisting\nvar Hoisting\n\nVersion\nThis rule was introduced in ESLint 0.1.0.\n该规则在 ESLint 0.1.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/block-scoped-var",
                "disable": false
            },
            {
                "real_name": "block-spacing",
                "display_name": "block-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止或强制在单行代码块中使用空格 (block-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow or enforce spaces inside of single line blocks (block-spacing)\n禁止或强制在单行代码块中使用空格 (block-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nRule Details\nThis rule enforces consistent spacing inside single-line blocks.\n该规则强制在单行块内的空格的一致性。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"always\" (default) requires one or more spaces\n\"always\" (more) 要求使用一个或多个空格\n\"never\" disallows spaces\n\"never\" 禁用空格\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项\"always\"的 错误 代码示例：\n/*eslint block-spacing: \"error\"*/\n\nfunction foo() {return true;}\nif (foo) { bar = 0;}\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项\"always\"的 正确 代码示例：\n/*eslint block-spacing: \"error\"*/\n\nfunction foo() { return true; }\nif (foo) { bar = 0; }\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项\"never\"的 错误 代码示例：\n/*eslint block-spacing: [\"error\", \"never\"]*/\n\nfunction foo() { return true; }\nif (foo) { bar = 0;}\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项\"never\"的 正确 代码示例：\n/*eslint block-spacing: [\"error\", \"never\"]*/\n\nfunction foo() {return true;}\nif (foo) {bar = 0;}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about spacing style inside of blocks, you can safely disable this rule.\n如果你不想收到单行代码块中间距风格问题的通知，你可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.2.0.\n该规则在 ESLint 1.2.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/block-spacing",
                "disable": false
            },
            {
                "real_name": "brace-style",
                "display_name": "brace-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "大括号风格要求 (brace-style)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Brace Style (brace-style)\n大括号风格要求 (brace-style)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nBrace style is closely related to indent style in programming and describes the placement of braces relative to their control statement and body. There are probably a dozen, if not more, brace styles in the world.\n在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对控制语句和代码块的位置，少说也有十几种。\nThe one true brace style is one of the most common brace styles in JavaScript, in which the opening brace of a block is placed on the same line as its corresponding statement or declaration. For example:\n在 Javascript 中，one true brace style也是最常见的一种，它将大括号放在控制语句或声明语句同一行的位置。例如：\nif (foo) {\n  bar();\n} else {\n  baz();\n}\n\n\nOne common variant of one true brace style is called Stroustrup, in which the else statements in an if-else construct, as well as catch and finally, must be on its own line after the preceding closing brace. For example:\none true brace style的一种常见的变体形式叫做 Stroustrup，if-else中的else语句，连同catch 和 finally，都必须在右括号后另起一行，如下面这个例子：\nif (foo) {\n  bar();\n}\nelse {\n  baz();\n}\n\n\nAnother style is called Allman, in which all the braces are expected to be on their own lines without any extra indentation. For example:\n另一种风格叫做Allman，\n括号必须单独成行且没有任何缩进：\nif (foo)\n{\n  bar();\n}\nelse\n{\n  baz();\n}\n\n\nWhile no style is considered better than the other, most developers agree that having a consistent style throughout a project is important for its long-term maintainability.\n尽管没有哪种风格被认为会比另一种更好，但大多数开发者一致认为在同一项目中保持一致的风格对于长期的可维护性是很重要的。\nRule Details\nThis rule enforces consistent brace style for blocks.\n该规则旨在强制在Javascript中使用特定的括号风格。因此，如果某条语句或声明没有遵守该该风格，该规则将发出警告。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"1tbs\" (default) enforces one true brace style\n\"1tbs\" (默认) 强制 one true brace style\n\"stroustrup\" enforces Stroustrup style\n\"stroustrup\" 强制 Stroustrup style\n\"allman\" enforces Allman style\n\"allman\" 强制 Allman style\n\nThis rule has an object option for an exception:\n该规则可以有例外情况，用对象表示：\n\n\"allowSingleLine\": true (default false) allows the opening and closing braces for a block to be on the same line\n\"allowSingleLine\": true (默认 false) 允许块的开括号和闭括号在 同一行\n\n1tbs\nExamples of incorrect code for this rule with the default \"1tbs\" option:\n选项\"1tbs\"的 错误 代码示例：\n/*eslint brace-style: \"error\"*/\n\nfunction foo()\n{\n  return true;\n}\n\nif (foo)\n{\n  bar();\n}\n\ntry\n{\n  somethingRisky();\n} catch(e)\n{\n  handleError();\n}\n\nif (foo) {\n  bar();\n}\nelse {\n  baz();\n}\n\n\nExamples of correct code for this rule with the default \"1tbs\" option:\n选项\"1tbs\"的 正确 代码示例：\n/*eslint brace-style: \"error\"*/\n\nfunction foo() {\n  return true;\n}\n\nif (foo) {\n  bar();\n}\n\nif (foo) {\n  bar();\n} else {\n  baz();\n}\n\ntry {\n  somethingRisky();\n} catch(e) {\n  handleError();\n}\n\n// when there are no braces, there are no problems\nif (foo) bar();\nelse if (baz) boom();\n\n\nExamples of correct code for this rule with the \"1tbs\", { \"allowSingleLine\": true } options:\n选项\"1tbs\", { \"allowSingleLine\": true }的 正确 代码示例：\n/*eslint brace-style: [\"error\", \"1tbs\", { \"allowSingleLine\": true }]*/\n\nfunction nop() { return; }\n\nif (foo) { bar(); }\n\nif (foo) { bar(); } else { baz(); }\n\ntry { somethingRisky(); } catch(e) { handleError(); }\n\n\nstroustrup\nExamples of incorrect code for this rule with the \"stroustrup\" option:\n选项\"stroustrup\"的 错误 代码示例：\n/*eslint brace-style: [\"error\", \"stroustrup\"]*/\n\nfunction foo()\n{\n  return true;\n}\n\nif (foo)\n{\n  bar();\n}\n\ntry\n{\n  somethingRisky();\n} catch(e)\n{\n  handleError();\n}\n\nif (foo) {\n  bar();\n} else {\n  baz();\n}\n\n\nExamples of correct code for this rule with the \"stroustrup\" option:\n选项\"stroustrup\"的 正确 代码示例：\n/*eslint brace-style: [\"error\", \"stroustrup\"]*/\n\nfunction foo() {\n  return true;\n}\n\nif (foo) {\n  bar();\n}\n\nif (foo) {\n  bar();\n}\nelse {\n  baz();\n}\n\ntry {\n  somethingRisky();\n}\ncatch(e) {\n  handleError();\n}\n\n// when there are no braces, there are no problems\nif (foo) bar();\nelse if (baz) boom();\n\n\nExamples of correct code for this rule with the \"stroustrup\", { \"allowSingleLine\": true } options:\n选项\"stroustrup\", { \"allowSingleLine\": true }的 正确 代码示例：\n/*eslint brace-style: [\"error\", \"stroustrup\", { \"allowSingleLine\": true }]*/\n\nfunction nop() { return; }\n\nif (foo) { bar(); }\n\nif (foo) { bar(); }\nelse { baz(); }\n\ntry { somethingRisky(); }\ncatch(e) { handleError(); }\n\n\nallman\nExamples of incorrect code for this rule with the \"allman\" option:\n选项\"allman\"的 错误 代码示例：\n/*eslint brace-style: [\"error\", \"allman\"]*/\n\nfunction foo() {\n  return true;\n}\n\nif (foo)\n{\n  bar(); }\n\ntry\n{\n  somethingRisky();\n} catch(e)\n{\n  handleError();\n}\n\nif (foo) {\n  bar();\n} else {\n  baz();\n}\n\n\nExamples of correct code for this rule with the \"allman\" option:\n选项\"allman\"的 正确 代码示例：\n/*eslint brace-style: [\"error\", \"allman\"]*/\n\nfunction foo()\n{\n  return true;\n}\n\nif (foo)\n{\n  bar();\n}\n\nif (foo)\n{\n  bar();\n}\nelse\n{\n  baz();\n}\n\ntry\n{\n  somethingRisky();\n}\ncatch(e)\n{\n  handleError();\n}\n\n// when there are no braces, there are no problems\nif (foo) bar();\nelse if (baz) boom();\n\n\nExamples of correct code for this rule with the \"allman\", { \"allowSingleLine\": true } options:\n选项\"allman\", { \"allowSingleLine\": true }的 正确 代码示例：\n/*eslint brace-style: [\"error\", \"allman\", { \"allowSingleLine\": true }]*/\n\nfunction nop() { return; }\n\nif (foo) { bar(); }\n\nif (foo) { bar(); }\nelse { baz(); }\n\ntry { somethingRisky(); }\ncatch(e) { handleError(); }\n\n\nWhen Not To Use It\nIf you don’t want to enforce a particular brace style, don’t enable this rule.\n如果伱不想强制使用一种括号风格，关闭此规则即可。\nFurther Reading\n\nIndent style\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/brace-style",
                "disable": false
            },
            {
                "real_name": "callback-return",
                "display_name": "callback-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制返回callback函数 (callback-return)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce Return After Callback (callback-return)\n强制返回callback函数 (callback-return)\nThe callback pattern is at the heart of most I/O and event-driven programming\nin JavaScript.\n在 JavaScript 中，回调模式是大多数 I/O 和事件驱动编程的核心。\nfunction doSomething(err, callback) {\n    if (err) {\n        return callback(err);\n    }\n    callback();\n}\n\n\nTo prevent calling the callback multiple times it is important to return anytime the callback is triggered outside\n of the main function body. Neglecting this technique often leads to issues where you do something more than once.\n For example, in the case of an HTTP request, you may try to send HTTP headers more than once leading Node.js to throw\n a Can't render headers after they are sent to the client. error.\n为了防止多次调用回调函数，在主函数体外，任何时候触发回调函数使用 return 语句是很重要的。忽视这个技巧，常常会导致问题出现。比如：在 HTTP 请求中，你可能试图多次发送 HTTP 请求导致 Node.js 抛出 Can't render headers after they are sent to the client.错误。\nRule Details\nThis rule is aimed at ensuring that callbacks used outside of the main function block are always part-of or immediately\npreceding a return statement. This rule decides what is a callback based on the name of the function being called.\n该规则只在保证在主函数外使用的回调函数是 return 语句的一部分或紧随 return 语句。该规则决定回调函数的名称。\nOptions\nThe rule takes a single option - an array of possible callback names - which may include object methods. The default callback names are callback, cb, next.\n该规则只有一个选项，是个数组，包含可能的回调函数名称，可能包含对象方法。默认的回调函数名称是 callback，cb，next。\nDefault callback names\nExamples of incorrect code for this rule with the default [\"callback\", \"cb\", \"next\"] option:\n默认选项[\"callback\", \"cb\", \"next\"]的 错误 代码示例：\n/*eslint callback-return: \"error\"*/\n\nfunction foo(err, callback) {\n    if (err) {\n        callback(err);\n    }\n    callback();\n}\n\n\nExamples of correct code for this rule with the default [\"callback\", \"cb\", \"next\"] option:\n默认选项[\"callback\", \"cb\", \"next\"]的 正确 代码示例：\n/*eslint callback-return: \"error\"*/\n\nfunction foo(err, callback) {\n    if (err) {\n        return callback(err);\n    }\n    callback();\n}\n\n\nSupplied callback names\nExamples of incorrect code for this rule with the option [\"done\", \"send.error\", \"send.success\"]:\n选项[\"done\", \"send.error\", \"send.success\"]的 错误 代码示例：\n/*eslint callback-return: [\"error\", [\"done\", \"send.error\", \"send.success\"]]*/\n\nfunction foo(err, done) {\n    if (err) {\n        done(err);\n    }\n    done();\n}\n\nfunction bar(err, send) {\n    if (err) {\n        send.error(err);\n    }\n    send.success();\n}\n\n\nExamples of correct code for this rule with the option [\"done\", \"send.error\", \"send.success\"]:\n选项[\"done\", \"send.error\", \"send.success\"]的 正确 代码示例：\n/*eslint callback-return: [\"error\", [\"done\", \"send.error\", \"send.success\"]]*/\n\nfunction foo(err, done) {\n    if (err) {\n        return done(err);\n    }\n    done();\n}\n\nfunction bar(err, send) {\n    if (err) {\n        return send.error(err);\n    }\n    send.success();\n}\n\n\nKnown Limitations\nBecause it is difficult to understand the meaning of a program through static analysis, this rule has limitations:\n由于很难通过静态分析理解程序的意思，该规则也有它的局限性：\n\nfalse negatives when this rule reports correct code, but the program calls the callback more than one time (which is incorrect behavior)\nfalse negatives 该规则报告了正确的代码，但程序多次调用了回调函数（不正确的行为）\nfalse positives when this rule reports incorrect code, but the program calls the callback only one time (which is correct behavior)\nfalse positives 该规则报告了错误的代码，但程序只调用了一次回调函数（正确的行为）\n\nPassing the callback by reference\nThe static analysis of this rule does not detect that the program calls the callback if it is an argument of a function (for example,  setTimeout).\n该规则的静态分析没有检测回调函数的参数如果是个函数的情况（例如，setTimeout）。\nExample of a false negative when this rule reports correct code:\n当该规则报告了正确的代码时，false negative的示例：\n/*eslint callback-return: \"error\"*/\n\nfunction foo(err, callback) {\n    if (err) {\n        setTimeout(callback, 0); // this is bad, but WILL NOT warn\n    }\n    callback();\n}\n\n\nTriggering the callback within a nested function\nThe static analysis of this rule does not detect that the program calls the callback from within a nested function or an immediately-invoked function expression (IIFE).\n该规则的静态分析没有检测回调函数来自嵌套函数或是个立即执行函数（IIFE）。\nExample of a false negative when this rule reports correct code:\n当该规则报告了正确的代码时，漏报的示例：\n/*eslint callback-return: \"error\"*/\n\nfunction foo(err, callback) {\n    if (err) {\n        process.nextTick(function() {\n            return callback(); // this is bad, but WILL NOT warn\n        });\n    }\n    callback();\n}\n\n\nIf/else statements\nThe static analysis of this rule does not detect that the program calls the callback only one time in each branch of an if statement.\n该规则的静态分析没有检测回调函数在 if 语句的每个分支只调用一次的情况。\nExample of a false positive when this rule reports incorrect code:\n当该规则报告了正确的代码时，漏报的示例：\n/*eslint callback-return: \"error\"*/\n\nfunction foo(err, callback) {\n    if (err) {\n        callback(err); // this is fine, but WILL warn\n    } else {\n        callback();    // this is fine, but WILL warn\n    }\n}\n\n\nWhen Not To Use It\nThere are some cases where you might want to call a callback function more than once. In those cases this rule\n may lead to incorrect behavior. In those cases you may want to reserve a special name for those callbacks and\n not include that in the list of callbacks that trigger warnings.\n在某些情况下你可能需要多次调用回调函数。在这些情况下，此规则可能会导致错误的行为。在这些情况下，你可能想给那些回调保留一个特别的名字，并且不包含在触发警告的回调函数列表里。\nFurther Reading\n\nThe Art Of Node: Callbacks\nNodejitsu: What are the error conventions?\n\nRelated Rules\n\nhandle-callback-err\n\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n此规则在 ESLint 1.0.0-rc-1 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/callback-return",
                "disable": false
            },
            {
                "real_name": "camelcase",
                "display_name": "camelcase",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求使用骆驼拼写法 (camelcase)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Camelcase (camelcase)\n要求使用骆驼拼写法 (camelcase)\nWhen it comes to naming variables, style guides generally fall into one of two camps: camelcase (variableName) and underscores (variable_name). This rule focuses on using the camelcase approach. If your style guide calls for camelcasing your variable names, then this rule is for you!\n当命名变量时，风格指南一般会分为骆驼拼写法 (variableName) 和下划线拼写法 (variable_name) 两大阵营。该规则主要关注骆驼拼写法的用法。如果你的风格指南要求变量名称以驼峰的形式书写，此规则正适合于你。\nRule Details\nThis rule looks for any underscores (_) located within the source code. It ignores leading and trailing underscores and only checks those in the middle of a variable name. If ESLint decides that the variable is a constant (all uppercase), then no warning will be thrown. Otherwise, a warning will be thrown. This rule only flags definitions and assignments but not function calls. In case of ES6 import statements, this rule only targets the name of the variable that will be imported into the local module scope.\n此规则在源码中查找下划线 (_)。它忽略前导和尾部的下划线，只检查在变量名称中间的下划线。如果 ESLint 判断定某个变量是个常量（全部大写），将不会发出警告。否则会发出警告。该规则仅仅标记定义和赋值，不适用于方法调用。在 ES6 import 语句中，该规则只针对将引入到本地模块作用域的变量名。\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"properties\": \"always\" (default) enforces camelcase style for property names\n\"properties\": \"always\" (默认) 强制属性名称为驼峰风格\n\"properties\": \"never\" does not check property names\n\"properties\": \"never\" 不检查属性名称\n\nalways\nExamples of incorrect code for this rule with the default { \"properties\": \"always\" } option:\n默认选项 { \"properties\": \"always\" } 的 错误 代码示例：\n/*eslint camelcase: \"error\"*/\n\nimport { no_camelcased } from \"external-module\"\n\nvar my_favorite_color = \"#112C85\";\n\nfunction do_something() {\n    // ...\n}\n\nobj.do_something = function() {\n    // ...\n};\n\nvar obj = {\n    my_pref: 1\n};\n\n\nExamples of correct code for this rule with the default { \"properties\": \"always\" } option:\n默认选项 { \"properties\": \"always\" } 的 正确 代码示例：\n/*eslint camelcase: \"error\"*/\n\nimport { no_camelcased as camelCased } from \"external-module\";\n\nvar myFavoriteColor   = \"#112C85\";\nvar _myFavoriteColor  = \"#112C85\";\nvar myFavoriteColor_  = \"#112C85\";\nvar MY_FAVORITE_COLOR = \"#112C85\";\nvar foo = bar.baz_boom;\nvar foo = { qux: bar.baz_boom };\n\nobj.do_something();\ndo_something();\nnew do_something();\n\nvar { category_id: category } = query;\n\n\nnever\nExamples of correct code for this rule with the { \"properties\": \"never\" } option:\n选项 { \"properties\": \"never\" } 的 正确 代码示例：\n/*eslint camelcase: [\"error\", {properties: \"never\"}]*/\n\nvar obj = {\n    my_pref: 1\n};\n\n\nWhen Not To Use It\nIf you have established coding standards using a different naming convention (separating words with underscores), turn this rule off.\n如果你已经建立了编码标准，使用了不同的命名约定(用下划线分隔单词)，关闭此规则即可。\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/camelcase",
                "disable": false
            },
            {
                "real_name": "capitalized-comments",
                "display_name": "capitalized-comments",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce or disallow capitalization of the first letter of a comment (capitalized-comments)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce or disallow capitalization of the first letter of a comment (capitalized-comments)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nComments are useful for leaving information for future developers. In order for that information to be useful and not distracting, it is sometimes desirable for comments to follow a particular style. One element of comment formatting styles is whether the first word of a comment should be capitalized or lowercase.\nIn general, no comment style is any more or less valid than any others, but many developers would agree that a consistent style can improve a project’s maintainability.\nRule Details\nThis rule aims to enforce a consistent style of comments across your codebase, specifically by either requiring or disallowing a capitalized letter as the first word character in a comment. This rule will not issue warnings when non-cased letters are used.\nBy default, this rule will require a non-lowercase letter at the beginning of comments.\nExamples of incorrect code for this rule:\n/* eslint capitalized-comments: [\"error\"] */\n\n// lowercase comment\n\n\n\nExamples of correct code for this rule:\n\n// Capitalized comment\n\n// 1. Non-letter at beginning of comment\n\n// 丈 Non-Latin character at beginning of comment\n\n/* eslint semi:off */\n/* eslint-env node */\n/* eslint-disable */\n/* eslint-enable */\n/* istanbul ignore next */\n/* jscs:enable */\n/* jshint asi:true */\n/* global foo */\n/* globals foo */\n/* exported myVar */\n// eslint-disable-line\n// eslint-disable-next-line\n// https://github.com\n\n\n\nOptions\nThis rule has two options: a string value \"always\" or \"never\" which determines whether capitalization of the first word of a comment should be required or forbidden, and optionally an object containing more configuration parameters for the rule.\nHere are the supported object options:\n\nignorePattern: A string representing a regular expression pattern of words that should be ignored by this rule. If the first word of a comment matches the pattern, this rule will not report that comment.\n    \nNote that the following words are always ignored by this rule: [\"jscs\", \"jshint\", \"eslint\", \"istanbul\", \"global\", \"globals\", \"exported\"].\n\n\nignoreInlineComments: If this is true, the rule will not report on comments in the middle of code. By default, this is false.\nignoreConsecutiveComments: If this is true, the rule will not report on a comment which violates the rule, as long as the comment immediately follows another comment. By default, this is false.\n\nHere is an example configuration:\n{\n    \"capitalized-comments\": [\n        \"error\",\n        \"always\",\n        {\n            \"ignorePattern\": \"pragma|ignored\",\n            \"ignoreInlineComments\": true\n        }\n    ]\n}\n\n\n\"always\"\nUsing the \"always\" option means that this rule will report any comments which start with a lowercase letter. This is the default configuration for this rule.\nNote that configuration comments and comments which start with URLs are never reported.\nExamples of incorrect code for this rule:\n/* eslint capitalized-comments: [\"error\", \"always\"] */\n\n// lowercase comment\n\n\n\nExamples of correct code for this rule:\n/* eslint capitalized-comments: [\"error\", \"always\"] */\n\n// Capitalized comment\n\n// 1. Non-letter at beginning of comment\n\n// 丈 Non-Latin character at beginning of comment\n\n/* eslint semi:off */\n/* eslint-env node */\n/* eslint-disable */\n/* eslint-enable */\n/* istanbul ignore next */\n/* jscs:enable */\n/* jshint asi:true */\n/* global foo */\n/* globals foo */\n/* exported myVar */\n// eslint-disable-line\n// eslint-disable-next-line\n// https://github.com\n\n\n\n\"never\"\nUsing the \"never\" option means that this rule will report any comments which start with an uppercase letter.\nExamples of incorrect code with the \"never\" option:\n/* eslint capitalized-comments: [\"error\", \"never\"] */\n\n// Capitalized comment\n\n\n\nExamples of correct code with the \"never\" option:\n/* eslint capitalized-comments: [\"error\", \"never\"] */\n\n// lowercase comment\n\n// 1. Non-letter at beginning of comment\n\n// 丈 Non-Latin character at beginning of comment\n\n\n\nignorePattern\nThe ignorePattern object takes a string value, which is used as a regular expression applied to the first word of a comment.\nExamples of correct code with the \"ignorePattern\" option set to \"pragma\":\n/* eslint capitalized-comments: [\"error\", \"always\", { \"ignorePattern\": \"pragma\" }] */\n\nfunction foo() {\n    /* pragma wrap(true) */\n}\n\n\n\nignoreInlineComments\nSetting the ignoreInlineComments option to true means that comments in the middle of code (with a token on the same line as the beginning of the comment, and another token on the same line as the end of the comment) will not be reported by this rule.\nExamples of correct code with the \"ignoreInlineComments\" option set to true:\n/* eslint capitalized-comments: [\"error\", \"always\", { \"ignoreInlineComments\": true }] */\n\nfunction foo(/* ignored */ a) {\n}\n\n\n\nignoreConsecutiveComments\nIf the ignoreConsecutiveComments option is set to true, then comments which otherwise violate the rule will not be reported as long as they immediately follow another comment. This can be applied more than once.\nExamples of correct code with ignoreConsecutiveComments set to true:\n/* eslint capitalize-comments: [\"error\", \"always\", { \"ignoreConsecutiveComments\": true }] */\n\n// This comment is valid since it has the correct capitalization.\n// this comment is ignored since it follows another comment,\n// and this one as well because it follows yet another comment.\n\n/* Here is a block comment which has the correct capitalization, */\n/* but this one is ignored due to being consecutive; */\n/*\n * in fact, even if any of these are multi-line, that is fine too.\n */\n\n\nExamples of incorrect code with ignoreConsecutiveComments set to true:\n/* eslint capitalize-comments: [\"error\", \"always\", { \"ignoreConsecutiveComments\": true }] */\n\n// this comment is invalid, but only on this line.\n// this comment does NOT get reported, since it is a consecutive comment.\n\n\nUsing Different Options for Line and Block Comments\nIf you wish to have a different configuration for line comments and block comments, you can do so by using two different object configurations (note that the capitalization option will be enforced consistently for line and block comments):\n{\n    \"capitalized-comments\": [\n        \"error\",\n        \"always\",\n        {\n            \"line\": {\n                \"ignorePattern\": \"pragma|ignored\",\n            },\n            \"block\": {\n                \"ignoreInlineComments\": true,\n                \"ignorePattern\": \"ignored\"\n            }\n        }\n    ]\n}\n\n\nExamples of incorrect code with different line and block comment configuration:\n/* eslint capitalized-comments: [\"error\", \"always\", { \"block\": { \"ignorePattern\": \"blockignore\" } }] */\n\n// capitalized line comment, this is incorrect, blockignore does not help here\n/* lowercased block comment, this is incorrect too */\n\n\n\nExamples of correct code with different line and block comment configuration:\n/* eslint capitalized-comments: [\"error\", \"always\", { \"block\": { \"ignorePattern\": \"blockignore\" } }] */\n\n// Uppercase line comment, this is correct\n/* blockignore lowercase block comment, this is correct due to ignorePattern */\n\n\n\nWhen Not To Use It\nThis rule can be disabled if you do not care about the grammatical style of comments in your codebase.\nCompatibility\n\nJSCS: requireCapitalizedComments and disallowCapitalizedComments\n\nVersion\nThis rule was introduced in ESLint 3.11.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/capitalized-comments",
                "disable": false
            },
            {
                "real_name": "class-methods-use-this",
                "display_name": "class-methods-use-this",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce that class methods utilize this (class-methods-use-this)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce that class methods utilize this (class-methods-use-this)\nIf a class method does not use this, it can safely be made a static function.\nIt’s possible to have a class method which doesn’t use this, such as:\nclass A {\n    constructor() {\n        this.a = \"hi\";\n    }\n\n    print() {\n        console.log(this.a);\n    }\n\n    sayHi() {\n        console.log(\"hi\");\n    }\n}\n\nlet a = new A();\na.sayHi(); // => \"hi\"\n\n\nIn the example above, the sayHi method doesn’t use this, so we can make it a static method:\nclass A {\n    constructor() {\n        this.a = \"hi\";\n    }\n\n    print() {\n        console.log(this.a);\n    }\n\n    static sayHi() {\n        console.log(\"hi\");\n    }\n}\n\nA.sayHi(); // => \"hi\"\n\n\nAlso note in the above examples that the code calling the function on an instance of the class (let a = new A(); a.sayHi();) changes to calling it on the class itself (A.sayHi();).\nRule Details\nThis rule is aimed to flag class methods that do not use this.\nExamples of incorrect code for this rule:\n/*eslint class-methods-use-this: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    foo() {\n        console.log(\"Hello World\");     /*error Expected 'this' to be used by class method 'foo'.*/\n    }\n}\n\n\nExamples of correct code for this rule:\n/*eslint class-methods-use-this: \"error\"*/\n/*eslint-env es6*/\nclass A {\n    foo() {\n        this.bar = \"Hello World\"; // OK, this is used\n    }\n}\n\nclass A {\n    constructor() {\n        // OK. constructor is exempt\n    }\n}\n\nclass A {\n    static foo() {\n        // OK. static methods aren't expected to use this.\n    }\n}\n\n\nOptions\nExceptions\n\"class-methods-use-this\": [<enabled>, { \"exceptMethods\": [<...exceptions>] }]\n\n\nThe exceptMethods option allows you to pass an array of method names for which you would like to ignore warnings.\nExamples of incorrect code for this rule when used without exceptMethods:\n/*eslint class-methods-use-this: \"error\"*/\n\nclass A {\n    foo() {\n    }\n}\n\n\nExamples of correct code for this rule when used with exceptMethods:\n/*eslint class-methods-use-this: [\"error\", { \"exceptMethods\": [\"foo\"] }] */\n\nclass A {\n    foo() {\n    }\n}\n\n\nVersion\nThis rule was introduced in ESLint 3.4.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/class-methods-use-this",
                "disable": false
            },
            {
                "real_name": "comma-dangle",
                "display_name": "comma-dangle",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止使用拖尾逗号 (comma-dangle)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow trailing commas (comma-dangle)\n要求或禁止使用拖尾逗号 (comma-dangle)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nTrailing commas in object literals are valid according to the ECMAScript 5 (and ECMAScript 3!) spec. However, IE8 (when not in IE8 document mode) and below will throw an error when it encounters trailing commas in JavaScript.\n根据 ECMAScript5 (和 ECMAScript3!)规范，对象字面量中的拖尾逗号是合法的。然而，在 IE8（非 IE8 文档模式）下，当在 JavaScript 出现拖尾逗号，以下情况下将抛出错误。\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\n\nTrailing commas simplify adding and removing items to objects and arrays, since only the lines you are modifying must be touched.\nAnother argument in favor of trailing commas is that it improves the clarity of diffs when an item is added or removed from an object or array:\n拖尾逗号简化了对象和数组增加或删除元素，因为你只需接触你要修改的行。另一个支持拖尾逗号的观点是，当对象或数组添加或删除元素时，它提高了代码差异的清晰度。\nLess clear:\n不太清晰：\n var foo = {\n-    bar: \"baz\",\n-    qux: \"quux\"\n+    bar: \"baz\"\n };\n\n\nMore clear:\n更清晰：\n var foo = {\n     bar: \"baz\",\n-    qux: \"quux\",\n };\n\n\nRule Details\nThis rule enforces consistent use of trailing commas in object and array literals.\n这个规则强制在对象和数组字面量中使用一致的拖尾逗号。\nOptions\nThis rule has a string option or an object option:\n该规则有一个字符串选项或一个对象选项：\n{\n    \"comma-dangle\": [\"error\", \"never\"],\n    // or\n    \"comma-dangle\": [\"error\", {\n        \"arrays\": \"never\",\n        \"objects\": \"never\",\n        \"imports\": \"never\",\n        \"exports\": \"never\",\n        \"functions\": \"ignore\",\n    }]\n}\n\n\n\n\"never\" (default) disallows trailing commas\n\"never\" (默认) 禁用拖尾逗号\n\"always\" requires trailing commas\n\"always\" 要求使用拖尾逗号\n\"always-multiline\" requires trailing commas when the last element or property is in a different line than the closing ] or } and disallows trailing commas when the last element or property is on the same line as the closing ] or }\n\"always-multiline\" 当最后一个元素或属性与闭括号 ] 或 } 在 不同的行时，要求使用拖尾逗号；当在 同一行时，禁止使用拖尾逗号。\n\"only-multiline\" allows (but does not require) trailing commas when the last element or property is in a different line than the closing ] or } and disallows trailing commas when the last element or property is on the same line as the closing ] or }\n\"only-multiline\" 当最后一个元素或属性与闭括号 ] 或 } 在 不同的行时，允许（但不要求）使用拖尾逗号；当在 同一行时，禁止使用拖尾逗号。\n\nTrailing commas in function declarations and function calls are valid syntax since ECMAScript 2017; however, the string option does not check these situations for backwards compatibility.\n从ECMAScript 2017开始，拖尾逗号在函数声明和函数调用中是有效的语法；然而，字符串选项不会检查这种情况以向后兼容。\nYou can also use an object option to configure this rule for each type of syntax.\n你也可以使用一个对象选项针对每种类型的语法来配置该规则规则。\nEach of the following options can be set to \"never\", \"always\", \"always-multiline\", \"only-multiline\", or \"ignore\".\n以下每个选项可以设置为 \"never\"、\"always\"、\"always-multiline\"、\"only-multiline\" 或 \"ignore\"。\nThe default for each option is \"never\" unless otherwise specified.\n每个选项默认为 \"never\"，除非额外指定。\n\narrays is for array literals and array patterns of destructuring. (e.g. let [a,] = [1,];)\narrays 针对数组字面量和解构赋值的数组模式。(比如 let [a,] = [1,];)\nobjects is for object literals and object patterns of destructuring. (e.g. let {a,} = {a: 1};)\nobjects 针对对象字面量和解构赋值的对象模式。(比如 let {a,} = {a: 1};)\nimports is for import declarations of ES Modules. (e.g. import {a,} from \"foo\";)\nimports 针对 ES 模块的 import 声明。 (比如 import {a,} from \"foo\";)\nexports is for export declarations of ES Modules. (e.g. export {a,};)\nexports 针对 ES 模块的 export 声明。 (比如 export {a,};)\nfunctions is for function declarations and function calls. (e.g. (function(a,){ })(b,);)\nfunctions 针对函数声明和函数调用。 (比如 (function(a,){ })(b,);)\n\nfunctions is set to \"ignore\" by default for consistency with the string option.\nfunctions 默认设置为 \"ignore\" 以与字符串选项保持一致。\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 错误 代码示例：\n/*eslint comma-dangle: [\"error\", \"never\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar arr = [1,2,];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});\n\n\nExamples of correct code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 正确 代码示例：\n/*eslint comma-dangle: [\"error\", \"never\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar arr = [1,2];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint comma-dangle: [\"error\", \"always\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar arr = [1,2];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint comma-dangle: [\"error\", \"always\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar arr = [1,2,];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});\n\n\nalways-multiline\nExamples of incorrect code for this rule with the \"always-multiline\" option:\n选项 \"always-multiline\" 的 错误 代码示例：\n/*eslint comma-dangle: [\"error\", \"always-multiline\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar foo = { bar: \"baz\", qux: \"quux\", };\n\nvar arr = [1,2,];\n\nvar arr = [1,\n    2,];\n\nvar arr = [\n    1,\n    2\n];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});\n\n\nExamples of correct code for this rule with the \"always-multiline\" option:\n选项 \"always-multiline\" 的 正确 代码示例：\n/*eslint comma-dangle: [\"error\", \"always-multiline\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar foo = {bar: \"baz\", qux: \"quux\"};\nvar arr = [1,2];\n\nvar arr = [1,\n    2];\n\nvar arr = [\n    1,\n    2,\n];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});\n\n\nonly-multiline\nExamples of incorrect code for this rule with the \"only-multiline\" option:\n选项 \"only-multiline\" 的 错误 代码示例：\n/*eslint comma-dangle: [\"error\", \"only-multiline\"]*/\n\nvar foo = { bar: \"baz\", qux: \"quux\", };\n\nvar arr = [1,2,];\n\nvar arr = [1,\n    2,];\n\n\n\nExamples of correct code for this rule with the \"only-multiline\" option:\n选项 \"only-multiline\" 的 正确 代码示例：\n/*eslint comma-dangle: [\"error\", \"only-multiline\"]*/\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\",\n};\n\nvar foo = {\n    bar: \"baz\",\n    qux: \"quux\"\n};\n\nvar foo = {bar: \"baz\", qux: \"quux\"};\nvar arr = [1,2];\n\nvar arr = [1,\n    2];\n\nvar arr = [\n    1,\n    2,\n];\n\nvar arr = [\n    1,\n    2\n];\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\",\n});\n\nfoo({\n  bar: \"baz\",\n  qux: \"quux\"\n});\n\n\nfunctions\nExamples of incorrect code for this rule with the {\"functions\": \"never\"} option:\n选项 {\"functions\": \"never\"} 的 错误 代码示例：\n/*eslint comma-dangle: [\"error\", {\"functions\": \"never\"}]*/\n\nfunction foo(a, b,) {\n}\n\nfoo(a, b,);\nnew foo(a, b,);\n\n\nExamples of correct code for this rule with the {\"functions\": \"never\"} option:\n选项 {\"functions\": \"never\"} 的 正确 代码示例：\n/*eslint comma-dangle: [\"error\", {\"functions\": \"never\"}]*/\n\nfunction foo(a, b) {\n}\n\nfoo(a, b);\nnew foo(a, b);\n\n\nExamples of incorrect code for this rule with the {\"functions\": \"always\"} option:\n选项 {\"functions\": \"always\"} 的 错误 代码示例：\n/*eslint comma-dangle: [\"error\", {\"functions\": \"always\"}]*/\n\nfunction foo(a, b) {\n}\n\nfoo(a, b);\nnew foo(a, b);\n\n\nExamples of correct code for this rule with the {\"functions\": \"always\"} option:\n选项 {\"functions\": \"always\"} 的 正确 代码示例：\n/*eslint comma-dangle: [\"error\", {\"functions\": \"always\"}]*/\n\nfunction foo(a, b,) {\n}\n\nfoo(a, b,);\nnew foo(a, b,);\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with dangling commas.\n如果你并不关心拖尾逗号的问题，你可以关闭这个规则。\nVersion\nThis rule was introduced in ESLint 0.16.0.\n该规则在 ESLint 0.16.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/comma-dangle",
                "disable": false
            },
            {
                "real_name": "comma-spacing",
                "display_name": "comma-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在逗号周围使用空格 (comma-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforces spacing around commas (comma-spacing)\n强制在逗号周围使用空格 (comma-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSpacing around commas improve readability of a list of items. Although most of the style guidelines for languages prescribe adding a space after a comma and not before it, it is subjective to the preferences of a project.\n逗号前后的空格可以提高列表项的可读性。对于大多数语言的代码风格来说一般是在逗号之后而不是之前添加一个空格，当然你也可以在项目中按照自己的偏好决定在哪里添加空格。\nvar foo = 1, bar = 2;\nvar foo = 1 ,bar = 2;\n\n\nRule Details\nThis rule enforces consistent spacing before and after commas in variable declarations, array literals, object literals, function parameters, and sequences.\n该规则强制在变量声明、数组字面量、对象字面量、函数参数 和 序列中的逗号左右的空格的一致性。\nThis rule does not apply in an ArrayExpression or ArrayPattern in either of the following cases:\n该规则在 ArrayExpression 或 ArrayPattern 中以下两种情况下不适用：\n\nadjacent null elements\n相邻的空元素\nan initial null element, to avoid conflicts with the array-bracket-spacing rule\n初始化的空元素，以避免与 array-bracket-spacing 规则冲突\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"before\": false (default) disallows spaces before commas\n\"before\": false (默认) 禁止在逗号前使用空格\n\"before\": true requires one or more spaces before commas\n\"before\": true 要求在逗号前使用一个或多个空格\n\"after\": true (default) requires one or more spaces after commas\n\"after\": true (默认) 要求在逗号后使用一个或多个空格\n\"after\": false disallows spaces after commas\n\"after\": false 禁止在逗号后使用空格\n\nafter\nExamples of incorrect code for this rule with the default { \"before\": false, \"after\": true } options:\n默认选项 { \"before\": false, \"after\": true } 的 错误 代码示例：\n/*eslint comma-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n\nvar foo = 1 ,bar = 2;\nvar arr = [1 , 2];\nvar obj = {\"foo\": \"bar\" ,\"baz\": \"qur\"};\nfoo(a ,b);\nnew Foo(a ,b);\nfunction foo(a ,b){}\na ,b\n\n\nExamples of correct code for this rule with the default { \"before\": false, \"after\": true } options:\n默认选项 { \"before\": false, \"after\": true } 的 正确 代码示例：\n/*eslint comma-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n\nvar foo = 1, bar = 2\n    , baz = 3;\nvar arr = [1, 2];\nvar arr = [1,, 3]\nvar obj = {\"foo\": \"bar\", \"baz\": \"qur\"};\nfoo(a, b);\nnew Foo(a, b);\nfunction foo(a, b){}\na, b\n\n\nExample of correct code for this rule with initial null element for the default { \"before\": false, \"after\": true } options:\n当用空元素进行初始化时，默认选项  { \"before\": false, \"after\": true } 的 正确 代码示例：\n/*eslint comma-spacing: [\"error\", { \"before\": false, \"after\": true }]*/\n/*eslint array-bracket-spacing: [\"error\", \"always\"]*/\n\nvar arr = [ , 2, 3 ]\n\n\nbefore\nExamples of incorrect code for this rule with the { \"before\": true, \"after\": false } options:\n选项 { \"before\": true, \"after\": false } 的 错误 代码示例：\n/*eslint comma-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo = 1, bar = 2;\nvar arr = [1 , 2];\nvar obj = {\"foo\": \"bar\", \"baz\": \"qur\"};\nnew Foo(a,b);\nfunction foo(a,b){}\na, b\n\n\nExamples of correct code for this rule with the { \"before\": true, \"after\": false } options:\n选项 { \"before\": true, \"after\": false } 的 正确 代码示例：\n/*eslint comma-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo = 1 ,bar = 2 ,\n    baz = true;\nvar arr = [1 ,2];\nvar arr = [1 ,,3]\nvar obj = {\"foo\": \"bar\" ,\"baz\": \"qur\"};\nfoo(a ,b);\nnew Foo(a ,b);\nfunction foo(a ,b){}\na ,b\n\n\nExamples of correct code for this rule with initial null element for the { \"before\": true, \"after\": false } options:\n当用空元素进行初始化时，选项 { \"before\": true, \"after\": false } 的 正确 代码示例：\n/*eslint comma-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n/*eslint array-bracket-spacing: [\"error\", \"never\"]*/\n\nvar arr = [,2 ,3]\n\n\nWhen Not To Use It\nIf your project will not be following a consistent comma-spacing pattern, turn this rule off.\n如果你的项目不追求一致逗号间距，关闭此规则即可。\nFurther Reading\n\nJavascript\nDojo Style Guide\n\nRelated Rules\n\narray-bracket-spacing\ncomma-style\nspace-in-brackets (deprecated)\nspace-in-parens\nspace-infix-ops\nspace-after-keywords\nspace-unary-ops\nspace-return-throw-case\n\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/comma-spacing",
                "disable": false
            },
            {
                "real_name": "comma-style",
                "display_name": "comma-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "逗号风格 (comma-style)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Comma style (comma-style)\n逗号风格 (comma-style)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThe Comma Style rule enforces styles for comma-separated lists. There are two comma styles primarily used in JavaScript:\n逗号风格规则强制逗号分隔列表使用一致的风格。在 JavaScript 中主要有两种逗号风格:\n\nThe standard style, in which commas are placed at the end of the current line\n标准风格, 即将逗号放置在当前行的末尾\nComma First style, in which commas are placed at the start of the next line\n逗号前置风格, 即将逗号放置在下一行的开始位置\n\nOne of the justifications for using Comma First style is that it can help track missing and trailing commas. These are problematic because missing commas in variable declarations can lead to the leakage of global variables and trailing commas can lead to errors in older versions of IE.\n使用逗号前置风格的一个理由是，它能帮助跟踪遗漏的逗号和拖尾的逗号。在旧版 IE 中，这两种情况都是有问题的：在变量声明中，遗漏逗号会导致全局变量的内存泄漏，而拖尾逗号会导致出现错误。\nRule Details\nThis rule enforce consistent comma style in array literals, object literals, and variable declarations.\n该规则强制在数组字面量、对象字面量和变量声明中使用一致的逗号风格。\nThis rule does not apply in either of the following cases:\n该规则不适用于以下两种情况：\n\ncomma preceded and followed by linebreak (lone comma)\n在逗号前后有换行符 (单独的逗号)\nsingle-line array literals, object literals, and variable declarations\n单行数组字面量、对象字面量和变量声明\n\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"last\" (default) requires a comma after and on the same line as an array element, object property, or variable declaration\n\"last\" (默认) 要求逗号放在数组元素、对象属性或变量声明之后，且在同一行\n\"first\" requires a comma before and on the same line as an array element, object property, or variable declaration\n\"first\" 要求逗号放在数组元素、对象属性或变量声明之前，且在同一行\n\nThis rule also accepts an additional exceptions object:\n该规则还接受一个额外的 exceptions 对象：\n\n\"exceptions\" has properties whose names correspond to node types in the abstract syntax tree (AST) of JavaScript code:\n\n\"exceptions\" 包含与 JavaScript 代码的抽象语法树 (AST) 的节点类型对应的属性：\n\n\"ArrayExpression\": true ignores comma style in array literals\n\"ArrayExpression\": true 忽略数组字面量的逗号风格\n\"ArrayPattern\": true ignores comma style in array patterns of destructuring\n\"ArrayPattern\": true 忽略数组的解构赋值语句中的逗号风格\n\"ArrowFunctionExpression\": true ignores comma style in the parameters of arrow function expressions\n\"ArrowFunctionExpression\": true 忽略箭头函数表达式的参数中的逗号风格\n\"CallExpression\": true ignores comma style in the arguments of function calls\n\"CallExpression\": true 忽略函数调用的参数中的逗号风格\n\"FunctionDeclaration\": true ignores comma style in the parameters of function declarations\n\"FunctionDeclaration\": true 忽略函数声明的参数中的逗号风格\n\"FunctionExpression\": true ignores comma style in the parameters of function expressions\n\"FunctionExpression\": true 忽略函数表达式的参数中的逗号风格\n\"ImportDeclaration\": true ignores comma style in the specifiers of import declarations\n\"ImportDeclaration\": true 忽略 import 语句中的逗号风格\n\"ObjectExpression\": true ignores comma style in object literals\n\"ObjectExpression\": true 忽略对象字面量的逗号风格\n\"ObjectPattern\": true ignores comma style in object patterns of destructuring\n\"ObjectPattern\": true 忽略对象的解构赋值中的逗号风格\n\"VariableDeclaration\": true ignores comma style in variable declarations\n\"VariableDeclaration\": true 忽略变量声明的逗号风格\n\n\n\nA way to determine the node types as defined by ESTree is to use the online demo.\n可以使用 online demo 来确定 ESTree 定义的节点类型。\nlast\nExamples of incorrect code for this rule with the default \"last\" option:\n默认选项 \"last\" 的 错误 代码示例：\n/*eslint comma-style: [\"error\", \"last\"]*/\n\nvar foo = 1\n,\nbar = 2;\n\nvar foo = 1\n  , bar = 2;\n\n\nvar foo = [\"apples\"\n           , \"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1\n        ,\"b:\": 2\n    };\n}\n\n\nExamples of correct code for this rule with the default \"last\" option:\n默认选项 \"last\" 的 正确 代码示例：\n/*eslint comma-style: [\"error\", \"last\"]*/\n\nvar foo = 1, bar = 2;\n\nvar foo = 1,\n    bar = 2;\n\nvar foo = [\"apples\",\n           \"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1,\n        \"b:\": 2\n    };\n}\n\n\nfirst\nExamples of incorrect code for this rule with the \"first\" option:\n选项 \"first\" 的 错误 代码示例：\n/*eslint comma-style: [\"error\", \"first\"]*/\n\nvar foo = 1,\n    bar = 2;\n\nvar foo = [\"apples\",\n           \"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1,\n        \"b:\": 2\n    };\n}\n\n\nExamples of correct code for this rule with the \"first\" option:\n选项 \"first\" 的 正确 代码示例：\n/*eslint comma-style: [\"error\", \"first\"]*/\n\nvar foo = 1, bar = 2;\n\nvar foo = 1\n    ,bar = 2;\n\nvar foo = [\"apples\"\n          ,\"oranges\"];\n\nfunction bar() {\n    return {\n        \"a\": 1\n        ,\"b:\": 2\n    };\n}\n\n\nexceptions\nAn example use case is to enforce comma style only in var statements.\n一个强制 只在变量声明中 使用逗号风格的例子。\nExamples of incorrect code for this rule with sample \"first\", { \"exceptions\": { … } } options:\n选项 \"first\", { \"exceptions\": { … } } 的 错误 代码示例：\n/*eslint comma-style: [\"error\", \"first\", { \"exceptions\": { \"ArrayExpression\": true, \"ObjectExpression\": true } }]*/\n\nvar o = {},\n    a = [];\n\n\nExamples of correct code for this rule with sample \"first\", { \"exceptions\": { … } } options:\n选项 \"first\", { \"exceptions\": { … } } 的 正确 代码示例：\n/*eslint comma-style: [\"error\", \"first\", { \"exceptions\": { \"ArrayExpression\": true, \"ObjectExpression\": true } }]*/\n\nvar o = {fst:1,\n         snd: [1,\n               2]}\n  , a = [];\n\n\nWhen Not To Use It\nThis rule can safely be turned off if your project does not care about enforcing a consistent comma style.\n如果你的项目不强制使用一致的逗号风格，关闭此规则即可。\nFurther Reading\nFor more information on the Comma First style:\n关于逗号前置风格的更多信息请查看：\n\nA better coding convention for lists and object literals in JavaScript by isaacs\nnpm coding style guideline\n\nRelated Rules\n\noperator-linebreak\n\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/comma-style",
                "disable": false
            },
            {
                "real_name": "complexity",
                "display_name": "complexity",
                "severity": "error",
                "category": "correctness",
                "rule_title": "限制圈复杂度 (complexity)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Limit Cyclomatic Complexity (complexity)\n限制圈复杂度 (complexity)\nCyclomatic complexity measures the number of linearly independent paths through a program’s source code. This rule allows setting a cyclomatic complexity threshold.\n圈复杂度数量上表现为覆盖所有代码的独立现行路径条数。该规则允许设置一个圈复杂度阈值。\nfunction a(x) {\n    if (true) {\n        return x; // 1st path\n    } else if (false) {\n        return x+1; // 2nd path\n    } else {\n        return 4; // 3rd path\n    }\n}\n\n\nRule Details\nThis rule is aimed at reducing code complexity by capping the amount of cyclomatic complexity allowed in a program. As such, it will warn when the cyclomatic complexity crosses the configured threshold (default is 20).\n此规则目的在于通过在项目中设置一个圈复杂度阈值来控制代码的复杂度，因此，它将会在圈复杂度超过配置的阈值时发出警告 (默认是 20)。\nExamples of incorrect code for a maximum of 2:\n最大阈值为 2 的 错误 代码示例：\n/*eslint complexity: [\"error\", 2]*/\n\nfunction a(x) {\n    if (true) {\n        return x;\n    } else if (false) {\n        return x+1;\n    } else {\n        return 4; // 3rd path\n    }\n}\n\n\nExamples of correct code for a maximum of 2:\n最大阈值为 2 的 正确 代码示例：\n/*eslint complexity: [\"error\", 2]*/\n\nfunction a(x) {\n    if (true) {\n        return x;\n    } else {\n        return 4;\n    }\n}\n\n\nOptions\nOptionally, you may specify a max object property:\n你可以指定一个包含 max 属性的对象：\n\"complexity\": [\"error\", 2]\n\n\nis equivalent to\n等同于：\n\"complexity\": [\"error\", { \"max\": 2 }]\n\n\nDeprecated: the object property maximum is deprecated. Please use the property max instead.\n弃用：属性 maximum 已弃用。请使用 max 属性。\nWhen Not To Use It\nIf you can’t determine an appropriate complexity limit for your code, then it’s best to disable this rule.\n如果你不能为你的代码确定一个合适的圈复杂度阈值，最好禁用此规则。\nFurther Reading\n\nAbout Complexity\nComplexity Analysis of JavaScript Code\n\nRelated Rules\n\nmax-depth\nmax-len\nmax-nested-callbacks\nmax-params\nmax-statements\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/complexity",
                "disable": false
            },
            {
                "real_name": "computed-property-spacing",
                "display_name": "computed-property-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止或强制在计算属性中使用空格 (computed-property-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow or enforce spaces inside of computed properties (computed-property-spacing)\n禁止或强制在计算属性中使用空格 (computed-property-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhile formatting preferences are very personal, a number of style guides require\nor disallow spaces between computed properties in the following situations:\n虽然代码风格纯属个人偏好，一些代码风格规范要求或禁止在以下情况的对计算属性内使用空格：\n/*eslint-env es6*/\n\nvar obj = { prop: \"value\" };\nvar a = \"prop\";\nvar x = obj[a]; // computed property in object member expression\n\nvar a = \"prop\";\nvar obj = {\n  [a]: \"value\" // computed property key in object literal (ECMAScript 6)\n};\n\n\nRule Details\nThis rule enforces consistent spacing inside computed property brackets.\n该规则旨在保持计算属性内空格的一致性。\nIt either requires or disallows spaces between the brackets and the values inside of them.\nThis rule does not apply to brackets that are separated from the adjacent value by a newline.\n它要求或禁止括号和其内部值之间的空格。括号内相邻的值出现折行的情况，不适用于此规则。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"never\" (default) disallows spaces inside computed property brackets\n\"never\" (默认) 禁止在计算属性内使用空格\n\"always\" requires one or more spaces inside computed property brackets\n\"always\" 要求在计算属性内使用一个或多个空格\n\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 错误 代码示例：\n/*eslint computed-property-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nobj[foo ]\nobj[ 'foo']\nvar x = {[ b ]: a}\nobj[foo[ bar ]]\n\n\nExamples of correct code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 正确 代码示例：\n/*eslint computed-property-spacing: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nobj[foo]\nobj['foo']\nvar x = {[b]: a}\nobj[foo[bar]]\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint computed-property-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nobj[foo]\nvar x = {[b]: a}\nobj[ foo]\nobj['foo' ]\nobj[foo[ bar ]]\nvar x = {[ b]: a}\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint computed-property-spacing: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nobj[ foo ]\nobj[ 'foo' ]\nvar x = {[ b ]: a}\nobj[ foo[ bar ] ]\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of computed properties.\n如果你并不关注计算属性的一致性的话，关闭此规则即可。\nRelated Rules\n\narray-bracket-spacing\ncomma-spacing\nspace-in-parens\n\nVersion\nThis rule was introduced in ESLint 0.23.0.\n该规则在 ESLint 0.23.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/computed-property-spacing",
                "disable": false
            },
            {
                "real_name": "consistent-return",
                "display_name": "consistent-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Require return statements to either always or never specify values (consistent-return).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require return statements to either always or never specify values (consistent-return)\n要求使用一致的 return 语句 (consistent-return)\nUnlike statically-typed languages which enforce that a function returns a specified type of value, JavaScript allows different code paths in a function to return different types of values.\n不像静态类型语言强制要求函数返回一个指定类型的值，JavaScript 允许在一个函数中不同的代码路径返回不同类的值。\nA confusing aspect of JavaScript is that a function returns undefined if any of the following are true:\nJavaScript 中令人感到困惑的一面是：在以下情况下函数返回 undefined ：\n\nit does not execute a return statement before it exits\n在退出之前没有执行 return 语句\nit executes return which does not specify a value explicitly\n执行 return 语句，但没有显式地指定一个值\nit executes return undefined\n执行 return undefined\nit executes return void followed by an expression (for example, a function call)\n执行 return void，其后跟着一个表达式 (例如，一个函数调用)\nit executes return followed by any other expression which evaluates to undefined\n执行 return，其后跟着其它等于 undefined 的表达式\n\nIf any code paths in a function return a value explicitly but some code path do not return a value explicitly, it might be a typing mistake, especially in a large function. In the following example:\n在一个函数中，如果任何代码路径显式的返回一个值，但一些代码路径不显式返回一个值，那么这种情况可能是个书写错误，尤其是在一个较大的函数里。例如下面的例子：\n\na code path through the function returns a Boolean value true\n函数中的某个代码路径返回一个布尔值 true\nanother code path does not return a value explicitly, therefore returns undefined implicitly\n另一个代码路径并不显式地返回一个值，因此隐式地返回 undefined\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    } else {\n        return;\n    }\n}\n\n\nRule Details\nThis rule requires return statements to either always or never specify values. This rule ignores function definitions where the name begins with an uppercase letter, because constructors (when invoked with the new operator) return the instantiated object implicitly if they do not return another object explicitly.\n该规则要求 return 语句要么总是要么从不指定值。该规则忽略名称首字母大写的函数定义，因为构造函数（当使用 new 操作符调用时）如果不显式地返回另一对象，则会隐式地返回实例化的对象。\nExamples of incorrect code for this rule:\n错误 的代码示例：\n/*eslint consistent-return: \"error\"*/\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    } else {\n        return;\n    }\n}\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 的代码示例：\n/*eslint consistent-return: \"error\"*/\n\nfunction doSomething(condition) {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction Foo() {\n    if (!(this instanceof Foo)) {\n        return new Foo();\n    }\n\n    this.a = 0;\n}\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"treatUndefinedAsUnspecified\": false (default) always either specify values or return undefined implicitly only.\n\"treatUndefinedAsUnspecified\": false (默认) 总是指定返回值或隐式返回 undefined 。\n\"treatUndefinedAsUnspecified\": true always either specify values or return undefined explicitly or implicitly.\n\"treatUndefinedAsUnspecified\": true 总是指定返回值或返回 undefined 无论是隐式或显式。\n\ntreatUndefinedAsUnspecified\nExamples of incorrect code for this rule with the default { \"treatUndefinedAsUnspecified\": false } option:\n默认选项 { \"treatUndefinedAsUnspecified\": false } 的 错误 代码示例：\n/*eslint consistent-return: [\"error\", { \"treatUndefinedAsUnspecified\": false }]*/\n\nfunction foo(callback) {\n    if (callback) {\n        return void callback();\n    }\n    // no return statement\n}\n\nfunction bar(condition) {\n    if (condition) {\n        return undefined;\n    }\n    // no return statement\n}\n\n\nExamples of incorrect code for this rule with the { \"treatUndefinedAsUnspecified\": true } option:\n选项 { \"treatUndefinedAsUnspecified\": true } 的 错误 代码示例：\n/*eslint consistent-return: [\"error\", { \"treatUndefinedAsUnspecified\": true }]*/\n\nfunction foo(callback) {\n    if (callback) {\n        return void callback();\n    }\n    return true;\n}\n\nfunction bar(condition) {\n    if (condition) {\n        return undefined;\n    }\n    return true;\n}\n\n\nExamples of correct code for this rule with the { \"treatUndefinedAsUnspecified\": true } option:\n选项 { \"treatUndefinedAsUnspecified\": true } 的 正确 代码示例：\n/*eslint consistent-return: [\"error\", { \"treatUndefinedAsUnspecified\": true }]*/\n\nfunction foo(callback) {\n    if (callback) {\n        return void callback();\n    }\n    // no return statement\n}\n\nfunction bar(condition) {\n    if (condition) {\n        return undefined;\n    }\n    // no return statement\n}\n\n\nWhen Not To Use It\nIf you want to allow functions to have different return behavior depending on code branching, then it is safe to disable this rule.\n如果你想要允许函数根据代码分支有不同的return行为，可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/consistent-return",
                "disable": false
            },
            {
                "real_name": "consistent-this",
                "display_name": "consistent-this",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求一致的 This (consistent-this)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Consistent This (consistent-this)\n要求一致的 This (consistent-this)\nIt is often necessary to capture the current execution context in order to make it available subsequently. A prominent example of this are jQuery callbacks:\n通常，非常有必要获取当前执行环境的上下文以便在后续过程中继续使用。一个常见的例子就是 jQuery 的回调函数：\nvar that = this;\njQuery('li').click(function (event) {\n    // here, \"this\" is the HTMLElement where the click event occurred\n    that.setFoo(42);\n});\n\n\nThere are many commonly used aliases for this such as that, self or me. It is desirable to ensure that whichever alias the team agrees upon is used consistently throughout the application.\nthis 有多个常用的别名，例如 self、that 或 me 。在整个项目中确保团队成员使用同样的别名是一个很有必要的事情。\nRule Details\nThis rule enforces two things about variables with the designated alias names for this:\n该规则指定一个变量作为 this 的别名。它将强制两件事情：\n\nIf a variable with a designated name is declared, it must be either initialized (in the declaration) or assigned (in the same scope as the declaration) the value this.\n如果一个变量声明为一个指定的名称，它 必须 初始化（在声明语句中）或被赋值（与声明语句在同一范围内）为 this。\nIf a variable is initialized or assigned the value this, the name of the variable must be a designated alias.\n如果一个变量初始化或被赋值为 this，那么该变量 必须 是指定的别名。\n\nOptions\nThis rule has one or more string options:\n该规则有一个到两个字符串选项：\n\ndesignated alias names for this (default \"that\")\n为 this 指定别名 (默认 \"that\")\n\nExamples of incorrect code for this rule with the default \"that\" option:\n默认选项 \"that\" 的 错误 代码示例：\n/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that = 42;\n\nvar self = this;\n\nthat = 42;\n\nself = this;\n\n\nExamples of correct code for this rule with the default \"that\" option:\n默认选项 \"that\" 的 正确 代码示例：\n/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that = this;\n\nvar self = 42;\n\nvar self;\n\nthat = this;\n\nfoo.bar = this;\n\n\nExamples of incorrect code for this rule with the default \"that\" option, if the variable is not initialized:\n如果指定的变量没有初始化，默认选项 \"that\" 的 错误 代码示例：\n/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that;\nfunction f() {\n    that = this;\n}\n\n\nExamples of correct code for this rule with the default \"that\" option, if the variable is not initialized:\n如果指定的变量没有初始化，默认选项 \"that\" 的 正确 代码示例：\n/*eslint consistent-this: [\"error\", \"that\"]*/\n\nvar that;\nthat = this;\n\nvar foo, that;\nfoo = 42;\nthat = this;\n\n\nWhen Not To Use It\nIf you need to capture nested context, consistent-this is going to be problematic. Code of that nature is usually difficult to read and maintain and you should consider refactoring it.\n如果你需要获取嵌套的上下文，consistent-this 是会有问题的。这种类型的代码通常很难阅读和维护，你应该考虑重构它。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/consistent-this",
                "disable": false
            },
            {
                "real_name": "constructor-super",
                "display_name": "constructor-super",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Verify calls of super() in constructors (constructor-super).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Verify calls of super() in constructors (constructor-super)\n验证构造函数中 super() 的调用 (constructor-super)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nConstructors of derived classes must call super().\nConstructors of non derived classes must not call super().\nIf this is not observed, the javascript engine will raise a runtime error.\n派生类中的构造函数必须调用 super()。非派生类的构造函数不能调用 super()。如果没有观察到，javascript 引擎将引发一个运行时错误\nThis rule checks whether or not there is a valid super() call.\n该规则检查是否有一个有效的 super() 调用。\nRule Details\nThis rule is aimed to flag invalid/missing super() calls.\n该规则旨在标记无效或缺失的 super() 调用。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint constructor-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() {\n        super();  // This is a SyntaxError.\n    }\n}\n\nclass A extends B {\n    constructor() { }  // Would throw a ReferenceError.\n}\n\n// Classes which inherits from a non constructor are always problems.\nclass A extends null {\n    constructor() {\n        super();  // Would throw a TypeError.\n    }\n}\n\nclass A extends null {\n    constructor() { }  // Would throw a ReferenceError.\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint constructor-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() { }\n}\n\nclass A extends B {\n    constructor() {\n        super();\n    }\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about invalid/missing super() callings in constructors, you can safely disable this rule.\n如果你不想收到构造函数中无效或缺失的 super() 调用，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.24.0.\n该规则在 ESLint 0.24.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/constructor-super",
                "disable": false
            },
            {
                "real_name": "curly",
                "display_name": "curly",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求遵循大括号约定 (curly)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Following Curly Brace Conventions (curly)\n要求遵循大括号约定 (curly)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript allows the omission of curly braces when a block contains only one statement. However, it is considered by many to be best practice to never omit curly braces around blocks, even when they are optional, because it can lead to bugs and reduces code clarity. So the following:\n当代码块只有一条语句时，JavaScript 允许省略大括号。然而，很多人认为，在块区域前后时刻保留大括号是一种最佳实践，即使他们是可有可无的，因为省略大括号会导致错误，并且降低代码的清晰度。所以以下模式：\nif (foo) foo++;\n\n\nCan be rewritten as:\n能被重写为：\nif (foo) {\n    foo++;\n}\n\n\nThere are, however, some who prefer to only use braces when there is more than one statement to be executed.\n然而，依然有人更乐意在有多条执行语句时才使用大括号。\nRule Details\nThis rule is aimed at preventing bugs and increasing code clarity by ensuring that block statements are wrapped in curly braces. It will warn when it encounters blocks that omit curly braces.\n此规则目的在于，通过确保代码块使用了大括号包裹以避免bug的发生，并且增加代码的清晰度\nOptions\nall\nExamples of incorrect code for the default \"all\" option:\n默认选项 \"all\" 的 错误 代码示例：\n/*eslint curly: \"error\"*/\n\nif (foo) foo++;\n\nwhile (bar)\n    baz();\n\nif (foo) {\n    baz();\n} else qux();\n\n\nExamples of correct code for the default \"all\" option:\n默认选项 \"all\" 的 正确 代码示例：\n/*eslint curly: \"error\"*/\n\nif (foo) {\n    foo++;\n}\n\nwhile (bar) {\n    baz();\n}\n\nif (foo) {\n    baz();\n} else {\n    qux();\n}\n\n\nmulti\nBy default, this rule warns whenever if, else, for, while, or do are used without block statements as their body. However, you can specify that block statements should be used only when there are multiple statements in the block and warn when there is only one statement in the block.\n默认情况下当 if、else、for、while 或 do 不使用大括号包裹代码时，会给出警告。然而，你可以指定当块中有多条语句时才使用大括号，而当代码块中只有一条语句时只会给出警告。\nExamples of incorrect code for the \"multi\" option:\n选项 \"multi\" 的 错误 代码示例：\n/*eslint curly: [\"error\", \"multi\"]*/\n\nif (foo) {\n    foo++;\n}\n\nif (foo) bar();\nelse {\n    foo++;\n}\n\nwhile (true) {\n    doSomething();\n}\n\nfor (var i=0; i < items.length; i++) {\n    doSomething();\n}\n\n\nExamples of correct code for the \"multi\" option:\n选项 \"multi\" 的 正确 代码示例：\n/*eslint curly: [\"error\", \"multi\"]*/\n\nif (foo) foo++;\n\nelse foo();\n\nwhile (true) {\n    doSomething();\n    doSomethingElse();\n}\n\n\nmulti-line\nAlternatively, you can relax the rule to allow brace-less single-line if, else if, else, for, while, or do, while still enforcing the use of curly braces for other instances.\n另外，你可以放宽规则，允许在单行中省略大括号，而if、else if、else、for、while 和 do，在其他使用中依然会强制使用大括号。实现如上定制，配置规则如下：\nExamples of incorrect code for the \"multi-line\" option:\n\"multi-line\"选项的 错误 代码示例：\n/*eslint curly: [\"error\", \"multi-line\"]*/\n\nif (foo)\n  doSomething();\nelse\n  doSomethingElse();\n\nif (foo) foo(\n  bar,\n  baz);\n\n\nExamples of correct code for the \"multi-line\" option:\n选项 \"multi-line\" 的 正确 代码示例：\n/*eslint curly: [\"error\", \"multi-line\"]*/\n\nif (foo) foo++; else doSomething();\n\nif (foo) foo++;\nelse if (bar) baz()\nelse doSomething();\n\ndo something();\nwhile (foo);\n\nwhile (foo\n  && bar) baz();\n\nif (foo) {\n    foo++;\n}\n\nif (foo) { foo++; }\n\nwhile (true) {\n    doSomething();\n    doSomethingElse();\n}\n\n\nmulti-or-nest\nYou can use another configuration that forces brace-less if, else if, else, for, while, or do if their body contains only one single-line statement. And forces braces in all other cases.\n如果 if、else if、else、for、while 和 do 的代码主体中只包含一条语句，你可以使用另外一个配置来强制省略大括号。同时在其他的情况下，强制使用大括号。\nExamples of incorrect code for the \"multi-or-nest\" option:\n选项 \"multi-or-nest\" 的 错误 代码示例：\n/*eslint curly: [\"error\", \"multi-or-nest\"]*/\n\nif (!foo)\n    foo = {\n        bar: baz,\n        qux: foo\n    };\n\nwhile (true)\n  if(foo)\n      doSomething();\n  else\n      doSomethingElse();\n\nif (foo) {\n    foo++;\n}\n\nwhile (true) {\n    doSomething();\n}\n\nfor (var i = 0; foo; i++) {\n    doSomething();\n}\n\nif (foo)\n    // some comment\n    bar();\n\n\nExamples of correct code for the \"multi-or-nest\" option:\n选项 \"multi-or-nest\" 的 正确 代码示例：\n/*eslint curly: [\"error\", \"multi-or-nest\"]*/\n\nif (!foo) {\n    foo = {\n        bar: baz,\n        qux: foo\n    };\n}\n\nwhile (true) {\n  if(foo)\n      doSomething();\n  else\n      doSomethingElse();\n}\n\nif (foo)\n    foo++;\n\nwhile (true)\n    doSomething();\n\nfor (var i = 0; foo; i++)\n    doSomething();\n\nif (foo) {\n    // some comment\n    bar();\n}\n\n\nconsistent\nWhen using any of the multi* options, you can add an option to enforce all bodies of a if,\nelse if and else chain to be with or without braces.\n当在使用任何 multi* 选项时，你可以添加一个参数来强制 if、else if 和 else 中所有的代码块使用或者不使用大括号。\nExamples of incorrect code for the \"multi\", \"consistent\" options:\n选项 \"multi\", \"consistent\" 的 错误 代码示例：\n/*eslint curly: [\"error\", \"multi\", \"consistent\"]*/\n\nif (foo) {\n    bar();\n    baz();\n} else\n    buz();\n\nif (foo)\n    bar();\nelse if (faa)\n    bor();\nelse {\n    other();\n    things();\n}\n\nif (true)\n    foo();\nelse {\n    baz();\n}\n\nif (foo) {\n    foo++;\n}\n\n\nExamples of correct code for the \"multi\", \"consistent\" options:\n选项 \"multi\", \"consistent\" 的 正确 代码示例：\n/*eslint curly: [\"error\", \"multi\", \"consistent\"]*/\n\nif (foo) {\n    bar();\n    baz();\n} else {\n    buz();\n}\n\nif (foo) {\n    bar();\n} else if (faa) {\n    bor();\n} else {\n    other();\n    things();\n}\n\nif (true)\n    foo();\nelse\n    baz();\n\nif (foo)\n    foo++;\n\n\n\nWhen Not To Use It\nIf you have no strict conventions about when to use block statements and when not to, you can safely disable this rule.\n如果你没有严格约定何时是否使用块语句，你可以放心的禁用此规则。\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/curly",
                "disable": false
            },
            {
                "real_name": "default-case",
                "display_name": "default-case",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求 Switch 语句中有 Default 分支 (default-case)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Default Case in Switch Statements (default-case)\n要求 Switch 语句中有 Default 分支 (default-case)\nSome code conventions require that all switch statements have a default case, even if the default case is empty, such as:\n一些编码规范中，要求所有的 switch 语句中必须包含 default 分支，即使默认分支中没有任何代码，如下所示：\nswitch (foo) {\n    case 1:\n        doSomething();\n        break;\n\n    case 2:\n        doSomething();\n        break;\n\n    default:\n        // do nothing\n}\n\n\nThe thinking is that it’s better to always explicitly state what the default behavior should be so that it’s clear whether or not the developer forgot to include the default behavior by mistake.\n考虑到开发人员可能会忘记定义默认分支而导致程序发生错误，所以明确规定定义默认分支是很好的选择。\nOther code conventions allow you to skip the default case so long as there is a comment indicating the omission is intentional, such as:\n有些代码规范中允许省略掉 default 分支，但是要写明注释以说明是故意为之。如下：\nswitch (foo) {\n    case 1:\n        doSomething();\n        break;\n\n    case 2:\n        doSomething();\n        break;\n\n    // no default\n}\n\n\nOnce again, the intent here is to show that the developer intended for there to be no default behavior.\n再次指出，以上示例的前提是开发者并没有默认分支的情况需要处理。\nRule Details\nThis rule aims to require default case in switch statements. You may optionally include a // no default after the last case if there is no default case. The comment may be in any desired case, such as // No Default.\n此规则的目的是在 switch 语句中强制声明 default 分支。或者也可以在最后一个 case 分支下，使用 // no default 来表明此处不需要 default 分支。注释可以任何形式出现，比如 // No Default。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint default-case: \"error\"*/\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n}\n\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint default-case: \"error\"*/\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    default:\n        /* code */\n        break;\n}\n\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    // no default\n}\n\nswitch (a) {\n    case 1:\n        /* code */\n        break;\n\n    // No Default\n}\n\n\nOptions\nThis rule accepts a single options argument:\n该规则接受单个选项参数：\n\nSet the commentPattern option to a regular expression string to change the default /^no default$/i comment test pattern\n设置 commentPattern 为一个正则表达式字符串，来改变默认的 /^no default$/i 注释匹配模式\n\ncommentPattern\nExamples of correct code for the { \"commentPattern\": \"^skip\\\\sdefault\" } option:\n选项 { \"commentPattern\": \"^skip\\\\sdefault\" } 的 正确 代码示例：\n/*eslint default-case: [\"error\", { \"commentPattern\": \"^skip\\\\sdefault\" }]*/\n\nswitch(a) {\n    case 1:\n        /* code */\n        break;\n\n    // skip default\n}\n\nswitch(a) {\n    case 1:\n        /* code */\n        break;\n\n    // skip default case\n}\n\n\nWhen Not To Use It\nIf you don’t want to enforce a default case for switch statements, you can safely disable this rule.\n如果你不想要求 switch 中必须要有 default 分支，禁用此规则即可。\nRelated Rules\n\nno-fallthrough\n\nVersion\nThis rule was introduced in ESLint 0.6.0.\n该规则在 ESLint 0.6.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/default-case",
                "disable": false
            },
            {
                "real_name": "dot-location",
                "display_name": "dot-location",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在点号之前或之后换行 (dot-location)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce newline before and after dot (dot-location)\n强制在点号之前或之后换行 (dot-location)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript allows you to place newlines before or after a dot in a member expression.\nJavaScript 允许你在成员表达式中的点操作符之前或之后放置一个换行符。\nConsistency in placing a newline before or after the dot can greatly increase readability.\n点操作符前后一致得放置换行符，可以能大大提供代码可读性。\nvar a = universe.\n        galaxy;\n\nvar b = universe\n       .galaxy;\n\n\nRule Details\nThis rule aims to enforce newline consistency in member expressions. This rule prevents the use of mixed newlines around the dot in a member expression.\n该规则旨在强制成员表达式中强制换行的一致性。防止既在点号操作之前也在之后使用换行符。\nOptions\nThe rule takes one option, a string:\n该规则有个字符串选项：\n\n\nIf it is \"object\", the dot in a member expression should be on the same line as the object portion. The default is \"object\".\n\n\n如果它的值是 \"object\"，表达式中的点号操作符应该和对象部分在同一行。默认是 \"object\"。\n\n\nIf it is \"property\", the dot in a member expression should be on the same line as the property portion.\n\n\n如果它的值是 \"property\"，表达式中的点号操作符应该和属性在同一行。\n\n\nobject\nThe default \"object\" option requires the dot to be on the same line as the object.\n默认选项 \"object\" 要求点操作符和对象部分放在同一行。\nExamples of incorrect code for the default \"object\" option:\n默认选项 \"object\" 的 错误 代码示例：\n/*eslint dot-location: [\"error\", \"object\"]*/\n\nvar foo = object\n.property;\n\n\nExamples of correct code for the default \"object\" option:\n默认选项 \"object\" 的 正确 代码示例：\n/*eslint dot-location: [\"error\", \"object\"]*/\n\nvar foo = object.\nproperty;\nvar bar = object.property;\n\n\nproperty\nThe \"property\" option requires the dot to be on the same line as the property.\n选项 \"property\" 要求点操作符和属性放在同一行。\nExamples of incorrect code for the \"property\" option:\n选项 \"property\" 的 错误 代码示例：\n/*eslint dot-location: [\"error\", \"property\"]*/\n\nvar foo = object.\nproperty;\n\n\nExamples of correct code for the \"property\" option:\n选项 \"property\" 的 正确 代码示例：\n/*eslint dot-location: [\"error\", \"property\"]*/\n\nvar foo = object\n.property;\nvar bar = object.property;\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of newlines before or after dots in member expressions.\n如果你不关心成员表达式中点操作符前后的换行符的一致性，可以关掉此规则。\nRelated Rules\n\nnewline-after-var\ndot-notation\n\nVersion\nThis rule was introduced in ESLint 0.21.0.\n该规则在 ESLint 0.21.0 中被引入\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/dot-location",
                "disable": false
            },
            {
                "real_name": "dot-notation",
                "display_name": "dot-notation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求使用点号 (dot-notation)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Dot Notation (dot-notation)\n要求使用点号 (dot-notation)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIn JavaScript, one can access properties using the dot notation (foo.bar) or square-bracket notation (foo[\"bar\"]). However, the dot notation is often preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.\n在 JavaScript 中，你可以使用点号 (foo.bar) 或者方括号 (foo[\"bar\"])来访问属性。然而，点号通常是首选，因为它更加易读，简洁，也更适于 JavaScript 压缩。\nfoo[\"bar\"];\n\n\nRule Details\nThis rule is aimed at maintaining code consistency and improving code readability by encouraging use of the dot notation style whenever possible. As such, it will warn when it encounters an unnecessary use of square-bracket notation.\n该规则旨在维护代码的一致性，通过鼓励使用点号操作符来提高代码可读性。因此，当遇到不必要的方括号时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint dot-notation: \"error\"*/\n\nvar x = foo[\"bar\"];\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint dot-notation: \"error\"*/\n\nvar x = foo.bar;\n\nvar x = foo[bar];    // Property name is a variable, square-bracket notation required\n\n\nOptions\nThis rule accepts a single options argument:\n该规则接受单个选项参数：\n\nSet the allowKeywords option to false (default is true) to follow ECMAScript version 3 compatible style, avoiding dot notation for reserved word properties.\n为了兼容 ECMAScript 3，设置 allowKeywords 为 false（默认为true），避免对是保留字的属性使用点号。\nSet the allowPattern option to a regular expression string to allow bracket notation for property names that match a pattern (by default, no pattern is tested).\n将 allowPattern设置为一个正则表达式字符串允许匹配这个模式的属性名使用括号。（默认情况下,没有匹配模式）。\n\nallowKeywords\nExamples of correct code for the { \"allowKeywords\": false } option:\n选项 { \"allowKeywords\": false } 的 正确 代码示例：\n/*eslint dot-notation: [\"error\", { \"allowKeywords\": false }]*/\n\nvar foo = { \"class\": \"CS 101\" }\nvar x = foo[\"class\"]; // Property name is a reserved word, square-bracket notation required\n\n\nallowPattern\nFor example, when preparing data to be sent to an external API, it is often required to use property names that include underscores. If the camelcase rule is in effect, these snake case properties would not be allowed. By providing an allowPattern to the dot-notation rule, these snake case properties can be accessed with bracket notation.\n例如，当把准备好的数据发送到外部接口时，经常要求使用包括下划线的属性名。如果启用了 camelcase 规则，这些 snake case 属性将不被允许使用。通过给 dot-notation 规则提供 allowPattern 选项，这些属性就可以使用括号来访问了。\nExamples of correct code for the sample { \"allowPattern\": \"^[a-z]+(_[a-z]+)+$\" } option:\n选项 { \"allowPattern\": \"^[a-z]+(_[a-z]+)+$\" } 的 正确 代码示例：\n/*eslint camelcase: \"error\"*/\n/*eslint dot-notation: [\"error\", { \"allowPattern\": \"^[a-z]+(_[a-z]+)+$\" }]*/\n\nvar data = {};\ndata.foo_bar = 42;\n\nvar data = {};\ndata[\"fooBar\"] = 42;\n\nvar data = {};\ndata[\"foo_bar\"] = 42; // no warning\n\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/dot-notation",
                "disable": false
            },
            {
                "real_name": "eol-last",
                "display_name": "eol-last",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止文件末尾保留一行空行 (eol-last)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow newline at the end of files (eol-last)\n要求或禁止文件末尾保留一行空行 (eol-last)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nTrailing newlines in non-empty files are a common UNIX idiom. Benefits of\ntrailing newlines include the ability to concatenate or append to files as well\nas output files to the terminal without interfering with shell prompts.\n在非空文件中存在拖尾换行是一个常见的 UNIX 风格。它的好处同输出文件到终端一样，方便在串联和追加文件时不会打断 shell 的提示。\nRule Details\nThis rule enforces at least one newline (or absence thereof) at the end\nof non-empty files.\n该规则要求在非空文件末尾至少存在一行空行（或缺少换行）。\nPrior to v0.16.0 this rule also enforced that there was only a single line at\nthe end of the file. If you still want this behaviour, consider enabling\nno-multiple-empty-lines with maxEOF and/or\nno-trailing-spaces.\n在 v0.16.0 之前此规则还强制在文件末尾只有一行空行。如果你仍然想要这样，可以考虑开启 no-multiple-empty-lines 使用 maxEOF 和/或 no-trailing-spaces。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint eol-last: [\"error\", \"always\"]*/\n\nfunction doSmth() {\n  var foo = 2;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint eol-last: [\"error\", \"always\"]*/\n\nfunction doSmth() {\n  var foo = 2;\n}\\n\n\n\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"always\" (default) enforces that files end with a newline (LF)\n\"always\" (默认) 强制使用换行 (LF)\n\"never\" enforces that files do not end with a newline\n\"never\" 强制文件末尾不要有换行符\n\"unix\" (deprecated) is identical to “always”\n\"unix\" (弃用) 等效于 “always”\n\"windows\" (deprecated) is identical to “always”, but will use a CRLF character when autofixing\n\"windows\" (弃用) 等效于 “always”，但是自动修复时将使用回车换行 (CRLF)\n\nDeprecated: The options \"unix\" and \"windows\" are deprecated. If you need to enforce a specific linebreak style, use this rule in conjunction with linebreak-style.\n弃用：\"unix\" 和 \"windows\" 选项已被弃用。 如果你需要强制一种指定的换行风格，结合 linebreak-style 规则一起使用。\nVersion\nThis rule was introduced in ESLint 0.7.1.\n该规则在 ESLint 0.7.1 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/eol-last",
                "disable": false
            },
            {
                "real_name": "eqeqeq",
                "display_name": "eqeqeq",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "要求使用 === 和 !== (eqeqeq)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require === and !== (eqeqeq)\r\n要求使用 === 和 !== (eqeqeq)\r\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\r\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\r\nIt is considered good practice to use the type-safe equality operators === and !== instead of their regular counterparts == and !=.\r\n使用类型安全的 === 和 !== 操作符代替 == 和 != 操作符是一个很好的实践。\r\nThe reason for this is that == and != do type coercion which follows the rather obscure Abstract Equality Comparison Algorithm.\r\nFor instance, the following statements are all considered true:\r\n这样做的原因是，== 和 != 遵循 Abstract Equality Comparison Algorithm 作强制转型。例如，以下语句被认为是 true。\r\n\r\n[] == false\r\n[] == false\r\n[] == ![]\r\n[] == ![]\r\n3 == \"03\"\r\n3 == \"03\"\r\n\r\nIf one of those occurs in an innocent-looking statement such as a == b the actual problem is very difficult to spot.\r\n如果它们中的任何一个出现在一个看上去无害的语句中，比如 a == b ，那么实际的问题是很难被发现的。\r\nRule Details\r\nThis rule is aimed at eliminating the type-unsafe equality operators.\r\n该规则旨在消除非类型安全的相等操作符。\r\nExamples of incorrect code for this rule:\r\n错误 代码示例：\r\n/*eslint eqeqeq: \"error\"*/\r\n\r\nif (x == 42) { }\r\n\r\nif (\"\" == text) { }\r\n\r\nif (obj.getStuff() != undefined) { }\r\n\r\n\r\nThe --fix option on the command line automatically fixes some problems reported by this rule. A problem is only fixed if one of the operands is a typeof expression, or if both operands are literals with the same type.\r\n命令行中的 --fix 选项可以自动修复该规则报告的一些问题。该规则唯一问题是只修复操作数之一是 typeof 表达式的或操作数是相同类型的字面量。\r\nOptions\r\nalways\r\nThe \"always\" option (default) enforces the use of === and !== in every situation (except when you opt-in to more specific handling of null [see below]).\r\n选项 \"always\"（默认）强制在任何情况下都使用 === 和 !== （除非你选择对 null 有更具体的处理[见下文]）。\r\nExamples of incorrect code for the \"always\" option:\r\n选项 \"always\" 的 错误 代码示例：\r\n/*eslint eqeqeq: [\"error\", \"always\"]*/\r\n\r\na == b\r\nfoo == true\r\nbananas != 1\r\nvalue == undefined\r\ntypeof foo == 'undefined'\r\n'hello' != 'world'\r\n0 == 0\r\ntrue == true\r\nfoo == null\r\n\r\n\r\n\r\nExamples of correct code for the \"always\" option:\r\n选项 \"always\" 的 正确 代码示例：\r\n/*eslint eqeqeq: [\"error\", \"always\"]*/\r\n\r\na === b\r\nfoo === true\r\nbananas !== 1\r\nvalue === undefined\r\ntypeof foo === 'undefined'\r\n'hello' !== 'world'\r\n0 === 0\r\ntrue === true\r\nfoo === null\r\n\r\n\r\n\r\nThis rule optionally takes a second argument, which should be an object with the following supported properties:\r\n该规则可以有第二个参数，是个对象，支持以下属性：\r\n\r\n\"null\": Customize how this rule treats null literals. Possible values:\r\n\"null\": 自定义如何对待 null 字面量。可能的值：\r\n    \r\nalways (default) - Always use === or !==.\r\nalways (默认) - 总是使用 === 或 !==.\r\nnever - Never use === or !== with null.\r\nnever - 从不和 null 一起使用 === 或 !==。\r\nignore - Do not apply this rule to null.\r\nignore - 不要对 null 应用此规则。\r\n\r\n\r\n\r\nsmart\r\nThe \"smart\" option enforces the use of === and !== except for these cases:\r\n选项 \"smart\" 除了以下这些情况外，强制使用 === 和 !==：\r\n\r\nComparing two literal values\r\n比较两个字面量的值\r\nEvaluating the value of typeof\r\n比较 typeof 的值\r\nComparing against null\r\n与 null 进行比较\r\n\r\nExamples of incorrect code for the \"smart\" option:\r\n选项 \"always\" 的 错误 代码示例：\r\n/*eslint eqeqeq: [\"error\", \"smart\"]*/\r\n\r\n// comparing two variables requires ===\r\na == b\r\n\r\n// only one side is a literal\r\nfoo == true\r\nbananas != 1\r\n\r\n// comparing to undefined requires ===\r\nvalue == undefined\r\n\r\n\r\nExamples of correct code for the \"smart\" option:\r\n选项 \"smart\" 的 正确 代码示例：\r\n/*eslint eqeqeq: [\"error\", \"smart\"]*/\r\n\r\ntypeof foo == 'undefined'\r\n'hello' != 'world'\r\n0 == 0\r\ntrue == true\r\nfoo == null\r\n\r\n\r\nallow-null\r\nDeprecated: Instead of using this option use “always” and pass a “null” option property with value “ignore”. This will tell eslint to always enforce strict equality except when comparing with the null literal.\r\n弃用： 使用 “always”，然后传一个 “null” 选项，属性值为 “ignore” 代替。这将告诉 eslint 除了与 null 字面量进行比较时，总是强制使用绝对相等。\r\n[\"error\", \"always\", {\"null\": \"ignore\"}]\r\n\r\n\r\nWhen Not To Use It\r\nIf you don’t want to enforce a style for using equality operators, then it’s safe to disable this rule.\r\n如果你不想强制使用相等操作符，可以禁用此规则。\r\nVersion\r\nThis rule was introduced in ESLint 0.0.2.\r\n该规则在 ESLint 0.0.2 中被引入。\r\nResources\r\n\r\nRule source\r\nDocumentation source\r\n\r\n\r\n\r\n可参考官网：\r\nhttps://cn.eslint.org/docs/rules/eqeqeq",
                "disable": false
            },
            {
                "real_name": "for-direction",
                "display_name": "for-direction",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce “for” loop update clause moving the counter in the right direction. (for-direction)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce “for” loop update clause moving the counter in the right direction. (for-direction)\nRule Details\nA for loop with a stop condition that can never be reached, such as one with a counter that moves in the wrong direction, will run infinitely. While there are occasions when an infinite loop is intended, the convention is to construct such loops as while loops. More typically, an infinite for loop is a bug.\nExamples of incorrect code for this rule:\n/*eslint for-direction: \"error\"*/\nfor (var i = 0; i < 10; i--) {\n}\n\nfor (var i = 10; i >= 0; i++) {\n}\n\n\nExamples of correct code for this rule:\n/*eslint for-direction: \"error\"*/\nfor (var i = 0; i < 10; i++) {\n}\n\n\nVersion\nThis rule was introduced in ESLint 4.0.0-beta.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/for-direction",
                "disable": false
            },
            {
                "real_name": "func-call-spacing",
                "display_name": "func-call-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require or disallow spacing between function identifiers and their invocations (func-call-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow spacing between function identifiers and their invocations (func-call-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nWhen calling a function, developers may insert optional whitespace between the function’s name and the parentheses that invoke it. The following pairs of function calls are equivalent:\nalert('Hello');\nalert ('Hello');\n\nconsole.log(42);\nconsole.log (42);\n\nnew Date();\nnew Date ();\n\n\nRule Details\nThis rule requires or disallows spaces between the function name and the opening parenthesis that calls it.\noptions\nThis rule has a string option:\n\n\"never\" (default) disallows space between the function name and the opening parenthesis.\n\"always\" requires space between the function name and the opening parenthesis.\n\nFurther, in \"always\" mode, a second object option is available that contains a single boolean allowNewlines property.\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n/*eslint func-call-spacing: [\"error\", \"never\"]*/\n\nfn ();\n\nfn\n();\n\n\nExamples of correct code for this rule with the default \"never\" option:\n/*eslint func-call-spacing: [\"error\", \"never\"]*/\n\nfn();\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n/*eslint func-call-spacing: [\"error\", \"always\"]*/\n\nfn();\n\nfn\n();\n\n\nExamples of correct code for this rule with the \"always\" option:\n/*eslint func-call-spacing: [\"error\", \"always\"]*/\n\nfn ();\n\n\nallowNewlines\nBy default, \"always\" does not allow newlines. To permit newlines when in \"always\" mode, set the allowNewlines option to true. Newlines are never required.\nExamples of incorrect code for this rule with allowNewlines option enabled:\n/*eslint func-call-spacing: [\"error\", \"always\", { \"allowNewlines\": true }]*/\n\nfn();\n\n\nExamples of correct code for this rule with the allowNewlines option enabled:\n/*eslint func-call-spacing: [\"error\", \"always\", { \"allowNewlines\": true }]*/\n\nfn (); // Newlines are never required.\n\nfn\n();\n\n\nWhen Not To Use It\nThis rule can safely be turned off if your project does not care about enforcing a consistent style for spacing within function calls.\nRelated Rules\n\nno-spaced-func (deprecated)\n\nCompatibility\n\nJSCS: disallowSpacesInCallExpression\nJSCS: requireSpacesInCallExpression\n\nVersion\nThis rule was introduced in ESLint 3.3.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/func-call-spacing",
                "disable": false
            },
            {
                "real_name": "func-name-matching",
                "display_name": "func-name-matching",
                "severity": "warning",
                "category": "convention",
                "rule_title": "require function names to match the name of the variable or property to which they are assigned (func-name-matching)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require function names to match the name of the variable or property to which they are assigned (func-name-matching)\r\nRule Details\r\nThis rule requires function names to match the name of the variable or property to which they are assigned. The rule will ignore property assignments where the property name is a literal that is not a valid identifier in the ECMAScript version specified in your configuration (default ES5).\r\nOptions\r\nThis rule takes an optional string of “always” or “never” (when omitted, it defaults to “always”), and an optional options object with one key, includeCommonJSModuleExports, and a boolean value. This option defaults to false, which means that module.exports and module[\"exports\"] are ignored by this rule. If includeCommonJSModuleExports is set to true, module.exports and module[\"exports\"] will be checked by this rule.\r\nExamples of incorrect code for this rule:\r\n/*eslint func-name-matching: \"error\"*/\r\n\r\nvar foo = function bar() {};\r\nfoo = function bar() {};\r\nobj.foo = function bar() {};\r\nobj['foo'] = function bar() {};\r\nvar obj = {foo: function bar() {}};\r\n({['foo']: function bar() {}});\r\n\r\n\r\n/*eslint func-name-matching: [\"error\", { \"includeCommonJSModuleExports\": true }]*/\r\n/*eslint func-name-matching: [\"error\", \"always\", { \"includeCommonJSModuleExports\": true }]*/ // these are equivalent\r\n\r\nmodule.exports = function foo(name) {};\r\nmodule['exports'] = function foo(name) {};\r\n\r\n\r\n/*eslint func-name-matching: [\"error\", \"never\"] */\r\n\r\nvar foo = function foo() {};\r\nfoo = function foo() {};\r\nobj.foo = function foo() {};\r\nobj['foo'] = function foo() {};\r\nvar obj = {foo: function foo() {}};\r\n({['foo']: function foo() {}});\r\n\r\n\r\nExamples of correct code for this rule:\r\n/*eslint func-name-matching: \"error\"*/\r\n/*eslint func-name-matching: [\"error\", \"always\"]*/ // these are equivalent\r\n/*eslint-env es6*/\r\n\r\nvar foo = function foo() {};\r\nvar foo = function() {};\r\nvar foo = () => {};\r\nfoo = function foo() {};\r\n\r\nobj.foo = function foo() {};\r\nobj['foo'] = function foo() {};\r\nobj['foo//bar'] = function foo() {};\r\nobj[foo] = function bar() {};\r\n\r\nvar obj = {foo: function foo() {}};\r\nvar obj = {[foo]: function bar() {}};\r\nvar obj = {'foo//bar': function foo() {}};\r\nvar obj = {foo: function() {}};\r\n\r\nobj['x' + 2] = function bar(){};\r\nvar [ bar ] = [ function bar(){} ];\r\n({[foo]: function bar() {}})\r\n\r\nmodule.exports = function foo(name) {};\r\nmodule['exports'] = function foo(name) {};\r\n\r\n\r\n/*eslint func-name-matching: [\"error\", \"never\"] */\r\n/*eslint-env es6*/\r\n\r\nvar foo = function bar() {};\r\nvar foo = function() {};\r\nvar foo = () => {};\r\nfoo = function bar() {};\r\n\r\nobj.foo = function bar() {};\r\nobj['foo'] = function bar() {};\r\nobj['foo//bar'] = function foo() {};\r\nobj[foo] = function foo() {};\r\n\r\nvar obj = {foo: function bar() {}};\r\nvar obj = {[foo]: function foo() {}};\r\nvar obj = {'foo//bar': function foo() {}};\r\nvar obj = {foo: function() {}};\r\n\r\nobj['x' + 2] = function bar(){};\r\nvar [ bar ] = [ function bar(){} ];\r\n({[foo]: function bar() {}})\r\n\r\nmodule.exports = function foo(name) {};\r\nmodule['exports'] = function foo(name) {};\r\n\r\n\r\nWhen Not To Use It\r\nDo not use this rule if you want to allow named functions to have different names from the variable or property to which they are assigned.\r\nCompatibility\r\n\r\nJSCS: requireMatchingFunctionName\r\n\r\nVersion\r\nThis rule was introduced in ESLint 3.8.0.\r\nResources\r\n\r\nRule source\r\nDocumentation source\r\n\r\n\r\n\r\n可参考官网：\r\nhttps://cn.eslint.org/docs/rules/func-name-matching",
                "disable": false
            },
            {
                "real_name": "func-names",
                "display_name": "func-names",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Require or disallow named function expressions (func-names).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow named function expressions (func-names)\n要求或禁止命名的 function 表达式 (func-names)\nA pattern that’s becoming more common is to give function expressions names to aid in debugging. For example:\n给函数表达式加个名字可以方便调试，这种模式越来越普遍。例如：\nFoo.prototype.bar = function bar() {};\n\n\nAdding the second bar in the above example is optional.  If you leave off the function name then when the function throws an exception you are likely to get something similar to anonymous function in the stack trace.  If you provide the optional name for a function expression then you will get the name of the function expression in the stack trace.\n在上面的例子中添加第二个 bar是可选的。如果不使用函数名的话，当该函数抛出异常时，你可能得到一些类似于堆栈里 anonymous function 的东西。如果你为函数表达式提供了可选名称，你将在堆栈中找到该函数表达式的名称。\nRule Details\nThis rule can enforce or disallow the use of named function expressions.\n该规则要求或禁止命名的 function 表达式。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"always\" (default) requires function expressions to have a name\n\"always\" (默认) 要求函数表达式有一个名字\n\"as-needed\" requires function expressions to have a name, if the name cannot be assigned automatically in an ES6 environment\n\"as-needed\" 如果 在 ES6 环境中，这个函数名无法自动被赋值，要求函数表达式有一个名字\n\"never\" disallows named function expressions, except in recursive functions, where a name is needed\n\"never\" 禁止命名函数表达式，除非在递归函数中，名字是需要的\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint func-names: [\"error\", \"always\"]*/\n\nFoo.prototype.bar = function() {};\n\n(function() {\n    // ...\n}())\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint func-names: [\"error\", \"always\"]*/\n\nFoo.prototype.bar = function bar() {};\n\n(function bar() {\n    // ...\n}())\n\n\nas-needed\nECMAScript 6 introduced a name property on all functions. The value of name is determined by evaluating the code around the function to see if a name can be inferred. For example, a function assigned to a variable will automatically have a name property equal to the name of the variable. The value of name is then used in stack traces for easier debugging.\nECMAScript 6 的所有函数中都有一个 name 属性。name值是根据函数的代码来推断的。比如，一个函数赋值给一个变量将会自动有一个 name 属性等同于变量的名称。在堆栈跟踪中使用 name值，更容易调试。\nExamples of incorrect code for this rule with the \"as-needed\" option:\n选项 \"as-needed\" 的 错误 代码示例：\n/*eslint func-names: [\"error\", \"as-needed\"]*/\n\nFoo.prototype.bar = function() {};\n\n(function() {\n    // ...\n}())\n\n\nExamples of correct code for this rule with the \"as-needed\" option:\n选项 \"as-needed\" 的 正确 代码示例：\n/*eslint func-names: [\"error\", \"as-needed\"]*/\n\nvar bar = function() {};\n\n(function bar() {\n    // ...\n}())\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint func-names: [\"error\", \"never\"]*/\n\nFoo.prototype.bar = function bar() {};\n\n(function bar() {\n    // ...\n}())\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint func-names: [\"error\", \"never\"]*/\n\nFoo.prototype.bar = function() {};\n\n(function() {\n    // ...\n}())\n\n\nFurther Reading\n\nFunctions Explained\nFunction Names in ES6\n\nCompatibility\n\nJSCS: requireAnonymousFunctions\nJSCS: disallowAnonymousFunctions\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/func-names",
                "disable": false
            },
            {
                "real_name": "func-style",
                "display_name": "func-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce the consistent use of either function declarations or expressions (func-style).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce the consistent use of either function declarations or expressions (func-style)\n强制 function 声明或表达式的一致性 (func-style)\nThere are two ways of defining functions in JavaScript: function declarations and function expressions. Declarations contain the function keyword first, followed by a name and then its arguments and the function body, for example:\n在 Javascript 中，有两种方式定义函数：function 声明和 function 表达式。函数声明是以 function 关键字开头，然后是函数的名字，其次是它的参数和函数主体，例如：\nfunction doSomething() {\n    // ...\n}\n\n\nEquivalent function expressions begin with the var keyword, followed by a name and then the function itself, such as:\n函数表达式以 var 关键字开头，后面是函数的名称，然后是函数本身，例如：\nvar doSomething = function() {\n    // ...\n};\n\n\nThe primary difference between function declarations and function expressions is that declarations are hoisted to the top of the scope in which they are defined, which allows you to write code that uses the function before its declaration. For example:\n函数声明和函数表达式的主要区别是：所有的声明都被提升到当前作用域的顶部，这就意味着可以把调用它的语句放在函数声明之前。例如：\ndoSomething();\n\nfunction doSomething() {\n    // ...\n}\n\n\nAlthough this code might seem like an error, it actually works fine because JavaScript engines hoist the function declarations to the top of the scope. That means this code is treated as if the declaration came before the invocation.\n虽然这段代码可能看起来像一个错误，但实际上由于 Javascript 引擎将函数声明提升到了作用域顶部，这段代码是可以运行的。这就意味着这段代码被视为在调用之前进行了声明。\nFor function expressions, you must define the function before it is used, otherwise it causes an error. Example:\n对于 function 表达式，必须在使用它之前进行定义，否则将会导致错误。例如：\ndoSomething();  // error!\n\nvar doSomething = function() {\n    // ...\n};\n\n\nIn this case, doSomething() is undefined at the time of invocation and so causes a runtime error.\n在这个例子中，doSomething()在调用时是没有定义的，所以导致运行时错误。\nDue to these different behaviors, it is common to have guidelines as to which style of function should be used. There is really no correct or incorrect choice here, it is just a preference.\n由于这些不同的行为，关于应该使用哪种类型的函数，一般要制定一些准则。这种选择没有正确或错误之分，只是一种偏好而已。\nRule Details\nThis rule enforces a particular type of function style throughout a JavaScript file, either declarations or expressions. You can specify which you prefer in the configuration.\n该规则强制在一个 JavaScript 文件中强制使用一种特定的 function 风格：函数声明或函数表达式。你可以在配置文件中指定你喜欢的。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"expression\" (default) requires the use of function expressions instead of function declarations\n\"expression\" (默认) 要求使用函数表达式而不是函数声明\n\"declaration\" requires the use of function declarations instead of function expressions\n\"declaration\" 要求使用函数声明而不是函数表达式\n\nThis rule has an object option for an exception:\n该规则对表达式有一个对象选项：\n\n\"allowArrowFunctions\": true (default false) allows the use of arrow functions\n\"allowArrowFunctions\": true (默认为 false) 允许使用箭头函数\n\nexpression\nExamples of incorrect code for this rule with the default \"expression\" option:\n默认选项 \"expression\" 的 错误 代码示例：\n/*eslint func-style: [\"error\", \"expression\"]*/\n\nfunction foo() {\n    // ...\n}\n\n\nExamples of correct code for this rule with the default \"expression\" option:\n默认选项 \"expression\" 的 正确 代码示例：\n/*eslint func-style: [\"error\", \"expression\"]*/\n\nvar foo = function() {\n    // ...\n};\n\n\ndeclaration\nExamples of incorrect code for this rule with the \"declaration\" option:\n选项 \"declaration\" 的 错误 代码示例：\n/*eslint func-style: [\"error\", \"declaration\"]*/\n\nvar foo = function() {\n    // ...\n};\n\nvar foo = () => {};\n\n\nExamples of correct code for this rule with the \"declaration\" option:\n选项 \"declaration\" 的 正确 代码示例：\n/*eslint func-style: [\"error\", \"declaration\"]*/\n\nfunction foo() {\n    // ...\n}\n\n// Methods (functions assigned to objects) are not checked by this rule\nSomeObject.foo = function() {\n    // ...\n};\n\n\nallowArrowFunctions\nExamples of additional correct code for this rule with the \"declaration\", { \"allowArrowFunctions\": true } options:\n选项 \"declaration\", { \"allowArrowFunctions\": true } 的 正确 代码示例：\n/*eslint func-style: [\"error\", \"declaration\", { \"allowArrowFunctions\": true }]*/\n\nvar foo = () => {};\n\n\nWhen Not To Use It\nIf you want to allow developers to each decide how they want to write functions on their own, then you can disable this rule.\n如果你允许每个开发者自己决定使用那种风格的函数，则可以禁用此规则。\nFurther Reading\n\nJavaScript Scoping and Hoisting\n\nVersion\nThis rule was introduced in ESLint 0.2.0.\n该规则在 ESLint 0.2.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/func-style",
                "disable": false
            },
            {
                "real_name": "function-paren-newline",
                "display_name": "function-paren-newline",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce consistent line breaks inside function parentheses.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "1.Unexpected newline after '('.\n2.Expected a newline after '('.\n3.Unexpected newline before ')'.\n4.Expected a newline before ')'.\n可参考官网：\nhttps://cn.eslint.org/docs/rules/function-paren-newline",
                "disable": false
            },
            {
                "real_name": "generator-star-spacing",
                "display_name": "generator-star-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制 generator 函数中 * 号周围有空格 (generator-star-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce spacing around the * in generator functions (generator-star-spacing)\n强制 generator 函数中 * 号周围有空格 (generator-star-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nGenerators are a new type of function in ECMAScript 6 that can return multiple values over time.\nThese special functions are indicated by placing an * after the function keyword.\n在 ECMAScript 6 中，Generators 是一个新的函数类型，随着时间的推移可以返回多个值。这些特殊的函数是在 function 关键字后放置一个 *。\nHere is an example of a generator function:\n以下是个 generator 函数的示例：\n/*eslint-env es6*/\n\nfunction* generator() {\n    yield \"44\";\n    yield \"55\";\n}\n\n\nThis is also valid:\n这个同样有效：\n/*eslint-env es6*/\n\nfunction *generator() {\n    yield \"44\";\n    yield \"55\";\n}\n\n\nThis is valid as well:\n这个也是有效的：\n/*eslint-env es6*/\n\nfunction * generator() {\n    yield \"44\";\n    yield \"55\";\n}\n\n\nTo keep a sense of consistency when using generators this rule enforces a single position for the *.\n为了保持使用 generators 函数的一致性，该规则对 * 强制设置一个单独的位置。\nRule Details\nThis rule aims to enforce spacing around the * of generator functions.\n该规则旨在约束 generator 函数的 * 周围的空格。\nOptions\nThe rule takes one option, an object, which has two keys before and after having boolean values true or false.\n该规则只有一个可选项，是个对象，有两个键before 和 after对应的值可以为true或false。\n\n\nbefore enforces spacing between the * and the function keyword.\nIf it is true, a space is required, otherwise spaces are disallowed.\nIn object literal shorthand methods, spacing before the * is not checked, as they lack a function keyword.\n\n\nbefore 强制在 * 和 function 关键字之间有空格。如果设置为 true ，要求有空格，否则不允许有空格。在对象文本的缩写方法中，*之前的空格不会被检查，因为它们缺少 function 关键字。\n\n\nafter enforces spacing between the * and the function name (or the opening parenthesis for anonymous generator functions).\nIf it is true, a space is required, otherwise spaces are disallowed.\n\n\nafter 强制在 * 和函数名之间有空格 (或匿名 generator 函数的左括号)。如果设置为 true，要求有空格，否则不允许有空格。\n\n\nThe default is {\"before\": true, \"after\": false}.\n默认为 {\"before\": true, \"after\": false}。\n\"generator-star-spacing\": [\"error\", {\"before\": false, \"after\": true}]\n\n\nAnd the option has shorthand as a string keyword:\n这些选项可缩写为一个字符串关键字：\n\n{\"before\": true, \"after\": false} → \"before\"\n{\"before\": true, \"after\": false} → \"before\"\n{\"before\": false, \"after\": true} → \"after\"\n{\"before\": false, \"after\": true} → \"after\"\n{\"before\": true, \"after\": true} → \"both\"\n{\"before\": true, \"after\": true} → \"both\"\n{\"before\": false, \"after\": false} → \"neither\"\n{\"before\": false, \"after\": false} → \"neither\"\n\n\"generator-star-spacing\": [\"error\", \"after\"]\n\n\nExamples\nbefore\nExamples of correct code for this rule with the \"before\" option:\n选项 \"before\" 的 正确 代码示例：\n/*eslint generator-star-spacing: [\"error\", {\"before\": true, \"after\": false}]*/\n/*eslint-env es6*/\n\nfunction *generator() {}\n\nvar anonymous = function *() {};\n\nvar shorthand = { *generator() {} };\n\n\nafter\nExamples of correct code for this rule with the \"after\" option:\n选项 \"after\" 的 正确 代码示例：\n/*eslint generator-star-spacing: [\"error\", {\"before\": false, \"after\": true}]*/\n/*eslint-env es6*/\n\nfunction* generator() {}\n\nvar anonymous = function* () {};\n\nvar shorthand = { * generator() {} };\n\n\nboth\nExamples of correct code for this rule with the \"both\" option:\n选项 \"both\" 的 正确 代码示例：\n/*eslint generator-star-spacing: [\"error\", {\"before\": true, \"after\": true}]*/\n/*eslint-env es6*/\n\nfunction * generator() {}\n\nvar anonymous = function * () {};\n\nvar shorthand = { * generator() {} };\n\n\nneither\nExamples of correct code for this rule with the \"neither\" option:\n选项 \"neither\" 的 正确 代码示例：\n/*eslint generator-star-spacing: [\"error\", {\"before\": false, \"after\": false}]*/\n/*eslint-env es6*/\n\nfunction*generator() {}\n\nvar anonymous = function*() {};\n\nvar shorthand = { *generator() {} };\n\n\nWhen Not To Use It\nIf your project will not be using generators or you are not concerned with spacing consistency, you do not need this rule.\n如果你的项目不使用 generators 或者你不关心空格的一致性，可以关闭此规则。\nFurther Reading\n\nUnderstanding ES6: Generators\n\nVersion\nThis rule was introduced in ESLint 0.17.0.\n该规则在 ESLint 0.17.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/generator-star-spacing",
                "disable": false
            },
            {
                "real_name": "getter-return",
                "display_name": "getter-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce `return` statements in getters.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "1.Expected {{name}} to always return a value.\n2.Expected to return a value in {{name}}.\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/getter-return",
                "disable": false
            },
            {
                "real_name": "global-require",
                "display_name": "global-require",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在模块顶部调用 require() (global-require)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce require() on the top-level module scope (global-require)\n强制在模块顶部调用 require() (global-require)\nIn Node.js, module dependencies are included using the require() function, such as:\n在 Node.js 中，使用 require() 函数引入依赖的模块，例如：\nvar fs = require(\"fs\");\n\n\nWhile require() may be called anywhere in code, some style guides prescribe that it should be called only in the top level of a module to make it easier to identify dependencies. For instance, it’s arguably harder to identify dependencies when they are deeply nested inside of functions and other statements:\n虽然 require() 可以在代码的任何地方被调用，一些风格指南规定，它只能在模块顶层被调用，这样更容易识别依赖关系。例如，当它们在深层次嵌套在函数和其它语句时，就很难识别依赖：\nfunction foo() {\n\n    if (condition) {\n        var fs = require(\"fs\");\n    }\n}\n\n\nSince require() does a synchronous load, it can cause performance problems when used in other locations.\n因为 require() 是同步加载的，在其它地方使用时，会导致性能问题。\nFurther, ES6 modules mandate that import and export statements can only occur in the top level of the module’s body.\n此外，ES6 模块要求 import 和 export 语句只能放在模块顶部。\nRule Details\nThis rule requires all calls to require() to be at the top level of the module, similar to ES6 import and export statements, which also can occur only at the top level.\n此规则要求所有调用 require() 必须在模块顶部，与 ES6 中 import 和 export  语句（只能放在顶部）相同。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint global-require: \"error\"*/\n/*eslint-env es6*/\n\n// calling require() inside of a function is not allowed\nfunction readFile(filename, callback) {\n    var fs = require('fs');\n    fs.readFile(filename, callback)\n}\n\n// conditional requires like this are also not allowed\nif (DEBUG) { require('debug'); }\n\n// a require() in a switch statement is also flagged\nswitch(x) { case '1': require('1'); break; }\n\n// you may not require() inside an arrow function body\nvar getModule = (name) => require(name);\n\n// you may not require() inside of a function body as well\nfunction getModule(name) { return require(name); }\n\n// you may not require() inside of a try/catch block\ntry {\n    require(unsafeModule);\n} catch(e) {\n    console.log(e);\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint global-require: \"error\"*/\n\n// all these variations of require() are ok\nrequire('x');\nvar y = require('y');\nvar z;\nz = require('z').initialize();\n\n// requiring a module and using it in a function is ok\nvar fs = require('fs');\nfunction readFile(filename, callback) {\n    fs.readFile(filename, callback)\n}\n\n// you can use a ternary to determine which module to require\nvar logger = DEBUG ? require('dev-logger') : require('logger');\n\n// if you want you can require() at the end of your module\nfunction doSomethingA() {}\nfunction doSomethingB() {}\nvar x = require(\"x\"),\n    z = require(\"z\");\n\n\nWhen Not To Use It\nIf you have a module that must be initialized with information that comes from the file-system or if a module is only used in very rare situations and will cause significant overhead to load it may make sense to disable the rule. If you need to require() an optional dependency inside of a try/catch, you can disable this rule for just that dependency using the // eslint-disable-line global-require comment.\n如果一个模块必须使用来至于系统文件的信息初始化或者一个模块仅仅在非常稀少的情况下使用，将导致重大开销去加载模块，禁用此规则将是有意义的。如果你需要在 try/catch 内部使用 require() 一个可选依赖，你可以使用 // eslint-disable-line global-require 注释只对此依赖禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.4.0.\n该规则在 ESLint 1.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/global-require",
                "disable": false
            },
            {
                "real_name": "guard-for-in",
                "display_name": "guard-for-in",
                "severity": "error",
                "category": "correctness",
                "rule_title": "需要约束 for-in (guard-for-in)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Guarding for-in (guard-for-in)\n需要约束 for-in (guard-for-in)\nLooping over objects with a for in loop will include properties that are inherited through the prototype chain. This behavior can lead to unexpected items in your for loop.\n在使用 for in 遍历对象时，会把从原型链继承来的属性也包括进来。这样会导致意想不到的项出现。\nfor (key in foo) {\n    doSomething(key);\n}\n\n\nNote that simply checking foo.hasOwnProperty(key) is likely to cause an error in some cases; see no-prototype-builtins.\n注意，在某些情况下，对 foo.hasOwnProperty(key) 做简单的检测可能会导致错误出现；查看no-prototype-builtins。\nRule Details\nThis rule is aimed at preventing unexpected behavior that could arise from using a for in loop without filtering the results in the loop. As such, it will warn when for in loops do not filter their results with an if statement.\n此规则目的在于，阻止在 for in 遍历过程中，由于不对结果进行筛选而导致意想不到的行为发生。因此，当 for in 循环没有使用 if 语句对结果进行筛选时，该规则将会发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint guard-for-in: \"error\"*/\n\nfor (key in foo) {\n    doSomething(key);\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint guard-for-in: \"error\"*/\n\nfor (key in foo) {\n    if (Object.prototype.hasOwnProperty.call(foo, key)) {\n        doSomething(key);\n    }\n    if ({}.hasOwnProperty.call(foo, key)) {\n        doSomething(key);\n    }\n}\n\n\nRelated Rules\n\nno-prototype-builtins\n\nFurther Reading\n\nExploring JavaScript for-in loops\nThe pitfalls of using objects as maps in JavaScript\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/guard-for-in",
                "disable": false
            },
            {
                "real_name": "handle-callback-err",
                "display_name": "handle-callback-err",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制回调错误处理 (handle-callback-err)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce Callback Error Handling (handle-callback-err)\n强制回调错误处理 (handle-callback-err)\nIn Node.js, a common pattern for dealing with asynchronous behavior is called the callback pattern.\n在 Node.js 中，最普遍的处理异步行为是回调模式。\nThis pattern expects an Error object or null as the first argument of the callback.\n这个模式期望一个 Error 对象或 null 作为回调的第一个参数。\nForgetting to handle these errors can lead to some really strange behavior in your application.\n如果忘记处理这些错误会导致你的应用程序出现一些非常奇怪的行为。\nfunction loadData (err, data) {\n    doSomething(); // forgot to handle error\n}\n\n\nRule Details\nThis rule expects that when you’re using the callback pattern in Node.js you’ll handle the error.\n该规则期望当你在 Node.js 中使用回调模式时，你将处理错误。\nOptions\nThe rule takes a single string option: the name of the error parameter. The default is \"err\".\n该规则只有一个字符串选项：错误参数的名称。默认是 err。\nExamples of incorrect code for this rule with the default \"err\" parameter name:\n默认参数 \"err\" 的 错误 代码示例：\n/*eslint handle-callback-err: \"error\"*/\n\nfunction loadData (err, data) {\n    doSomething();\n}\n\n\n\nExamples of correct code for this rule with the default \"err\" parameter name:\n默认参数 \"err\" 的 正确 代码示例：\n/*eslint handle-callback-err: \"error\"*/\n\nfunction loadData (err, data) {\n    if (err) {\n        console.log(err.stack);\n    }\n    doSomething();\n}\n\nfunction generateError (err) {\n    if (err) {}\n}\n\n\nExamples of correct code for this rule with a sample \"error\" parameter name:\n参数 \"error\" 的 正确 代码示例：\n/*eslint handle-callback-err: [\"error\", \"error\"]*/\n\nfunction loadData (error, data) {\n    if (error) {\n       console.log(error.stack);\n    }\n    doSomething();\n}\n\n\nregular expression\nSometimes (especially in big projects) the name of the error variable is not consistent across the project,\nso you need a more flexible configuration to ensure that the rule reports all unhandled errors.\n有时候（特别是在大项目中）错误变量名不都一致在整个项目中，所以你需要一个更加灵活的配置去确保未处理的错误得到此规则的认可。\nIf the configured name of the error variable begins with a ^ it is considered to be a regexp pattern.\n如果错误变量的配置名以 ^ 开头被认为是一个正则模式。\n\nIf the option is \"^(err|error|anySpecificError)$\", the rule reports unhandled errors where the parameter name can be err, error or anySpecificError.\n如果这个选项是 \"^(err|error|anySpecificError)$\"，当参数名为 err, error or anySpecificError 时，该规则会报告有未处理的错误。\nIf the option is \"^.+Error$\", the rule reports unhandled errors where the parameter name ends with Error (for example, connectionError or validationError will match).\n如果这个选项是 \"^.+Error$\"，当参数名以 Error 结尾时（例如，connectionError 或 validationError），该规则会报告有未处理的错误。\nIf the option is \"^.*(e|E)rr\", the rule reports unhandled errors where the parameter name matches any string that contains err or Err (for example, err, error, anyError, some_err will match).\n如果这个选项是 \"^.*(e|E)rr\"，当参数名匹配任何字符串中含有 err 或 Err的（例如，err，error，anyError，some_err`）该规则会报告有未处理的错误。\n\nWhen Not To Use It\nThere are cases where it may be safe for your application to ignore errors, however only ignore errors if you are\nconfident that some other form of monitoring will help you catch the problem.\n如果一些情况下忽略错误处理并不影响应用的安全，并且你相信一些其他形式的监督将帮助你发现问题，这时可以不使用此规则。\nFurther Reading\n\nThe Art Of Node: Callbacks\nNodejitsu: What are the error conventions?\n\nVersion\nThis rule was introduced in ESLint 0.4.5.\n该规则在 ESLint 0.4.5 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/handle-callback-err",
                "disable": false
            },
            {
                "real_name": "id-blacklist",
                "display_name": "id-blacklist",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用指定的标识符 (id-blacklist)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow specified identifiers (id-blacklist)\n禁止使用指定的标识符 (id-blacklist)\n\n“There are only two hard things in Computer Science: cache invalidation and naming things.” — Phil Karlton\n\n\n“There are only two hard things in Computer Science: cache invalidation and naming things.” — Phil Karlton\n\nBad names can lead to hard-to-decipher code. Generic names, such as data, don’t infer much about the code and the values it receives. This rule allows you to configure a blacklist of bad identifier names, that you don’t want to see in your code.\n糟糕的名字会导致代码很难理解。通用的名字，比如 data，并不能推断出关于代码和接收到的值的更多信息。该规则允许你配置一个标识符名称的黑名单，也就是包含那些你不想在代码中看到的名字。\nRule Details\nThis rule disallows specified identifiers in assignments and function definitions.\n该规则禁止在赋值语句和 function 定义中使用指定的标识符。\nThis rule will catch blacklisted identifiers that are:\n该规则对以下情况，将捕捉黑名单里的标识符：\n\nvariable declarations\n变量声明\nfunction declarations\n函数声明\nobject properties assigned to during object creation\n在对象创建过程中的属性赋值\n\nIt will not catch blacklisted identifiers that are:\n该规则对以下情况，不会捕捉黑名单里的标识符：\n\nfunction calls (so you can still use functions you do not have control over)\n函数调用 (所以你仍然可以使用不受限制函数)\nobject properties (so you can still use objects you do not have control over)\n对象属性 (所以你仍然可以使用不受限制的对象)\n\nOptions\nThe rule takes one or more strings as options: the names of restricted identifiers.\n该规则有一个或多个字符串选项：受限制的标识符的名称：\nFor example, to restrict the use of common generic identifiers:\n例如，限制通用标识符的使用：\n{\n    \"id-blacklist\": [\"error\", \"data\", \"err\", \"e\", \"cb\", \"callback\"]\n}\n\n\nExamples of incorrect code for this rule with sample \"data\", \"callback\" restricted identifiers:\n受限制的 \"data\", \"callback\" 标识符的 错误 代码示例：\n/*eslint id-blacklist: [\"error\", \"data\", \"callback\"] */\n\nvar data = {...};\n\nfunction callback() {\n    // ...\n}\n\nelement.callback = function() {\n    // ...\n};\n\nvar itemSet = {\n    data: [...]\n};\n\n\nExamples of correct code for this rule with sample \"data\", \"callback\" restricted identifiers:\n受限制的 \"data\", \"callback\" 标识符的 正确 代码示例：\n/*eslint id-blacklist: [\"error\", \"data\", \"callback\"] */\n\nvar encodingOptions = {...};\n\nfunction processFileResult() {\n    // ...\n}\n\nelement.successHandler = function() {\n    // ...\n};\n\nvar itemSet = {\n    entities: [...]\n};\n\ncallback(); // all function calls are ignored\n\nfoo.callback(); // all function calls are ignored\n\nfoo.data; // all property names that are not assignments are ignored\n\n\nWhen Not To Use It\nYou can turn this rule off if you are happy for identifiers to be named freely.\n如果对标识符命名没什么要求，可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.2.\n该规则在 ESLint 2.0.0-beta.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/id-blacklist",
                "disable": false
            },
            {
                "real_name": "id-length",
                "display_name": "id-length",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制标识符的最大和最小长度 (id-length)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce minimum and maximum identifier lengths (id-length)\n强制标识符的最大和最小长度 (id-length)\nVery short identifier names like e, x, _t or very long ones like hashGeneratorResultOutputContainerObject can make code harder to read and potentially less maintainable. To prevent this, one may enforce a minimum and/or maximum identifier length.\n非常短的标识符名称像 e，x，_t 或非常长的名称像 hashGeneratorResultOutputContainerObject 使代码难以阅读和潜在的不可维护性。为了防止这种情况出现，应该限制标识符的最大和/或最小长度。\nvar x = 5; // too short; difficult to understand its purpose without context\n\n\nRule Details\nThis rule enforces a minimum and/or maximum identifier length convention.\n该规则旨在通过限制标识符的长度来提高代码的可读性和可维护性。对不符合长度限制(上限和下限)的任何类型的标识符，它将发出警告。\nIt allows the programmers to silently by-pass this check by using \"quoted\" property names or calculated property access to allow potential server-side data requirements.\n它允许程序员使用带引号的属性或计算的属性访问允许潜在的服务端数据请求来通过该规则的检查。\nOptions\nExamples of incorrect code for this rule with the default options:\n默认选项的 错误 代码示例：\n/*eslint id-length: \"error\"*/     // default is minimum 2-chars ({ \"min\": 2 })\n/*eslint-env es6*/\n\nvar x = 5;\nobj.e = document.body;\nvar foo = function (e) { };\ntry {\n    dangerousStuff();\n} catch (e) {\n    // ignore as many do\n}\nvar myObj = { a: 1 };\n(a) => { a * a };\nclass x { }\nclass Foo { x() {} }\nfunction foo(...x) { }\nvar { x } = {};\nvar { x: a} = {};\nvar { a: [x]} = {};\n({ prop: obj.x }) = {};\n\n\nExamples of correct code for this rule with the default options:\n默认选项的 正确 代码示例：\n/*eslint id-length: \"error\"*/     // default is minimum 2-chars ({ \"min\": 2 })\n/*eslint-env es6*/\n\nvar num = 5;\nfunction _f() { return 42; }\nfunction _func() { return 42; }\nobj.el = document.body;\nvar foo = function (evt) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\nvar myObj = { apple: 1 };\n(num) => { num * num };\nfunction foo(num = 0) { }\nclass MyClass { }\nclass Foo { method() {} }\nfunction foo(...args) { }\nvar { prop } = {};\nvar { prop: a } = {};\nvar { prop: [x] } = {};\n({ prop: obj.longName }) = {};\nvar data = { \"x\": 1 };  // excused because of quotes\ndata[\"y\"] = 3;  // excused because of calculated property access\n\n\nThis rule has a shorthand integer option for the \"min\" object property.\n该规则中 \"min\" 属性可以简写为数字。\nExamples of incorrect code for this rule with a minimum of 4:\n最小值为 4 的 错误 代码示例：\n/*eslint id-length: [\"error\", 4]*/\n/*eslint-env es6*/\n\nvar val = 5;\nobj.e = document.body;\nfunction (e) { };\ntry {\n    dangerousStuff();\n} catch (e) {\n    // ignore as many do\n}\nvar myObj = { a: 1 };\n(val) => { val * val };\nclass x { }\nclass Foo { x() {} }\nfunction foo(...x) { }\nvar { x } = {};\nvar { x: a} = {};\nvar { a: [x]} = {};\n({ prop: obj.x }) = {};\n\n\nExamples of correct code for this rule with a minimum of 4:\n最小值为 4 的 正确 代码示例：\n/*eslint id-length: [\"error\", 4]*/\n/*eslint-env es6*/\n\nvar value = 5;\nfunction func() { return 42; }\nobj.element = document.body;\nvar foo = function (event) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\nvar myObj = { apple: 1 };\n(value) => { value * value };\nfunction foobar(value = 0) { }\nclass MyClass { }\nclass Foobar { method() {} }\nfunction foobar(...args) { }\nvar { prop } = {};\nvar { prop: a } = {};\nvar { prop: [x] } = {};\n({ prop: obj.name }) = {};\nvar data = { \"x\": 1 };  // excused because of quotes\ndata[\"y\"] = 3;  // excused because of calculated property access\n\n\nThis rule has an object option:\n该规则有个对象选项：\n\n\"min\" (default: 2) enforces a minimum identifier length\n\"min\" (默认为 2) 强制最小标识符长度\n\"max\" (default: Infinity) enforces a maximum identifier length\n\"max\" (默认无穷大) 强制最大标识符长度\n\"properties\": always (default) enforces identifier length convention for property names\n\"properties\": always (默认) 强制属性名称的标识符长度约定\n\"properties\": never ignores identifier length convention for property names\n\"properties\": never 忽略属性名称的标识符长度约定\n\"exceptions\" allows an array of specified identifier names\n\"exceptions\" 所允许的特定的标识符名称数组\n\nmin\nExamples of incorrect code for this rule with the { \"min\": 4 } option:\n选项 { \"min\": 4 } 的 错误 代码示例：\n/*eslint id-length: [\"error\", { \"min\": 4 }]*/\n/*eslint-env es6*/\n\nvar val = 5;\nobj.e = document.body;\nfunction (e) { };\ntry {\n    dangerousStuff();\n} catch (e) {\n    // ignore as many do\n}\nvar myObj = { a: 1 };\n(val) => { val * val };\nclass x { }\nclass Foo { x() {} }\nfunction foo(...x) { }\nvar { x } = {};\nvar { x: a} = {};\nvar { a: [x]} = {};\n({ prop: obj.x }) = {};\n\n\nExamples of correct code for this rule with the { \"min\": 4 } option:\n选项 { \"min\": 4 } 的 正确 代码示例：\n/*eslint id-length: [\"error\", { \"min\": 4 }]*/\n/*eslint-env es6*/\n\nvar value = 5;\nfunction func() { return 42; }\nobj.element = document.body;\nvar foo = function (event) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\nvar myObj = { apple: 1 };\n(value) => { value * value };\nfunction foobar(value = 0) { }\nclass MyClass { }\nclass Foobar { method() {} }\nfunction foobar(...args) { }\nvar { prop } = {};\nvar { prop: a } = {};\nvar { prop: [x] } = {};\n({ prop: obj.name }) = {};\nvar data = { \"x\": 1 };  // excused because of quotes\ndata[\"y\"] = 3;  // excused because of calculated property access\n\n\nmax\nExamples of incorrect code for this rule with the { \"max\": 10 } option:\n选项 { \"max\": 10 } 的 错误 代码示例：\n/*eslint id-length: [\"error\", { \"max\": \"10\" }]*/\n/*eslint-env es6*/\n\nvar reallyLongVarName = 5;\nfunction reallyLongFuncName() { return 42; }\nobj.reallyLongPropName = document.body;\nvar foo = function (reallyLongArgName) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (reallyLongErrorName) {\n    // ignore as many do\n}\n(reallyLongArgName) => { return !reallyLongArgName; };\n\n\nExamples of correct code for this rule with the { \"max\": 10 } option:\n选项 { \"max\": 10 } 的 正确 代码示例：\n/*eslint id-length: [\"error\", { \"max\": \"10\" }]*/\n/*eslint-env es6*/\n\nvar varName = 5;\nfunction funcName() { return 42; }\nobj.propName = document.body;\nvar foo = function (arg) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (error) {\n    // ignore as many do\n}\n(arg) => { return !arg; };\n\n\nproperties\nExamples of correct code for this rule with the { \"properties\": \"never\" } option:\n选项 { \"properties\": \"never\" } 的 正确 代码示例：\n/*eslint id-length: [\"error\", { \"properties\": \"never\" }]*/\n/*eslint-env es6*/\n\nvar myObj = { a: 1 };\n({ a: obj.x.y.z }) = {};\n({ prop: obj.i }) = {};\n\n\nexceptions\nExamples of additional correct code for this rule with the { \"exceptions\": [\"x\"] } option:\n选项 { \"exceptions\": [\"x\"] } 的 正确 代码示例：\n/*eslint id-length: [\"error\", { \"exceptions\": [\"x\"] }]*/\n/*eslint-env es6*/\n\nvar x = 5;\nfunction x() { return 42; }\nobj.x = document.body;\nvar foo = function (x) { /* do stuff */ };\ntry {\n    dangerousStuff();\n} catch (x) {\n    // ignore as many do\n}\n(x) => { return x * x; };\n\n\nRelated Rules\n\nmax-len\nnew-cap\nfunc-names\ncamelcase\n\nVersion\nThis rule was introduced in ESLint 1.0.0.\n该规则在 ESLint 1.0.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/id-length",
                "disable": false
            },
            {
                "real_name": "id-match",
                "display_name": "id-match",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求标识符匹配特定的正则表达式 (id-match)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require identifiers to match a specified regular expression (id-match)\n要求标识符匹配特定的正则表达式 (id-match)\n\n“There are only two hard things in Computer Science: cache invalidation and naming things.” — Phil Karlton\n\n\n“There are only two hard things in Computer Science: cache invalidation and naming things.” — Phil Karlton\n\nNaming things consistently in a project is an often underestimated aspect of code creation.\nWhen done correctly, it can save your team hours of unnecessary head scratching and misdirections.\nThis rule allows you to precisely define and enforce the variables and function names on your team should use.\nNo more limiting yourself to camelCase, snake_case, PascalCase or oHungarianNotation. Id-match has all your needs covered!\n在一个项目中，一致的命名是代码创建经常被低估的一方面。使用得当时，它可以为你的团队节省掉因为不必要纠结和误导浪费的时间。该规则允许你精确地定义和强制使用你的团队应该用的变量和方法名。不再将你自己局限于 camelCase、nake_case、PascalCase 或 oHungarianNotation。该规则覆盖了你所有的需求!\nRule Details\nThis rule requires identifiers in assignments and function definitions to match a specified regular expression.\n该规则要求赋值语句和 function 定义中的标识符匹配某个特定的正则表达式。\nOptions\nThis rule has a string option for the specified regular expression.\n该规则有个字符串选项，是特定的正则表达式。\nFor example, to enforce a camelcase naming convention:\n例如，强制使用骆驼拼写法命名约定：\n{\n    \"id-match\": [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\"]\n}\n\n\nExamples of correct code for this rule with the \"^[a-z]+([A-Z][a-z]+)*$\" option:\n选项 \"^[a-z]+([A-Z][a-z]+)*$\" 的 正确 代码示例：\n/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\"]*/\n\nvar myFavoriteColor   = \"#112C85\";\nvar foo = bar.baz_boom;\nvar foo = { qux: bar.baz_boom };\ndo_something();\nvar obj = {\n    my_pref: 1\n};\n\n\nExamples of incorrect code for this rule with the \"^[a-z]+([A-Z][a-z]+)*$\" option:\n选项 \"^[a-z]+([A-Z][a-z]+)*$\" 的 错误 代码示例：\n/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\"]*/\n\nvar my_favorite_color = \"#112C85\";\nvar _myFavoriteColor  = \"#112C85\";\nvar myFavoriteColor_  = \"#112C85\";\nvar MY_FAVORITE_COLOR = \"#112C85\";\nfunction do_something() {\n    // ...\n}\nobj.do_something = function() {\n    // ...\n};\n\n\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"properties\": true requires object properties to match the specified regular expression\n\"properties\": true 要求对象属性匹配特定的正则表达式\n\"onlyDeclarations\": true requires only var, function, and class declarations to match the specified regular expression\n\"onlyDeclarations\": true 只要求 var、function 和 class 声明匹配特定的正则表达式\n\nproperties\nExamples of incorrect code for this rule with the \"^[a-z]+([A-Z][a-z]+)*$\", { \"properties\": true } options:\n选项 \"^[a-z]+([A-Z][a-z]+)*$\", { \"properties\": true } 的 错误 代码示例：\n/*eslint id-match: [\"error\", \"^[a-z]+([A-Z][a-z]+)*$\", { \"properties\": true }]*/\n\nvar obj = {\n    my_pref: 1\n};\n\n\nonlyDeclarations\nExamples of correct code for this rule with the \"^[a-z]+([A-Z][a-z]+)*$\", { \"onlyDeclarations\": true } options:\n选项 \"^[a-z]+([A-Z][a-z]+)*$\", { \"onlyDeclarations\": true } 的 正确 代码示例：\n/*eslint id-match: [2, \"^[a-z]+([A-Z][a-z]+)*$\", { \"onlyDeclarations\": true }]*/\n\ndo_something(__dirname);\n\n\nWhen Not To Use It\nIf your rules are too complex, it is possible that you encounter performance issues due to the nature of the job.\n如果你的规则太复杂，你很有可能会遇到性能问题，关闭此规则即可。\nVersion\nThis rule was introduced in ESLint 1.0.0.\n该规则在 ESLint 1.0.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/id-match",
                "disable": false
            },
            {
                "real_name": "implicit-arrow-linebreak",
                "display_name": "implicit-arrow-linebreak",
                "severity": "warning",
                "category": "convention",
                "rule_title": "为包含隐式返回的箭头函数强制执行一致的位置",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "enforce a consistent location for an arrow function containing an implicit return.",
                "owner": null,
                "labels": [],
                "description": "enforce a consistent location for an arrow function containing an implicit return.\r\n[参考官网](https://eslint.org/docs/rules/implicit-arrow-linebreak)",
                "disable": false
            },
            {
                "real_name": "indent",
                "display_name": "indent",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制使用一致的缩进 (indent)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent indentation (indent)\n强制使用一致的缩进 (indent)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThere are several common guidelines which require specific indentation of nested blocks and statements, like:\n一些常见的准则要求嵌套的块和语句使用特定的缩进，比如：\nfunction hello(indentSize, type) {\n    if (indentSize === 4 && type !== 'tab') {\n        console.log('Each next indentation will increase on 4 spaces');\n    }\n}\n\n\nThese are the most common scenarios recommended in different style guides:\n这是最常见的情况，也是不同的风格指南中都推荐的：\n\nTwo spaces, not longer and no tabs: Google, npm, Node.js, Idiomatic, Felix\n两个空格，不要 tab： Google、npm、Node.js、Idiomatic、Felix\nTabs: jQuery\ntab：jQuery\nFour spaces: Crockford\n四个空格：Crockford\n\nRule Details\nThis rule enforces a consistent indentation style. The default style is 4 spaces.\n该规则旨在强制使用一致的缩进风格。默认是 4个空格。\nOptions\nThis rule has a mixed option:\n该规则有一个混合选项：\nFor example, for 2-space indentation:\n例如，2 个空格缩进：\n{\n    \"indent\": [\"error\", 2]\n}\n\n\nOr for tabbed indentation:\n或 tab 缩进：\n{\n    \"indent\": [\"error\", \"tab\"]\n}\n\n\nExamples of incorrect code for this rule with the default options:\n默认选项的 错误 代码示例：\n/*eslint indent: \"error\"*/\n\nif (a) {\n  b=c;\n  function foo(d) {\n    e=f;\n  }\n}\n\n\nExamples of correct code for this rule with the default options:\n默认选项的 正确 代码示例：\n/*eslint indent: \"error\"*/\n\nif (a) {\n    b=c;\n    function foo(d) {\n        e=f;\n    }\n}\n\n\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"SwitchCase\" (default: 0) enforces indentation level for case clauses in switch statements\n\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进级别\n\"VariableDeclarator\" (default: 1) enforces indentation level for var declarators; can also take an object to define separate rules for var, let and const declarations.\n\"VariableDeclarator\" (默认：1) 强制 var 声明的缩进级别；也可以使用一个对象为 var、let 和 const 声明分别定义。\n\"outerIIFEBody\" (default: 1) enforces indentation level for file-level IIFEs.\n\"outerIIFEBody\" (默认: 1) 强制针对文件级别的 IIFE 的缩进\n\"MemberExpression\" (off by default) enforces indentation level for multi-line property chains (except in variable declarations and assignments)\n\"MemberExpression\" (默认关闭) 强制针对多行属性链的缩进 (除了在变量声明和赋值语句中)\n\"FunctionDeclaration\" takes an object to define rules for function declarations.\n\"FunctionDeclaration\" 使用一个对象定义函数声明的缩进规则。\n    \nparameters (off by default) enforces indentation level for parameters in a function declaration. This can either be a number indicating indentation level, or the string \"first\" indicating that all parameters of the declaration must be aligned with the first parameter.\nparameters (默认关闭) 强制针对函数声明中参数的缩进。可以是一个数字来表示缩进级别，或字符串 \"first\" 表示声明中的所有参数必须与第一个参数对齐。\nbody (default: 1) enforces indentation level for the body of a function declaration.\nbody (默认: 1) 强制针对函数声明的函数体的缩进级别。\n\n\n\"FunctionExpression\" takes an object to define rules for function expressions.\n\"FunctionExpression\" 使用一个对象定义函数表达式的缩进规则。\n    \nparameters (off by default) enforces indentation level for parameters in a function expression. This can either be a number indicating indentation level, or the string \"first\" indicating that all parameters of the expression must be aligned with the first parameter.\nparameters (默认关闭) 强制针对函数表达式中参数的缩进。可以是一个数字来表示缩进级别，或字符串 \"first\" 表示表达式中的所有参数必须与第一个参数对齐。\nbody (default: 1) enforces indentation level for the body of a function expression.\nbody (默认: 1) 强制针对函数表达式的函数体的缩进级别。\n\n\n\"CallExpression\" takes an object to define rules for function call expressions.\n\"CallExpression\" 使用一个对象定义函数调用表达式的缩进规则。\n    \narguments (off by default) enforces indentation level for arguments in a call expression. This can either be a number indicating indentation level, or the string \"first\" indicating that all arguments of the expression must be aligned with the first argument.\narguments (默认关闭) 强制针对函数调用表达式中参数的缩进。可以是一个数字来表示缩进级别，或字符串 \"first\" 表示表达式中的所有参数必须先与第一个参数对齐。\n\n\n\"ArrayExpression\" (default: 1) enforces indentation level for elements in arrays. It can also be set to the string \"first\", indicating that all the elements in the array should be aligned with the first element.\n\"ArrayExpression\" (默认: 1) 强制针对数组中的元素的缩进。可以是一个数字来表示缩进级别，或字符串 \"first\" 表示数组中的所有元素必须与第一个元素对齐。\n\"ObjectExpression\" (default: 1) enforces indentation level for properties in objects. It can be set to the string \"first\", indicating that all properties in the object should be aligned with the first property.\n\"ObjectExpression\" (默认: 1) 强制针对对象中的属性的缩进。可以是一个数字来表示缩进级别，或字符串 \"first\" 表示对象中的所有属性必须与第一个属性对齐。\n\nLevel of indentation denotes the multiple of the indent specified. Example:\n缩进级别表示指定的多个缩进。例如：\n\nIndent of 4 spaces with VariableDeclarator set to 2 will indent the multi-line variable declarations with 8 spaces.\n如果缩进设置为 4 个空格，VariableDeclarator 设置为 2，多行变量声明将会缩进 8 个空格。\nIndent of 2 spaces with VariableDeclarator set to 2 will indent the multi-line variable declarations with 4 spaces.\n如果缩进设置为 2 个空格，VariableDeclarator 设置为 2，多行变量声明将会缩进 4 个空格。\nIndent of 2 spaces with VariableDeclarator set to {\"var\": 2, \"let\": 2, \"const\": 3} will indent the multi-line variable declarations with 4 spaces for var and let, 6 spaces for const statements.\n如果缩进设置为 2 个空格，VariableDeclarator 设置为 {\"var\": 2, \"let\": 2, \"const\": 3}，多行变量声明将会分别为 var 和 let 语句缩进 4 个空格，const 语句缩进 6 个空格语句。\nIndent of tab with VariableDeclarator set to 2 will indent the multi-line variable declarations with 2 tabs.\n如果缩进设置为 tab 缩进，VariableDeclarator 设置为 2，多行变量声明将会缩进 2 个 tab。\nIndent of 2 spaces with SwitchCase set to 0 will not indent case clauses with respect to switch statements.\n如果缩进设置为 2 个空格，SwitchCase 设置为 0，case将不会缩进。\nIndent of 2 spaces with SwitchCase set to 1 will indent case clauses with 2 spaces with respect to switch statements.\n如果缩进设置为 2 个空格，SwitchCase 设置为 1，case 子句将相对于 switch 语句缩进 2 个空格。\nIndent of 2 spaces with SwitchCase set to 2 will indent case clauses with 4 spaces with respect to switch statements.\n如果缩进设置为 2 个空格，SwitchCase 设置为 2，case 子句将相对于 switch 语句缩进 4 个空格。\nIndent of tab with SwitchCase set to 2 will indent case clauses with 2 tabs with respect to switch statements.\n如果缩进设置为 tab 缩进，SwitchCase 设置为 2，case 子句将相对于 switch 语句缩进 2 个 tab。\nIndent of 2 spaces with MemberExpression set to 0 will indent the multi-line property chains with 0 spaces.\n如果缩进设置为 2 个空格， MemberExpression 设置为 0，多行属性将不对缩进。\nIndent of 2 spaces with MemberExpression set to 1 will indent the multi-line property chains with 2 spaces.\n如果缩进设置为 2 个空格， MemberExpression 设置为 1，多行属性将缩进 2 个空格。\nIndent of 2 spaces with MemberExpression set to 2 will indent the multi-line property chains with 4 spaces.\n如果缩进设置为 2 个空格， MemberExpression 设置为 2，多行属性将缩进 4 个空格。\nIndent of 4 spaces with MemberExpression set to 0 will indent the multi-line property chains with 0 spaces.\n如果缩进设置为 4 个空格， MemberExpression 设置为 0，多行属性将不会缩进。\nIndent of 4 spaces with MemberExpression set to 1 will indent the multi-line property chains with 4 spaces.\n如果缩进设置为 4 个空格， MemberExpression 设置为 1，多行属性将将缩进 4 个空格。\nIndent of 4 spaces with MemberExpression set to 2 will indent the multi-line property chains with 8 spaces.\n如果缩进设置为 4 个空格， MemberExpression 设置为 2，多行属性将将缩进 8 个空格。\n\ntab\nExamples of incorrect code for this rule with the \"tab\" option:\n选项 \"tab\" 的 错误 代码示例：\n/*eslint indent: [\"error\", \"tab\"]*/\n\nif (a) {\n     b=c;\nfunction foo(d) {\n           e=f;\n }\n}\n\n\nExamples of correct code for this rule with the \"tab\" option:\n选项 \"tab\" 的 正确 代码示例：\n/*eslint indent: [\"error\", \"tab\"]*/\n\nif (a) {\n/*tab*/b=c;\n/*tab*/function foo(d) {\n/*tab*//*tab*/e=f;\n/*tab*/}\n}\n\n\nSwitchCase\nExamples of incorrect code for this rule with the 2, { \"SwitchCase\": 1 } options:\n选项 2, { \"SwitchCase\": 1 } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"SwitchCase\": 1 }]*/\n\nswitch(a){\ncase \"a\":\n    break;\ncase \"b\":\n    break;\n}\n\n\nExamples of correct code for this rule with the 2, { \"SwitchCase\": 1 } option:\n选项 2, { \"SwitchCase\": 1 } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"SwitchCase\": 1 }]*/\n\nswitch(a){\n  case \"a\":\n    break;\n  case \"b\":\n    break;\n}\n\n\nVariableDeclarator\nExamples of incorrect code for this rule with the 2, { \"VariableDeclarator\": 1 } options:\n选项 2, { \"VariableDeclarator\": 1 } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 1 }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n    b = 2,\n    c = 3;\n\n\nExamples of correct code for this rule with the 2, { \"VariableDeclarator\": 1 } options:\n选项 2, { \"VariableDeclarator\": 1 } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 1 }]*/\n/*eslint-env es6*/\n\nvar a,\n  b,\n  c;\nlet a,\n  b,\n  c;\nconst a = 1,\n  b = 2,\n  c = 3;\n\n\nExamples of correct code for this rule with the 2, { \"VariableDeclarator\": 2 } options:\n选项 2, { \"VariableDeclarator\": 2 } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 2 }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n    b = 2,\n    c = 3;\n\n\nExamples of correct code for this rule with the 2, { \"VariableDeclarator\": { \"var\": 2, \"let\": 2, \"const\": 3 } } options:\n选项 2, { \"VariableDeclarator\": { \"var\": 2, \"let\": 2, \"const\": 3 } } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": { \"var\": 2, \"let\": 2, \"const\": 3 } }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n      b = 2,\n      c = 3;\n\n\nouterIIFEBody\nExamples of incorrect code for this rule with the options 2, { \"outerIIFEBody\": 0 }:\n选项 2, { \"outerIIFEBody\": 0 } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": 0 }]*/\n\n(function() {\n\n  function foo(x) {\n    return x + 1;\n  }\n\n})();\n\n\nif(y) {\nconsole.log('foo');\n}\n\n\nExamples of correct code for this rule with the options 2, {\"outerIIFEBody\": 0}:\n选项 2, {\"outerIIFEBody\": 0} 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": 0 }]*/\n\n(function() {\n\nfunction foo(x) {\n  return x + 1;\n}\n\n})();\n\n\nif(y) {\n   console.log('foo');\n}\n\n\nMemberExpression\nExamples of incorrect code for this rule with the 2, { \"MemberExpression\": 1 } options:\n选项 2, { \"MemberExpression\": 1 } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"MemberExpression\": 1 }]*/\n\nfoo\n.bar\n.baz()\n\n\nExamples of correct code for this rule with the 2, { \"MemberExpression\": 1 } option:\n选项 2, { \"MemberExpression\": 1 } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"MemberExpression\": 1 }]*/\n\nfoo\n  .bar\n  .baz();\n\n// Any indentation is permitted in variable declarations and assignments.\nvar bip = aardvark.badger\n                  .coyote;\n\n\nFunctionDeclaration\nExamples of incorrect code for this rule with the 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} } option:\n选项 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} }]*/\n\nfunction foo(bar,\n  baz,\n  qux) {\n    qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} } option:\n选项 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} }]*/\n\nfunction foo(bar,\n    baz,\n    qux) {\n  qux();\n}\n\n\nExamples of incorrect code for this rule with the 2, { \"FunctionDeclaration\": {\"parameters\": \"first\"} } option:\n选项 2, { \"FunctionDeclaration\": {\"parameters\": \"first\"} } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, {\"FunctionDeclaration\": {\"parameters\": \"first\"}}]*/\n\nfunction foo(bar, baz,\n  qux, boop) {\n  qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionDeclaration\": {\"parameters\": \"first\"} } option:\n选项 2, { \"FunctionDeclaration\": {\"parameters\": \"first\"} } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, {\"FunctionDeclaration\": {\"parameters\": \"first\"}}]*/\n\nfunction foo(bar, baz,\n             qux, boop) {\n  qux();\n}\n\n\nFunctionExpression\nExamples of incorrect code for this rule with the 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} } option:\n选项 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} }]*/\n\nvar foo = function(bar,\n  baz,\n  qux) {\n    qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} } option:\n选项 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} }]*/\n\nvar foo = function(bar,\n    baz,\n    qux) {\n  qux();\n}\n\n\nExamples of incorrect code for this rule with the 2, { \"FunctionExpression\": {\"parameters\": \"first\"} } option:\n选项 2, { \"FunctionExpression\": {\"parameters\": \"first\"} } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, {\"FunctionExpression\": {\"parameters\": \"first\"}}]*/\n\nvar foo = function(bar, baz,\n  qux, boop) {\n  qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionExpression\": {\"parameters\": \"first\"} } option:\n选项 2, { \"FunctionExpression\": {\"parameters\": \"first\"} } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, {\"FunctionExpression\": {\"parameters\": \"first\"}}]*/\n\nvar foo = function(bar, baz,\n                   qux, boop) {\n  qux();\n}\n\n\nCallExpression\nExamples of incorrect code for this rule with the 2, { \"CallExpression\": {\"arguments\": 1} } option:\n选项 2, { \"CallExpression\": {\"arguments\": 1} } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"CallExpression\": {\"arguments\": 1} }]*/\n\nfoo(bar,\n    baz,\n      qux\n);\n\n\nExamples of correct code for this rule with the 2, { \"CallExpression\": {\"arguments\": 1} } option:\n选项 2, { \"CallExpression\": {\"arguments\": 1} } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"CallExpression\": {\"arguments\": 1} }]*/\n\nfoo(bar,\n  baz,\n  qux\n);\n\n\nExamples of incorrect code for this rule with the 2, { \"CallExpression\": {\"arguments\": \"first\"} } option:\n选项 2, { \"CallExpression\": {\"arguments\": \"first\"} } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, {\"CallExpression\": {\"arguments\": \"first\"}}]*/\n\nfoo(bar, baz,\n  baz, boop, beep);\n\n\nExamples of correct code for this rule with the 2, { \"CallExpression\": {\"arguments\": \"first\"} } option:\n选项 2, { \"CallExpression\": {\"arguments\": \"first\"} } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, {\"CallExpression\": {\"arguments\": \"first\"}}]*/\n\nfoo(bar, baz,\n    baz, boop, beep);\n\n\nArrayExpression\nExamples of incorrect code for this rule with the 2, { \"ArrayExpression\": 1 } option:\n选项 2, { \"ArrayExpression\": 1 } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"ArrayExpression\": 1 }]*/\n\nvar foo = [\n    bar,\nbaz,\n      qux\n];\n\n\nExamples of correct code for this rule with the 2, { \"ArrayExpression\": 1 } option:\n选项 2, { \"ArrayExpression\": 1 } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"ArrayExpression\": 1 }]*/\n\nvar foo = [\n  bar,\n  baz,\n  qux\n];\n\n\nExamples of incorrect code for this rule with the 2, { \"ArrayExpression\": \"first\" } option:\n选项 2, { \"ArrayExpression\": \"first\" } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, {\"ArrayExpression\": \"first\"}]*/\n\nvar foo = [bar,\n  baz,\n  qux\n];\n\n\nExamples of correct code for this rule with the 2, { \"ArrayExpression\": \"first\" } option:\n选项 2, { \"ArrayExpression\": \"first\" } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, {\"ArrayExpression\": \"first\"}]*/\n\nvar foo = [bar,\n           baz,\n           qux\n];\n\n\nObjectExpression\nExamples of incorrect code for this rule with the 2, { \"ObjectExpression\": 1 } option:\n选项 2, { \"ObjectExpression\": 1 } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, { \"ObjectExpression\": 1 }]*/\n\nvar foo = {\n    bar: 1,\nbaz: 2,\n      qux: 3\n};\n\n\nExamples of correct code for this rule with the 2, { \"ObjectExpression\": 1 } option:\n选项 2, { \"ObjectExpression\": 1 } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, { \"ObjectExpression\": 1 }]*/\n\nvar foo = {\n  bar: 1,\n  baz: 2,\n  qux: 3\n};\n\n\nExamples of incorrect code for this rule with the 2, { \"ObjectExpression\": \"first\" } option:\n选项 2, { \"ObjectExpression\": \"first\" } 的 错误 代码示例：\n/*eslint indent: [\"error\", 2, {\"ObjectExpression\": \"first\"}]*/\n\nvar foo = { bar: 1,\n  baz: 2 };\n\n\nExamples of correct code for this rule with the 2, { \"ObjectExpression\": \"first\" } option:\n选项 2, { \"ObjectExpression\": \"first\" } 的 正确 代码示例：\n/*eslint indent: [\"error\", 2, {\"ObjectExpression\": \"first\"}]*/\n\nvar foo = { bar: 1,\n            baz: 2 };\n\n\nCompatibility\n\nJSHint: indent\nJSCS: validateIndentation\n\nVersion\nThis rule was introduced in ESLint 0.14.0.\n该规则在 ESLint 0.14.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/indent",
                "disable": false
            },
            {
                "real_name": "indent-legacy",
                "display_name": "indent-legacy",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce consistent indentation (indent-legacy)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent indentation (indent-legacy)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nESLint 4.0.0 introduced a rewrite of the indent rule, which now reports more errors than it did in previous versions. To ease the process of migrating to 4.0.0, the indent-legacy rule was introduced as a snapshot of the indent rule from ESLint 3.x. If your build is failing after the upgrade to 4.0.0, you can disable indent and enable indent-legacy as a quick fix. Eventually, you should switch back to the indent rule to get bugfixes and improvements in future versions.\n\nThere are several common guidelines which require specific indentation of nested blocks and statements, like:\nfunction hello(indentSize, type) {\n    if (indentSize === 4 && type !== 'tab') {\n        console.log('Each next indentation will increase on 4 spaces');\n    }\n}\n\n\nThese are the most common scenarios recommended in different style guides:\n\nTwo spaces, not longer and no tabs: Google, npm, Node.js, Idiomatic, Felix\nTabs: jQuery\nFour spaces: Crockford\n\nRule Details\nThis rule enforces a consistent indentation style. The default style is 4 spaces.\nOptions\nThis rule has a mixed option:\nFor example, for 2-space indentation:\n{\n    \"indent\": [\"error\", 2]\n}\n\n\nOr for tabbed indentation:\n{\n    \"indent\": [\"error\", \"tab\"]\n}\n\n\nExamples of incorrect code for this rule with the default options:\n/*eslint indent: \"error\"*/\n\nif (a) {\n  b=c;\n  function foo(d) {\n    e=f;\n  }\n}\n\n\nExamples of correct code for this rule with the default options:\n/*eslint indent: \"error\"*/\n\nif (a) {\n    b=c;\n    function foo(d) {\n        e=f;\n    }\n}\n\n\nThis rule has an object option:\n\n\"SwitchCase\" (default: 0) enforces indentation level for case clauses in switch statements\n\"VariableDeclarator\" (default: 1) enforces indentation level for var declarators; can also take an object to define separate rules for var, let and const declarations.\n\"outerIIFEBody\" (default: 1) enforces indentation level for file-level IIFEs.\n\"MemberExpression\" (off by default) enforces indentation level for multi-line property chains (except in variable declarations and assignments)\n\"FunctionDeclaration\" takes an object to define rules for function declarations.\n    \nparameters (off by default) enforces indentation level for parameters in a function declaration. This can either be a number indicating indentation level, or the string \"first\" indicating that all parameters of the declaration must be aligned with the first parameter.\nbody (default: 1) enforces indentation level for the body of a function declaration.\n\n\n\"FunctionExpression\" takes an object to define rules for function expressions.\n    \nparameters (off by default) enforces indentation level for parameters in a function expression. This can either be a number indicating indentation level, or the string \"first\" indicating that all parameters of the expression must be aligned with the first parameter.\nbody (default: 1) enforces indentation level for the body of a function expression.\n\n\n\"CallExpression\" takes an object to define rules for function call expressions.\n    \narguments (off by default) enforces indentation level for arguments in a call expression. This can either be a number indicating indentation level, or the string \"first\" indicating that all arguments of the expression must be aligned with the first argument.\n\n\n\"ArrayExpression\" (default: 1) enforces indentation level for elements in arrays. It can also be set to the string \"first\", indicating that all the elements in the array should be aligned with the first element.\n\"ObjectExpression\" (default: 1) enforces indentation level for properties in objects. It can be set to the string \"first\", indicating that all properties in the object should be aligned with the first property.\n\nLevel of indentation denotes the multiple of the indent specified. Example:\n\nIndent of 4 spaces with VariableDeclarator set to 2 will indent the multi-line variable declarations with 8 spaces.\nIndent of 2 spaces with VariableDeclarator set to 2 will indent the multi-line variable declarations with 4 spaces.\nIndent of 2 spaces with VariableDeclarator set to {\"var\": 2, \"let\": 2, \"const\": 3} will indent the multi-line variable declarations with 4 spaces for var and let, 6 spaces for const statements.\nIndent of tab with VariableDeclarator set to 2 will indent the multi-line variable declarations with 2 tabs.\nIndent of 2 spaces with SwitchCase set to 0 will not indent case clauses with respect to switch statements.\nIndent of 2 spaces with SwitchCase set to 1 will indent case clauses with 2 spaces with respect to switch statements.\nIndent of 2 spaces with SwitchCase set to 2 will indent case clauses with 4 spaces with respect to switch statements.\nIndent of tab with SwitchCase set to 2 will indent case clauses with 2 tabs with respect to switch statements.\nIndent of 2 spaces with MemberExpression set to 0 will indent the multi-line property chains with 0 spaces.\nIndent of 2 spaces with MemberExpression set to 1 will indent the multi-line property chains with 2 spaces.\nIndent of 2 spaces with MemberExpression set to 2 will indent the multi-line property chains with 4 spaces.\nIndent of 4 spaces with MemberExpression set to 0 will indent the multi-line property chains with 0 spaces.\nIndent of 4 spaces with MemberExpression set to 1 will indent the multi-line property chains with 4 spaces.\nIndent of 4 spaces with MemberExpression set to 2 will indent the multi-line property chains with 8 spaces.\n\ntab\nExamples of incorrect code for this rule with the \"tab\" option:\n/*eslint indent: [\"error\", \"tab\"]*/\n\nif (a) {\n     b=c;\nfunction foo(d) {\n           e=f;\n }\n}\n\n\nExamples of correct code for this rule with the \"tab\" option:\n/*eslint indent: [\"error\", \"tab\"]*/\n\nif (a) {\n/*tab*/b=c;\n/*tab*/function foo(d) {\n/*tab*//*tab*/e=f;\n/*tab*/}\n}\n\n\nSwitchCase\nExamples of incorrect code for this rule with the 2, { \"SwitchCase\": 1 } options:\n/*eslint indent: [\"error\", 2, { \"SwitchCase\": 1 }]*/\n\nswitch(a){\ncase \"a\":\n    break;\ncase \"b\":\n    break;\n}\n\n\nExamples of correct code for this rule with the 2, { \"SwitchCase\": 1 } option:\n/*eslint indent: [\"error\", 2, { \"SwitchCase\": 1 }]*/\n\nswitch(a){\n  case \"a\":\n    break;\n  case \"b\":\n    break;\n}\n\n\nVariableDeclarator\nExamples of incorrect code for this rule with the 2, { \"VariableDeclarator\": 1 } options:\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 1 }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n    b = 2,\n    c = 3;\n\n\nExamples of correct code for this rule with the 2, { \"VariableDeclarator\": 1 } options:\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 1 }]*/\n/*eslint-env es6*/\n\nvar a,\n  b,\n  c;\nlet a,\n  b,\n  c;\nconst a = 1,\n  b = 2,\n  c = 3;\n\n\nExamples of correct code for this rule with the 2, { \"VariableDeclarator\": 2 } options:\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": 2 }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n    b = 2,\n    c = 3;\n\n\nExamples of correct code for this rule with the 2, { \"VariableDeclarator\": { \"var\": 2, \"let\": 2, \"const\": 3 } } options:\n/*eslint indent: [\"error\", 2, { \"VariableDeclarator\": { \"var\": 2, \"let\": 2, \"const\": 3 } }]*/\n/*eslint-env es6*/\n\nvar a,\n    b,\n    c;\nlet a,\n    b,\n    c;\nconst a = 1,\n      b = 2,\n      c = 3;\n\n\nouterIIFEBody\nExamples of incorrect code for this rule with the options 2, { \"outerIIFEBody\": 0 }:\n/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": 0 }]*/\n\n(function() {\n\n  function foo(x) {\n    return x + 1;\n  }\n\n})();\n\n\nif(y) {\nconsole.log('foo');\n}\n\n\nExamples of correct code for this rule with the options 2, {\"outerIIFEBody\": 0}:\n/*eslint indent: [\"error\", 2, { \"outerIIFEBody\": 0 }]*/\n\n(function() {\n\nfunction foo(x) {\n  return x + 1;\n}\n\n})();\n\n\nif(y) {\n   console.log('foo');\n}\n\n\nMemberExpression\nExamples of incorrect code for this rule with the 2, { \"MemberExpression\": 1 } options:\n/*eslint indent: [\"error\", 2, { \"MemberExpression\": 1 }]*/\n\nfoo\n.bar\n.baz()\n\n\nExamples of correct code for this rule with the 2, { \"MemberExpression\": 1 } option:\n/*eslint indent: [\"error\", 2, { \"MemberExpression\": 1 }]*/\n\nfoo\n  .bar\n  .baz();\n\n// Any indentation is permitted in variable declarations and assignments.\nvar bip = aardvark.badger\n                  .coyote;\n\n\nFunctionDeclaration\nExamples of incorrect code for this rule with the 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} } option:\n/*eslint indent: [\"error\", 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} }]*/\n\nfunction foo(bar,\n  baz,\n  qux) {\n    qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} } option:\n/*eslint indent: [\"error\", 2, { \"FunctionDeclaration\": {\"body\": 1, \"parameters\": 2} }]*/\n\nfunction foo(bar,\n    baz,\n    qux) {\n  qux();\n}\n\n\nExamples of incorrect code for this rule with the 2, { \"FunctionDeclaration\": {\"parameters\": \"first\"} } option:\n/*eslint indent: [\"error\", 2, {\"FunctionDeclaration\": {\"parameters\": \"first\"}}]*/\n\nfunction foo(bar, baz,\n  qux, boop) {\n  qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionDeclaration\": {\"parameters\": \"first\"} } option:\n/*eslint indent: [\"error\", 2, {\"FunctionDeclaration\": {\"parameters\": \"first\"}}]*/\n\nfunction foo(bar, baz,\n             qux, boop) {\n  qux();\n}\n\n\nFunctionExpression\nExamples of incorrect code for this rule with the 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} } option:\n/*eslint indent: [\"error\", 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} }]*/\n\nvar foo = function(bar,\n  baz,\n  qux) {\n    qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} } option:\n/*eslint indent: [\"error\", 2, { \"FunctionExpression\": {\"body\": 1, \"parameters\": 2} }]*/\n\nvar foo = function(bar,\n    baz,\n    qux) {\n  qux();\n}\n\n\nExamples of incorrect code for this rule with the 2, { \"FunctionExpression\": {\"parameters\": \"first\"} } option:\n/*eslint indent: [\"error\", 2, {\"FunctionExpression\": {\"parameters\": \"first\"}}]*/\n\nvar foo = function(bar, baz,\n  qux, boop) {\n  qux();\n}\n\n\nExamples of correct code for this rule with the 2, { \"FunctionExpression\": {\"parameters\": \"first\"} } option:\n/*eslint indent: [\"error\", 2, {\"FunctionExpression\": {\"parameters\": \"first\"}}]*/\n\nvar foo = function(bar, baz,\n                   qux, boop) {\n  qux();\n}\n\n\nCallExpression\nExamples of incorrect code for this rule with the 2, { \"CallExpression\": {\"arguments\": 1} } option:\n/*eslint indent: [\"error\", 2, { \"CallExpression\": {\"arguments\": 1} }]*/\n\nfoo(bar,\n    baz,\n      qux\n);\n\n\nExamples of correct code for this rule with the 2, { \"CallExpression\": {\"arguments\": 1} } option:\n/*eslint indent: [\"error\", 2, { \"CallExpression\": {\"arguments\": 1} }]*/\n\nfoo(bar,\n  baz,\n  qux\n);\n\n\nExamples of incorrect code for this rule with the 2, { \"CallExpression\": {\"arguments\": \"first\"} } option:\n/*eslint indent: [\"error\", 2, {\"CallExpression\": {\"arguments\": \"first\"}}]*/\n\nfoo(bar, baz,\n  baz, boop, beep);\n\n\nExamples of correct code for this rule with the 2, { \"CallExpression\": {\"arguments\": \"first\"} } option:\n/*eslint indent: [\"error\", 2, {\"CallExpression\": {\"arguments\": \"first\"}}]*/\n\nfoo(bar, baz,\n    baz, boop, beep);\n\n\nArrayExpression\nExamples of incorrect code for this rule with the 2, { \"ArrayExpression\": 1 } option:\n/*eslint indent: [\"error\", 2, { \"ArrayExpression\": 1 }]*/\n\nvar foo = [\n    bar,\nbaz,\n      qux\n];\n\n\nExamples of correct code for this rule with the 2, { \"ArrayExpression\": 1 } option:\n/*eslint indent: [\"error\", 2, { \"ArrayExpression\": 1 }]*/\n\nvar foo = [\n  bar,\n  baz,\n  qux\n];\n\n\nExamples of incorrect code for this rule with the 2, { \"ArrayExpression\": \"first\" } option:\n/*eslint indent: [\"error\", 2, {\"ArrayExpression\": \"first\"}]*/\n\nvar foo = [bar,\n  baz,\n  qux\n];\n\n\nExamples of correct code for this rule with the 2, { \"ArrayExpression\": \"first\" } option:\n/*eslint indent: [\"error\", 2, {\"ArrayExpression\": \"first\"}]*/\n\nvar foo = [bar,\n           baz,\n           qux\n];\n\n\nObjectExpression\nExamples of incorrect code for this rule with the 2, { \"ObjectExpression\": 1 } option:\n/*eslint indent: [\"error\", 2, { \"ObjectExpression\": 1 }]*/\n\nvar foo = {\n    bar: 1,\nbaz: 2,\n      qux: 3\n};\n\n\nExamples of correct code for this rule with the 2, { \"ObjectExpression\": 1 } option:\n/*eslint indent: [\"error\", 2, { \"ObjectExpression\": 1 }]*/\n\nvar foo = {\n  bar: 1,\n  baz: 2,\n  qux: 3\n};\n\n\nExamples of incorrect code for this rule with the 2, { \"ObjectExpression\": \"first\" } option:\n/*eslint indent: [\"error\", 2, {\"ObjectExpression\": \"first\"}]*/\n\nvar foo = { bar: 1,\n  baz: 2 };\n\n\nExamples of correct code for this rule with the 2, { \"ObjectExpression\": \"first\" } option:\n/*eslint indent: [\"error\", 2, {\"ObjectExpression\": \"first\"}]*/\n\nvar foo = { bar: 1,\n            baz: 2 };\n\n\nCompatibility\n\nJSHint: indent\nJSCS: validateIndentation\n\nVersion\nThis rule was introduced in ESLint 4.0.0-alpha.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/indent-legacy",
                "disable": false
            },
            {
                "real_name": "init-declarations",
                "display_name": "init-declarations",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制或禁止变量声明语句中初始化 (init-declarations)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow initialization in variable declarations (init-declarations)\n强制或禁止变量声明语句中初始化 (init-declarations)\nIn JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, foo is initialized during declaration, while bar is initialized later.\n在 JavaScript 中，变量可在声明时初始化，或者在赋值语句中初始化。例如，在下面的代码中，foo 在声明时被初始化，而 bar 在之后被初始化。\nvar foo = 1;\nvar bar;\n\nif (foo) {\n    bar = 1;\n} else {\n    bar = 2;\n}\n\n\nRule Details\nThis rule is aimed at enforcing or eliminating variable initializations during declaration. For example, in the following code, foo is initialized during declaration, while bar is not.\n此规则旨在声明的过程中强制或消除变量在声明时进行初始化。例如，在下面的代码，foo 在声明过程中初始化，而 bar 不是。\nvar foo = 1;\nvar bar;\n\nbar = 2;\n\n\nThis rule aims to bring consistency to variable initializations and declarations.\n这一规则的目的是保持一致的变量初始化和声明。\nOptions\nThe rule takes two options:\n该规则有两个选项：\n\nA string which must be either \"always\" (the default), to enforce initialization at declaration, or \"never\" to disallow initialization during declaration. This rule applies to var, let, and const variables, however \"never\" is ignored for const variables, as unassigned consts generate a parse error.\n一个字符串，值为 \"always\"（默认）强制在声明时进行初始化，或 \"never\" 禁止在声明时进行初始化。该规则适用于var、let 和const 变量，然而，const 变量会忽略 \"never\"，因为未赋值的常量（const）会生成一个解析错误。\nAn object that further controls the behavior of this rule. Currently, the only available parameter is ignoreForLoopInit, which indicates if initialization at declaration is allowed in for loops when \"never\" is set, since it is a very typical use case.\n一个对象，进一步控制该规则的行为。目前，唯一可以的参数是 ignoreForLoopInit ，用来表明在设置了 \"never\" 之后，是否允许在 for 循环中变量声明时进行初始化，这是一个典型的用例。\n\nYou can configure the rule as follows:\n你可以配置规则如下：\nVariables must be initialized at declaration (default)\n变量必须在声明时初始化（默认）\n{\n    \"init-declarations\": [\"error\", \"always\"],\n}\n\n\nVariables must not be initialized at declaration\n变量不能在声明时初始化\n{\n    \"init-declarations\": [\"error\", \"never\"]\n}\n\n\nVariables must not be initialized at declaration, except in for loops, where it is allowed\n除了 for 循环外，变量不能在声明时初始化\n{\n    \"init-declarations\": [\"error\", \"never\", { \"ignoreForLoopInit\": true }]\n}\n\n\nalways\nExamples of incorrect code for the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint init-declarations: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    let baz;\n}\n\n\nExamples of correct code for the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint init-declarations: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar = 1;\n    let baz = 2;\n    const qux = 3;\n}\n\n\nnever\nExamples of incorrect code for the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint init-declarations: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar = 1;\n    let baz = 2;\n\n    for (var i = 0; i < 1; i++) {}\n}\n\n\nExamples of correct code for the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint init-declarations: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    let baz;\n    const buzz = 1;\n}\n\n\nThe \"never\" option ignores const variable initializations.\n选项 \"never\" 忽略 const 变量的初始化。\nignoreForLoopInit\nExamples of correct code for the \"never\", { \"ignoreForLoopInit\": true } options:\n选项 \"never\", { \"ignoreForLoopInit\": true } 的 正确 代码示例：\n/*eslint init-declarations: [\"error\", \"never\", { \"ignoreForLoopInit\": true }]*/\nfor (var i = 0; i < 1; i++) {}\n\n\nWhen Not To Use It\nWhen you are indifferent as to how your variables are initialized.\n如果你不关心变量如何初始化，可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/init-declarations",
                "disable": false
            },
            {
                "real_name": "jsx-quotes",
                "display_name": "jsx-quotes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在 JSX 属性中使用一致的单引号或双引号 (jsx-quotes)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce the consistent use of either double or single quotes in JSX attributes (jsx-quotes)\n强制在 JSX 属性中使用一致的单引号或双引号 (jsx-quotes)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJSX attribute values can contain string literals, which are delimited with single or double quotes.\nJSX 的属性可以包含由单引号或双引号分隔的字符串字面量。\n<a b='c' />\n<a b=\"c\" />\n\n\nUnlike string literals in JavaScript, string literals within JSX attributes can’t contain escaped quotes.\n不同于 Javascript 中的字符串字面量，JSX 属性中字符串字面量不能包含转义的引号\nIf you want to have e.g. a double quote within a JSX attribute value, you have to use single quotes as string delimiter.\n如果你想在 JSX 的属性中使用双引号，你必须使用单引号作为字符串分隔符。\n<a b=\"'\" />\n<a b='\"' />\n\n\nRule Details\nThis rule enforces the consistent use of either double or single quotes in JSX attributes.\n该规则强制在 JSX 属性中使用一致的单引号或双引号。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"prefer-double\" (default) enforces the use of double quotes for all JSX attribute values that don’t contain a double quote.\n\"prefer-double\" (默认) 强制所有不包含双引号的 JSX 属性值使用双引号。\n\"prefer-single\" enforces the use of single quotes for all JSX attribute values that don’t contain a single quote.\n\"prefer-single\" 强制所有不包含单引号的 JSX 属性值使用单引号。\n\nprefer-double\nExamples of incorrect code for this rule with the default \"prefer-double\" option:\n默认选项 \"prefer-double\" 的 错误 代码示例：\n/*eslint jsx-quotes: [\"error\", \"prefer-double\"]*/\n\n<a b='c' />\n\n\nExamples of correct code for this rule with the default \"prefer-double\" option:\n默认选项 \"prefer-double\" 的 正确 代码示例：\n/*eslint jsx-quotes: [\"error\", \"prefer-double\"]*/\n\n<a b=\"c\" />\n<a b='\"' />\n\n\nprefer-single\nExamples of incorrect code for this rule with the \"prefer-single\" option:\n选项 \"prefer-single\" 的 错误 代码示例：\n/*eslint jsx-quotes: [\"error\", \"prefer-single\"]*/\n\n<a b=\"c\" />\n\n\nExamples of correct code for this rule with the \"prefer-single\" option:\n选项 \"prefer-single\" 的 正确 代码示例：\n/*eslint jsx-quotes: [\"error\", \"prefer-single\"]*/\n\n<a b='c' />\n<a b=\"'\" />\n\n\nWhen Not To Use It\nYou can turn this rule off if you don’t use JSX or if you aren’t concerned with a consistent usage of quotes within JSX attributes.\n如果你不使用 JSX 或者不关心 JSX 属性中引号使用的一致性，关闭此规则即可。\nRelated Rules\n\nquotes\n\nVersion\nThis rule was introduced in ESLint 1.4.0.\n该规则在 ESLint 1.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/jsx-quotes",
                "disable": false
            },
            {
                "real_name": "key-spacing",
                "display_name": "key-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在对象字面量的键和值之间使用一致的空格 (key-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent spacing between keys and values in object literal properties (key-spacing)\n强制在对象字面量的键和值之间使用一致的空格 (key-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThis rule enforces spacing around the colon in object literal properties. It can verify each property individually, or it can ensure horizontal alignment of adjacent properties in an object literal.\n该规则强制对象属性的冒号左右的空格的一致性。它可以单独验证每一个属性，或它可以确保对象中的属性在垂直方向上对齐。\nRule Details\nThis rule enforces consistent spacing between keys and values in object literal properties. In the case of long lines, it is acceptable to add a new line wherever whitespace is allowed.\n该规则强制在对象字面量的键和值之间使用一致的空格。如果某一行很长的话，在允许空白出现的情况下，可以增加一空行，这种情况是该规则可以接受的。\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"beforeColon\": false (default) disallows spaces between the key and the colon in object literals.\n\"beforeColon\": false (默认) 禁止在对象字面量的键和值之间存在空格\n\"beforeColon\": true requires at least one space between the key and the colon in object literals.\n\"beforeColon\": true 要求在对象字面量的键和值之间存在至少有一个空格\n\"afterColon\": true (default) requires at least one space between the colon and the value in object literals.\n\"afterColon\": true (默认) 要求在对象字面量的冒号和值之间存在至少有一个空格\n\"afterColon\": false disallows spaces between the colon and the value in object literals.\n\"afterColon\": false 禁止在对象字面量的冒号和值之间存在空格\n\"mode\": \"strict\" (default) enforces exactly one space before or after colons in object literals.\n\"mode\": \"strict\" (默认) 要求在冒号前后只有一个空格\n\"mode\": \"minimum\" enforces one or more spaces before or after colons in object literals.\n\"mode\": \"minimum\" 要求在冒号前后最少有一个空格\n\"align\": \"value\" enforces horizontal alignment of values in object literals.\n\"align\": \"value\" 要求对象字面量中的值水平对齐\n\"align\": \"colon\" enforces horizontal alignment of both colons and values in object literals.\n\"align\": \"colon\" 要求对象字面量中的冒号和值都水平对齐\n\"align\" with an object value allows for fine-grained spacing when values are being aligned in object literals.\n\"align\" 允许细粒度的控制对象字面量值的间距直到对齐\n\"singleLine\" specifies a spacing style for single-line object literals.\n\"singleLine\" 为单行对象字面量指定一个空格风格\n\"multiLine\" specifies a spacing style for multi-line object literals.\n\"multiLine\" 为多行对象字面量指定一个空格风格\n\nPlease note that you can either use the top-level options or the grouped options (singleLine and multiLine) but not both.\n请注意，你可以使用顶级选项或分组选项 (singleLine 和 multiLine)，但不能同时使用两者。\nbeforeColon\nExamples of incorrect code for this rule with the default { \"beforeColon\": false } option:\n默认选项 { \"beforeColon\": false } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"beforeColon\": false }]*/\n\nvar obj = { \"foo\" : 42 };\n\n\nExamples of correct code for this rule with the default { \"beforeColon\": false } option:\n默认选项 { \"beforeColon\": false } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"beforeColon\": false }]*/\n\nvar obj = { \"foo\": 42 };\n\n\nExamples of incorrect code for this rule with the { \"beforeColon\": true } option:\n选项 { \"beforeColon\": true } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"beforeColon\": true }]*/\n\nvar obj = { \"foo\": 42 };\n\n\nExamples of correct code for this rule with the { \"beforeColon\": true } option:\n选项 { \"beforeColon\": true } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"beforeColon\": true }]*/\n\nvar obj = { \"foo\" : 42 };\n\n\nafterColon\nExamples of incorrect code for this rule with the default { \"afterColon\": true } option:\n默认选项 { \"afterColon\": true } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"afterColon\": true }]*/\n\nvar obj = { \"foo\":42 };\n\n\nExamples of correct code for this rule with the default { \"afterColon\": true } option:\n默认选项 { \"afterColon\": true } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"afterColon\": true }]*/\n\nvar obj = { \"foo\": 42 };\n\n\nExamples of incorrect code for this rule with the { \"afterColon\": false } option:\n选项 { \"afterColon\": false } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"afterColon\": false }]*/\n\nvar obj = { \"foo\": 42 };\n\n\nExamples of correct code for this rule with the { \"afterColon\": false } option:\n选项 { \"afterColon\": false } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"afterColon\": false }]*/\n\nvar obj = { \"foo\":42 };\n\n\nmode\nExamples of incorrect code for this rule with the default { \"mode\": \"strict\" } option:\n默认选项 { \"mode\": \"strict\" } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"mode\": \"strict\" }]*/\n\ncall({\n    foobar: 42,\n    bat:    2 * 2\n});\n\n\nExamples of correct code for this rule with the default { \"mode\": \"strict\" } option:\n默认选项 { \"mode\": \"strict\" } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"mode\": \"strict\" }]*/\n\ncall({\n    foobar: 42,\n    bat: 2 * 2\n});\n\n\nExamples of correct code for this rule with the { \"mode\": \"minimum\" } option:\n选项 { \"mode\": \"minimum\" } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"mode\": \"minimum\" }]*/\n\ncall({\n    foobar: 42,\n    bat:    2 * 2\n});\n\n\nalign\nExamples of incorrect code for this rule with the { \"align\": \"value\" } option:\n选项 { \"align\": \"value\" } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"align\": \"value\" }]*/\n\nvar obj = {\n    a: value,\n    bcde:  42,\n    fg :   foo()\n};\n\n\nExamples of correct code for this rule with the { \"align\": \"value\" } option:\n选项 { \"align\": \"value\" } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"align\": \"value\" }]*/\n\nvar obj = {\n    a:    value,\n    bcde: 42,\n\n    fg: foo(),\n    h:  function() {\n        return this.a;\n    },\n    ijkl: 'Non-consecutive lines form a new group'\n};\n\nvar obj = { a: \"foo\", longPropertyName: \"bar\" };\n\n\nExamples of incorrect code for this rule with the { \"align\": \"colon\" } option:\n选项 { \"align\": \"colon\" } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", { \"align\": \"colon\" }]*/\n\ncall({\n    foobar: 42,\n    bat:    2 * 2\n});\n\n\nExamples of correct code for this rule with the { \"align\": \"colon\" } option:\n选项 { \"align\": \"colon\" } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", { \"align\": \"colon\" }]*/\n\ncall({\n    foobar: 42,\n    bat   : 2 * 2\n});\n\n\nalign\nThe align option can take additional configuration through the beforeColon, afterColon, mode, and on options.\nalign 选项可以通过 beforeColon、afterColon、mode 和 on 进行额外的配置。\nIf align is defined as an object, but not all of the parameters are provided, undefined parameters will default to the following:\n如果 align 被定义为一个对象，但是没有提供所有的参数，那么，未定义的参数将默认为：\n// Defaults\nalign: {\n    \"beforeColon\": false,\n    \"afterColon\": true,\n    \"on\": \"colon\",\n    \"mode\": \"strict\"\n}\n\n\nExamples of correct code for this rule with sample { \"align\": { } } options:\n选项 { \"align\": { } } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", {\n    \"align\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"on\": \"colon\"\n    }\n}]*/\n\nvar obj = {\n    \"one\"   : 1,\n    \"seven\" : 7\n}\n\n\n/*eslint key-spacing: [\"error\", {\n    \"align\": {\n        \"beforeColon\": false,\n        \"afterColon\": false,\n        \"on\": \"value\"\n    }\n}]*/\n\nvar obj = {\n    \"one\":  1,\n    \"seven\":7\n}\n\n\nalign and multiLine\nThe multiLine and align options can differ, which allows for fine-tuned control over the key-spacing of your files.  align will not inherit from multiLine if align is configured as an object.\nmultiLine 和 align 选项可以有所区别，这将允许对你的文件进行更细粒度的控制 key-spacing。如果 align 被配置为一个对象，align 将不会 从 multiLine 继承。\nmultiLine is used any time  an object literal spans multiple lines.  The align configuration is used when there is a group of properties in the same object. For example:\nmultiLine 可以在任何时候被用在跨行的对象字面量上。而当一个对象有多个属性时，使用 align 配置。\nvar myObj = {\n  key1: 1, // uses multiLine\n\n  key2: 2, // uses align (when defined)\n  key3: 3, // uses align (when defined)\n\n  key4: 4 // uses multiLine\n}\n\n\n\nExamples of incorrect code for this rule with sample { \"align\": { }, \"multiLine\": { } } options:\n选项 { \"align\": { }, \"multiLine\": { } } 的 错误 代码示例：\n/*eslint key-spacing: [\"error\", {\n    \"multiLine\": {\n        \"beforeColon\": false,\n        \"afterColon\":true\n    },\n    \"align\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"on\": \"colon\"\n    }\n}]*/\n\nvar obj = {\n    \"myObjectFunction\": function() {\n        // Do something\n    },\n    \"one\"             : 1,\n    \"seven\"           : 7\n}\n\n\nExamples of correct code for this rule with sample { \"align\": { }, \"multiLine\": { } } options:\n选项 { \"align\": { }, \"multiLine\": { } } 的 正确 代码示例：\n/*eslint key-spacing: [\"error\", {\n    \"multiLine\": {\n        \"beforeColon\": false,\n        \"afterColon\": true\n\n    },\n    \"align\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"on\": \"colon\"\n    }\n}]*/\n\nvar obj = {\n    \"myObjectFunction\": function() {\n        // Do something\n        //\n    }, // These are two separate groups, so no alignment between `myObjectFuction` and `one`\n    \"one\"   : 1,\n    \"seven\" : 7 // `one` and `seven` are in their own group, and therefore aligned\n}\n\n\nsingleLine and multiLine\nExamples of correct code for this rule with sample { \"singleLine\": { }, \"multiLine\": { } } options:\n选项 { \"singleLine\": { }, \"multiLine\": { } } 的 正确 代码示例：\n/*eslint \"key-spacing\": [2, {\n    \"singleLine\": {\n        \"beforeColon\": false,\n        \"afterColon\": true\n    },\n    \"multiLine\": {\n        \"beforeColon\": true,\n        \"afterColon\": true,\n        \"align\": \"colon\"\n    }\n}]*/\nvar obj = { one: 1, \"two\": 2, three: 3 };\nvar obj2 = {\n    \"two\" : 2,\n    three : 3\n};\n\n\nWhen Not To Use It\nIf you have another convention for property spacing that might not be consistent with the available options, or if you want to permit multiple styles concurrently you can safely disable this rule.\n对属性空格，如果你有其它约定，与上面可用的选项不一致；或者你允许同时使用多种风格，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/key-spacing",
                "disable": false
            },
            {
                "real_name": "keyword-spacing",
                "display_name": "keyword-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制关键字周围空格的一致性 (keyword-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent spacing before and after keywords (keyword-spacing)\n强制关键字周围空格的一致性 (keyword-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nKeywords are syntax elements of JavaScript, such as function and if.\nThese identifiers have special meaning to the language and so often appear in a different color in code editors.\nAs an important part of the language, style guides often refer to the spacing that should be used around keywords.\nFor example, you might have a style guide that says keywords should be always surrounded by spaces, which would mean if-else statements must look like this:\n关键字是 JavaScript 的语法元素，比如 function 和 if。这些标识符对 这门语言具有特殊的意义，所以，在代码编辑器内以不同的颜色显示。作为该语言很重要的一部分，风格指南常有关键字周围应该有空格的约定。例如，你可能有个风格指南说关键字周围应该总是有空格，if-else 语句就像这样：\nif (foo) {\n    // ...\n} else {\n    // ...\n}\n\n\nOf course, you could also have a style guide that disallows spaces around keywords.\n当然，你也可以有个禁止关键字前后的空格风格指南。\nRule Details\nThis rule enforces consistent spacing around keywords and keyword-like tokens: as (in module declarations), async (of async functions), await (of await expressions), break, case, catch, class, const, continue, debugger, default, delete, do, else, export, extends, finally, for, from (in module declarations), function, get (of getters), if, import, in, instanceof, let, new, of (in for-of statements), return, set (of setters), static, super, switch, this, throw, try, typeof, var, void, while, with, and yield. This rule is designed carefully not to conflict with other spacing rules: it does not apply to spacing where other rules report problems.\n该规则强制关键字和类似关键字的符号周围空格的一致性：as、async、await、break、case、catch、class、const、continue、debugger、default、delete、do、else、export、extends、finally、for、from、function、get、if、import、in、instanceof、let、new、of、return、set、static、super、switch、this、throw、try、typeof、var、void、while、with 和 yield。该规则不会与其它空格规则发生冲突：它并不应用于别的规则会报告问题的空格。\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"before\": true (default) requires at least one space before keywords\n\"before\": true (默认) 要求在关键字之前至少有一个空格\n\"before\": false disallows spaces before keywords\n\"before\": false 禁止在关键字之前有空格\n\"after\": true (default) requires at least one space after keywords\n\"after\": true (默认) 要求在关键字之后至少有一个空格\n\"after\": false disallows spaces after keywords\n\"after\": false 禁止在关键字之后有空格\n\"overrides\" allows overriding spacing style for specified keywords\n\"overrides\" 允许覆盖指定的关键字的空格风格\n\nbefore\nExamples of incorrect code for this rule with the default { \"before\": true } option:\n默认选项 { \"before\": true } 的 错误 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"before\": true }]*/\n\nif (foo) {\n    //...\n}else if (bar) {\n    //...\n}else {\n    //...\n}\n\n\nExamples of correct code for this rule with the default { \"before\": true } option:\n默认选项 { \"before\": true } 的 正确 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"before\": true }]*/\n/*eslint-env es6*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}\n\n// no conflict with `array-bracket-spacing`\nlet a = [this];\nlet b = [function() {}];\n\n// no conflict with `arrow-spacing`\nlet a = ()=> this.foo;\n\n// no conflict with `block-spacing`\n{function foo() {}}\n\n// no conflict with `comma-spacing`\nlet a = [100,this.foo, this.bar];\n\n// not conflict with `computed-property-spacing`\nobj[this.foo] = 0;\n\n// no conflict with `generator-star-spacing`\nfunction *foo() {}\n\n// no conflict with `key-spacing`\nlet obj = {\n    foo:function() {}\n};\n\n// no conflict with `object-curly-spacing`\nlet obj = {foo: this};\n\n// no conflict with `semi-spacing`\nlet a = this;function foo() {}\n\n// no conflict with `space-in-parens`\n(function () {})();\n\n// no conflict with `space-infix-ops`\nif (\"foo\"in {foo: 0}) {}\nif (10+this.foo<= this.bar) {}\n\n// no conflict with `jsx-curly-spacing`\nlet a = <A foo={this.foo} bar={function(){}} />\n\n\nExamples of incorrect code for this rule with the { \"before\": false } option:\n选项 { \"before\": false } 的 错误 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"before\": false }]*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}\n\n\nExamples of correct code for this rule with the { \"before\": false } option:\n选项 { \"before\": false } 的 正确 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"before\": false }]*/\n\nif (foo) {\n    //...\n}else if (bar) {\n    //...\n}else {\n    //...\n}\n\n\nafter\nExamples of incorrect code for this rule with the default { \"after\": true } option:\n默认选项 { \"after\": true } 的 错误 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"after\": true }]*/\n\nif(foo) {\n    //...\n} else if(bar) {\n    //...\n} else{\n    //...\n}\n\n\nExamples of correct code for this rule with the default { \"after\": true } option:\n默认选项 { \"after\": true } 的 正确 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"after\": true }]*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}\n\n// not conflict with `array-bracket-spacing`\nlet a = [this];\n\n// not conflict with `arrow-spacing`\nlet a = ()=> this.foo;\n\n// not conflict with `comma-spacing`\nlet a = [100, this.foo, this.bar];\n\n// not conflict with `computed-property-spacing`\nobj[this.foo] = 0;\n\n// not conflict with `generator-star-spacing`\nfunction* foo() {}\n\n// not conflict with `key-spacing`\nlet obj = {\n    foo:function() {}\n};\n\n// not conflict with `func-call-spacing`\nclass A {\n    constructor() {\n        super();\n    }\n}\n\n// not conflict with `object-curly-spacing`\nlet obj = {foo: this};\n\n// not conflict with `semi-spacing`\nlet a = this;function foo() {}\n\n// not conflict with `space-before-function-paren`\nfunction() {}\n\n// no conflict with `space-infix-ops`\nif (\"foo\"in{foo: 0}) {}\nif (10+this.foo<= this.bar) {}\n\n// no conflict with `space-unary-ops`\nfunction* foo(a) {\n    return yield+a;\n}\n\n// no conflict with `yield-star-spacing`\nfunction* foo(a) {\n    return yield* a;\n}\n\n// no conflict with `jsx-curly-spacing`\nlet a = <A foo={this.foo} bar={function(){}} />\n\n\nExamples of incorrect code for this rule with the { \"after\": false } option:\n选项 { \"after\": false } 的 错误 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"after\": false }]*/\n\nif (foo) {\n    //...\n} else if (bar) {\n    //...\n} else {\n    //...\n}\n\n\nExamples of correct code for this rule with the { \"after\": false } option:\n选项 { \"after\": false } 的 正确 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"after\": false }]*/\n\nif(foo) {\n    //...\n} else if(bar) {\n    //...\n} else{\n    //...\n}\n\n\noverrides\nExamples of correct code for this rule with the { \"overrides\": { \"if\": { \"after\": false }, \"for\": { \"after\": false }, \"while\": { \"after\": false } } } option:\n选项 { \"overrides\": { \"if\": { \"after\": false }, \"for\": { \"after\": false }, \"while\": { \"after\": false } } } 的 正确 代码示例：\n/*eslint keyword-spacing: [\"error\", { \"overrides\": {\n  \"if\": { \"after\": false },\n  \"for\": { \"after\": false },\n  \"while\": { \"after\": false }\n} }]*/\n\nif(foo) {\n    //...\n} else if(bar) {\n    //...\n} else {\n    //...\n}\n\nfor(;;);\n\nwhile(true) {\n  //...\n}\n\n\nWhen Not To Use It\nIf you don’t want to enforce consistency on keyword spacing, then it’s safe to disable this rule.\n如果你不想强制关键字空格的一致性，可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.1.\n该规则在 ESLint 2.0.0-beta.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/keyword-spacing",
                "disable": false
            },
            {
                "real_name": "line-comment-position",
                "display_name": "line-comment-position",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce position of line comments (line-comment-position)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce position of line comments (line-comment-position)\nLine comments can be positioned above or beside code. This rule helps teams maintain a consistent style.\n// above comment\nvar foo = \"bar\";  // beside comment\n\n\nRule Details\nThis rule enforces consistent position of line comments. Block comments are not affected by this rule. By default, this rule ignores comments starting with the following words: eslint, jshint, jslint, istanbul, global, exported, jscs, falls through.\nOptions\nThis rule takes one argument, which can be a string or an object. The string settings are the same as those of the position property (explained below). The object option has the following properties:\nposition\nThe position option has two settings:\n\nabove (default) enforces line comments only above code, in its own line.\nbeside enforces line comments only at the end of code lines.\n\nposition: above\nExamples of correct code for the { \"position\": \"above\" } option:\n/*eslint line-comment-position: [\"error\", { \"position\": \"above\" }]*/\n// valid comment\n1 + 1;\n\n\nExamples of incorrect code for the { \"position\": \"above\" } option:\n/*eslint line-comment-position: [\"error\", { \"position\": \"above\" }]*/\n1 + 1; // invalid comment\n\n\nposition: beside\nExamples of correct code for the { \"position\": \"beside\" } option:\n/*eslint line-comment-position: [\"error\", { \"position\": \"beside\" }]*/\n1 + 1; // valid comment\n\n\nExamples of incorrect code for the { \"position\": \"beside\" } option:\n/*eslint line-comment-position: [\"error\", { \"position\": \"beside\" }]*/\n// invalid comment\n1 + 1;\n\n\nignorePattern\nBy default this rule ignores comments starting with the following words: eslint, jshint, jslint, istanbul, global, exported, jscs, falls through. An alternative regular expression can be provided.\nExamples of correct code for the ignorePattern option:\n/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\" }]*/\n1 + 1; // pragma valid comment\n\n\nExamples of incorrect code for the ignorePattern option:\n/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\" }]*/\n1 + 1; // invalid comment\n\n\napplyDefaultIgnorePatterns\nDefault ignore patterns are applied even when ignorePattern is provided. If you want to omit default patterns, set this option to false.\nExamples of correct code for the { \"applyDefaultIgnorePatterns\": false } option:\n/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\", \"applyDefaultIgnorePatterns\": false }]*/\n1 + 1; // pragma valid comment\n\n\nExamples of incorrect code for the { \"applyDefaultIgnorePatterns\": false } option:\n/*eslint line-comment-position: [\"error\", { \"ignorePattern\": \"pragma\", \"applyDefaultIgnorePatterns\": false }]*/\n1 + 1; // falls through\n\n\nDeprecated: the object property applyDefaultPatterns is deprecated. Please use the property applyDefaultIgnorePatterns instead.\nWhen Not To Use It\nIf you aren’t concerned about having different line comment styles, then you can turn off this rule.\nCompatibility\nJSCS: validateCommentPosition\nVersion\nThis rule was introduced in ESLint 3.5.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/line-comment-position",
                "disable": false
            },
            {
                "real_name": "linebreak-style",
                "display_name": "linebreak-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制使用一致的换行符风格 (linebreak-style)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent linebreak style (linebreak-style)\n强制使用一致的换行符风格 (linebreak-style)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhen developing with a lot of people all having different editors, VCS applications and operating systems it may occur that\ndifferent line endings are written by either of the mentioned (might especially happen when using the windows and mac versions of SourceTree together).\n当很多人协同开发时，会用到不同的编辑器，在 VCS 应用程序和操作系统中可能会出现不同的编辑器行结束方式也不同(尤其是同时使用 windows 和 mac 版本的源码)。\nThe linebreaks (new lines) used in windows operating system are usually carriage returns (CR) followed by a line feed (LF) making it a carriage return line feed (CRLF)\nwhereas Linux and Unix use a simple line feed (LF). The corresponding control sequences are \"\\n\" (for LF) and \"\\r\\n\" for (CRLF).\n在 windows 操作系统中换行符通常是回车 (CR) 加换行分隔符 (LF)，也就是回车换行(CRLF)，然而在 Linux 和 Unix 中只使用简单的换行分隔符 (LF)。对应的控制字符为 \"\\n\" (LF) 和 \"\\r\\n\"(CRLF)。\nMany versioning systems (like git and subversion) can automatically ensure the correct ending. However to cover all contingencies, you can activate this rule.\n很多版本控制系统（如 git 和 subversion）可以自动的保证正确的结尾。然而如果要涵盖所有情况，你可以激活此规则。\nRule Details\nThis rule enforces consistent line endings independent of operating system, VCS, or editor used across your codebase.\n该规则强制在独立的开源系统、VCS 或 你使用的编辑器中使用一致的换行符。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"unix\" (default) enforces the usage of Unix line endings: \\n for LF.\n\"unix\" (默认) 强制使用 Unix 换行符： \\n。\n\"windows\" enforces the usage of Windows line endings: \\r\\n for CRLF.\n\"windows\" 强制使用 Windows 换行符： \\r\\n。\n\nunix\nExamples of incorrect code for this rule with the default \"unix\" option:\n默认选项 \"unix\" 的 错误 代码示例：\n/*eslint linebreak-style: [\"error\", \"unix\"]*/\n\nvar a = 'a'; // \\r\\n\n\n\n\nExamples of correct code for this rule with the default \"unix\" option:\n默认选项 \"unix\" 的 正确 代码示例：\n/*eslint linebreak-style: [\"error\", \"unix\"]*/\n\nvar a = 'a', // \\n\n    b = 'b'; // \\n\n// \\n\nfunction foo(params) { // \\n\n    // do stuff \\n\n}// \\n\n\n\nwindows\nExamples of incorrect code for this rule with the \"windows\" option:\n选项 \"windows\" 的 错误 代码示例：\n/*eslint linebreak-style: [\"error\", \"windows\"]*/\n\nvar a = 'a'; // \\n\n\n\nExamples of correct code for this rule with the \"windows\" option:\n选项 \"windows\" 的 正确 代码示例：\n/*eslint linebreak-style: [\"error\", \"windows\"]*/\n\nvar a = 'a', // \\r\\n\n    b = 'b'; // \\r\\n\n// \\r\\n\nfunction foo(params) { // \\r\\n\n    // do stuff \\r\\n\n} // \\r\\n\n\n\nUsing this rule with version control systems\nVersion control systems sometimes have special behavior for linebreaks. To make it easy for developers to contribute to your codebase from different platforms, you may want to configure your VCS to handle linebreaks appropriately.\n版本控制系统有时对换行符有一些特殊的行为。为了让开发人员更方便的在不同的平台贡献自己的代码库，你可能需要配置你 VCS 的来适当地处理换行符。\nFor example, the default behavior of git on Windows systems is to convert LF linebreaks to CRLF when checking out files, but to store the linebreaks as LF when committing a change. This will cause the linebreak-style rule to report errors if configured with the \"unix\" setting, because the files that ESLint sees will have CRLF linebreaks. If you use git, you may want to add a line to your .gitattributes file to prevent git from converting linebreaks in .js files:\n比如，window 系统中 git 在 checkout 文件时会把换行符 LF 转换为 CRLF， 但在提交时，会把换行符保存为 LF。如果配置了了 \"unix\" 设置，这将导致 linebreak-style 规则报告错误，因为 ESLint 检测到的是 CRLF。如果你使用 git， 伱可能希望在你的 .gitattributes 文件 添加一行来避免 git 对 .js 文件中的换行符进行转换。\n*.js text eol=lf\n\n\nWhen Not To Use It\nIf you aren’t concerned about having different line endings within your code, then you can safely turn this rule off.\n如果你不关心你的代码中是否以不同的换行符结尾，你可以关闭此规则。\nCompatibility\n\nJSCS: validateLineBreaks\n\nVersion\nThis rule was introduced in ESLint 0.21.0.\n该规则在 ESLint 0.21.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/linebreak-style",
                "disable": false
            },
            {
                "real_name": "lines-around-comment",
                "display_name": "lines-around-comment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制注释周围有空行 (lines-around-comment)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require empty lines around comments (lines-around-comment)\n强制注释周围有空行 (lines-around-comment)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nMany style guides require empty lines before or after comments. The primary goal\nof these rules is to make the comments easier to read and improve readability of the code.\n很多风格指南要求在注释前后要有空行。该规则的主要目标是使这些注释更易阅读，提高代码的可读性。\nRule Details\nThis rule requires empty lines before and/or after comments. It can be enabled separately for both block (/*) and line (//) comments. This rule does not apply to comments that appear on the same line as code and does not require empty lines at the beginning or end of a file.\n该规则允许你指定在注释之前或之后是否应该有空行。它可以区分块级注释 (/*) 和单行注释(//)。该规则不适用于注释和代码出现在同一行的情况，也不要求在文件开头和末尾有空行。空行\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"beforeBlockComment\": true (default) requires an empty line before block comments\n\"beforeBlockComment\": true (默认) 要求在块级注释之前有一空行\n\"beforeBlockComment\": false disallows an empty line before block comments\n\"beforeBlockComment\": false 禁止在块级注释之前有一空行\n\"afterBlockComment\": true requires an empty line after block comments\n\"afterBlockComment\": true 要求在块级注释之后有一空行\n\"beforeLineComment\": true requires an empty line before line comments\n\"beforeLineComment\": true 要求在行级注释之前有一空行\n\"afterLineComment\": true requires an empty line after line comments\n\"afterLineComment\": true 要求在行级注释之后有一空行\n\"allowBlockStart\": true allows comments to appear at the start of block statements\n\"allowBlockStart\": true 允许注释出现在块语句的开始位置\n\"allowBlockEnd\": true allows comments to appear at the end of block statements\n\"allowBlockEnd\": true 允许注释出现在块语句的结束位置\n\"allowObjectStart\": true allows comments to appear at the start of object literals\n\"allowObjectStart\": true 允许注释出现在对象字面量的开始位置\n\"allowObjectEnd\": true allows comments to appear at the end of object literals\n\"allowObjectEnd\": true 允许注释出现在对象字面量的结束位置\n\"allowArrayStart\": true allows comments to appear at the start of array literals\n\"allowArrayStart\": true 允许注释出现在数组字面量的开始位置\n\"allowArrayEnd\": true allows comments to appear at the end of array literals\n\"allowArrayEnd\": true 允许注释出现在数组字面量的结束位置\n\"applyDefaultIgnorePatterns\" enables or disables the default comment patterns to be ignored by the rule\n\"ignorePattern\" custom patterns to be ignored by the rule\n    beforeBlockComment\n\n\nExamples of incorrect code for this rule with the default { \"beforeBlockComment\": true } option:\n默认选项 { \"beforeBlockComment\": true } 的 错误 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true }]*/\n\nvar night = \"long\";\n/* what a great and wonderful day */\nvar day = \"great\"\n\n\nExamples of correct code for this rule with the default { \"beforeBlockComment\": true } option:\n默认选项 { \"beforeBlockComment\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true }]*/\n\nvar night = \"long\";\n\n/* what a great and wonderful day */\nvar day = \"great\"\n\n\nafterBlockComment\nExamples of incorrect code for this rule with the { \"afterBlockComment\": true } option:\n选项 { \"afterBlockComment\": true } 的 错误 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true }]*/\n\nvar night = \"long\";\n\n/* what a great and wonderful day */\nvar day = \"great\"\n\n\nExamples of correct code for this rule with the { \"afterBlockComment\": true } option:\n选项 { \"afterBlockComment\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true }]*/\n\nvar night = \"long\";\n\n/* what a great and wonderful day */\n\nvar day = \"great\"\n\n\nbeforeLineComment\nExamples of incorrect code for this rule with the { \"beforeLineComment\": true } option:\n选项 { \"beforeLineComment\": true } 的 错误 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true }]*/\n\nvar night = \"long\";\n// what a great and wonderful day\nvar day = \"great\"\n\n\nExamples of correct code for this rule with the { \"beforeLineComment\": true } option:\n选项 { \"beforeLineComment\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true }]*/\n\nvar night = \"long\";\n\n// what a great and wonderful day\nvar day = \"great\"\n\n\nafterLineComment\nExamples of incorrect code for this rule with the { \"afterLineComment\": true } option:\n选项 { \"afterLineComment\": true } 的 错误 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true }]*/\n\nvar night = \"long\";\n// what a great and wonderful day\nvar day = \"great\"\n\n\nExamples of correct code for this rule with the { \"afterLineComment\": true } option:\n选项 { \"afterLineComment\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true }]*/\n\nvar night = \"long\";\n// what a great and wonderful day\n\nvar day = \"great\"\n\n\nallowBlockStart\nExamples of correct code for this rule with the { \"beforeLineComment\": true, \"allowBlockStart\": true } options:\n选项 { \"beforeLineComment\": true, \"allowBlockStart\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowBlockStart\": true }]*/\n\nfunction foo(){\n    // what a great and wonderful day\n    var day = \"great\"\n    return day;\n}\n\n\nExamples of correct code for this rule with the { \"beforeBlockComment\": true, \"allowBlockStart\": true } options:\n选项 { \"beforeBlockComment\": true, \"allowBlockStart\": true } 的 正确代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowBlockStart\": true }]*/\n\nfunction foo(){\n    /* what a great and wonderful day */\n    var day = \"great\"\n    return day;\n}\n\n\nallowBlockEnd\nExamples of correct code for this rule with the { \"afterLineComment\": true, \"allowBlockEnd\": true } option:\n选项 { \"afterLineComment\": true, \"allowBlockEnd\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowBlockEnd\": true }]*/\n\nfunction foo(){\n    var day = \"great\"\n    return day;\n    // what a great and wonderful day\n}\n\n\nExamples of correct code for this rule with the { \"afterBlockComment\": true, \"allowBlockEnd\": true } option:\n选项 { \"afterBlockComment\": true, \"allowBlockEnd\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowBlockEnd\": true }]*/\n\nfunction foo(){\n    var day = \"great\"\n    return day;\n\n    /* what a great and wonderful day */\n}\n\n\nallowObjectStart\nExamples of correct code for this rule with the { \"beforeLineComment\": true, \"allowObjectStart\": true } option:\n选项 { \"beforeLineComment\": true, \"allowObjectStart\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowObjectStart\": true }]*/\n\nvar foo = {\n    // what a great and wonderful day\n    day: \"great\"\n};\n\nconst {\n    // what a great and wonderful day\n    foo: someDay\n} = {foo: \"great\"};\n\nconst {\n    // what a great and wonderful day\n    day\n} = {day: \"great\"};\n\n\nExamples of correct code for this rule with the { \"beforeBlockComment\": true, \"allowObjectStart\": true } option:\n选项 { \"beforeBlockComment\": true, \"allowObjectStart\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowObjectStart\": true }]*/\n\nvar foo = {\n    /* what a great and wonderful day */\n    day: \"great\"\n};\n\nconst {\n    /* what a great and wonderful day */\n    foo: someDay\n} = {foo: \"great\"};\n\nconst {\n    /* what a great and wonderful day */\n    day\n} = {day: \"great\"};\n\n\nallowObjectEnd\nExamples of correct code for this rule with the { \"afterLineComment\": true, \"allowObjectEnd\": true } option:\n选项 { \"afterLineComment\": true, \"allowObjectEnd\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowObjectEnd\": true }]*/\n\nvar foo = {\n    day: \"great\"\n    // what a great and wonderful day\n};\n\nconst {\n    foo: someDay\n    // what a great and wonderful day\n} = {foo: \"great\"};\n\nconst {\n    day\n    // what a great and wonderful day\n} = {day: \"great\"};\n\n\nExamples of correct code for this rule with the { \"afterBlockComment\": true, \"allowObjectEnd\": true } option:\n选项 { \"afterBlockComment\": true, \"allowObjectEnd\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowObjectEnd\": true }]*/\n\nvar foo = {\n    day: \"great\"\n\n    /* what a great and wonderful day */\n};\n\nconst {\n    foo: someDay\n\n    /* what a great and wonderful day */\n} = {foo: \"great\"};\n\nconst {\n    day\n\n    /* what a great and wonderful day */\n} = {day: \"great\"};\n\n\nallowArrayStart\nExamples of correct code for this rule with the { \"beforeLineComment\": true, \"allowArrayStart\": true } option:\n选项 { \"beforeLineComment\": true, \"allowArrayStart\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeLineComment\": true, \"allowArrayStart\": true }]*/\n\nvar day = [\n    // what a great and wonderful day\n    \"great\",\n    \"wonderful\"\n];\n\nconst [\n    // what a great and wonderful day\n    someDay\n] = [\"great\", \"not great\"];\n\n\nExamples of correct code for this rule with the { \"beforeBlockComment\": true, \"allowArrayStart\": true } option:\n选项 { \"beforeBlockComment\": true, \"allowArrayStart\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"beforeBlockComment\": true, \"allowArrayStart\": true }]*/\n\nvar day = [\n    /* what a great and wonderful day */\n    \"great\",\n    \"wonderful\"\n];\n\nconst [\n    /* what a great and wonderful day */\n    someDay\n] = [\"great\", \"not great\"];\n\n\nallowArrayEnd\nExamples of correct code for this rule with the { \"afterLineComment\": true, \"allowArrayEnd\": true } option:\n选项 { \"afterLineComment\": true, \"allowArrayEnd\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterLineComment\": true, \"allowArrayEnd\": true }]*/\n\nvar day = [\n    \"great\",\n    \"wonderful\"\n    // what a great and wonderful day\n];\n\nconst [\n    someDay\n    // what a great and wonderful day\n] = [\"great\", \"not great\"];\n\n\nExamples of correct code for this rule with the { \"afterBlockComment\": true, \"allowArrayEnd\": true } option:\n选项 { \"afterBlockComment\": true, \"allowArrayEnd\": true } 的 正确 代码示例：\n/*eslint lines-around-comment: [\"error\", { \"afterBlockComment\": true, \"allowArrayEnd\": true }]*/\n\nvar day = [\n    \"great\",\n    \"wonderful\"\n\n    /* what a great and wonderful day */\n];\n\nconst [\n    someDay\n\n    /* what a great and wonderful day */\n] = [\"great\", \"not great\"];\n\n\nignorePattern\nBy default this rule ignores comments starting with the following words: eslint, jshint, jslint, istanbul, global, exported, jscs. An alternative regular expression can be provided.\nExamples of correct code for the ignorePattern option:\n/*eslint lines-around-comment: [\"error\"]*/\n\nfoo();\n/* eslint mentioned in this comment */,\nbar();\n\n\n/*eslint lines-around-comment: [\"error\", { \"ignorePattern\": \"pragma\" }] */\n\nfoo();\n/* a valid comment using pragma in it */\n\n\nExamples of incorrect code for the ignorePattern option:\n/*eslint lines-around-comment: [\"error\", { \"ignorePattern\": \"pragma\" }] */\n\n1 + 1;\n/* something else */\n\n\napplyDefaultIgnorePatterns\nDefault ignore patterns are applied even when ignorePattern is provided. If you want to omit default patterns, set this option to false.\nExamples of correct code for the { \"applyDefaultIgnorePatterns\": false } option:\n/*eslint lines-around-comment: [\"error\", { \"ignorePattern\": \"pragma\", applyDefaultIgnorePatterns: false }] */\n\nfoo();\n/* a valid comment using pragma in it */\n\n\nExamples of incorrect code for the { \"applyDefaultIgnorePatterns\": false } option:\n/*eslint lines-around-comment: [\"error\", { \"applyDefaultIgnorePatterns\": false }] */\n\nfoo();\n/* eslint mentioned in comment */\n\n\n\nWhen Not To Use It\nMany people enjoy a terser code style and don’t mind comments bumping up against code. If you fall into that category this rule is not for you.\n很多人喜欢简洁的代码风格，不介意代码中注释的风格。如果你也是这样的，此规则不适合你。\nRelated Rules\n\nspace-before-blocks\nspaced-comment\n\nVersion\nThis rule was introduced in ESLint 0.22.0.\n该规则在 ESLint 0.22.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/lines-around-comment",
                "disable": false
            },
            {
                "real_name": "lines-around-directive",
                "display_name": "lines-around-directive",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require or disallow newlines around directives (lines-around-directive)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow newlines around directives (lines-around-directive)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nThis rule was deprecated in ESLint v4.0.0 and replaced by the padding-line-between-statements rule.\nDirectives are used in JavaScript to indicate to the execution environment that a script would like to opt into a feature such as \"strict mode\". Directives are grouped together in a directive prologue at the top of either a file or function block and are applied to the scope in which they occur.\n// Strict mode is invoked for the entire script\n\"use strict\";\n\nvar foo;\n\nfunction bar() {\n  var baz;\n}\n\n\nvar foo;\n\nfunction bar() {\n  // Strict mode is only invoked within this function\n  \"use strict\";\n\n  var baz;\n}\n\n\nRule Details\nThis rule requires or disallows blank newlines around directive prologues. This rule does not enforce any conventions about blank newlines between the individual directives. In addition, it does not require blank newlines before directive prologues unless they are preceded by a comment. Please use the padded-blocks rule if this is a style you would like to enforce.\nOptions\nThis rule has one option. It can either be a string or an object:\n\n\"always\" (default) enforces blank newlines around directives.\n\"never\" disallows blank newlines around directives.\n\nor\n{\n  \"before\": \"always\" or \"never\"\n  \"after\": \"always\" or \"never\",\n}\n\n\nalways\nThis is the default option.\nExamples of incorrect code for this rule with the \"always\" option:\n/* eslint lines-around-directive: [\"error\", \"always\"] */\n\n/* Top of file */\n\"use strict\";\nvar foo;\n\n/* Top of file */\n// comment\n\"use strict\";\n\"use asm\";\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n  var bar;\n}\n\nfunction foo() {\n  // comment\n  \"use strict\";\n  var bar;\n}\n\n\nExamples of correct code for this rule with the \"always\" option:\n/* eslint lines-around-directive: [\"error\", \"always\"] */\n\n/* Top of file */\n\"use strict\";\n\nvar foo;\n\n/* Top of file */\n// comment\n\n\"use strict\";\n\"use asm\";\n\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n\n  var bar;\n}\n\nfunction foo() {\n  // comment\n\n  \"use strict\";\n\n  var bar;\n}\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n/* eslint lines-around-directive: [\"error\", \"never\"] */\n\n/* Top of file */\n\n\"use strict\";\n\nvar foo;\n\n\n/* Top of file */\n// comment\n\n\"use strict\";\n\"use asm\";\n\nvar foo;\n\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n\n  var bar;\n}\n\n\nfunction foo() {\n  // comment\n\n  \"use strict\";\n\n  var bar;\n}\n\n\nExamples of correct code for this rule with the \"never\" option:\n/* eslint lines-around-directive: [\"error\", \"never\"] */\n\n/* Top of file */\n\"use strict\";\nvar foo;\n\n/* Top of file */\n// comment\n\"use strict\";\n\"use asm\";\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n  var bar;\n}\n\nfunction foo() {\n  // comment\n  \"use strict\";\n  var bar;\n}\n\n\nbefore & after\nExamples of incorrect code for this rule with the { \"before\": \"never\", \"after\": \"always\" } option:\n/* eslint lines-around-directive: [\"error\", { \"before\": \"never\", \"after\": \"always\" }] */\n\n/* Top of file */\n\n\"use strict\";\nvar foo;\n\n/* Top of file */\n// comment\n\n\"use strict\";\n\"use asm\";\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n  var bar;\n}\n\nfunction foo() {\n  // comment\n\n  \"use strict\";\n  var bar;\n}\n\n\nExamples of correct code for this rule with the { \"before\": \"never\", \"after\": \"always\" }  option:\n/* eslint lines-around-directive: [\"error\", { \"before\": \"never\", \"after\": \"always\" }] */\n\n/* Top of file */\n\"use strict\";\n\nvar foo;\n\n/* Top of file */\n// comment\n\"use strict\";\n\"use asm\";\n\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n\n  var bar;\n}\n\nfunction foo() {\n  // comment\n  \"use strict\";\n\n  var bar;\n}\n\n\nExamples of incorrect code for this rule with the { \"before\": \"always\", \"after\": \"never\" } option:\n/* eslint lines-around-directive: [\"error\", { \"before\": \"always\", \"after\": \"never\" }] */\n\n/* Top of file */\n\"use strict\";\n\nvar foo;\n\n/* Top of file */\n// comment\n\"use strict\";\n\"use asm\";\n\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n\n  var bar;\n}\n\nfunction foo() {\n  // comment\n  \"use strict\";\n\n  var bar;\n}\n\n\nExamples of correct code for this rule with the { \"before\": \"always\", \"after\": \"never\" } option:\n/* eslint lines-around-directive: [\"error\", { \"before\": \"always\", \"after\": \"never\" }] */\n\n/* Top of file */\n\"use strict\";\nvar foo;\n\n/* Top of file */\n// comment\n\n\"use strict\";\n\"use asm\";\nvar foo;\n\nfunction foo() {\n  \"use strict\";\n  \"use asm\";\n  var bar;\n}\n\nfunction foo() {\n  // comment\n\n  \"use strict\";\n  var bar;\n}\n\n\nWhen Not To Use It\nYou can safely disable this rule if you do not have any strict conventions about whether or not directive prologues should have blank newlines before or after them.\nRelated Rules\n\nlines-around-comment\npadded-blocks\n\nCompatibility\n\nJSCS: requirePaddingNewLinesAfterUseStrict\nJSCS: disallowPaddingNewLinesAfterUseStrict\n\nVersion\nThis rule was introduced in ESLint 3.5.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/lines-around-directive",
                "disable": false
            },
            {
                "real_name": "lines-between-class-members",
                "display_name": "lines-between-class-members",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require or disallow an empty line between class members.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "1.Expected blank line between class members.\n2.Unexpected blank line between class members.\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/lines-between-class-members",
                "disable": false
            },
            {
                "real_name": "max-depth",
                "display_name": "max-depth",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制块语句的最大可嵌套深度 (max-depth)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum depth that blocks can be nested (max-depth)\n强制块语句的最大可嵌套深度 (max-depth)\nMany developers consider code difficult to read if blocks are nested beyond a certain depth.\n很多开发者认为如果块语句嵌套深度超过某个值，代码就很难阅读。\nRule Details\nThis rule enforces a maximum depth that blocks can be nested to reduce code complexity.\n该规则强制块语句的最大可嵌套深度来降低代码的复杂性。\nOptions\nThis rule has a number or object option:\n该规则有一个数字或对象选项：\n\n\"max\" (default 4) enforces a maximum depth that blocks can be nested\n\"max\" (默认 4) 强制块语句的最大可嵌套深度\n\nDeprecated: The object property maximum is deprecated; please use the object property max instead.\n已弃用： maximum 属性已弃用；请使用 max 属性。\nmax\nExamples of incorrect code for this rule with the default { \"max\": 4 } option:\n默认选项 { \"max\": 4 } 的 错误 代码示例：\n/*eslint max-depth: [\"error\", 4]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    for (;;) { // Nested 1 deep\n        let val = () => (param) => { // Nested 2 deep\n            if (true) { // Nested 3 deep\n                if (true) { // Nested 4 deep\n                    if (true) { // Nested 5 deep\n                    }\n                }\n            }\n        };\n    }\n}\n\n\nExamples of correct code for this rule with the default { \"max\": 4 } option:\n默认选项 { \"max\": 4 } 的 正确 代码示例：\n/*eslint max-depth: [\"error\", 4]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    for (;;) { // Nested 1 deep\n        let val = () => (param) => { // Nested 2 deep\n           if (true) { // Nested 3 deep\n                if (true) { // Nested 4 deep\n                }\n            }\n        };\n    }\n}\n\n\nRelated Rules\n\ncomplexity\nmax-len\nmax-nested-callbacks\nmax-params\nmax-statements\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-depth",
                "disable": false
            },
            {
                "real_name": "max-len",
                "display_name": "max-len",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制行的最大长度 (max-len)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum line length (max-len)\n强制行的最大长度 (max-len)\nVery long lines of code in any language can be difficult to read. In order to aid in readability and maintainability many coders have developed a convention to limit lines of code to X number of characters (traditionally 80 characters).\n代码中非常长的行在任何语言中都很难阅读。为了提高可读性和可维护性，许多程序员制定了一项约定，来限制一行代码的字符数量(按照惯例80个字符)。\nvar foo = { \"bar\": \"This is a bar.\", \"baz\": { \"qux\": \"This is a qux\" }, \"difficult\": \"to read\" }; // very long\n\n\nRule Details\nThis rule enforces a maximum line length to increase code readability and maintainability. The length of a line is defined as the number of Unicode characters in the line.\n该规则旨在通过限制代码行的长度来提高代码的可读性和可维护性。因此，如果超过了配置的最大值，该规则将发出警告。一行的长度为行中的 Unicode 字符的数量。\nNote: This rule calculates the length of a line via code points, not characters. That means if you use a double-byte character in your code, it will count as 2 code points instead of 1, and 2 will be used to calculate line length. This is a technical limitation of JavaScript that is made easier with ES2015, and we will look to update this when ES2015 is available in Node.js.\n注意：该规则是通过编码长度而不是字符格式来计算某一行的长度。这就意味着，如果你在代码中使用了双字节字符，它将被计数为 2 而不是 1 。这是 JavaScript 的一个技术上的局限性，在 ES2015 中会变得更加容易，而且在  Node.js 支持 ES2015 时，我们将更新这个规则。\nOptions\nThis rule has a number or object option:\n该规则有一个数字或对象选项：\n\n\"code\" (default 80) enforces a maximum line length\n\"code\" (默认 80) 强制行的最大长度\n\"tabWidth\" (default 4) specifies the character width for tab characters\n\"tabWidth\" (默认 4) 指定 tab 字符的宽度\n\"comments\" enforces a maximum line length for comments; defaults to value of code\n\"comments\" 强制注释的最大长度；默认长度同 code\n\"ignorePattern\" ignores lines matching a regular expression; can only match a single line and need to be double escaped when written in YAML or JSON\n\"ignorePattern\" 忽略正则表达式匹配的行；可以只匹配单行，而且在 YAML 或 JSON 中需要双重转义\n\"ignoreComments\": true ignores all trailing comments and comments on their own line\n\"ignoreComments\": true 忽略所有拖尾注释和行内注释\n\"ignoreTrailingComments\": true ignores only trailing comments\n\"ignoreTrailingComments\": true 忽略拖尾注释\n\"ignoreUrls\": true ignores lines that contain a URL\n\"ignoreUrls\": true 忽略含有链接的行\n\"ignoreStrings\": true ignores lines that contain a double-quoted or single-quoted string\n\"ignoreStrings\": true 忽略含有双引号或单引号字符串的行\n\"ignoreTemplateLiterals\": true ignores lines that contain a template literal\n\"ignoreTemplateLiterals\": true 忽略包含模板字面量的行\n\"ignoreRegExpLiterals\": true ignores lines that contain a RegExp literal\n\"ignoreRegExpLiterals\": true 忽略包含正则表达式的行\n\ncode\nExamples of incorrect code for this rule with the default { \"code\": 80 } option:\n默认选项 { \"code\": 80 } 的 错误 代码示例：\n/*eslint max-len: [\"error\", 80]*/\n\nvar foo = { \"bar\": \"This is a bar.\", \"baz\": { \"qux\": \"This is a qux\" }, \"difficult\": \"to read\" };\n\n\nExamples of correct code for this rule with the default { \"code\": 80 } option:\n默认选项 { \"code\": 80 } 的 正确 代码示例：\n/*eslint max-len: [\"error\", 80]*/\n\nvar foo = {\n  \"bar\": \"This is a bar.\",\n  \"baz\": { \"qux\": \"This is a qux\" },\n  \"easier\": \"to read\"\n};\n\n\ntabWidth\nExamples of incorrect code for this rule with the default { \"tabWidth\": 4 } option:\n默认选项 { \"tabWidth\": 4 } 的 错误 代码示例：\n/*eslint max-len: [\"error\", 80, 4]*/\n\n\\t  \\t  var foo = { \"bar\": \"This is a bar.\", \"baz\": { \"qux\": \"This is a qux\" } };\n\n\nExamples of correct code for this rule with the default { \"tabWidth\": 4 } option:\n默认选项 { \"tabWidth\": 4 } 的 正确 代码示例：\n/*eslint max-len: [\"error\", 80, 4]*/\n\n\\t  \\t  var foo = {\n\\t  \\t  \\t  \\t  \"bar\": \"This is a bar.\",\n\\t  \\t  \\t  \\t  \"baz\": { \"qux\": \"This is a qux\" }\n\\t  \\t  };\n\n\ncomments\nExamples of incorrect code for this rule with the { \"comments\": 65 } option:\n选项 { \"comments\": 65 } 的 错误 代码示例：\n/*eslint max-len: [\"error\", { \"comments\": 65 }]*/\n\n/**\n * This is a comment that violates the maximum line length we have specified\n**/\n\n\nignoreComments\nExamples of correct code for this rule with the { \"ignoreComments\": true } option:\n选项 { \"ignoreComments\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignoreComments\": true }]*/\n\n/**\n * This is a really really really really really really really really really long comment\n**/\n\n\nignoreTrailingComments\nExamples of correct code for this rule with the { \"ignoreTrailingComments\": true } option:\n选项 { \"ignoreTrailingComments\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignoreTrailingComments\": true }]*/\n\nvar foo = 'bar'; // This is a really really really really really really really long comment\n\n\nignoreUrls\nExamples of correct code for this rule with the { \"ignoreUrls\": true } option:\n选项 { \"ignoreUrls\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignoreUrls\": true }]*/\n\nvar url = 'https://www.example.com/really/really/really/really/really/really/really/long';\n\n\nignoreStrings\nExamples of correct code for this rule with the { \"ignoreStrings\": true } option:\n选项 { \"ignoreStrings\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignoreStrings\": true }]*/\n\nvar longString = 'this is a really really really really really long string!';\n\n\nignoreTemplateLiterals\nExamples of correct code for this rule with the { \"ignoreTemplateLiterals\": true } option:\n选项 { \"ignoreTemplateLiterals\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignoreTemplateLiterals\": true }]*/\n\nvar longTemplateLiteral = `this is a really really really really really long template literal!`;\n\n\nignoreRegExpLiterals\nExamples of correct code for this rule with the { \"ignoreRegExpLiterals\": true } option:\n选项 { \"ignoreRegExpLiterals\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignoreRegExpLiterals\": true }]*/\n\nvar longRegExpLiteral = /this is a really really really really really long regular expression!/;\n\n\nignorePattern\nExamples of correct code for this rule with the { \"ignorePattern\": true } option:\n选项 { \"ignorePattern\": true } 的 正确 代码示例：\n/*eslint max-len: [\"error\", { \"ignorePattern\": \"^\\\\s*var\\\\s.+=\\\\s*require\\\\s*\\\\(/\" }]*/\n\nvar dep = require('really/really/really/really/really/really/really/really/long/module');\n\n\nRelated Rules\n\ncomplexity\nmax-depth\nmax-nested-callbacks\nmax-params\nmax-statements\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-len",
                "disable": false
            },
            {
                "real_name": "max-lines",
                "display_name": "max-lines",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制文件的最大行数 (max-lines)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum file length (max-lines)\n强制文件的最大行数 (max-lines)\nSome people consider large files a code smell. Large files tend to do a lot of things and can make it hard following what’s going. While there is not an objective maximum number of lines considered acceptable in a file, most people would agree it should not be in the thousands. Recommendations usually range from 100 to 500 lines.\n有些人把大文件看作是一种代码味道。大文件可以做很多事情，也很难跟踪到底发生了什么。虽然没有一个客观的被认为是可接受的最大行数，大多数人会同意文件中的行数不应该不受限制。通常建议 100 到 500 行。\nRule Details\nThis rule enforces a maximum number of lines per file, in order to aid in maintainability and reduce complexity.\n该规则强制文件的最大行数，以提高可维护性和降低复杂度。\nOptions\nThis rule has a number or object option:\n该规则有一个数字或对象选项：\n\n\"max\" (default 300) enforces a maximum number of lines in a file\n\"max\" (默认 300) 强制一个文件的最大行数\n\"skipBlankLines\": true ignore lines made up purely of whitespace.\n\"skipBlankLines\": true 忽略空白行\n\"skipComments\": true ignore lines containing just comments\n\"skipComments\": true 忽略只包含注释的行\n\ncode\nExamples of incorrect code for this rule with a max value of 2:\n最大行数为 2 的 错误 代码示例：\n/*eslint max-lines: [\"error\", 2]*/\nvar a,\n    b,\n    c;\n\n\n/*eslint max-lines: [\"error\", 2]*/\n\nvar a,\n    b,c;\n\n\n/*eslint max-lines: [\"error\", 2]*/\n// a comment\nvar a,\n    b,c;\n\n\nExamples of correct code for this rule with a max value of 2:\n最大行数为 2 的 正确 代码示例：\n/*eslint max-lines: [\"error\", 2]*/\nvar a,\n    b, c;\n\n\n/*eslint max-lines: [\"error\", 2]*/\n\nvar a, b, c;\n\n\n/*eslint max-lines: [\"error\", 2]*/\n// a comment\nvar a, b, c;\n\n\nskipBlankLines\nExamples of incorrect code for this rule with the { \"skipBlankLines\": true } option:\n选项 { \"skipBlankLines\": true } 的 错误 代码示例：\n/*eslint max-lines: [\"error\", {\"max\": 2, \"skipBlankLines\": true}]*/\n\nvar a,\n    b,\n    c;\n\n\nExamples of correct code for this rule with the { \"skipBlankLines\": true } option:\n选项 { \"skipBlankLines\": true } 的 正确 代码示例：\n/*eslint max-lines: [\"error\", {\"max\": 2, \"skipBlankLines\": true}]*/\n\nvar a,\n    b, c;\n\n\nskipComments\nExamples of incorrect code for this rule with the { \"skipComments\": true } option:\n选项 { \"skipComments\": true } 的 错误 代码示例：\n/*eslint max-lines: [\"error\", {\"max\": 2, \"skipComments\": true}]*/\n// a comment\nvar a,\n    b,\n    c;\n\n\nExamples of correct code for this rule with the { \"skipComments\": true } option:\n选项 { \"skipComments\": true } 的 正确 代码示例：\n/*eslint max-lines: [\"error\", {\"max\": 2, \"skipComments\": true}]*/\n// a comment\nvar a,\n    b, c;\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the number of lines in your files.\n如果你并不关心文件中的行数，你可以关闭此规则。\nFurther reading\n\nSoftware Module size and file size\n\nRelated Rules\n\ncomplexity\nmax-depth\nmax-nested-callbacks\nmax-params\nmax-statements\n\nCompatibility\n\nJSCS: maximumNumberOfLines\n\nVersion\nThis rule was introduced in ESLint 2.12.0.\n该规则在 ESLint 2.12.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-lines",
                "disable": false
            },
            {
                "real_name": "max-lines-per-function",
                "display_name": "max-lines-per-function",
                "severity": "warning",
                "category": "convention",
                "rule_title": "强制函数最大行数 (max-lines-per-function)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "此规则为每个函数强制执行最大行数，以帮助提高可维护性并降低复杂性。",
                "owner": null,
                "labels": [],
                "description": "此规则为每个函数强制执行最大行数，以帮助提高可维护性并降低复杂性。",
                "disable": false
            },
            {
                "real_name": "max-nested-callbacks",
                "display_name": "max-nested-callbacks",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制回调函数最大嵌套深度 (max-nested-callbacks)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum depth that callbacks can be nested (max-nested-callbacks)\n强制回调函数最大嵌套深度 (max-nested-callbacks)\nMany JavaScript libraries use the callback pattern to manage asynchronous operations. A program of any complexity will most likely need to manage several asynchronous operations at various levels of concurrency. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested.\n很多 JavaScript 类库是使用回调模式处理异步操作。任何复杂的程序都将最有可能在不同级别的并发性下处理多个异步回调操作。一个最长见的隐患就是嵌套的回调，使得代码嵌套层级越深越难以阅读。\nfoo(function () {\n    bar(function () {\n        baz(function() {\n            qux(function () {\n\n            });\n        });\n    });\n});\n\n\nRule Details\nThis rule enforces a maximum depth that callbacks can be nested to increase code clarity.\n该规则旨在强制回调函数最大可嵌套深度，以提高代码的清晰度。\nOptions\nThis rule has a number or object option:\n该规则有一个数字或对象选项：\n\n\"max\" (default 10) enforces a maximum depth that callbacks can be nested\n\"max\" (默认 10) 强制回调函数最大可嵌套深度\n\nDeprecated: The object property maximum is deprecated; please use the object property max instead.\n已弃用： maximum 属性已弃用；请使用 max 属性。\nmax\nExamples of incorrect code for this rule with the { \"max\": 3 } option:\n选项 { \"max\": 3 } 的 错误 代码示例：\n/*eslint max-nested-callbacks: [\"error\", 3]*/\n\nfoo1(function() {\n    foo2(function() {\n        foo3(function() {\n            foo4(function() {\n                // Do something\n            });\n        });\n    });\n});\n\n\nExamples of correct code for this rule with the { \"max\": 3 } option:\n选项 { \"max\": 3 } 的 正确 代码示例：\n/*eslint max-nested-callbacks: [\"error\", 3]*/\n\nfoo1(handleFoo1);\n\nfunction handleFoo1() {\n    foo2(handleFoo2);\n}\n\nfunction handleFoo2() {\n    foo3(handleFoo3);\n}\n\nfunction handleFoo3() {\n    foo4(handleFoo4);\n}\n\nfunction handleFoo4() {\n    foo5();\n}\n\n\nFurther Reading\n\nControl flow in Node.js\nControl Flow in Node\nControl Flow in Node Part II\n\nRelated Rules\n\ncomplexity\nmax-depth\nmax-len\nmax-params\nmax-statements\n\nVersion\nThis rule was introduced in ESLint 0.2.0.\n该规则在 ESLint 0.2.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-nested-callbacks",
                "disable": false
            },
            {
                "real_name": "max-params",
                "display_name": "max-params",
                "severity": "error",
                "category": "correctness",
                "rule_title": "限制函数定义中最大参数个数(max-params)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum number of parameters in function definitions (max-params)\n限制函数定义中最大参数个数(max-params)\nFunctions that take numerous parameters can be difficult to read and write because it requires the memorization of what each parameter is, its type, and the order they should appear in. As a result, many coders adhere to a convention that caps the number of parameters a function can take.\n函数如果有许多参数的话，会难以阅读和书写，因为要记住每个参数是什么，它的类型以及它们出现顺序。因此，许多程序员都约定一个函数中参数个数的上限。\nfunction foo (bar, baz, qux, qxx) { // four parameters, may be too many\n    doSomething();\n}\n\n\nRule Details\nThis rule enforces a maximum number of parameters allowed in function definitions.\n该规则强制函数定义中所允许的最大参数个数。\nOptions\nThis rule has a number or object option:\n该规则有一个数字或对象选项：\n\n\"max\" (default 3) enforces a maximum number of parameters in function definitions\n\"max\" (默认 3) 强制函数定义中最大参数个数\n\nDeprecated: The object property maximum is deprecated; please use the object property max instead.\n已弃用： maximum 属性已弃用；请使用 max 属性。\nmax\nExamples of incorrect code for this rule with the default { \"max\": 3 } option:\n默认选 { \"max\": 3 } 的 错误 代码示例：\n/*eslint max-params: [\"error\", 3]*/\n/*eslint-env es6*/\n\nfunction foo (bar, baz, qux, qxx) {\n    doSomething();\n}\n\nlet foo = (bar, baz, qux, qxx) => {\n    doSomething();\n};\n\n\nExamples of correct code for this rule with the default { \"max\": 3 } option:\n默认选项 { \"max\": 3 } 的 正确 代码示例：\n/*eslint max-params: [\"error\", 3]*/\n/*eslint-env es6*/\n\nfunction foo (bar, baz, qux) {\n    doSomething();\n}\n\nlet foo = (bar, baz, qux) => {\n    doSomething();\n};\n\n\nRelated Rules\n\ncomplexity\nmax-depth\nmax-len\nmax-nested-callbacks\nmax-statements\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-params",
                "disable": false
            },
            {
                "real_name": "max-statements",
                "display_name": "max-statements",
                "severity": "error",
                "category": "correctness",
                "rule_title": "限制函数块中的语句的最大数量 (max-statements)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum number of statements allowed in function blocks (max-statements)\n限制函数块中的语句的最大数量 (max-statements)\nThe max-statements rule allows you to specify the maximum number of statements allowed in a function.\n该规则允许你指定一个函数中所允许允许的最大语句数量。\nfunction foo() {\n  var bar = 1; // one statement\n  var baz = 2; // two statements\n  var qux = 3; // three statements\n}\n\n\nRule Details\nThis rule enforces a maximum number of statements allowed in function blocks.\n该规则强制函数中所允许的最大语句数量。\nOptions\nThis rule has a number or object option:\n该规则有一个数字或对象选项：\n\n\"max\" (default 10) enforces a maximum number of statements allows in function blocks\n\nDeprecated: The object property maximum is deprecated; please use the object property max instead.\n已弃用： maximum 属性已弃用；请使用 max 属性。\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"ignoreTopLevelFunctions\": true ignores top-level functions\n\"ignoreTopLevelFunctions\": true 忽略顶级函数\n\nmax\nExamples of incorrect code for this rule with the default { \"max\": 10 } option:\n默认选项 { \"max\": 10 } 的 错误 代码示例：\n/*eslint max-statements: [\"error\", 10]*/\n/*eslint-env es6*/\n\nfunction foo() {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n\n  var foo11 = 11; // Too many.\n}\n\nlet foo = () => {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n\n  var foo11 = 11; // Too many.\n};\n\n\nExamples of correct code for this rule with the default { \"max\": 10 } option:\n默认选项 { \"max\": 10 } 的 正确 代码示例：\n/*eslint max-statements: [\"error\", 10]*/\n/*eslint-env es6*/\n\nfunction foo() {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n  return function () {\n\n    // The number of statements in the inner function does not count toward the\n    // statement maximum.\n\n    return 42;\n  };\n}\n\nlet foo = () => {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n  return function () {\n\n    // The number of statements in the inner function does not count toward the\n    // statement maximum.\n\n    return 42;\n  };\n}\n\n\nignoreTopLevelFunctions\nExamples of additional correct code for this rule with the { \"max\": 10 }, { \"ignoreTopLevelFunctions\": true } options:\n选项 { \"max\": 10 }, { \"ignoreTopLevelFunctions\": true } 的 正确 代码示例：\n/*eslint max-statements: [\"error\", 10, { \"ignoreTopLevelFunctions\": true }]*/\n\nfunction foo() {\n  var foo1 = 1;\n  var foo2 = 2;\n  var foo3 = 3;\n  var foo4 = 4;\n  var foo5 = 5;\n  var foo6 = 6;\n  var foo7 = 7;\n  var foo8 = 8;\n  var foo9 = 9;\n  var foo10 = 10;\n  var foo11 = 11;\n}\n\n\nRelated Rules\n\ncomplexity\nmax-depth\nmax-len\nmax-nested-callbacks\nmax-params\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-statements",
                "disable": false
            },
            {
                "real_name": "max-statements-per-line",
                "display_name": "max-statements-per-line",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制每一行中所允许的最大语句数量 (max-statements-per-line)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce a maximum number of statements allowed per line (max-statements-per-line)\n强制每一行中所允许的最大语句数量 (max-statements-per-line)\nA line of code containing too many statements can be difficult to read. Code is generally read from the top down, especially when scanning, so limiting the number of statements allowed on a single line can be very beneficial for readability and maintainability.\n一行代码中包含太多的语句会很难阅读。代码通常是从上往下阅读，尤其是浏览时，所以，限制单行中所允许的语句数量可以提高可读性和维护性。\nfunction () { var bar; if (condition) { bar = 1; } else { bar = 2; } return true; } // too many statements\n\n\nRule Details\nThis rule enforces a maximum number of statements allowed per line.\n该规则强制每一行中所允许的最大语句数量。\nOptions\nmax\nThe “max” object property is optional (default: 1).\n\"max\" 属性书可选的（默认为 1)。\nExamples of incorrect code for this rule with the default { \"max\": 1 } option:\n默认选项 { \"max\": 1 } 的 错误 代码示例：\n/*eslint max-statements-per-line: [\"error\", { \"max\": 1 }]*/\n\nvar bar; var baz;\nif (condition) { bar = 1; }\nfor (var i = 0; i < length; ++i) { bar = 1; }\nswitch (discriminant) { default: break; }\nfunction foo() { bar = 1; }\nvar foo = function foo() { bar = 1; };\n(function foo() { bar = 1; })();\n\n\nExamples of correct code for this rule with the default { \"max\": 1 } option:\n默认选项 { \"max\": 1 } 的 正确 代码示例：\n/*eslint max-statements-per-line: [\"error\", { \"max\": 1 }]*/\n\nvar bar, baz;\nif (condition) bar = 1;\nfor (var i = 0; i < length; ++i);\nswitch (discriminant) { default: }\nfunction foo() { }\nvar foo = function foo() { };\n(function foo() { })();\n\n\nExamples of incorrect code for this rule with the { \"max\": 2 } option:\n选项 { \"max\": 2 } 的 错误 代码示例：\n/*eslint max-statements-per-line: [\"error\", { \"max\": 2 }]*/\n\nvar bar; var baz; var qux;\nif (condition) { bar = 1; } else { baz = 2; }\nfor (var i = 0; i < length; ++i) { bar = 1; baz = 2; }\nswitch (discriminant) { case 'test': break; default: break; }\nfunction foo() { bar = 1; baz = 2; }\nvar foo = function foo() { bar = 1; };\n(function foo() { bar = 1; baz = 2; })();\n\n\nExamples of correct code for this rule with the { \"max\": 2 } option:\n选项 { \"max\": 2 } 的 正确 代码示例：\n/*eslint max-statements-per-line: [\"error\", { \"max\": 2 }]*/\n\nvar bar; var baz;\nif (condition) bar = 1; if (condition) baz = 2;\nfor (var i = 0; i < length; ++i) { bar = 1; }\nswitch (discriminant) { default: break; }\nfunction foo() { bar = 1; }\nvar foo = function foo() { bar = 1; };\n(function foo() { var bar = 1; })();\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the number of statements on each line.\n如果你并不关心每一行的语句数量，你可以关闭此规则。\nRelated Rules\n\nmax-depth\nmax-len\nmax-nested-callbacks\nmax-params\nmax-statements\n\nVersion\nThis rule was introduced in ESLint 2.5.0.\n该规则在 ESLint 2.5.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/max-statements-per-line",
                "disable": false
            },
            {
                "real_name": "multiline-comment-style",
                "display_name": "multiline-comment-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce a particular style for multiline comments.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "1.Expected a block comment instead of consecutive line comments.\n2.Expected a linebreak after '/*'.\n3.Expected a linebreak before '*/'.\n4.Expected a '*' at the start of this line.\n5.Expected this line to be aligned with the start of the comment.\n6.Expected multiple line comments instead of a block comment.\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/multiline-comment-style",
                "disable": false
            },
            {
                "real_name": "multiline-ternary",
                "display_name": "multiline-ternary",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce or disallow newlines between operands of ternary expressions (multiline-ternary)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce or disallow newlines between operands of ternary expressions (multiline-ternary)\nJavaScript allows operands of ternary expressions to be separated by newlines, which can improve the readability of your program.\nFor example:\nvar foo = bar > baz ? value1 : value2;\n\n\nThe above can be rewritten as the following to improve readability and more clearly delineate the operands:\nvar foo = bar > baz ?\n    value1 :\n    value2;\n\n\nRule Details\nThis rule enforces or disallows newlines between operands of a ternary expression.\nNote: The location of the operators is not enforced by this rule. Please see the operator-linebreak rule if you are interested in enforcing the location of the operators themselves.\nOptions\nThis rule has a string option:\n\n\"always\" (default) enforces newlines between the operands of a ternary expression.\n\"never\" disallows newlines between the operands of a ternary expression (enforcing that the entire ternary expression is on one line).\n\nalways\nThis is the default option.\nExamples of incorrect code for this rule with the \"always\" option:\n/*eslint multiline-ternary: [\"error\", \"always\"]*/\n\nfoo > bar ? value1 : value2;\n\nfoo > bar ? value :\n    value2;\n\nfoo > bar ?\n    value : value2;\n\n\nExamples of correct code for this rule with the \"always\" option:\n/*eslint multiline-ternary: [\"error\", \"always\"]*/\n\nfoo > bar ?\n    value1 :\n    value2;\n\nfoo > bar ?\n    (baz > qux ?\n        value1 :\n        value2) :\n    value3;\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n/*eslint multiline-ternary: [\"error\", \"never\"]*/\n\nfoo > bar ? value :\n    value2;\n\nfoo > bar ?\n    value : value2;\n\nfoo >\n    bar ?\n    value1 :\n    value2;\n\n\nExamples of correct code for this rule with the \"never\" option:\n/*eslint multiline-ternary: [\"error\", \"never\"]*/\n\nfoo > bar ? value1 : value2;\n\nfoo > bar ? (baz > qux ? value1 : value2) : value3;\n\n\nWhen Not To Use It\nYou can safely disable this rule if you do not have any strict conventions about whether the operands of a ternary expression should be separated by newlines.\nRelated Rules\n\noperator-linebreak\n\nCompatibility\n\nJSCS: requireMultiLineTernary\n\nVersion\nThis rule was introduced in ESLint 3.1.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/multiline-ternary",
                "disable": false
            },
            {
                "real_name": "new-cap",
                "display_name": "new-cap",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求构造函数首字母大写 (new-cap)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require constructor names to begin with a capital letter (new-cap)\n要求构造函数首字母大写 (new-cap)\nThe new operator in JavaScript creates a new instance of a particular type of object. That type of object is represented by a constructor function. Since constructor functions are just regular functions, the only defining characteristic is that new is being used as part of the call. Native JavaScript functions begin with an uppercase letter to distinguish those functions that are to be used as constructors from functions that are not. Many style guides recommend following this pattern to more easily determine which functions are to be used as constructors.\n在 JavaScript 中 new 操作符用来创建某个特定类型的对象的一个实例。该类型的对象是由一个构造函数表示的。由于构造函数只是常规函数，唯一区别是使用 new 来调用。本地 JavaScript 函数以首字母大写来区分是否是构造函数。许多风格指南推荐以下模式，可以更容易的确定哪些函数被用作构造函数。\nvar friend = new Person();\n\n\nRule Details\nThis rule requires constructor names to begin with a capital letter. Certain built-in identifiers are exempt from this rule. These identifiers are:\n该规则要求构造函数名首字母大写。特定内建标识符不适用于此规则。这些标识符是：\n\nArray\nArray\nBoolean\nBoolean\nDate\nDate\nError\nError\nFunction\nFunction\nNumber\nNumber\nObject\nObject\nRegExp\nRegExp\nString\nString\nSymbol\nSymbol\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint new-cap: \"error\"*/\n\nfunction foo(arg) {\n    return Boolean(arg);\n}\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"newIsCap\": true (default) requires all new operators to be called with uppercase-started functions.\n\"newIsCap\": true (默认) 要求调用 new 操作符时有首字母大小的函数。\n\"newIsCap\": false allows new operators to be called with lowercase-started or uppercase-started functions.\n\"newIsCap\": false 允许调用 new 操作符有首字母小写或首字母大写的函数。\n\"capIsNew\": true (default) requires all uppercase-started functions to be called with new operators.\n\"capIsNew\": true (默认) 要求调用首字母大写的函数时有 new 操作符。\n\"capIsNew\": false allows uppercase-started functions to be called without new operators.\n\"capIsNew\": false 允许调用首字母大写的函数时没有 new 操作符。\n\"newIsCapExceptions\" allows specified lowercase-started function names to be called with the new operator.\n\"newIsCapExceptions\" 允许调用指定的首字母小写的函数时有 new 操作符。\n\"newIsCapExceptionPattern\" allows any lowercase-started function names that match the specified regex pattern to be called with the new operator.\n\"newIsCapExceptionPattern\" 允许调用任何的首字母小写的函数名匹配指定的正则表达式时有 new 操作符。\n\"capIsNewExceptions\" allows specified uppercase-started function names to be called without the new operator.\n\"capIsNewExceptions\" 允许调用指定的首字母大写的函数时没有 new 操作符。\n\"capIsNewExceptionPattern\" allows any uppercase-started function names that match the specified regex pattern to be called without the new operator.\n\"capIsNewExceptionPattern\" 允许调用任何的首字母大写的函数名匹配指定的正则表达式时没有 new 操作符。\n\"properties\": true (default) enables checks on object properties\n\"properties\": true (默认) 检查对象属性。\n\"properties\": false disables checks on object properties\n\"properties\": false 禁止检查对象属性。\n\nnewIsCap\nExamples of incorrect code for this rule with the default { \"newIsCap\": true } option:\n默认选项 { \"newIsCap\": true } 的 错误 代码示例：\n/*eslint new-cap: [\"error\", { \"newIsCap\": true }]*/\n\nvar friend = new person();\n\n\nExamples of correct code for this rule with the default { \"newIsCap\": true } option:\n默认选项 { \"newIsCap\": true } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"newIsCap\": true }]*/\n\nvar friend = new Person();\n\n\nExamples of correct code for this rule with the { \"newIsCap\": false } option:\n选项 { \"newIsCap\": false } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"newIsCap\": false }]*/\n\nvar friend = new person();\n\n\ncapIsNew\nExamples of incorrect code for this rule with the default { \"capIsNew\": true } option:\n默认选项 { \"capIsNew\": true } 的 错误 代码示例：\n/*eslint new-cap: [\"error\", { \"capIsNew\": true }]*/\n\nvar colleague = Person();\n\n\nExamples of correct code for this rule with the default { \"capIsNew\": true } option:\n默认选项 { \"capIsNew\": true } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"capIsNew\": true }]*/\n\nvar colleague = new Person();\n\n\nExamples of correct code for this rule with the { \"capIsNew\": false } option:\n选项 { \"capIsNew\": false } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"capIsNew\": false }]*/\n\nvar colleague = Person();\n\n\nnewIsCapExceptions\nExamples of additional correct code for this rule with the { \"newIsCapExceptions\": [\"events\"] } option:\n选项 { \"newIsCapExceptions\": [\"events\"] } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"newIsCapExceptions\": [\"events\"] }]*/\n\nvar events = require('events');\n\nvar emitter = new events();\n\n\nnewIsCapExceptionPattern\nExamples of additional correct code for this rule with the { \"newIsCapExceptionPattern\": \"^person\\..\" } option:\n选项 { \"newIsCapExceptionPattern\": \"^person\\..\" } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"newIsCapExceptionPattern\": \"^person\\..\" }]*/\n\nvar friend = new person.acquaintance();\nvar bestFriend = new person.friend();\n\n\ncapIsNewExceptions\nExamples of additional correct code for this rule with the { \"capIsNewExceptions\": [\"Person\"] } option:\n选项 { \"capIsNewExceptions\": [\"Person\"] } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"capIsNewExceptions\": [\"Person\"] }]*/\n\nfunction foo(arg) {\n    return Person(arg);\n}\n\n\ncapIsNewExceptionPattern\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"^Person\\..\" } option:\n选项 { \"capIsNewExceptionPattern\": \"^Person\\..\" } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"capIsNewExceptionPattern\": \"^Person\\..\" }]*/\n\nvar friend = person.Acquaintance();\nvar bestFriend = person.Friend();\n\n\nproperties\nExamples of incorrect code for this rule with the default { \"properties\": true } option:\n默认选项 { \"properties\": true } 的 错误 代码示例：\n/*eslint new-cap: [\"error\", { \"properties\": true }]*/\n\nvar friend = new person.acquaintance();\n\n\nExamples of correct code for this rule with the default { \"properties\": true } option:\n默认选项 { \"properties\": true } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"properties\": true }]*/\n\nvar friend = new person.Acquaintance();\n\n\nExamples of correct code for this rule with the { \"properties\": false } option:\n选项 { \"properties\": false } 的 正确 代码示例：\n/*eslint new-cap: [\"error\", { \"properties\": false }]*/\n\nvar friend = new person.acquaintance();\n\n\nWhen Not To Use It\nIf you have conventions that don’t require an uppercase letter for constructors, or don’t require capitalized functions be only used as constructors, turn this rule off.\n如果你有约定，不需要构造函数首字母大写，或不需要首字母大写的函数仅仅被用作构造函数，那么可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.0.3-0.\n该规则在 ESLint 0.0.3-0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/new-cap",
                "disable": false
            },
            {
                "real_name": "new-parens",
                "display_name": "new-parens",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求调用无参构造函数时带括号 (new-parens)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require parentheses when invoking a constructor with no arguments (new-parens)\n要求调用无参构造函数时带括号 (new-parens)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript allows the omission of parentheses when invoking a function via the new keyword and the constructor has no arguments. However, some coders believe that omitting the parentheses is inconsistent with the rest of the language and thus makes code less clear.\n在 JavaScript 中，如果通过 new 关键调用一个函数而且它的构造函数不带参数，则可以省略后面圆括号。然而，一些程序员认为省略圆括号与整体不一致，从而使代码不清晰。\nvar person = new Person;\n\n\nRule Details\nThis rule requires parentheses when invoking a constructor with no arguments using the new keyword in order to increase code clarity.\n该规则目的在于，当通过 new 关键字调用构造函数时，要求使用圆括号，以此提高代码的清晰度。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint new-parens: \"error\"*/\n\nvar person = new Person;\nvar person = new (Person);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint new-parens: \"error\"*/\n\nvar person = new Person();\nvar person = new (Person)();\n\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/new-parens",
                "disable": false
            },
            {
                "real_name": "newline-after-var",
                "display_name": "newline-after-var",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止变量声明语句后有一行空行 (newline-after-var)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow an empty line after variable declarations (newline-after-var)\n要求或禁止变量声明语句后有一行空行 (newline-after-var)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThis rule was deprecated in ESLint v4.0.0 and replaced by the padding-line-between-statements rule.\n该规则在 ESLint v4.0.0 中 已弃用，被 padding-line-between-statements 替代。\nAs of today there is no consistency in separating variable declarations from the rest of the code. Some developers leave an empty line between var statements and the rest of the code like:\n目前，变量声明和其余代码如何分开并没有一致性。一些开发者在两者之间保留一行空行：\nvar foo;\n\n// do something with foo\n\n\nWhereas others don’t leave any empty newlines at all.\n然而其他人并不这样做。\nvar foo;\n// do something with foo\n\n\nThe problem is when these developers work together in a project. This rule enforces a coding style where empty newlines are allowed or disallowed after var, let, or const statements. It helps the code to look consistent across the entire project.\n在一个项目中，这些开发者在一起工作时就成了问题。该规则强制使用一种代码风格，即 var、let 或 const 语句之后是否允许有空行。它有助于整个项目的代码看起来是一致的。\nRule Details\nThis rule enforces a coding style where empty lines are required or disallowed after var, let, or const statements to achieve a consistent coding style across the project.\n该规则强制一种代码风格，即在 var、let 或 const 之后要求或禁止有空行，以此在整个项目中达到一致的代码风格。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"always\" (default) requires an empty line after var, let, or const. Comments on a line directly after var statements are treated like additional var statements.\n\"always\" (默认) 要求在 var、let 或 const 之后有空行。声明语句后紧随的注释被当作类似于声明语句\n\"never\" disallows empty lines after var, let, or const\n\"never\" 禁止在 var、let 或 const 之后有空行\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint newline-after-var: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar greet = \"hello,\",\n    name = \"world\";\nconsole.log(greet, name);\n\nlet greet = \"hello,\",\n    name = \"world\";\nconsole.log(greet, name);\n\nvar greet = \"hello,\";\nconst NAME = \"world\";\nconsole.log(greet, NAME);\n\nvar greet = \"hello,\";\nvar name = \"world\";\n// var name = require(\"world\");\nconsole.log(greet, name);\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint newline-after-var: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar greet = \"hello,\",\n    name = \"world\";\n\nconsole.log(greet, name);\n\nlet greet = \"hello,\",\n    name = \"world\";\n\nconsole.log(greet, name);\n\nvar greet = \"hello,\";\nconst NAME = \"world\";\n\nconsole.log(greet, NAME);\n\nvar greet = \"hello,\";\nvar name = \"world\";\n// var name = require(\"world\");\n\nconsole.log(greet, name);\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n默认选项 \"never\" 的 错误 代码示例：\n/*eslint newline-after-var: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nvar greet = \"hello,\",\n    name = \"world\";\n\nconsole.log(greet, name);\n\nlet greet = \"hello,\",\n    name = \"world\";\n\nconsole.log(greet, name);\n\nvar greet = \"hello,\";\nconst NAME = \"world\";\n\nconsole.log(greet, NAME);\n\nvar greet = \"hello,\";\nvar name = \"world\";\n// var name = require(\"world\");\n\nconsole.log(greet, name);\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint newline-after-var: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nvar greet = \"hello,\",\n    name = \"world\";\nconsole.log(greet, name);\n\nlet greet = \"hello,\",\n    name = \"world\";\nconsole.log(greet, name);\n\nvar greet = \"hello,\";\nconst NAME = \"world\";\nconsole.log(greet, NAME);\n\nvar greet = \"hello,\";\nvar name = \"world\";\n// var name = require(\"world\");\nconsole.log(greet, name);\n\n\nVersion\nThis rule was introduced in ESLint 0.18.0.\n该规则在 ESLint 0.18.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/newline-after-var",
                "disable": false
            },
            {
                "real_name": "newline-before-return",
                "display_name": "newline-before-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Require an empty line before return statements (newline-before-return).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require an empty line before return statements (newline-before-return)\n要求 return 语句之前有一空行 (newline-before-return)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThis rule was deprecated in ESLint v4.0.0 and replaced by the padding-line-between-statements rule.\n该规则在 ESLint v4.0.0 中 已弃用，被 padding-line-between-statements 替代。\nThere is no hard and fast rule about whether empty lines should precede return statements in JavaScript. However, clearly delineating where a function is returning can greatly increase the readability and clarity of the code. For example:\n在 JavaScript 中，并没有硬性的规定在 return 语句之前应该有空行。然而，清晰的描述函数的返回位置可以大大提高可读性和代码的清晰度。例如：\nfunction foo(bar) {\n  var baz = 'baz';\n  if (!bar) {\n    bar = baz;\n    return bar;\n  }\n  return bar;\n}\n\n\nAdding newlines visibly separates the return statements from the previous lines, making it clear where the function exits and what value it returns:\n通过在 return 语句和它之前的语句之间添加空行，可以使函数的退出位置以及函数的返回值更加清晰：\nfunction foo(bar) {\n  var baz = 'baz';\n\n  if (!bar) {\n    bar = baz;\n\n    return bar;\n  }\n\n  return bar;\n}\n\n\nRule Details\nThis rule requires an empty line before return statements to increase code clarity, except when the return is alone inside a statement group (such as an if statement). In the latter case, the return statement does not need to be delineated by virtue of it being alone. Comments are ignored and do not count as empty lines.\n该规则要求在 return 语句之前添加空行以提高代码清晰度，除了 return 语句空中的唯一语句（比如 if 语句）。注释将被忽略，而且不会记为空行。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint newline-before-return: \"error\"*/\n\nfunction foo(bar) {\n    if (!bar) {\n        return;\n    }\n    return bar;\n}\n\nfunction foo(bar) {\n    if (!bar) {\n        return;\n    }\n    /* multi-line\n    comment */\n    return bar;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint newline-before-return: \"error\"*/\n\nfunction foo() {\n    return;\n}\n\nfunction foo() {\n\n    return;\n}\n\nfunction foo(bar) {\n    if (!bar) return;\n}\n\nfunction foo(bar) {\n    if (!bar) { return };\n}\n\nfunction foo(bar) {\n    if (!bar) {\n        return;\n    }\n}\n\nfunction foo(bar) {\n    if (!bar) {\n        return;\n    }\n\n    return bar;\n}\n\nfunction foo(bar) {\n    if (!bar) {\n\n        return;\n    }\n}\n\nfunction foo() {\n\n    // comment\n    return;\n}\n\n\nWhen Not To Use It\nYou can safely disable this rule if you do not have any strict conventions about whitespace before return statements.\n如果你对 return 语句之前的空白没有严格的约定，你可以禁用此规则。\nRelated Rules\n\nnewline-after-var\n\nVersion\nThis rule was introduced in ESLint 2.3.0.\n该规则在 ESLint 2.3.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/newline-before-return",
                "disable": false
            },
            {
                "real_name": "newline-per-chained-call",
                "display_name": "newline-per-chained-call",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求方法链中每个调用都有一个换行符 (newline-per-chained-call)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require a newline after each call in a method chain (newline-per-chained-call)\n要求方法链中每个调用都有一个换行符 (newline-per-chained-call)\nChained method calls on a single line without line breaks are harder to read, so some developers place a newline character after each method call in the chain to make it more readable and easy to maintain.\n方法链在同一行上调用，不带换行符会使代码很难阅读，所以，一些开发者将换行符放在每个方法调用之后，使它更容易阅读和维护。\nLet’s look at the following perfectly valid (but single line) code.\n让我们看看下面这段完全有效（但在同一行）的代码。\nd3.select(\"body\").selectAll(\"p\").data([4, 8, 15, 16, 23, 42 ]).enter().append(\"p\").text(function(d) { return \"I'm number \" + d + \"!\"; });\n\n\nHowever, with appropriate new lines, it becomes easy to read and understand. Look at the same code written below with line breaks after each call.\n然而，如果进行适当的换行，就很容易阅读和理解。看一下同样的代码，在每个调用后带有换行符。\nd3\n    .select(\"body\")\n    .selectAll(\"p\")\n    .data([\n        4,\n        8,\n        15,\n        16,\n        23,\n        42\n    ])\n    .enter()\n    .append(\"p\")\n    .text(function (d) {\n        return \"I'm number \" + d + \"!\";\n    });\n\n\nAnother argument in favor of this style is that it improves the clarity of diffs when something in the method chain is changed:\n另一种赞成这种风格的观点是，当方法链发生改变，它提高了差异的清晰度。\nLess clear:\n不太清晰：\n-d3.select(\"body\").selectAll(\"p\").style(\"color\", \"white\");\n+d3.select(\"body\").selectAll(\"p\").style(\"color\", \"blue\");\n\n\nMore clear:\n更清楚：\nd3\n    .select(\"body\")\n    .selectAll(\"p\")\n-    .style(\"color\", \"white\");\n+    .style(\"color\", \"blue\");\n\n\nRule Details\nThis rule requires a newline after each call in a method chain or deep member access. Computed property accesses such as instance[something] are excluded.\n该规则要求在方法链中的每个调用之后或或深度成员访问之后有一个换行符。计算属性访问比如 instance[something] 不适用于此规则。\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"ignoreChainWithDepth\" (default: 2) allows chains up to a specified depth.\n\"ignoreChainWithDepth\" (默认为 2) 允许在同一行成链的深度。\n\nignoreChainWithDepth\nExamples of incorrect code for this rule with the default { \"ignoreChainWithDepth\": 2 } option:\n默认选项 { \"ignoreChainWithDepth\": 2 } 的 错误 代码示例：\n/*eslint newline-per-chained-call: [\"error\", { \"ignoreChainWithDepth\": 2 }]*/\n\n_.chain({}).map(foo).filter(bar).value();\n\n// Or\n_.chain({}).map(foo).filter(bar);\n\n// Or\n_\n  .chain({}).map(foo)\n  .filter(bar);\n\n// Or\nobj.method().method2().method3();\n\n\nExamples of correct code for this rule with the default { \"ignoreChainWithDepth\": 2 } option:\n默认选项 { \"ignoreChainWithDepth\": 2 } 的 正确 代码示例：\n/*eslint newline-per-chained-call: [\"error\", { \"ignoreChainWithDepth\": 2 }]*/\n\n_\n  .chain({})\n  .map(foo)\n  .filter(bar)\n  .value();\n\n// Or\n_\n  .chain({})\n  .map(foo)\n  .filter(bar);\n\n// Or\n_.chain({})\n  .map(foo)\n  .filter(bar);\n\n// Or\nobj\n  .prop\n  .method().prop;\n\n// Or\nobj\n  .prop.method()\n  .method2()\n  .method3().prop;\n\n\nWhen Not To Use It\nIf you have conflicting rules or when you are fine with chained calls on one line, you can safely turn this rule off.\n如果你有与之冲突的规则或允许在同一行上成链调用，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-rc.0.\n该规则在 ESLint 2.0.0-rc.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/newline-per-chained-call",
                "disable": false
            },
            {
                "real_name": "no-alert",
                "display_name": "no-alert",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 Alert (no-alert)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Use of Alert (no-alert)\n禁用 Alert (no-alert)\nJavaScript’s alert, confirm, and prompt functions are widely considered to be obtrusive as UI elements and should be replaced by a more appropriate custom UI implementation. Furthermore, alert is often used while debugging code, which should be removed before deployment to production.\nJavaScript 的 alert、confirm 和 prompt 被广泛认为是突兀的 UI 元素，应该被一个更合适的自定义的 UI 界面代替。此外, alert 经常被用于调试代码，部署到生产环境之前应该删除。\nalert(\"here!\");\n\n\nRule Details\nThis rule is aimed at catching debugging code that should be removed and popup UI elements that should be replaced with less obtrusive, custom UIs. As such, it will warn when it encounters alert, prompt, and confirm function calls which are not shadowed.\n该规则旨在捕获本应移除的调试代码和应该被替换为不那么突兀的 UI 元素。因此，当遇到 alert、prompt 和 confirm 时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-alert: \"error\"*/\n\nalert(\"here!\");\n\nconfirm(\"Are you sure?\");\n\nprompt(\"What's your name?\", \"John Doe\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-alert: \"error\"*/\n\ncustomAlert(\"Something happened!\");\n\ncustomConfirm(\"Are you sure?\");\n\ncustomPrompt(\"Who are you?\");\n\nfunction foo() {\n    var alert = myCustomLib.customAlert;\n    alert();\n}\n\n\nRelated Rules\n\nno-console\nno-debugger\n\nVersion\nThis rule was introduced in ESLint 0.0.5.\n该规则在 ESLint 0.0.5 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-alert",
                "disable": false
            },
            {
                "real_name": "no-array-constructor",
                "display_name": "no-array-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow Array constructors (no-array-constructor).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow Array constructors (no-array-constructor)\n禁止使用 Array 构造函数\nUse of the Array constructor to construct a new array is generally\ndiscouraged in favour of array literal notation because of the single-argument\npitfall and because the Array global may be redefined. The exception is when\nthe Array constructor is used to intentionally create sparse arrays of a\nspecified size by giving the constructor a single numeric argument.\n由于单参数的陷阱，和全局范围的 Array 可能被重定义，通常不允许使用 Array的构造函数来创建数组。唯一的例外是通过给构造函数传入指定的一个数值来创建稀疏数组。\nRule Details\nThis rule disallows Array constructors.\n该规则禁止使用 Array 构造函数。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-array-constructor: \"error\"*/\n\nArray(0, 1, 2)\n\n\n/*eslint no-array-constructor: \"error\"*/\n\nnew Array(0, 1, 2)\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-array-constructor: \"error\"*/\n\nArray(500)\n\n\n/*eslint no-array-constructor: \"error\"*/\n\nnew Array(someOtherArray.length)\n\n\nWhen Not To Use It\nThis rule enforces a nearly universal stylistic concern. That being said, this\nrule may be disabled if the constructor style is preferred.\n该规则强制一个几乎很普遍的风格问题。也就是说，如果构造函数的风格是首选的，可以禁用此规则。\nRelated Rules\n\nno-new-object\nno-new-wrappers\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-array-constructor",
                "disable": false
            },
            {
                "real_name": "no-async-constructor",
                "display_name": "no-async-constructor",
                "severity": "warning",
                "category": "convention",
                "rule_title": "禁止使用异步函数作为 Promise executor (no-async-promise-executor)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "此规则旨在禁止使用异步的 Promise executor 函数。",
                "owner": null,
                "labels": [],
                "description": "此规则旨在禁止使用异步的 Promise executor 函数。",
                "disable": false
            },
            {
                "real_name": "no-await-in-loop",
                "display_name": "no-await-in-loop",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow await inside of loops (no-await-in-loop).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow await inside of loops (no-await-in-loop)\nPerforming an operation on each element of an iterable is a common task. However, performing an\nawait as part of each operation is an indication that the program is not taking full advantage of\nthe parallelization benefits of async/await.\nUsually, the code should be refactored to create all the promises at once, then get access to the\nresults using Promise.all(). Otherwise, each successive operation will not start until the\nprevious one has completed.\nConcretely, the following function should be refactored as shown:\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Bad: each loop iteration is delayed until the entire asynchronous operation completes\n    results.push(await bar(thing));\n  }\n  return baz(results);\n}\n\n\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Good: all asynchronous operations are immediately started.\n    results.push(bar(thing));\n  }\n  // Now that all the asynchronous operations are running, here we wait until they all complete.\n  return baz(await Promise.all(results));\n}\n\n\nRule Details\nThis rule disallows the use of await within loop bodies.\nExamples\nExamples of correct code for this rule:\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Good: all asynchronous operations are immediately started.\n    results.push(bar(thing));\n  }\n  // Now that all the asynchronous operations are running, here we wait until they all complete.\n  return baz(await Promise.all(results));\n}\n\n\nExamples of incorrect code for this rule:\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Bad: each loop iteration is delayed until the entire asynchronous operation completes\n    results.push(await bar(thing));\n  }\n  return baz(results);\n}\n\n\nWhen Not To Use It\nIn many cases the iterations of a loop are not actually independent of each-other. For example, the\noutput of one iteration might be used as the input to another. Or, loops may be used to retry\nasynchronous operations that were unsuccessful. In such cases it makes sense to use await within a\nloop and it is recommended to disable the rule via a standard ESLint disable comment.\nVersion\nThis rule was introduced in ESLint 3.12.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-await-in-loop",
                "disable": false
            },
            {
                "real_name": "no-bitwise",
                "display_name": "no-bitwise",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用按位操作符 (no-bitwise)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow bitwise operators (no-bitwise)\n禁止使用按位操作符 (no-bitwise)\nThe use of bitwise operators in JavaScript is very rare and often & or | is simply a mistyped && or ||, which will lead to unexpected behavior.\n在 JavaScript 是很少使用按位操作符，& 或 | 经常会错写为 && 或 ||，这将导致意外的情况出现。\nvar x = y | z;\n\n\nRule Details\nThis rule disallows bitwise operators.\n该规则禁止使用按位操作符。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-bitwise: \"error\"*/\n\nvar x = y | z;\n\nvar x = y & z;\n\nvar x = y ^ z;\n\nvar x = ~ z;\n\nvar x = y << z;\n\nvar x = y >> z;\n\nvar x = y >>> z;\n\nx |= y;\n\nx &= y;\n\nx ^= y;\n\nx <<= y;\n\nx >>= y;\n\nx >>>= y;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-bitwise: \"error\"*/\n\nvar x = y || z;\n\nvar x = y && z;\n\nvar x = y > z;\n\nvar x = y < z;\n\nx += y;\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"allow\": Allows a list of bitwise operators to be used as exceptions.\n\"allow\": 允许作为例外情况出现的按位操作符列表。\n\"int32Hint\": Allows the use of bitwise OR in |0 pattern for type casting.\n\"int32Hint\": 预习使用在 |0 模式中按位或进行类型转换。\n\nallow\nExamples of correct code for this rule with the { \"allow\": [\"~\"] } option:\n选项 { \"allow\": [\"~\"] } 的 正确 代码示例：\n/*eslint no-bitwise: [\"error\", { \"allow\": [\"~\"] }] */\n\n~[1,2,3].indexOf(1) === -1;\n\n\nint32Hint\nExamples of correct code for this rule with the { \"int32Hint\": true } option:\n选项 { \"int32Hint\": true } 的 正确 代码示例：\n/*eslint no-bitwise: [\"error\", { \"int32Hint\": true }] */\n\nvar b = a|0;\n\n\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-bitwise",
                "disable": false
            },
            {
                "real_name": "no-buffer-constructor",
                "display_name": "no-buffer-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow use of the Buffer() constructor (no-buffer-constructor)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow use of the Buffer() constructor (no-buffer-constructor)\nIn Node.js, the behavior of the Buffer constructor is different depending on the type of its argument. Passing an argument from user input to Buffer() without validating its type can lead to security vulnerabilities such as remote memory disclosure and denial of service. As a result, the Buffer constructor has been deprecated and should not be used. Use the producer methods Buffer.from, Buffer.alloc, and Buffer.allocUnsafe instead.\nRule Details\nThis rule disallows calling and constructing the Buffer() constructor.\nExamples of incorrect code for this rule:\nnew Buffer(5);\nnew Buffer([1, 2, 3]);\n\nBuffer(5);\nBuffer([1, 2, 3]);\n\nnew Buffer(res.body.amount);\nnew Buffer(res.body.values);\n\n\nExamples of correct code for this rule:\nBuffer.alloc(5);\nBuffer.allocUnsafe(5);\nBuffer.from([1, 2, 3]);\n\nBuffer.alloc(res.body.amount);\nBuffer.from(res.body.values);\n\n\nWhen Not To Use It\nIf you don’t use Node.js, or you still need to support versions of Node.js that lack methods like Buffer.from, then you should not enable this rule.\nFurther Reading\n\nBuffer API documentation\nLet’s fix Node.js Buffer API\nBuffer(number) is unsafe\n\nVersion\nThis rule was introduced in ESLint 4.0.0-alpha.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-buffer-constructor",
                "disable": false
            },
            {
                "real_name": "no-caller",
                "display_name": "no-caller",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 caller 或 callee (no-caller)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Use of caller/callee (no-caller)\n禁用 caller 或 callee (no-caller)\nThe use of arguments.caller and arguments.callee make several code optimizations impossible. They have been deprecated in future versions of JavaScript and their use is forbidden in ECMAScript 5 while in strict mode.\narguments.caller 和 arguments.callee 的使用使一些代码优化变得不可能。在 JavaScript 的新版本中它们已被弃用，同时在 ECMAScript 5 的严格模式下，它们也是被禁用的。\nfunction foo() {\n    var callee = arguments.callee;\n}\n\n\nRule Details\nThis rule is aimed at discouraging the use of deprecated and sub-optimal code, but disallowing the use of arguments.caller and arguments.callee. As such, it will warn when arguments.caller and arguments.callee are used.\n此规则目的在于阻止使用已弃用的代码和次优的代码，而且禁止使用 arguments.caller 和 arguments.callee。因此，当 arguments.caller 和 arguments.callee 被使用时，该规则将会发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-caller: \"error\"*/\n\nfunction foo(n) {\n    if (n <= 0) {\n        return;\n    }\n\n    arguments.callee(n - 1);\n}\n\n[1,2,3,4,5].map(function(n) {\n    return !(n > 1) ? 1 : arguments.callee(n - 1) * n;\n});\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-caller: \"error\"*/\n\nfunction foo(n) {\n    if (n <= 0) {\n        return;\n    }\n\n    foo(n - 1);\n}\n\n[1,2,3,4,5].map(function factorial(n) {\n    return !(n > 1) ? 1 : factorial(n - 1) * n;\n});\n\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-caller",
                "disable": false
            },
            {
                "real_name": "no-case-declarations",
                "display_name": "no-case-declarations",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在 case 或 default 子句中出现词法声明 (no-case-declarations)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow lexical declarations in case/default clauses (no-case-declarations)\n禁止在 case 或 default 子句中出现词法声明 (no-case-declarations)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThis rule disallows lexical declarations (let, const, function and class)\nin case/default clauses. The reason is that the lexical declaration is visible\nin the entire switch block but it only gets initialized when it is assigned, which\nwill only happen if the case where it is defined is reached.\n该规则禁止词法声明 (let、const、function 和 class) 出现在 case或default 子句中。原因是，词法声明在整个 switch 语句块中是可见的，但是它只有在运行到它定义的 case 语句时，才会进行初始化操作。\nTo ensure that the lexical declaration only applies to the current case clause\nwrap your clauses in blocks.\n为了保证词法声明语句只在当前 case 语句中有效，将你子句包裹在块中。\nRule Details\nThis rule aims to prevent access to uninitialized lexical bindings as well as accessing hoisted functions across case clauses.\n该规则旨在避免访问未经初始化的词法绑定以及跨 case 语句访问被提升的函数。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-case-declarations: \"error\"*/\n/*eslint-env es6*/\n\nswitch (foo) {\n    case 1:\n        let x = 1;\n        break;\n    case 2:\n        const y = 2;\n        break;\n    case 3:\n        function f() {}\n        break;\n    default:\n        class C {}\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-case-declarations: \"error\"*/\n/*eslint-env es6*/\n\n// Declarations outside switch-statements are valid\nconst a = 0;\n\nswitch (foo) {\n    // The following case clauses are wrapped into blocks using brackets\n    case 1: {\n        let x = 1;\n        break;\n    }\n    case 2: {\n        const y = 2;\n        break;\n    }\n    case 3: {\n        function f() {}\n        break;\n    }\n    case 4:\n        // Declarations using var without brackets are valid due to function-scope hoisting\n        var z = 4;\n        break;\n    default: {\n        class C {}\n    }\n}\n\n\nWhen Not To Use It\nIf you depend on fall through behavior and want access to bindings introduced in the case block.\n如果你依赖 case 落空行为，并想访问 case 块中引入的绑定，可以关闭此规则。\nRelated Rules\n\nno-fallthrough\n\nVersion\nThis rule was introduced in ESLint 1.9.0.\n该规则在 ESLint 1.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-case-declarations",
                "disable": false
            },
            {
                "real_name": "no-catch-shadow",
                "display_name": "no-catch-shadow",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许在 catch 语句中遮盖变量 (no-catch-shadow)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Shadowing of Variables Inside of catch (no-catch-shadow)\n不允许在 catch 语句中遮盖变量 (no-catch-shadow)\nIn IE 8 and earlier, the catch clause parameter can overwrite the value of a variable in the outer scope, if that variable has the same name as the catch clause parameter.\n在 IE 8 及更早的版本，catch 子句的参数可以覆盖一个外部的同名变量的值。\nvar err = \"x\";\n\ntry {\n    throw \"problem\";\n} catch (err) {\n\n}\n\nconsole.log(err)    // err is 'problem', not 'x'\n\n\nRule Details\nThis rule is aimed at preventing unexpected behavior in your program that may arise from a bug in IE 8 and earlier, in which the catch clause parameter can leak into outer scopes. This rule will warn whenever it encounters a catch clause parameter that has the same name as a variable in an outer scope.\n在 IE 8 及更早版本中，catch 子句的参数会泄露到外部范围，该规则的目的就是避免这种 bug 导致的意外行为。但 catch 子句中的参数与外部范围的变量同名时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-catch-shadow: \"error\"*/\n\nvar err = \"x\";\n\ntry {\n    throw \"problem\";\n} catch (err) {\n\n}\n\nfunction err() {\n    // ...\n};\n\ntry {\n    throw \"problem\";\n} catch (err) {\n\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-catch-shadow: \"error\"*/\n\nvar err = \"x\";\n\ntry {\n    throw \"problem\";\n} catch (e) {\n\n}\n\nfunction err() {\n    // ...\n};\n\ntry {\n    throw \"problem\";\n} catch (e) {\n\n}\n\n\nWhen Not To Use It\nIf you do not need to support IE 8 and earlier, you should turn this rule off.\n如果你并不需要支持 IE 8 及更早的版本，你应该关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-catch-shadow",
                "disable": false
            },
            {
                "real_name": "no-class-assign",
                "display_name": "no-class-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许修改类声明的变量 (no-class-assign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow modifying variables of class declarations (no-class-assign)\n不允许修改类声明的变量 (no-class-assign)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nClassDeclaration creates a variable, and we can modify the variable.\nClassDeclaration 创建一个变量，我们可以修改这个变量。\n/*eslint-env es6*/\n\nclass A { }\nA = 0;\n\n\nBut the modification is a mistake in most cases.\n但是在大多数情况下，这样的修改是个错误。\nRule Details\nThis rule is aimed to flag modifying variables of class declarations.\n该规则旨在标记类声明中变量的修改情况。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nclass A { }\nA = 0;\n\n\n/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nA = 0;\nclass A { }\n\n\n/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    b() {\n        A = 0;\n    }\n}\n\n\n/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class A {\n    b() {\n        A = 0;\n        // `let A` is shadowed by the class name.\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class A { }\nA = 0; // A is a variable.\n\n\n/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class {\n    b() {\n        A = 0; // A is a variable.\n    }\n}\n\n\n/*eslint no-class-assign: 2*/\n/*eslint-env es6*/\n\nclass A {\n    b(A) {\n        A = 0; // A is a parameter.\n    }\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about modifying variables of class declarations, you can safely disable this rule.\n如果你不想收到类声明中变量的修改的通知，你可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-class-assign",
                "disable": false
            },
            {
                "real_name": "no-compare-neg-zero",
                "display_name": "no-compare-neg-zero",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow comparing against -0 (no-compare-neg-zero)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow comparing against -0 (no-compare-neg-zero)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\nRule Details\nThe rule should warn against code that tries to compare against -0, since that will not work as intended. That is, code like x === -0 will pass for both +0 and -0. The author probably intended Object.is(x, -0).\nExamples of incorrect code for this rule:\n\nif (x === -0) {\n    // doSomething()...\n}\n\n\nExamples of correct code for this rule:\n\nif (x === 0) {\n    // doSomething()...\n}\n\n\n\nif (Object.is(x, -0)) {\n    // doSomething()...\n}\n\n\nVersion\nThis rule was introduced in ESLint 3.17.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-compare-neg-zero",
                "disable": false
            },
            {
                "real_name": "no-cond-assign",
                "display_name": "no-cond-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在条件语句中出现赋值操作符（no-cond-assign）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow assignment operators in conditional statements (no-cond-assign)\n禁止在条件语句中出现赋值操作符（no-cond-assign）\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIn conditional statements, it is very easy to mistype a comparison operator (such as ==) as an assignment operator (such as =). For example:\n在条件语句中，很容易将一个比较运算符（像 ==）错写成赋值运算符（如 =）。例如：\n// Check the user's job title\nif (user.jobTitle = \"manager\") {\n    // user.jobTitle is now incorrect\n}\n\n\nThere are valid reasons to use assignment operators in conditional statements. However, it can be difficult to tell whether a specific assignment was intentional.\n在条件语句中使用赋值操作符是有效的。然而，很难判断某个特定的赋值是否是有意为之。\nRule Details\nThis rule disallows ambiguous assignment operators in test conditions of if, for, while, and do...while statements.\n该规则禁止在 if、for、while 和 do...while 语句中出现模棱两可的赋值操作符。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"except-parens\" (default) allows assignments in test conditions only if they are enclosed in parentheses (for example, to allow reassigning a variable in the test of a while or do...while loop)\n\"except-parens\" (默认) 允许条件语句中出现赋值操作符，前提是它们被圆括号括起来 (例如，在 while 或 do...while 循环条件中，允许赋值给一个变量)\n\"always\" disallows all assignments in test conditions\n\"always\" 禁止条件语句中出现赋值语句\n\nexcept-parens\nExamples of incorrect code for this rule with the default \"except-parens\" option:\n默认选项 \"except-parens\" 的 错误 代码示例：\n/*eslint no-cond-assign: \"error\"*/\n\n// Unintentional assignment\nvar x;\nif (x = 0) {\n    var b = 1;\n}\n\n// Practical example that is similar to an error\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while (someNode = someNode.parentNode);\n}\n\n\nExamples of correct code for this rule with the default \"except-parens\" option:\n默认选项 \"except-parens\" 的 正确 代码示例：\n/*eslint no-cond-assign: \"error\"*/\n\n// Assignment replaced by comparison\nvar x;\nif (x === 0) {\n    var b = 1;\n}\n\n// Practical example that wraps the assignment in parentheses\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode));\n}\n\n// Practical example that wraps the assignment and tests for 'null'\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode) !== null);\n}\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint no-cond-assign: [\"error\", \"always\"]*/\n\n// Unintentional assignment\nvar x;\nif (x = 0) {\n    var b = 1;\n}\n\n// Practical example that is similar to an error\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while (someNode = someNode.parentNode);\n}\n\n// Practical example that wraps the assignment in parentheses\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode));\n}\n\n// Practical example that wraps the assignment and tests for 'null'\nfunction setHeight(someNode) {\n    \"use strict\";\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode) !== null);\n}\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint no-cond-assign: [\"error\", \"always\"]*/\n\n// Assignment replaced by comparison\nvar x;\nif (x === 0) {\n    var b = 1;\n}\n\n\nRelated Rules\n\nno-extra-parens\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-cond-assign",
                "disable": false
            },
            {
                "real_name": "no-confusing-arrow",
                "display_name": "no-confusing-arrow",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow arrow functions where they could be confused with comparisons (no-confusing-arrow)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow arrow functions where they could be confused with comparisons (no-confusing-arrow)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nArrow functions (=>) are similar in syntax to some comparison operators (>, <, <=, and >=). This rule warns against using the arrow function syntax in places where it could be confused with a comparison operator. Even if the arguments of the arrow function are wrapped with parens, this rule still warns about it unless allowParens is set to true.\nHere’s an example where the usage of => could be confusing:\n// The intent is not clear\nvar x = a => 1 ? 2 : 3;\n// Did the author mean this\nvar x = function (a) { return 1 ? 2 : 3 };\n// Or this\nvar x = a <= 1 ? 2 : 3;\n\n\nRule Details\nExamples of incorrect code for this rule:\n/*eslint no-confusing-arrow: \"error\"*/\n/*eslint-env es6*/\n\nvar x = a => 1 ? 2 : 3;\nvar x = (a) => 1 ? 2 : 3;\nvar x = (a) => (1 ? 2 : 3);\n\n\nExamples of correct code for this rule:\n/*eslint no-confusing-arrow: \"error\"*/\n/*eslint-env es6*/\n\nvar x = a => { return 1 ? 2 : 3; };\nvar x = (a) => { return 1 ? 2 : 3; };\n\n\nOptions\nThis rule accepts a single options argument with the following defaults:\n{\n    \"rules\": {\n        \"no-confusing-arrow\": [\"error\", {\"allowParens\": false}]\n    }\n}\n\n\nallowParens is a boolean setting that can be true or false:\n\ntrue relaxes the rule and accepts parenthesis as a valid “confusion-preventing” syntax.\nfalse warns even if the expression is wrapped in parenthesis\n\nExamples of correct code for this rule with the {\"allowParens\": true} option:\n/*eslint no-confusing-arrow: [\"error\", {\"allowParens\": true}]*/\n/*eslint-env es6*/\nvar x = a => (1 ? 2 : 3);\nvar x = (a) => (1 ? 2 : 3);\n\n\nRelated Rules\n\nno-constant-condition\narrow-parens\n\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-2.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-confusing-arrow",
                "disable": false
            },
            {
                "real_name": "no-console",
                "display_name": "no-console",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow the use of console (no-console).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow the use of console (no-console)\n禁用 console (no-console)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIn JavaScript that is designed to be executed in the browser, it’s considered a best practice to avoid using methods on console. Such messages are considered to be for debugging purposes and therefore not suitable to ship to the client. In general, calls using console should be stripped before being pushed to production.\n在 JavaScript，虽然console 被设计为在浏览器中执行的，但避免使用 console 的方法被认为是一种最佳实践。这样的消息被认为是用于调试的，因此不适合输出到客户端。通常，在发布到产品之前应该剔除 console 的调用。\nconsole.log(\"Made it here.\");\nconsole.error(\"That shouldn't have happened.\");\n\n\nRule Details\nThis rule disallows calls to methods of the console object.\n该规则禁止调用 console 对象的方法。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-console: \"error\"*/\n\n\n\nconsole.log(\"Log a debug level message.\");\nconsole.warn(\"Log a warn level message.\");\nconsole.error(\"Log an error level message.\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-console: \"error\"*/\n\n// custom console\nConsole.log(\"Hello world!\");\n\n\nOptions\nThis rule has an object option for exceptions:\n该规则有例外情况，是个对象：\n\n\"allow\" has an array of strings which are allowed methods of the console object\n\"allow\" 是个字符串数组，包含允许使用的console 对象的方法\n\nExamples of additional correct code for this rule with a sample { \"allow\": [\"warn\", \"error\"] } option:\n选项 { \"allow\": [\"warn\", \"error\"] } 的 正确 代码示例：\n/*eslint no-console: [\"error\", { allow: [\"warn\", \"error\"] }] */\n\nconsole.warn(\"Log a warn level message.\");\nconsole.error(\"Log an error level message.\");\n\n\nWhen Not To Use It\nIf you’re using Node.js, however, console is used to output information to the user and so is not strictly used for debugging purposes. If you are developing for Node.js then you most likely do not want this rule enabled.\n如果你在使用 Node.js，然后，console 主要用来向用户输出信息，所以不是严格用于调试目的。如果你正在做 Node.js 开发，那么你很可能不想启用此规则。\nRelated Rules\n\nno-alert\nno-debugger\n\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-console",
                "disable": false
            },
            {
                "real_name": "no-const-assign",
                "display_name": "no-const-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow modifying variables that are declared using const (no-const-assign).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow modifying variables that are declared using const (no-const-assign)\n不允许改变用const声明的变量 (no-const-assign)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nWe cannot modify variables that are declared using const keyword.\nIt will raise a runtime error.\n我们不能修改使用const关键字声明的变量。\n它会引发一个运行时错误。\nUnder non ES2015 environment, it might be ignored merely.\n非 ES2015 环境下，它只是可能被忽略。\nRule Details\nThis rule is aimed to flag modifying variables that are declared using const keyword.\n该规则旨在标记修改用const关键字声明的变量。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na = 1;\n\n\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na += 1;\n\n\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\n++a;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\nconsole.log(a);\n\n\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a in [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}\n\n\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a of [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about modifying variables that are declared using const keyword, you can safely disable this rule.\n如果你不想收到有关修改用const关键字声明的变量的通知，你可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-const-assign",
                "disable": false
            },
            {
                "real_name": "no-constant-condition",
                "display_name": "no-constant-condition",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在条件中使用常量表达式 (no-constant-condition)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow constant expressions in conditions (no-constant-condition)\n禁止在条件中使用常量表达式 (no-constant-condition)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nA constant expression (for example, a literal) as a test condition might be a typo or development trigger for a specific behavior. For example, the following code looks as if it is not ready for production.\n将一个常量表达式（比如，一个字面值）作为一个测试条件可能是个书写错误或者为了触发某个特定的行为。例如，下面的代码看起来像是没有准备好发布的。\nif (false) {\n    doSomethingUnfinished();\n}\n\n\nRule Details\nThis rule disallows constant expressions in the test condition of:\n该规则禁止在以下语句的条件中出现常量表达式：\n\nif, for, while, or do...while statement\nif、for、while 或 do...while 语句\n?: ternary expression\n?: 三元表达式\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-constant-condition: \"error\"*/\n\nif (false) {\n    doSomethingUnfinished();\n}\n\nif (void x) {\n    doSomethingUnfinished();\n}\n\nfor (;-2;) {\n    doSomethingForever();\n}\n\nwhile (typeof x) {\n    doSomethingForever();\n}\n\ndo{\n    doSomethingForever();\n} while (x = -1);\n\nvar result = 0 ? a : b;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-constant-condition: \"error\"*/\n\nif (x === 0) {\n    doSomething();\n}\n\nfor (;;) {\n    doSomethingForever();\n}\n\nwhile (typeof x === \"undefined\") {\n    doSomething();\n}\n\ndo{\n    doSomething();\n} while (x);\n\nvar result = x !== 0 ? a : b;\n\n\nOptions\ncheckLoops\nSet to true by default. Setting this option to false allows constant expressions in loops.\n默认为 true。设置该选项为 false 允许在循环中使用常量表达式。\nExamples of correct code for when checkLoops is false:\n当 checkLoops 为 false 时的 正确 代码示例：\n/*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\nwhile (true) {\n    doSomething();\n    if (condition()) {\n        break;\n    }\n};\n\nfor (;true;) {\n    doSomething();\n    if (condition()) {\n        break;\n    }\n};\n\ndo {\n    doSomething();\n    if (condition()) {\n        break;\n    }\n} while (true)\n\n\nVersion\nThis rule was introduced in ESLint 0.4.1.\n该规则在 ESLint 0.4.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-constant-condition",
                "disable": false
            },
            {
                "real_name": "no-continue",
                "display_name": "no-continue",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 continue (no-continue)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow continue statements (no-continue)\n禁用 continue (no-continue)\nThe continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration. When used incorrectly it makes code less testable, less readable and less maintainable. Structured control flow statements such as if should be used instead.\ncontinue 语句终止当前的循环的此次迭代或带标签的循环，执行循环中的下一个迭代。不正确的使用会降低代码可测性、可读性以及可维护性。应使用结构化的控制语句如 if 来代替。\nvar sum = 0,\n    i;\n\nfor(i = 0; i < 10; i++) {\n    if(i >= 5) {\n        continue;\n    }\n\n    a += i;\n}\n\n\nRule Details\nThis rule disallows continue statements.\n该规则禁止使用 continue 语句。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-continue: \"error\"*/\n\nvar sum = 0,\n    i;\n\nfor(i = 0; i < 10; i++) {\n    if(i >= 5) {\n        continue;\n    }\n\n    a += i;\n}\n\n\n/*eslint no-continue: \"error\"*/\n\nvar sum = 0,\n    i;\n\nlabeledLoop: for(i = 0; i < 10; i++) {\n    if(i >= 5) {\n        continue labeledLoop;\n    }\n\n    a += i;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-continue: \"error\"*/\n\nvar sum = 0,\n    i;\n\nfor(i = 0; i < 10; i++) {\n    if(i < 5) {\n       a += i;\n    }\n}\n\n\nCompatibility\n\nJSLint: continue\n\nVersion\nThis rule was introduced in ESLint 0.19.0.\n该规则在 ESLint 0.19.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-continue",
                "disable": false
            },
            {
                "real_name": "no-control-regex",
                "display_name": "no-control-regex",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在正则表达式中使用控制字符（no-control-regex）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow control characters in regular expressions (no-control-regex)\n禁止在正则表达式中使用控制字符（no-control-regex）\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nControl characters are special, invisible characters in the ASCII range 0-31. These characters are rarely used in JavaScript strings so a regular expression containing these characters is most likely a mistake.\n在 ASCII 中，0-31 范围内的控制字符是特殊的、不可见的字符。这些字符很少被用在 JavaScript 字符串中，所以一个正则表达式如果包含这些字符的，很有可能一个错误。\nRule Details\nThis rule disallows control characters in regular expressions.\n该规则禁止在正则表达式中出现控制字符。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-control-regex: \"error\"*/\n\nvar pattern1 = /\\x1f/;\nvar pattern2 = new RegExp(\"\\x1f\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-control-regex: \"error\"*/\n\nvar pattern1 = /\\x20/;\nvar pattern2 = new RegExp(\"\\x20\");\n\n\nWhen Not To Use It\nIf you need to use control character pattern matching, then you should turn this rule off.\n如果你需要使用控制字符进行模式匹配，你应该关闭该规则。\nRelated Rules\n\nno-div-regex\nno-regex-spaces\n\nVersion\nThis rule was introduced in ESLint 0.1.0.\n该规则在 ESLint 0.1.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-control-regex",
                "disable": false
            },
            {
                "real_name": "no-debugger",
                "display_name": "no-debugger",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow the use of debugger (no-debugger).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow the use of debugger (no-debugger)\n禁用 debugger (no-debugger)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThe debugger statement is used to tell the executing JavaScript environment to stop execution and start up a debugger at the current point in the code. This has fallen out of favor as a good practice with the advent of modern debugging and development tools. Production code should definitely not contain debugger, as it will cause the browser to stop executing code and open an appropriate debugger.\ndebugger 语句用于告诉 JavaScript 执行环境停止执行并在代码的当前位置启动调试器。随着现代调试和开发工具的出现，使用调试器已不是最佳实践。产品代码不应该包含 debugger，因为它会导致浏览器停止执行代码并打开一个适当的调试器。\nRule Details\nThis rule disallows debugger statements.\n该规则禁止 debugger 语句。\nExample of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-debugger: \"error\"*/\n\nfunction isTruthy(x) {\n    debugger;\n    return Boolean(x);\n}\n\n\nExample of correct code for this rule:\n正确 代码示例：\n/*eslint no-debugger: \"error\"*/\n\nfunction isTruthy(x) {\n    return Boolean(x); // set a breakpoint at this line\n}\n\n\nWhen Not To Use It\nIf your code is still very much in development and don’t want to worry about stripping debugger statements, then turn this rule off. You’ll generally want to turn it back on when testing code prior to deployment.\n如果你的代码在很大程度上仍处于开发阶段，不想担心剥离 debugger 语句，那么就关闭此规则。通常在部署测试代码之前，你会想重新开启此规则。\nFurther Reading\n\nDebugger\n\nRelated Rules\n\nno-alert\nno-console\n\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-debugger",
                "disable": false
            },
            {
                "real_name": "no-delete-var",
                "display_name": "no-delete-var",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止删除变量 (no-delete-var)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow deleting variables (no-delete-var)\n禁止删除变量 (no-delete-var)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe purpose of the delete operator is to remove a property from an object. Using the delete operator on a variable might lead to unexpected behavior.\ndelete 的目的是删除对象的属性。使用 delete 操作删除一个变量可能会导致意外情况发生。\nRule Details\nThis rule disallows the use of the delete operator on variables.\n该规则禁止对变量使用 delete 操作符。\nIf ESLint parses code in strict mode, the parser (instead of this rule) reports the error.\n如果 ESLint 是在严格模式下解析代码，解析器（而不是该规则）会报告错误。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-delete-var: \"error\"*/\n\nvar x;\ndelete x;\n\n\nFurther Reading\n\nOnly properties should be deleted\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-delete-var",
                "disable": false
            },
            {
                "real_name": "no-div-regex",
                "display_name": "no-div-regex",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用看起来像除法的正则表达式 (no-div-regex)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Regexs That Look Like Division (no-div-regex)\n禁止使用看起来像除法的正则表达式 (no-div-regex)\nRequire regex literals to escape division operators.\n要求正则表达式字面量避开除法操作符。\nfunction bar() { return /=foo/; }\n\n\nRule Details\nThis is used to disambiguate the division operator to not confuse users.\n该规则用来消除除法操作符的歧义。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-div-regex: \"error\"*/\n\nfunction bar() { return /=foo/; }\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-div-regex: \"error\"*/\n\nfunction bar() { return /\\=foo/; }\n\n\nRelated Rules\n\nno-control-regex\nno-regex-spaces\n\nVersion\nThis rule was introduced in ESLint 0.1.0.\n该规则在 ESLint 0.1.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-div-regex",
                "disable": false
            },
            {
                "real_name": "no-dupe-args",
                "display_name": "no-dupe-args",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在 function 定义中出现重复的参数 (no-dupe-args).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow duplicate arguments in function definitions (no-dupe-args)\n禁止在 function 定义中出现重复的参数 (no-dupe-args)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIf more than one parameter has the same name in a function definition, the last occurrence “shadows” the preceding occurrences. A duplicated name might be a typing error.\n如果在一个函数定义中出现多个同名的参数，后面出现的会覆盖前面出现的参数。重复的名称可能是一个打字错误。\nRule Details\nThis rule disallows duplicate parameter names in function declarations or expressions. It does not apply to arrow functions or class methods, because the parser reports the error.\n该规则禁止在函数定义或表达中出现重名参数。该规则并不适用于箭头函数或类方法，因为解析器会报告这样的错误。\nIf ESLint parses code in strict mode, the parser (instead of this rule) reports the error.\n如果 ESLint 在严格模式下解析代码，解析器（不是该规则）将报告这样的错误。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-dupe-args: \"error\"*/\n\nfunction foo(a, b, a) {\n    console.log(\"value of the second a:\", a);\n}\n\nvar bar = function (a, b, a) {\n    console.log(\"value of the second a:\", a);\n};\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-dupe-args: \"error\"*/\n\nfunction foo(a, b, c) {\n    console.log(a, b, c);\n}\n\nvar bar = function (a, b, c) {\n    console.log(a, b, c);\n};\n\n\nVersion\nThis rule was introduced in ESLint 0.16.0.\n该规则在 ESLint 0.16.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-dupe-args",
                "disable": false
            },
            {
                "real_name": "no-dupe-class-members",
                "display_name": "no-dupe-class-members",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许类成员中有重复的名称 (no-dupe-class-members)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow duplicate name in class members (no-dupe-class-members)\n不允许类成员中有重复的名称 (no-dupe-class-members)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIf there are declarations of the same name in class members, the last declaration overwrites other declarations silently.\nIt can cause unexpected behaviors.\n如果类成员中有同名的声明，最后一个声明将会默默地覆盖其它声明。\n它可能导致意外的行为。\n/*eslint-env es6*/\n\nclass Foo {\n  bar() { console.log(\"hello\"); }\n  bar() { console.log(\"goodbye\"); }\n}\n\nvar foo = new Foo();\nfoo.bar(); // goodbye\n\n\nRule Details\nThis rule is aimed to flag the use of duplicate names in class members.\n该规则旨在标记类成员中重复名称的使用。\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-dupe-class-members: \"error\"*/\n/*eslint-env es6*/\n\nclass Foo {\n  bar() { }\n  bar() { }\n}\n\nclass Foo {\n  bar() { }\n  get bar() { }\n}\n\nclass Foo {\n  static bar() { }\n  static bar() { }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-dupe-class-members: \"error\"*/\n/*eslint-env es6*/\n\nclass Foo {\n  bar() { }\n  qux() { }\n}\n\nclass Foo {\n  get bar() { }\n  set bar(value) { }\n}\n\nclass Foo {\n  static bar() { }\n  bar() { }\n}\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\n该规则不应在 ES3/5 环境下使用。\nIn ES2015 (ES6) or later, if you don’t want to be notified about duplicate names in class members, you can safely disable this rule.\n在ES2015 (ES6)或之后的版本，如果你不想收到关于类成员中有重复名称的通知，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 1.2.0.\n该规则在 ESLint 1.2.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-dupe-class-members",
                "disable": false
            },
            {
                "real_name": "no-dupe-keys",
                "display_name": "no-dupe-keys",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在对象字面量中出现重复的键 (no-dupe-keys)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow duplicate keys in object literals (no-dupe-keys)\n禁止在对象字面量中出现重复的键 (no-dupe-keys)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nMultiple properties with the same key in object literals can cause unexpected behavior in your application.\n在你的应用程序中，如果对象字面量中出现多个属性有同样的键可能会到导致意想不到的情况出现。\nvar foo = {\n    bar: \"baz\",\n    bar: \"qux\"\n};\n\n\nRule Details\nThis rule disallows duplicate keys in object literals.\n该规则禁止在对象字面量中出现重复的键。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-dupe-keys: \"error\"*/\n\nvar foo = {\n    bar: \"baz\",\n    bar: \"qux\"\n};\n\nvar foo = {\n    \"bar\": \"baz\",\n    bar: \"qux\"\n};\n\nvar foo = {\n    0x1: \"baz\",\n    1: \"qux\"\n};\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-dupe-keys: \"error\"*/\n\nvar foo = {\n    bar: \"baz\",\n    quxx: \"qux\"\n};\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-dupe-keys",
                "disable": false
            },
            {
                "real_name": "no-duplicate-case",
                "display_name": "no-duplicate-case",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止重复 case 标签（no-duplicate-case）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Rule to disallow a duplicate case label (no-duplicate-case)\n禁止重复 case 标签（no-duplicate-case）\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIf a switch statement has duplicate test expressions in case clauses, it is likely that a programmer copied a case clause but forgot to change the test expression.\n如果一个 switch 语句中的 case 子句中出现重复的测试表达式，那么很有可能是某个程序员拷贝了一个 case 子句但忘记了修改测试表达式。\nRule Details\nThis rule disallows duplicate test expressions in case clauses of switch statements.\n该规则禁止在 switch 语句中的 case 子句中出现重复的测试表达式。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-duplicate-case: \"error\"*/\n\nvar a = 1,\n    one = 1;\n\nswitch (a) {\n    case 1:\n        break;\n    case 2:\n        break;\n    case 1:         // duplicate test expression\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case one:\n        break;\n    case 2:\n        break;\n    case one:         // duplicate test expression\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case \"1\":\n        break;\n    case \"2\":\n        break;\n    case \"1\":         // duplicate test expression\n        break;\n    default:\n        break;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-duplicate-case: \"error\"*/\n\nvar a = 1,\n    one = 1;\n\nswitch (a) {\n    case 1:\n        break;\n    case 2:\n        break;\n    case 3:\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case one:\n        break;\n    case 2:\n        break;\n    case 3:\n        break;\n    default:\n        break;\n}\n\nswitch (a) {\n    case \"1\":\n        break;\n    case \"2\":\n        break;\n    case \"3\":\n        break;\n    default:\n        break;\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.17.0.\n该规则在 ESLint 0.17.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-duplicate-case",
                "disable": false
            },
            {
                "real_name": "no-duplicate-imports",
                "display_name": "no-duplicate-imports",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow duplicate imports (no-duplicate-imports)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow duplicate imports (no-duplicate-imports)\nUsing a single import statement per module will make the code clearer because you can see everything being imported from that module on one line.\nIn the following example the module import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.\nimport { merge } from 'module';\nimport something from 'another-module';\nimport { find } from 'module';\n\n\nRule Details\nThis rules requires that all imports from a single module exists in a single import statement.\nExample of incorrect code for this rule:\n/*eslint no-duplicate-imports: \"error\"*/\n\nimport { merge } from 'module';\nimport something from 'another-module';\nimport { find } from 'module';\n\n\nExample of correct code for this rule:\n/*eslint no-duplicate-imports: \"error\"*/\n\nimport { merge, find } from 'module';\nimport something from 'another-module';\n\n\nOptions\nThis rule takes one optional argument, an object with a single key, includeExports which is a boolean. It defaults to false.\nIf re-exporting from an imported module, you should add the imports to the import-statement, and export that directly, not use export ... from.\nExample of incorrect code for this rule with the { \"includeExports\": true } option:\n/*eslint no-duplicate-imports: [\"error\", { \"includeExports\": true }]*/\n\nimport { merge } from 'module';\n\nexport { find } from 'module';\n\n\nExample of correct code for this rule with the { \"includeExports\": true } option:\n/*eslint no-duplicate-imports: [\"error\", { \"includeExports\": true }]*/\n\nimport { merge, find } from 'module';\n\nexport { find };\n\n\nVersion\nThis rule was introduced in ESLint 2.5.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-duplicate-imports",
                "disable": false
            },
            {
                "real_name": "no-else-return",
                "display_name": "no-else-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在 else 前有 return (no-else-return)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow return before else (no-else-return)\n禁止在 else 前有 return (no-else-return)\nIf an if block contains a return statement, the else block becomes unnecessary. Its contents can be placed outside of the block.\n如果 if 块中包含了一个 return 语句，else 块就成了多余的了。可以将其内容移至块外。\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nfunction foo() {\n    if (x) {\n        return y;\n    } else {\n        return z;\n    }\n}\n\n\nRule Details\nThis rule is aimed at highlighting an unnecessary block of code following an if containing a return statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a return statement.\n该规则旨在突出含有 return 语句的 if 语句后的不必要的代码。因此，当else 语句出现在含有 return 语句的 if 语句之后，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-else-return: \"error\"*/\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else {\n        return z;\n    }\n}\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else if (z) {\n        return w;\n    } else {\n        return t;\n    }\n}\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else {\n        var t = \"foo\";\n    }\n\n    return t;\n}\n\n// Two warnings for nested occurrences\nfunction foo() {\n    if (x) {\n        if (y) {\n            return y;\n        } else {\n            return x;\n        }\n    } else {\n        return z;\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-else-return: \"error\"*/\n\nfunction foo() {\n    if (x) {\n        return y;\n    }\n\n    return z;\n}\n\nfunction foo() {\n    if (x) {\n        return y;\n    } else if (z) {\n        var t = \"foo\";\n    } else {\n        return w;\n    }\n}\n\nfunction foo() {\n    if (x) {\n        if (z) {\n            return y;\n        }\n    } else {\n        return z;\n    }\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-else-return",
                "disable": false
            },
            {
                "real_name": "no-empty",
                "display_name": "no-empty",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止空块语句 (no-empty)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow empty block statements (no-empty)\n禁止空块语句 (no-empty)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nEmpty block statements, while not technically errors, usually occur due to refactoring that wasn’t completed. They can cause confusion when reading code.\n空语句块，如果不是技术上的错误，通常是由于不完整的重构造成的。这会造成代码阅读上的困惑。\nRule Details\nThis rule disallows empty block statements. This rule ignores block statements which contain a comment (for example, in an empty catch or finally block of a try statement to indicate that execution should continue regardless of errors).\n该规则禁止空语句块出现。该规则忽略包含一个注释的语句块（例如，在 try 语句中，一个空的 catch 或 finally 语句块意味着程序应该继续执行，无论是否出现错误）。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-empty: \"error\"*/\n\nif (foo) {\n}\n\nwhile (foo) {\n}\n\nswitch(foo) {\n}\n\ntry {\n    doSomething();\n} catch(ex) {\n\n} finally {\n\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-empty: \"error\"*/\n\nif (foo) {\n    // empty\n}\n\nwhile (foo) {\n    /* empty */\n}\n\ntry {\n    doSomething();\n} catch (ex) {\n    // continue regardless of error\n}\n\ntry {\n    doSomething();\n} finally {\n    /* continue regardless of error */\n}\n\n\nOptions\nThis rule has an object option for exceptions:\n该规则有例外情况，是个对象：\n\n\"allowEmptyCatch\": true allows empty catch clauses (that is, which do not contain a comment)\n\"allowEmptyCatch\": true 允许出现空的 catch 子句 (也就是说，不包含注释)\n\nallowEmptyCatch\nExamples of additional correct code for this rule with the { \"allowEmptyCatch\": true } option:\n选项 { \"allowEmptyCatch\": true } 的 正确 代码示例：\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\ntry {\n    doSomething();\n} catch (ex) {}\n\ntry {\n    doSomething();\n}\ncatch (ex) {}\nfinally {\n    /* continue regardless of error */\n}\n\n\nWhen Not To Use It\nIf you intentionally use empty block statements then you can disable this rule.\n如果你打算使用空语句块，那么你可以禁用此规则。\nRelated Rules\n\nno-empty-function\n\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-empty",
                "disable": false
            },
            {
                "real_name": "no-empty-character-class",
                "display_name": "no-empty-character-class",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在正则表达式中出现空字符集 (no-empty-character-class)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow empty character classes in regular expressions (no-empty-character-class)\n禁止在正则表达式中出现空字符集 (no-empty-character-class)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nBecause empty character classes in regular expressions do not match anything, they might be typing mistakes.\n在正则表达式中空字符集不能匹配任何字符，它们可能是打字错误。\nvar foo = /^abc[]/;\n\n\nRule Details\nThis rule disallows empty character classes in regular expressions.\n该规则禁止在正则表达式中出现空字符集。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-empty-character-class: \"error\"*/\n\n/^abc[]/.test(\"abcdefg\"); // false\n\"abcdefg\".match(/^abc[]/); // null\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-empty-character-class: \"error\"*/\n\n/^abc/.test(\"abcdefg\"); // true\n\"abcdefg\".match(/^abc/); // [\"abc\"]\n\n/^abc[a-z]/.test(\"abcdefg\"); // true\n\"abcdefg\".match(/^abc[a-z]/); // [\"abcd\"]\n\n\nKnown Limitations\nThis rule does not report empty character classes in the string argument of calls to the RegExp constructor.\n该规则不会报告 RegExp 构造函数的字符串参数中空字符集的使用情况。\nExample of a false negative when this rule reports correct code:\n当该规则报告了正确的代码时，漏报的示例：\n/*eslint no-empty-character-class: \"error\"*/\n\nvar abcNeverMatches = new RegExp(\"^abc[]\");\n\n\nVersion\nThis rule was introduced in ESLint 0.22.0.\n该规则在 ESLint 0.22.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-empty-character-class",
                "disable": false
            },
            {
                "real_name": "no-empty-function",
                "display_name": "no-empty-function",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止出现空函数 (no-empty-function)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow empty functions (no-empty-function)\n禁止出现空函数 (no-empty-function)\nEmpty functions can reduce readability because readers need to guess whether it’s intentional or not.\nSo writing a clear comment for empty functions is a good practice.\n空函数能降低代码的可读性，因为读者需要猜测它是否是有意为之。所以，为空函数写一个清晰的注释是个很好的实践。\nfunction foo() {\n    // do nothing.\n}\n\n\nEspecially, the empty block of arrow functions might be confusing developers.\nIt’s very similar to an empty object literal.\n尤其是箭头函数的空语句块可能使开发者感到困惑。它非常类似于一个空对象。\nlist.map(() => {});   // This is a block, would return undefined.\nlist.map(() => ({})); // This is an empty object.\n\n\nRule Details\nThis rule is aimed at eliminating empty functions.\nA function will not be considered a problem if it contains a comment.\n该规则旨在消除空函数。如果一个函数包含了一条注释，它将不会被认为有问题。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-empty-function: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {}\n\nvar foo = function() {};\n\nvar foo = () => {};\n\nfunction* foo() {}\n\nvar foo = function*() {};\n\nvar obj = {\n    foo: function() {},\n\n    foo: function*() {},\n\n    foo() {},\n\n    *foo() {},\n\n    get foo() {},\n\n    set foo(value) {}\n};\n\nclass A {\n    constructor() {}\n\n    foo() {}\n\n    *foo() {}\n\n    get foo() {}\n\n    set foo(value) {}\n\n    static foo() {}\n\n    static *foo() {}\n\n    static get foo() {}\n\n    static set foo(value) {}\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-empty-function: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // do nothing.\n}\n\nvar foo = function() {\n    // any clear comments.\n};\n\nvar foo = () => {\n    bar();\n};\n\nfunction* foo() {\n    // do nothing.\n}\n\nvar foo = function*() {\n    // do nothing.\n};\n\nvar obj = {\n    foo: function() {\n        // do nothing.\n    },\n\n    foo: function*() {\n        // do nothing.\n    },\n\n    foo() {\n        // do nothing.\n    },\n\n    *foo() {\n        // do nothing.\n    },\n\n    get foo() {\n        // do nothing.\n    },\n\n    set foo(value) {\n        // do nothing.\n    }\n};\n\nclass A {\n    constructor() {\n        // do nothing.\n    }\n\n    foo() {\n        // do nothing.\n    }\n\n    *foo() {\n        // do nothing.\n    }\n\n    get foo() {\n        // do nothing.\n    }\n\n    set foo(value) {\n        // do nothing.\n    }\n\n    static foo() {\n        // do nothing.\n    }\n\n    static *foo() {\n        // do nothing.\n    }\n\n    static get foo() {\n        // do nothing.\n    }\n\n    static set foo(value) {\n        // do nothing.\n    }\n}\n\n\nOptions\nThis rule has an option to allow specific kinds of functions to be empty.\n该规则一个选项，允许特定类型的函数为空。\n\nallow (string[]) - A list of kind to allow empty functions. List items are some of the following strings. An empty array ([]) by default.\nallow (string[]) - 所允许的空函数列表。列表元素为以下字符。默认为空数组 ([])。\n    \n\"functions\" - Normal functions.\n\"functions\" - 常规函数。\n\"arrowFunctions\" - Arrow functions.\n\"arrowFunctions\" - 箭头函数。\n\"generatorFunctions\" - Generator functions.\n\"generatorFunctions\" - Generator 函数。\n\"methods\" - Class methods and method shorthands of object literals.\n\"methods\" - 类方法和对象的方法简写\n\"generatorMethods\" - Class methods and method shorthands of object literals with generator.\n\"generatorMethods\" - 类方法和带有 generator 的对象的方法简写。\n\"getters\" - Getters.\n\"getters\" - Getters。\n\"setters\" - Setters.\n\"setters\" - Setters。\n\"constructors\" - Class constructors.\n\"constructors\" - 类的构造函数。\n\n\n\nallow: functions\nExamples of correct code for the { \"allow\": [\"functions\"] } option:\n选项 { \"allow\": [\"functions\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"functions\"] }]*/\n\nfunction foo() {}\n\nvar foo = function() {};\n\nvar obj = {\n    foo: function() {}\n};\n\n\nallow: arrowFunctions\nExamples of correct code for the { \"allow\": [\"arrowFunctions\"] } option:\n选项 { \"allow\": [\"arrowFunctions\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"arrowFunctions\"] }]*/\n/*eslint-env es6*/\n\nvar foo = () => {};\n\n\nallow: generatorFunctions\nExamples of correct code for the { \"allow\": [\"generatorFunctions\"] } option:\n选项 { \"allow\": [\"generatorFunctions\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"generatorFunctions\"] }]*/\n/*eslint-env es6*/\n\nfunction* foo() {}\n\nvar foo = function*() {};\n\nvar obj = {\n    foo: function*() {}\n};\n\n\nallow: methods\nExamples of correct code for the { \"allow\": [\"methods\"] } option:\n选项 { \"allow\": [\"methods\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"methods\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    foo() {}\n};\n\nclass A {\n    foo() {}\n    static foo() {}\n}\n\n\nallow: generatorMethods\nExamples of correct code for the { \"allow\": [\"generatorMethods\"] } option:\n选项 { \"allow\": [\"generatorMethods\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"generatorMethods\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    *foo() {}\n};\n\nclass A {\n    *foo() {}\n    static *foo() {}\n}\n\n\nallow: getters\nExamples of correct code for the { \"allow\": [\"getters\"] } option:\n选项 { \"allow\": [\"getters\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"getters\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    get foo() {}\n};\n\nclass A {\n    get foo() {}\n    static get foo() {}\n}\n\n\nallow: setters\nExamples of correct code for the { \"allow\": [\"setters\"] } option:\n选项 { \"allow\": [\"setters\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"setters\"] }]*/\n/*eslint-env es6*/\n\nvar obj = {\n    set foo(value) {}\n};\n\nclass A {\n    set foo(value) {}\n    static set foo(value) {}\n}\n\n\nallow: constructors\nExamples of correct code for the { \"allow\": [\"constructors\"] } option:\n选项 { \"allow\": [\"constructors\"] } 的 正确 代码示例：\n/*eslint no-empty-function: [\"error\", { \"allow\": [\"constructors\"] }]*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() {}\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about empty functions, then it’s safe to disable this rule.\n如果你不想收到关于空函数的通知，你可以禁用此规则。\nRelated Rules\n\nno-empty\n\nVersion\nThis rule was introduced in ESLint 2.0.0.\n该规则在 ESLint 2.0.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-empty-function",
                "disable": false
            },
            {
                "real_name": "no-empty-pattern",
                "display_name": "no-empty-pattern",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用空解构模式 (no-empty-pattern)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow empty destructuring patterns (no-empty-pattern)\n禁止使用空解构模式 (no-empty-pattern)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nWhen using destructuring, it’s possible to create a pattern that has no effect. This happens when empty curly braces are used to the right of an embedded object destructuring pattern, such as:\n当使用解构赋值时，可能创建了一个不起作用的模式。把空的花括号放在嵌入的对象的解构模式右边时，就会产生这种情况，例如：\n// doesn't create any variables\nvar {a: {}} = foo;\n\n\nIn this code, no new variables are created because a is just a location helper while the {} is expected to contain the variables to create, such as:\n在以上代码中，没有创建新的变量，因为 a 只是一个辅助位置，而 {} 将包含创建的变量，例如：\n// creates variable b\nvar {a: { b }} = foo;\n\n\nIn many cases, the empty object pattern is a mistake where the author intended to use a default value instead, such as:\n在许多情况下，作者本来打算使用一个默认值，却错写成空对象，例如：\n// creates variable a\nvar {a = {}} = foo;\n\n\nThe difference between these two patterns is subtle, especially because the problematic empty pattern looks just like an object literal.\n这两种模式直接的区别是微妙的，因为空模式看起来像是一个对象字面量。\nRule Details\nThis rule aims to flag any empty patterns in destructured objects and arrays, and as such, will report a problem whenever one is encountered.\n此规则目的在于标记出在解构对象和数组中的任何的空模式，每当遇到一个这样的空模式，该规则就会报告一个问题。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-empty-pattern: \"error\"*/\n\nvar {} = foo;\nvar [] = foo;\nvar {a: {}} = foo;\nvar {a: []} = foo;\nfunction foo({}) {}\nfunction foo([]) {}\nfunction foo({a: {}}) {}\nfunction foo({a: []}) {}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-empty-pattern: \"error\"*/\n\nvar {a = {}} = foo;\nvar {a = []} = foo;\nfunction foo({a = {}}) {}\nfunction foo({a = []}) {}\n\n\nVersion\nThis rule was introduced in ESLint 1.7.0.\n该规则在 ESLint 1.7.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-empty-pattern",
                "disable": false
            },
            {
                "real_name": "no-eq-null",
                "display_name": "no-eq-null",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止与 null 进行比较 (no-eq-null)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Null Comparisons (no-eq-null)\n禁止与 null 进行比较 (no-eq-null)\nComparing to null without a type-checking operator (== or !=), can have unintended results as the comparison will evaluate to true when comparing to not just a null, but also an undefined value.\n与 null 进行比较时不使用类型检测操作符（== 或 !=），可能得意想不到的的结果，因为 null 其本身以及 null 与 undefined 比较结果都为 true。\nif (foo == null) {\n  bar();\n}\n\n\nRule Details\nThe no-eq-null rule aims reduce potential bug and unwanted behavior by ensuring that comparisons to null only match null, and not also undefined. As such it will flag comparisons to null when using == and !=.\n该规则旨在通过确保与 null 比较时只等于 null，而不同时等于 undefined， 来减少潜在的 bug 和 意外行为。因此，它也将标记使用 == 和 != 与 null比较的情况。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-eq-null: \"error\"*/\n\nif (foo == null) {\n  bar();\n}\n\nwhile (qux != null) {\n  baz();\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-eq-null: \"error\"*/\n\nif (foo === null) {\n  bar();\n}\n\nwhile (qux !== null) {\n  baz();\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-eq-null",
                "disable": false
            },
            {
                "real_name": "no-eval",
                "display_name": "no-eval",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 eval()（no-eval）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow eval() (no-eval)\n禁用 eval()（no-eval）\nJavaScript’s eval() function is potentially dangerous and is often misused. Using eval() on untrusted code can open a program up to several different injection attacks. The use of eval() in most contexts can be substituted for a better, alternative approach to a problem.\nJavaScript 中的 eval() 函数是有潜在危险的，而且经常被误用。在不可信的代码里使用 eval() 有可能使程序受到不同的注入攻击。eval() 在大多数情况下可以被更好的解决问题的方法代替。\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = eval(\"obj.\" + key);\n\n\nRule Details\nThis rule is aimed at preventing potentially dangerous, unnecessary, and slow code by disallowing the use of the eval() function. As such, it will warn whenever the eval() function is used.\n此规则目的在于通过禁止使用 eval() 函数来避免潜在地危险、不必要的和运行效率低下的代码。因此，当时使用 eval() 函数时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-eval: \"error\"*/\n\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = eval(\"obj.\" + key);\n\n(0, eval)(\"var a = 0\");\n\nvar foo = eval;\nfoo(\"var a = 0\");\n\n// This `this` is the global object.\nthis.eval(\"var a = 0\");\n\n\nExample of additional incorrect code for this rule when browser environment is set to true:\n当环境指定为 browser 为  true 时的 错误 代码示例：\n/*eslint no-eval: \"error\"*/\n/*eslint-env browser*/\n\nwindow.eval(\"var a = 0\");\n\n\nExample of additional incorrect code for this rule when node environment is set to true:\n当环境指定为 node 为  true 时的 错误 代码示例：\n/*eslint no-eval: \"error\"*/\n/*eslint-env node*/\n\nglobal.eval(\"var a = 0\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-eval: \"error\"*/\n/*eslint-env es6*/\n\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = obj[key];\n\nclass A {\n    foo() {\n        // This is a user-defined method.\n        this.eval(\"var a = 0\");\n    }\n\n    eval() {\n    }\n}\n\n\nOptions\nThis rule has an option to allow indirect calls to eval.\nIndirect calls to eval are less dangerous than direct calls to eval because they cannot dynamically change the scope. Because of this, they also will not negatively impact performance to the degree of direct eval.\n该规则有一个选项，允许间接调用 eval。间接调用 eval 相对于直接调用 eval 危害性较低，因为不会动态改变作用域。正因为如此，相对于直接调用 eval ，它们也不会对性能造成负面影响。\n{\n    \"no-eval\": [\"error\", {\"allowIndirect\": true}] // default is false\n}\n\n\nExample of incorrect code for this rule with the {\"allowIndirect\": true} option:\n选项 {\"allowIndirect\": true} 的 错误 代码示例：\n/*eslint no-eval: \"error\"*/\n\nvar obj = { x: \"foo\" },\n    key = \"x\",\n    value = eval(\"obj.\" + key);\n\n\nExamples of correct code for this rule with the {\"allowIndirect\": true} option:\n选项 {\"allowIndirect\": true} 的 正确 代码示例：\n/*eslint no-eval: \"error\"*/\n\n(0, eval)(\"var a = 0\");\n\nvar foo = eval;\nfoo(\"var a = 0\");\n\nthis.eval(\"var a = 0\");\n\n\n/*eslint no-eval: \"error\"*/\n/*eslint-env browser*/\n\nwindow.eval(\"var a = 0\");\n\n\n/*eslint no-eval: \"error\"*/\n/*eslint-env node*/\n\nglobal.eval(\"var a = 0\");\n\n\nKnown Limitations\n\nThis rule is warning every eval() even if the eval is not global’s. This behavior is in order to detect calls of direct eval. Such as:\n\n该规则会对每一个 eval() 发出警告，即使 eval 是非全局的函数。这种行为是为了检测对 eval 的直接调用。比如：\nmodule.exports = function(eval) {\n    // If the value of this `eval` is built-in `eval` function, this is a\n    // call of direct `eval`.\n    eval(\"var a = 0\");\n};\n\n\n\nThis rule cannot catch renaming the global object. Such as:\n\n该规则无法捕获重命名的全局对象。比如：\nvar foo = window;\nfoo.eval(\"var a = 0\");\n\n\n\n\nFurther Reading\n\nEval is Evil, Part One\nHow evil is eval\n\nRelated Rules\n\nno-implied-eval\n\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-eval",
                "disable": false
            },
            {
                "real_name": "no-ex-assign",
                "display_name": "no-ex-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止对 catch 子句中的异常重新赋值 (no-ex-assign).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow reassigning exceptions in catch clauses (no-ex-assign)\n禁止对 catch 子句中的异常重新赋值 (no-ex-assign)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIf a catch clause in a try statement accidentally (or purposely) assigns another value to the exception parameter, it impossible to refer to the error from that point on.\nSince there is no arguments object to offer alternative access to this data, assignment of the parameter is absolutely destructive.\n在 try 语句中的 catch 子句中，如果意外地（或故意地）给异常参数赋值，是不可能引用那个位置的错误的。由于没有 arguments 对象提供额外的方式访问这个异常，对它进行赋值绝对是毁灭性的。\nRule Details\nThis rule disallows reassigning exceptions in catch clauses.\n该规则禁止对 catch 子句中的异常重新赋值。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-ex-assign: \"error\"*/\n\ntry {\n    // code\n} catch (e) {\n    e = 10;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-ex-assign: \"error\"*/\n\ntry {\n    // code\n} catch (e) {\n    var foo = 10;\n}\n\n\nFurther Reading\n\nThe “catch” with try…catch by Ben Alman explains how the exception identifier can leak into the outer scope in IE 6-8\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-ex-assign",
                "disable": false
            },
            {
                "real_name": "no-extend-native",
                "display_name": "no-extend-native",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止扩展原生对象 (no-extend-native)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Extending of Native Objects (no-extend-native)\n禁止扩展原生对象 (no-extend-native)\nIn JavaScript, you can extend any object, including builtin or “native” objects. Sometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code.\n在 JavaScript 中，你可以扩展任何对象，包括内置或者”原生”对象。有时人们改变这些原生对象的行为，会影响到代码中的其它部分。\nFor example here we are overriding a builtin method that will then affect all Objects, even other builtins.\n例如我们重写了一个内建的方法，将会影响到所有对象，甚至是其它内建对象。\n// seems harmless\nObject.prototype.extra = 55;\n\n// loop through some userIds\nvar users = {\n    \"123\": \"Stan\",\n    \"456\": \"David\"\n};\n\n// not what you'd expect\nfor (var id in users) {\n    console.log(id); // \"123\", \"456\", \"extra\"\n}\n\n\nA common suggestion to avoid this problem would be to wrap the inside of the for loop with users.hasOwnProperty(id). However, if this rule is strictly enforced throughout your codebase you won’t need to take that step.\n建议在 for 循环里使用 users.hasOwnProperty(id)来避免此问题出现。然而，如果你的代码库强制执行此规则，你会需要这么做。\nRule Details\nDisallows directly modifying the prototype of builtin objects.\n禁止直接修改内建对象的属性。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-extend-native: \"error\"*/\n\nObject.prototype.a = \"a\";\nObject.defineProperty(Array.prototype, \"times\", { value: 999 });\n\n\nOptions\nThis rule accepts an exceptions option, which can be used to specify a list of builtins for which extensions will be allowed.\n此规则接受一个 exceptions 选项，可以用来指定允许扩展的内建列表。\nexceptions\nExamples of correct code for the sample { \"exceptions\": [\"Object\"] } option:\n选项 { \"exceptions\": [\"Object\"] } 的 正确 代码示例：\n/*eslint no-extend-native: [\"error\", { \"exceptions\": [\"Object\"] }]*/\n\nObject.prototype.a = \"a\";\n\n\nKnown Limitations\nThis rule does not report any of the following less obvious approaches to modify the prototype of builtin objects:\n该规则不会报告对内建对象不太明显的修改情况：\nvar x = Object;\nx.prototype.thing = a;\n\neval(\"Array.prototype.forEach = 'muhahaha'\");\n\nwith(Array) {\n    prototype.thing = 'thing';\n};\n\nwindow.Function.prototype.bind = 'tight';\n\n\nWhen Not To Use It\nYou may want to disable this rule when working with polyfills that try to patch older versions of JavaScript with the latest spec, such as those that might Function.prototype.bind or Array.prototype.forEach in a future-friendly way.\n当你要兼容旧版 JavaScript 时，比如使用在未来会得到友好支持的 Function.prototype.bind 或 Array.prototype.forEach，你可以禁用此规则。\nRelated Rules\n\nno-global-assign\n\nVersion\nThis rule was introduced in ESLint 0.1.4.\n该规则在 ESLint 0.1.4 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-extend-native",
                "disable": false
            },
            {
                "real_name": "no-extra-bind",
                "display_name": "no-extra-bind",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止不必要的函数绑定 (no-extra-bind)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow unnecessary function binding (no-extra-bind)\n禁止不必要的函数绑定 (no-extra-bind)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThe bind() method is used to create functions with specific this values and, optionally, binds arguments to specific values. When used to specify the value of this, it’s important that the function actually use this in its function body. For example:\nbind() 方法使用特定的 this 值来创建函数，并可选地将参数绑定到特定的值。当使用 this 时，在函数体中实际上使用的 this 值。例如：\nvar boundGetName = (function getName() {\n    return this.name;\n}).bind({ name: \"ESLint\" });\n\nconsole.log(boundGetName());      // \"ESLint\"\n\n\nThis code is an example of a good use of bind() for setting the value of this.\n这段代码就是一个很好的例子，它使用 bind() 来设置 this 值。\nSometimes during the course of code maintenance, the this value is removed from the function body. In that case, you can end up with a call to bind() that doesn’t accomplish anything:\n有时，在代码维护过程中，this 值从函数体中被移除。在这种情况下，你可以结束 bind()的调用，因为它没有做任何事情。\n// useless bind\nvar boundGetName = (function getName() {\n    return \"ESLint\";\n}).bind({ name: \"ESLint\" });\n\nconsole.log(boundGetName());      // \"ESLint\"\n\n\nIn this code, the reference to this has been removed but bind() is still used. In this case, the bind() is unnecessary overhead (and a performance hit) and can be safely removed.\n在这段代码中，this 的引用已经被删除，但是 bind() 仍在使用。在这种情况下，bind() 就成了不必要的开销（和性能损耗），可以安全地删除。\nRule Details\nThis rule is aimed at avoiding the unnecessary use of bind() and as such will warn whenever an immediately-invoked function expression (IIFE) is using bind() and doesn’t have an appropriate this value. This rule won’t flag usage of bind() that includes function argument binding.\n此规则目的在于避免不必要的 bind() 使用，并且当立即执行的函数表达式 (IIFE) 使用 bind()，但是没有一个合适的 this 值时，该规则会发出警告。此规则不会标记有函数参数绑定的bind() 的使用情况。\nNote: Arrow functions can never have their this value set using bind(). This rule flags all uses of bind() with arrow functions as a problem\n注意：箭头函数不能通过使用 bind() 设置它们的自己 this 值。此规则把所有使用bind() 的箭头函数标记为是有问题的。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-extra-bind: \"error\"*/\n/*eslint-env es6*/\n\nvar x = function () {\n    foo();\n}.bind(bar);\n\nvar x = (() => {\n    foo();\n}).bind(bar);\n\nvar x = (() => {\n    this.foo();\n}).bind(bar);\n\nvar x = function () {\n    (function () {\n      this.foo();\n    }());\n}.bind(bar);\n\nvar x = function () {\n    function foo() {\n      this.bar();\n    }\n}.bind(baz);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-extra-bind: \"error\"*/\n\nvar x = function () {\n    this.foo();\n}.bind(bar);\n\nvar x = function (a) {\n    return a + 1;\n}.bind(foo, bar);\n\n\nWhen Not To Use It\nIf you are not concerned about unnecessary calls to bind(), you can safely disable this rule.\n如果你不担心不必要的 bind() 调用，你可以禁用此规则。\nFurther Reading\n\nFunction.prototype.bind\nUnderstanding JavaScript’s Function.prototype.bind\n\nVersion\nThis rule was introduced in ESLint 0.8.0.\n该规则在 ESLint 0.8.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-extra-bind",
                "disable": false
            },
            {
                "real_name": "no-extra-boolean-cast",
                "display_name": "no-extra-boolean-cast",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止不必要的布尔类型转换（no-extra-boolean-cast）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow unnecessary boolean casts (no-extra-boolean-cast)\n禁止不必要的布尔类型转换（no-extra-boolean-cast）\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIn contexts such as an if statement’s test where the result of the expression will already be coerced to a Boolean, casting to a Boolean via double negation (!!) or a Boolean call is unnecessary. For example, these if statements are equivalent:\n在上下文中比如 if 语句的测试表达式的结果已经被强制转化成了一个布尔值，再通过双重否定（!!）或 Boolean 转化是不必要的。例如，这些 if 语句是等价的：\nif (!!foo) {\n    // ...\n}\n\nif (Boolean(foo)) {\n    // ...\n}\n\nif (foo) {\n    // ...\n}\n\n\nRule Details\nThis rule disallows unnecessary boolean casts.\n该规则禁止不必要的布尔类型转换。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-extra-boolean-cast: \"error\"*/\n\nvar foo = !!!bar;\n\nvar foo = !!bar ? baz : bat;\n\nvar foo = Boolean(!!bar);\n\nvar foo = new Boolean(!!bar);\n\nif (!!foo) {\n    // ...\n}\n\nif (Boolean(foo)) {\n    // ...\n}\n\nwhile (!!foo) {\n    // ...\n}\n\ndo {\n    // ...\n} while (Boolean(foo));\n\nfor (; !!foo; ) {\n    // ...\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-extra-boolean-cast: \"error\"*/\n\nvar foo = !!bar;\nvar foo = Boolean(bar);\n\nfunction foo() {\n    return !!bar;\n}\n\nvar foo = bar ? !!baz : !!bat;\n\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-extra-boolean-cast",
                "disable": false
            },
            {
                "real_name": "no-extra-label",
                "display_name": "no-extra-label",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用不必要的标签 (no-extra-label)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Unnecessary Labels (no-extra-label)\n禁用不必要的标签 (no-extra-label)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIf a loop contains no nested loops or switches, labeling the loop is unnecessary.\n如果一个循环中不包含嵌套循环或 switch 语句，对这样的循环使用标签是不必要的。\nA: while (a) {\n    break A;\n}\n\n\nYou can achieve the same result by removing the label and using break or continue without a label.\nProbably those labels would confuse developers because they expect labels to jump to further.\n你可以通过移除标签，只使用 break 或 continue实现同样的结果。这些标签可能会使开发者感到困惑，因为他们可能希望使用标签跳转到更远的地方。\nRule Details\nThis rule is aimed at eliminating unnecessary labels.\n该规则旨在消除不必要的标签。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-extra-label: \"error\"*/\n\nA: while (a) {\n    break A;\n}\n\nB: for (let i = 0; i < 10; ++i) {\n    break B;\n}\n\nC: switch (a) {\n    case 0:\n        break C;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-extra-label: \"error\"*/\n\nwhile (a) {\n    break;\n}\n\nfor (let i = 0; i < 10; ++i) {\n    break;\n}\n\nswitch (a) {\n    case 0:\n        break;\n}\n\nA: {\n    break A;\n}\n\nB: while (a) {\n    while (b) {\n        break B;\n    }\n}\n\nC: switch (a) {\n    case 0:\n        while (b) {\n            break C;\n        }\n        break;\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about usage of labels, then it’s safe to disable this rule.\n如果你不想收到有关标签的使用情况的通知，关闭此规则即可。\nRelated Rules\n\nno-labels\nno-label-var\nno-unused-labels\n\nVersion\nThis rule was introduced in ESLint 2.0.0-rc.0.\n该规则在 ESLint 2.0.0-rc.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-extra-label",
                "disable": false
            },
            {
                "real_name": "no-extra-parens",
                "display_name": "no-extra-parens",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止冗余的括号（no-extra-parens）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow unnecessary parentheses (no-extra-parens)\n禁止冗余的括号（no-extra-parens）\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThis rule restricts the use of parentheses to only where they are necessary.\n该规则对圆括号的使用做了限制，只有在必要的地方才能使用。\nRule Details\nThis rule always ignores extra parentheses around the following:\n该规则总是忽略以下情况的额外的圆括号：\n\nRegExp literals such as (/abc/).test(var) to avoid conflicts with the wrap-regex rule\nRegExp 字面量比如 (/abc/).test(var) 避免与 wrap-regex 规则产生冲突\nimmediately-invoked function expressions (also known as IIFEs) such as var x = (function () {})(); and ((function foo() {return 1;})()) to avoid conflicts with the wrap-iife rule\n立即执行函数 (也就是 IIFE) 比如 var x = (function () {})(); 和 ((function foo() {return 1;})()) 避免与 wrap-iife 规则产生冲突\n\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"all\" (default) disallows unnecessary parentheses around any expression\n\"all\" (默认) 禁止在 任何 表达式周围出现不必要的圆括号\n\"functions\" disallows unnecessary parentheses only around function expressions\n\"functions\" 只在 函数表达式周围禁止不必要的圆括号\n\nThis rule has an object option for exceptions to the \"all\" option:\n该规则对于 \"all\" 选项有例外情况，是个对象：\n\n\"conditionalAssign\": false allows extra parentheses around assignments in conditional test expressions\n\"conditionalAssign\": false 允许在条件语句的测试表达式中的赋值语句周围出现额外的圆括号\n\"returnAssign\": false allows extra parentheses around assignments in return statements\n\"returnAssign\": false 允许在 return 语句中的赋值语句周围出现额外的圆括号\n\"nestedBinaryExpressions\": false allows extra parentheses in nested binary expressions\n\"nestedBinaryExpressions\": false 允许在嵌套的二元表达式中出现额外的圆括号\n\"ignoreJSX\": \"none|all|multi-line|single-line\" allows extra parentheses around no/all/multi-line/single-line JSX components. Defaults to none.\n\"ignoreJSX\": \"none|all|multi-line|single-line\" 允许在 no/所有/多行/单行的JSX 组件周围出现额外的圆括号。 默认为 none。\n\"enforceForArrowConditionals\": false allows extra parentheses around ternary expressions which are the body of an arrow function\n\"enforceForArrowConditionals\": false 允许在箭头函数体中的三元表达式周围出现额外的圆括号\n\nall\nExamples of incorrect code for this rule with the default \"all\" option:\n默认选项 \"all\" 的 错误 代码示例：\n/* eslint no-extra-parens: \"error\" */\n\na = (b * c);\n\n(a * b) + c;\n\ntypeof (a);\n\n(function(){} ? a() : b());\n\n\nExamples of correct code for this rule with the default \"all\" option:\n默认选项 \"all\" 的 正确 代码示例：\n/* eslint no-extra-parens: \"error\" */\n\n(0).toString();\n\n(Object.prototype.toString.call());\n\n({}.toString.call());\n\n(function(){}) ? a() : b();\n\n(/^a$/).test(x);\n\n\nconditionalAssign\nExamples of correct code for this rule with the \"all\" and { \"conditionalAssign\": false } options:\n选项 \"all\" 和 { \"conditionalAssign\": false } 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { \"conditionalAssign\": false }] */\n\nwhile ((foo = bar())) {}\n\nif ((foo = bar())) {}\n\ndo; while ((foo = bar()))\n\nfor (;(a = b););\n\n\nreturnAssign\nExamples of correct code for this rule with the \"all\" and { \"returnAssign\": false } options:\n选项 \"all\" 和 { \"returnAssign\": false } 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { \"returnAssign\": false }] */\n\nfunction a(b) {\n  return (b = 1);\n}\n\nfunction a(b) {\n  return b ? (c = d) : (c = e);\n}\n\nb => (b = 1);\n\nb => b ? (c = d) : (c = e);\n\n\nnestedBinaryExpressions\nExamples of correct code for this rule with the \"all\" and { \"nestedBinaryExpressions\": false } options:\n选项 \"all\" 和 { \"nestedBinaryExpressions\": false } 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { \"nestedBinaryExpressions\": false }] */\n\nx = a || (b && c);\nx = a + (b * c);\nx = (a * b) / c;\n\n\nignoreJSX\nExamples of correct code for this rule with the all and { \"ignoreJSX\": \"all\" } options:\n选项 all 和 { \"ignoreJSX\": \"all\" } 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"all\" }] */\nconst Component = (<div />)\nconst Component = (\n    <div\n        prop={true}\n    />\n)\n\n\nExamples of incorrect code for this rule with the all and { \"ignoreJSX\": \"multi-line\" } options:\n选项 all 和 { \"ignoreJSX\": \"multi-line\" } 的 错误 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"multi-line\" }] */\nconst Component = (<div />)\nconst Component = (<div><p /></div>)\n\n\nExamples of correct code for this rule with the all and { \"ignoreJSX\": \"multi-line\" } options:\n选项 all 和 { \"ignoreJSX\": \"multi-line\" } 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"multi-line\" }] */\nconst Component = (\n    <div>\n        <p />\n    </div>\n)\nconst Component = (\n    <div\n        prop={true}\n    />\n)\n\n\nExamples of incorrect code for this rule with the all and { \"ignoreJSX\": \"single-line\" } options:\n选项 all 和 { \"ignoreJSX\": \"single-line\" } 的 错误 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"single-line\" }] */\nconst Component = (\n    <div>\n        <p />\n    </div>\n)\nconst Component = (\n    <div\n        prop={true}\n    />\n)\n\n\nExamples of correct code for this rule with the all and { \"ignoreJSX\": \"single-line\" } options:\n选项 all 和 { \"ignoreJSX\": \"single-line\" } 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"single-line\" }] */\nconst Component = (<div />)\nconst Component = (<div><p /></div>)\n\n\nenforceForArrowConditionals\nExamples of correct code for this rule with the \"all\" and { \"enforceForArrowConditionals\": false } options:\n选项 \"all\" and { \"enforceForArrowConditionals\": false } 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForArrowConditionals\": false }] */\n\nconst b = a => 1 ? 2 : 3;\nconst d = c => (1 ? 2 : 3);\n\n\nfunctions\nExamples of incorrect code for this rule with the \"functions\" option:\n选项 \"functions\" 的 错误 代码示例：\n/* eslint no-extra-parens: [\"error\", \"functions\"] */\n\n((function foo() {}))();\n\nvar y = (function () {return 1;});\n\n\nExamples of correct code for this rule with the \"functions\" option:\n选项 \"functions\" 的 正确 代码示例：\n/* eslint no-extra-parens: [\"error\", \"functions\"] */\n\n(0).toString();\n\n(Object.prototype.toString.call());\n\n({}.toString.call());\n\n(function(){} ? a() : b());\n\n(/^a$/).test(x);\n\na = (b * c);\n\n(a * b) + c;\n\ntypeof (a);\n\n\nFurther Reading\n\nMDN: Operator Precedence\n\nRelated Rules\n\nno-cond-assign\nno-return-assign\n\nVersion\nThis rule was introduced in ESLint 0.1.4.\n该规则在 ESLint 0.1.4 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-extra-parens",
                "disable": false
            },
            {
                "real_name": "no-extra-semi",
                "display_name": "no-extra-semi",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用不必要的分号 (no-extra-semi)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow unnecessary semicolons (no-extra-semi)\n禁用不必要的分号 (no-extra-semi)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nTyping mistakes and misunderstandings about where semicolons are required can lead to semicolons that are unnecessary. While not technically an error, extra semicolons can cause confusion when reading code.\n书写错误和对哪里需要使用分号的误解，会导致出现不必要的分号。虽然在技术上不是个错误，但阅读代码时会引起困惑。\nRule Details\nThis rule disallows unnecessary semicolons.\n该规则禁用不必要的分号。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-extra-semi: \"error\"*/\n\nvar x = 5;;\n\nfunction foo() {\n    // code\n};\n\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-extra-semi: \"error\"*/\n\nvar x = 5;\n\nvar foo = function() {\n    // code\n};\n\n\n\nWhen Not To Use It\nIf you intentionally use extra semicolons then you can disable this rule.\n如果你有意使用额外的分号，那么你可以禁用此规则。\nRelated Rules\n\nsemi\nsemi-spacing\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-extra-semi",
                "disable": false
            },
            {
                "real_name": "no-fallthrough",
                "display_name": "no-fallthrough",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止 case 语句落空 (no-fallthrough)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Case Statement Fallthrough (no-fallthrough)\n禁止 case 语句落空 (no-fallthrough)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe switch statement in JavaScript is one of the more error-prone constructs of the language thanks in part to the ability to “fall through” from one case to the next. For example:\n在 JavaScript 中，switch 语句是一种比较容易出错的结构，在某种程度上这要归功于 case 的落空能力。比如：\nswitch(foo) {\n    case 1:\n        doSomething();\n\n    case 2:\n        doSomethingElse();\n}\n\n\nIn this example, if foo is 1, then execution will flow through both cases, as the first falls through to the second. You can prevent this by using break, as in this example:\n在这个例子中，如果 foo 值为 1，两个 case 语句都会执行。你可以使用 break 阻止这种情况，例如以下例子：\nswitch(foo) {\n    case 1:\n        doSomething();\n        break;\n\n    case 2:\n        doSomethingElse();\n}\n\n\nThat works fine when you don’t want a fallthrough, but what if the fallthrough is intentional, there is no way to indicate that in the language. It’s considered a best practice to always indicate when a fallthrough is intentional using a comment which matches the /falls?\\s?through/i regular expression:\n当你不想要落空时是没有问题的，但是，如果落空是有意为之呢，没有办法来表明这一点。使用匹配 /falls?\\s?through/i 的正则表达式的注释来表明落空是有意为之的，，被认为是一个最佳实际。\nswitch(foo) {\n    case 1:\n        doSomething();\n        // falls through\n\n    case 2:\n        doSomethingElse();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // fall through\n\n    case 2:\n        doSomethingElse();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // fallsthrough\n\n    case 2:\n        doSomethingElse();\n}\n\n\nIn this example, there is no confusion as to the expected behavior. It is clear that the first case is meant to fall through to the second case.\n在这个例子中，不会再引起困惑。很明显，第一个 case 的意思是要落空到第二个 case。\nRule Details\nThis rule is aimed at eliminating unintentional fallthrough of one case to the other. As such, it flags any fallthrough scenarios that are not marked by a comment.\n该规则旨在消除非故意 case 落空行为。因此，它会标记处没有使用注释标明的落空情况。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-fallthrough: \"error\"*/\n\nswitch(foo) {\n    case 1:\n        doSomething();\n\n    case 2:\n        doSomething();\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-fallthrough: \"error\"*/\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        break;\n\n    case 2:\n        doSomething();\n}\n\nfunction bar(foo) {\n    switch(foo) {\n        case 1:\n            doSomething();\n            return;\n\n        case 2:\n            doSomething();\n    }\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        throw new Error(\"Boo!\");\n\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // falls through\n\n    case 2:\n        doSomething();\n}\n\n\nNote that the last case statement in these examples does not cause a warning because there is nothing to fall through into.\n注意，在上面的例子中，最后的 case 语句，不会引起警告，因为没有可落空的语句了。\nOptions\nThis rule accepts a single options argument:\n该规则接受单个选项参数：\n\nSet the commentPattern option to a regular expression string to change the test for intentional fallthrough comment\n设置 commentPattern 选项为一个正则表达式字符串，来改变对有意为之的落空注释的检索\n\ncommentPattern\nExamples of correct code for the { \"commentPattern\": \"break[\\\\s\\\\w]*omitted\" } option:\n选项 { \"commentPattern\": \"break[\\\\s\\\\w]*omitted\" } 的 正确 代码示例：\n/*eslint no-fallthrough: [\"error\", { \"commentPattern\": \"break[\\\\s\\\\w]*omitted\" }]*/\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // break omitted\n\n    case 2:\n        doSomething();\n}\n\nswitch(foo) {\n    case 1:\n        doSomething();\n        // caution: break is omitted intentionally\n\n    default:\n        doSomething();\n}\n\n\nWhen Not To Use It\nIf you don’t want to enforce that each case statement should end with a throw, return, break, or comment, then you can safely turn this rule off.\n如果你不想强制每个 case 语句中都要以 throw、return、break或者注释作为结束，你可以关闭此规则。\nRelated Rules\n\ndefault-case\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-fallthrough",
                "disable": false
            },
            {
                "real_name": "no-floating-decimal",
                "display_name": "no-floating-decimal",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止浮点小数 (no-floating-decimal)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Floating Decimals (no-floating-decimal)\n禁止浮点小数 (no-floating-decimal)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nFloat values in JavaScript contain a decimal point, and there is no requirement that the decimal point be preceded or followed by a number. For example, the following are all valid JavaScript numbers:\n在 JavaScript 中，浮点值会包含一个小数点，没有要求小数点之前或之后必须有一个数字。例如，以下例子都是有效的 JavaScript 数字：\nvar num = .5;\nvar num = 2.;\nvar num = -.7;\n\n\nAlthough not a syntax error, this format for numbers can make it difficult to distinguish between true decimal numbers and the dot operator. For this reason, some recommend that you should always include a number before and after a decimal point to make it clear the intent is to create a decimal number.\n虽然不是一个语法错误，这种格式的数字使真正的小数和点操作符变的难以区分。由于这个原因，有些人建议应该总是在小数点前面和后面有一个数字，以明确表明是要创建一个小数。\nRule Details\nThis rule is aimed at eliminating floating decimal points and will warn whenever a numeric value has a decimal point but is missing a number either before or after it.\n此规则目的在于消除浮动小数点，并且，当数值的小数点之前或之后缺少数字时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-floating-decimal: \"error\"*/\n\nvar num = .5;\nvar num = 2.;\nvar num = -.7;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-floating-decimal: \"error\"*/\n\nvar num = 0.5;\nvar num = 2.0;\nvar num = -0.7;\n\n\nWhen Not To Use It\nIf you aren’t concerned about misinterpreting floating decimal point values, then you can safely turn this rule off.\n如果你并不担心误解浮点小数，你可以安全的关闭此规则。\nCompatibility\n\nJSHint: W008\n\nFurther Reading\n\nA leading decimal point can be confused with a dot\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-floating-decimal",
                "disable": false
            },
            {
                "real_name": "no-func-assign",
                "display_name": "no-func-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止对 function 声明重新赋值 (no-func-assign).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow reassigning function declarations (no-func-assign)\n禁止对 function 声明重新赋值 (no-func-assign)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nJavaScript functions can be written as a FunctionDeclaration function foo() { ... } or as a FunctionExpression var foo = function() { ... };. While a JavaScript interpreter might tolerate it, overwriting/reassigning a function written as a FunctionDeclaration is often indicative of a mistake or issue.\nJavaScript 函数有两种形式：函数声明 function foo() { ... } 或者函数表达式 var foo = function() { ... } 。虽然 JavaScript 解释器可以容忍对函数声明进行覆盖或重新赋值，但通常这是个错误或会导致问题出现。\nfunction foo() {}\nfoo = bar;\n\n\nRule Details\nThis rule disallows reassigning function declarations.\n该规则禁止对 function 声明重新赋值。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-func-assign: \"error\"*/\n\nfunction foo() {}\nfoo = bar;\n\nfunction foo() {\n    foo = bar;\n}\n\n\nExamples of incorrect code for this rule, unlike the corresponding rule in JSHint:\n与 JSHint 中对应的规则不同，该规则的 错误 代码示例：\n/*eslint no-func-assign: \"error\"*/\n\nfoo = bar;\nfunction foo() {}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-func-assign: \"error\"*/\n\nvar foo = function () {}\nfoo = bar;\n\nfunction foo(foo) { // `foo` is shadowed.\n    foo = bar;\n}\n\nfunction foo() {\n    var foo = bar;  // `foo` is shadowed.\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-func-assign",
                "disable": false
            },
            {
                "real_name": "no-global-assign",
                "display_name": "no-global-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow assignment to native objects or read-only global variables (no-global-assign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow assignment to native objects or read-only global variables (no-global-assign)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\nJavaScript environments contain a number of built-in global variables, such as window in browsers and process in Node.js. In almost all cases, you don’t want to assign a value to these global variables as doing so could result in losing access to important functionality. For example, you probably don’t want to do this in browser code:\nwindow = {};\n\n\nWhile examples such as window are obvious, there are often hundreds of built-in global objects provided by JavaScript environments. It can be hard to know if you’re assigning to a global variable or not.\nRule Details\nThis rule disallows modifications to read-only global variables.\nESLint has the capability to configure global variables as read-only.\n\nSpecifying Environments\nSpecifying Globals\n\nExamples of incorrect code for this rule:\n/*eslint no-global-assign: \"error\"*/\n\nObject = null\nundefined = 1\n\n\n/*eslint no-global-assign: \"error\"*/\n/*eslint-env browser*/\n\nwindow = {}\nlength = 1\ntop = 1\n\n\n/*eslint no-global-assign: \"error\"*/\n/*globals a:false*/\n\na = 1\n\n\nExamples of correct code for this rule:\n/*eslint no-global-assign: \"error\"*/\n\na = 1\nvar b = 1\nb = 2\n\n\n/*eslint no-global-assign: \"error\"*/\n/*eslint-env browser*/\n\nonload = function() {}\n\n\n/*eslint no-global-assign: \"error\"*/\n/*globals a:true*/\n\na = 1\n\n\nOptions\nThis rule accepts an exceptions option, which can be used to specify a list of builtins for which reassignments will be allowed:\n{\n    \"rules\": {\n        \"no-global-assign\": [\"error\", {\"exceptions\": [\"Object\"]}]\n    }\n}\n\n\nWhen Not To Use It\nIf you are trying to override one of the native objects.\nRelated Rules\n\nno-extend-native\nno-redeclare\nno-shadow\n\nVersion\nThis rule was introduced in ESLint 3.3.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-global-assign",
                "disable": false
            },
            {
                "real_name": "no-implicit-coercion",
                "display_name": "no-implicit-coercion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用较短的符号实现类型转换 (no-implicit-coercion)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow the type conversion with shorter notations. (no-implicit-coercion)\n禁止使用较短的符号实现类型转换 (no-implicit-coercion)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIn JavaScript, there are a lot of different ways to convert value types.\nSome of them might be hard to read and understand.\n在 JavaScript 中，有许多不同的方式进行类型转换。其中有些可能难于阅读和理解。\nSuch as:\n例如：\nvar b = !!foo;\nvar b = ~foo.indexOf(\".\");\nvar n = +foo;\nvar n = 1 * foo;\nvar s = \"\" + foo;\nfoo += ``;\n\n\nThose can be replaced with the following code:\n可以使用下面的代码替换:\nvar b = Boolean(foo);\nvar b = foo.indexOf(\".\") !== -1;\nvar n = Number(foo);\nvar n = Number(foo);\nvar s = String(foo);\nfoo = String(foo);\n\n\nRule Details\nThis rule is aimed to flag shorter notations for the type conversion, then suggest a more self-explanatory notation.\n该规则目的是标记出使用较短的符号进行类型转换的情况，建议使用一个更明确的符号。\nOptions\nThis rule has three main options and one override option to allow some coercions as required.\n该规则有三个主要选项和一个覆盖选项，覆盖选项允许一些强制要求。\n\n\"boolean\" (true by default) - When this is true, this rule warns shorter type conversions for boolean type.\n\"boolean\"(默认是 true)－当为 true 时，规则会对简短的 boolean 类型转换发出警告。\n\"number\" (true by default) - When this is true, this rule warns shorter type conversions for number type.\n\"number\"(默认是 true)－当为 true 时，规则会对简短的 number 类型转换发出警告。\n\"string\" (true by default) - When this is true, this rule warns shorter type conversions for string type.\n\"string\"(默认是 true)－当为 true 时，规则会对简短的 string 类型转换发出警告。\n\"allow\" (empty by default) - Each entry in this array can be one of ~, !!, + or * that are to be allowed.\n\"allow\" (默认是 empty) - 这个数组的每一项可以是 ~、!!、+ 或 *。\n\nNote that operator + in allow list would allow +foo (number coercion) as well as \"\" + foo (string coercion).\n注意，在 allow 列表中，操作符 + 同时允许 +foo（数字）和 \"\" + foo (字符串)\nboolean\nExamples of incorrect code for the default { \"boolean\": true } option:\n默认选项 { \"boolean\": true } 的 错误 代码示例：\n/*eslint no-implicit-coercion: \"error\"*/\n\nvar b = !!foo;\nvar b = ~foo.indexOf(\".\");\n// bitwise not is incorrect only with `indexOf`/`lastIndexOf` method calling.\n\n\nExamples of correct code for the default { \"boolean\": true } option:\n默认选项 { \"boolean\": true } 的 正确 代码示例：\n/*eslint no-implicit-coercion: \"error\"*/\n\nvar b = Boolean(foo);\nvar b = foo.indexOf(\".\") !== -1;\n\nvar n = ~foo; // This is a just bitwise not.\n\n\nnumber\nExamples of incorrect code for the default { \"number\": true } option:\n默认选项 { \"number\": true } 的 错误 代码示例：\n/*eslint no-implicit-coercion: \"error\"*/\n\nvar n = +foo;\nvar n = 1 * foo;\n\n\nExamples of correct code for the default { \"number\": true } option:\n默认选项 { \"number\": true } 的 正确 代码示例：\n/*eslint no-implicit-coercion: \"error\"*/\n\nvar n = Number(foo);\nvar n = parseFloat(foo);\nvar n = parseInt(foo, 10);\n\n\nstring\nExamples of incorrect code for the default { \"string\": true } option:\n默认选项 { \"string\": true } 的 错误 代码示例：\n/*eslint no-implicit-coercion: \"error\"*/\n\nvar s = \"\" + foo;\nvar s = `` + foo;\nfoo += \"\";\nfoo += ``;\n\n\nExamples of correct code for the default { \"string\": true } option:\n默认选项 { \"string\": true } 的 正确 代码示例：\n/*eslint no-implicit-coercion: \"error\"*/\n\nvar s = String(foo);\nfoo = String(foo);\n\n\nallow\nUsing allow list, we can override and allow specific operators.\n使用 allow 列表，我们可以覆盖和允许特定的操作符。\nExamples of correct code for the sample { \"allow\": [\"!!\", \"~\"] } option:\n默认选项 { \"allow\": [\"!!\", \"~\"] } 的 正确 代码示例：\n/*eslint no-implicit-coercion: [2, { \"allow\": [\"!!\", \"~\"] } ]*/\n\nvar b = !!foo;\nvar b = ~foo.indexOf(\".\");\n\n\nWhen Not To Use It\nIf you don’t want to be notified about shorter notations for the type conversion, you can safely disable this rule.\n如果你不想收到关于使用较短符号进行类型转换的通知，可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-2.\n该规则在 ESLint 1.0.0-rc-2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-implicit-coercion",
                "disable": false
            },
            {
                "real_name": "no-implicit-globals",
                "display_name": "no-implicit-globals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在全局范围使用变量和函数声明 (no-implicit-globals)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow variable and function declarations in the global scope (no-implicit-globals)\n禁止在全局范围使用变量和函数声明 (no-implicit-globals)\nWhen working with browser scripts, developers often forget that variable and function declarations at the top-level scope become global variables on the window object. As opposed to modules which have their own scope. Globals should be explicitly assigned to window or self if that is the intent. Otherwise variables intended to be local to the script should be wrapped in an IIFE.\n当使用浏览器端脚本时，开发者经常忘记在顶级作用域下变量和函数声明都会变成全局变量，作为 window 对象的一个属性或方法存在。它们没有自己的作用域，这一点与模块不一样。全局变量应该显式地赋值给 window 或 self。否则，局部变量应该包裹在 IIFE 中。\nRule Details\nThis rule disallows var and named function declarations at the top-level script scope. This does not apply to ES and CommonJS modules since they have a module scope.\n该规则禁止在顶级作用域下使用 var 和命名的 function 声明。该规则不适用于 ES 和 CommonJS 的模块，因为它们有自己的模块作用域。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-implicit-globals: \"error\"*/\n\nvar foo = 1;\n\nfunction bar() {}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-implicit-globals: \"error\"*/\n\n// explicitly set on window\nwindow.foo = 1;\nwindow.bar = function() {};\n\n// intended to be scope to this file\n(function() {\n  var foo = 1;\n\n  function bar() {}\n})();\n\n\nExamples of correct code for this rule with \"parserOptions\": { \"sourceType\": \"module\" } in the ESLint configuration:\n选项 \"parserOptions\": { \"sourceType\": \"module\" } 的 正确 代码示例：\n/*eslint no-implicit-globals: \"error\"*/\n\n// foo and bar are local to module\nvar foo = 1;\nfunction bar() {}\n\n\nWhen Not To Use It\nIf you want to be able to declare variables and functions in the global scope you can safely disable this rule. Or if you are always using module scoped files, this rule will never apply.\n如果你希望能够在全局作用域下声明变量和函数，你可以禁用此规则。如果你总是使用模块作用域的文件，该规则将永远不会起作用。\nFurther Reading\n\nImmediately-Invoked Function Expression (IIFE)\n\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-1.\n该规则在 ESLint 2.0.0-alpha-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-implicit-globals",
                "disable": false
            },
            {
                "real_name": "no-implied-eval",
                "display_name": "no-implied-eval",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用隐式的eval() (no-implied-eval)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Implied eval() (no-implied-eval)\n禁用隐式的eval() (no-implied-eval)\nIt’s considered a good practice to avoid using eval() in JavaScript. There are security and performance implications involved with doing so, which is why many linters (including ESLint) recommend disallowing eval(). However, there are some other ways to pass a string and have it interpreted as JavaScript code that have similar concerns.\n在 JavaScript 中避免使用 eval() 被认为是一个很好的实践。这么做是考虑到安全性和性能的影响，这也是为什么很多检查工具（包括 ESLint ）推荐禁用 eval()。然而，也有一些其它方式，通过传递一个字符串，并将它解析为 JavaScript 代码，也有类似的问题。\nThe first is using setTimeout(), setInterval() or execScript() (Internet Explorer only), both of which can accept a string of JavaScript code as their first argument. For example:\n首当其冲的就是 setTimeout()、setInterval() 或者 execScript() (仅限IE浏览器)，它们都可以接受一个 JavaScript 字符串代码作为第一个参数。例如：\nsetTimeout(\"alert('Hi!');\", 100);\n\n\nThis is considered an implied eval() because a string of JavaScript code is\n passed in to be interpreted. The same can be done with setInterval() and execScript(). Both interpret the JavaScript code in  the global scope. For  both setTimeout() and setInterval(), the first argument can also be a function, and that is considered safer and is more performant:\n这被认为是一个隐式的 eval() 因为传入的 JavaScript 字符串可以被解析。setInterval() 和 execScript() 也一样。两种方式都能在全局作用域解析 JavaScript 代码。对于 setTimeout() 和 setInterval() 来说，第一个参数也可以是个函数，并且这种方式被认为更安全更高效。\nsetTimeout(function() {\n    alert(\"Hi!\");\n}, 100);\n\n\nThe best practice is to always use a function for the first argument of setTimeout() and setInterval() (and avoid execScript()).\n最佳实践是总是使用函数作为 setTimeout() 和 setInterval() 的第一个参数。\nRule Details\nThis rule aims to eliminate implied eval() through the use of setTimeout(), setInterval() or execScript(). As such, it will warn when either function is used with a string as the first argument.\n此规则目的在于消除使用 setTimeout()、setInterval() 或 execScript() 时隐式的 eval()。因此，当它们中的任何一个使用字符串作为第一个参数时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-implied-eval: \"error\"*/\n\nsetTimeout(\"alert('Hi!');\", 100);\n\nsetInterval(\"alert('Hi!');\", 100);\n\nexecScript(\"alert('Hi!')\");\n\nwindow.setTimeout(\"count = 5\", 10);\n\nwindow.setInterval(\"foo = bar\", 10);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-implied-eval: \"error\"*/\n\nsetTimeout(function() {\n    alert(\"Hi!\");\n}, 100);\n\nsetInterval(function() {\n    alert(\"Hi!\");\n}, 100);\n\n\nWhen Not To Use It\nIf you want to allow setTimeout() and setInterval() with string arguments, then you can safely disable this rule.\n如果你想要允许 setTimeout() 和 setInterval() 使用字符串参数，你可以关闭此规则。\nRelated Rules\n\nno-eval\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-implied-eval",
                "disable": false
            },
            {
                "real_name": "no-inline-comments",
                "display_name": "no-inline-comments",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用内联注释 (no-inline-comments)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow inline comments after code (no-inline-comments)\n禁止使用内联注释 (no-inline-comments)\nSome style guides disallow comments on the same line as code. Code can become difficult to read if comments immediately follow the code on the same line.\nOn the other hand, it is sometimes faster and more obvious to put comments immediately following code.\n一些风格指南禁止注释和代码出现在同一行。如果注释紧随代码，会使代码是变得难以阅读。另一方面，将注释放在代码后面会快更明显。\nRule Details\nThis rule disallows comments on the same line as code.\n该规则禁止注释和代码出现在同一行。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-inline-comments: \"error\"*/\n\nvar a = 1; // declaring a to 1\n\nfunction getRandomNumber(){\n    return 4; // chosen by fair dice roll.\n              // guaranteed to be random.\n}\n\n/* A block comment before code */ var b = 2;\n\nvar c = 3; /* A block comment after code */\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-inline-comments: \"error\"*/\n\n// This is a comment above a line of code\nvar foo = 5;\n\nvar bar = 5;\n//This is a comment below a line of code\n\n\nVersion\nThis rule was introduced in ESLint 0.10.0.\n该规则在 ESLint 0.10.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-inline-comments",
                "disable": false
            },
            {
                "real_name": "no-inner-declarations",
                "display_name": "no-inner-declarations",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow variable or function declarations in nested blocks  (no-inner-declarations).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow variable or function declarations in nested blocks  (no-inner-declarations)\n禁止在嵌套的语句块中出现变量或 function 声明 (no-inner-declarations)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIn JavaScript, prior to ES6, a function declaration is only allowed in the first level of a program or the body of another function, though parsers sometimes erroneously accept them elsewhere. This only applies to function declarations; named or anonymous function expressions can occur anywhere an expression is permitted.\n在 ES6 之前的 JavaScript 中，函数声明只能在程序或另一个函数体的顶层，尽管解析器有时会错误地接受它们。这只适用于函数声明；命名的或匿名的函数表达式是可以出现在任何允许的地方。\n// Good\nfunction doSomething() { }\n\n// Bad\nif (test) {\n    function doSomethingElse () { }\n}\n\nfunction anotherThing() {\n    var fn;\n\n    if (test) {\n\n        // Good\n        fn = function expression() { };\n\n        // Bad\n        function declaration() { }\n    }\n}\n\n\nA variable declaration is permitted anywhere a statement can go, even nested deeply inside other blocks. This is often undesirable due to variable hoisting, and moving declarations to the root of the program or function body can increase clarity. Note that block bindings (let, const) are not hoisted and therefore they are not affected by this rule.\n可以在任何地方声明变量，甚至是在深层嵌套的语句块中。由于变量声明提升，把声明放在程序或函数体的顶部会使代码更清晰，在任何地方随意声明变量的做法通常是不可取的。注意 block bindings 中提到的 let 和 const 不会被提升，因此它们不受此规则影响。\n/*eslint-env es6*/\n\n// Good\nvar foo = 42;\n\n// Good\nif (foo) {\n    let bar1;\n}\n\n// Bad\nwhile (test) {\n    var bar2;\n}\n\nfunction doSomething() {\n    // Good\n    var baz = true;\n\n    // Bad\n    if (baz) {\n        var quux;\n    }\n}\n\n\nRule Details\nThis rule requires that function declarations and, optionally, variable declarations be in the root of a program or the body of a function.\n该规则要求函数声明和变量声明（可选的）在程序或函数体的顶部。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"functions\" (default) disallows function declarations in nested blocks\n\"functions\" (默认) 禁止 function 声明出现在嵌套的语句块中\n\"both\" disallows function and var declarations in nested blocks\n\"both\" 禁止 function 和 var 声明出现在嵌套的语句块中\n\nfunctions\nExamples of incorrect code for this rule with the default \"functions\" option:\n默认选项 \"functions\" 的 错误 代码示例：\n/*eslint no-inner-declarations: \"error\"*/\n\nif (test) {\n    function doSomething() { }\n}\n\nfunction doSomethingElse() {\n    if (test) {\n        function doAnotherThing() { }\n    }\n}\n\n\nExamples of correct code for this rule with the default \"functions\" option:\n默认选项 \"functions\" 的 正确 代码示例：\n/*eslint no-inner-declarations: \"error\"*/\n\nfunction doSomething() { }\n\nfunction doSomethingElse() {\n    function doAnotherThing() { }\n}\n\nif (test) {\n    asyncCall(id, function (err, data) { });\n}\n\nvar fn;\nif (test) {\n    fn = function fnExpression() { };\n}\n\n\nboth\nExamples of incorrect code for this rule with the \"both\" option:\n选项 \"both\" 的 错误 代码示例：\n/*eslint no-inner-declarations: [\"error\", \"both\"]*/\n\nif (test) {\n    var foo = 42;\n}\n\nfunction doAnotherThing() {\n    if (test) {\n        var bar = 81;\n    }\n}\n\n\nExamples of correct code for this rule with the \"both\" option:\n选项 \"both\" 的 正确 代码示例：\n/*eslint no-inner-declarations: \"error\"*/\n/*eslint-env es6*/\n\nvar bar = 42;\n\nif (test) {\n    let baz = 43;\n}\n\nfunction doAnotherThing() {\n    var baz = 81;\n}\n\n\nWhen Not To Use It\nThe function declaration portion rule will be rendered obsolete when block-scoped functions land in ES6, but until then, it should be left on to enforce valid constructions. Disable checking variable declarations when using block-scoped-var or if declaring variables in nested blocks is acceptable despite hoisting.\n当 block-scoped functions 出现在 ES6 中时，函数声明的部分规则将被废弃，但在那之前，它应该是行之有效的。当使用 block-scoped-var 规则时或者在嵌套块中声明变量是可以接受的（尽管有变量声明提升）时候，可以不再检测变量声明。\nVersion\nThis rule was introduced in ESLint 0.6.0.\n该规则在 ESLint 0.6.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-inner-declarations",
                "disable": false
            },
            {
                "real_name": "no-invalid-regexp",
                "display_name": "no-invalid-regexp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow invalid regular expression strings in RegExp constructors (no-invalid-regexp).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow invalid regular expression strings in RegExp constructors (no-invalid-regexp)\n禁止在 RegExp 构造函数中出现无效的正则表达式 (no-invalid-regexp)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nAn invalid pattern in a regular expression literal is a SyntaxError when the code is parsed, but an invalid string in RegExp constructors throws a SyntaxError only when the code is executed.\n在正则表达式字面量中无效的模式在代码解析时会引起 SyntaxError，但是 RegExp 的构造函数中无效的字符串只在代码执行时才会抛出 SyntaxError。\nRule Details\nThis rule disallows invalid regular expression strings in RegExp constructors.\n该规则禁止在 RegExp 构造函数中出现无效的正则表达式。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-invalid-regexp: \"error\"*/\n\nRegExp('[')\n\nRegExp('.', 'z')\n\nnew RegExp('\\\\')\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-invalid-regexp: \"error\"*/\n\nRegExp('.')\n\nnew RegExp\n\nthis.RegExp('[')\n\n\nEnvironments\nECMAScript 6 adds the following flag arguments to the RegExp constructor:\nECMAScript 6 为 RegExp 构造函数增加了以下标志参数：\n\n\"u\" (unicode)\n\"u\" (unicode)\n\"y\" (sticky)\n\"y\" (sticky)\n\nYou can enable these to be recognized as valid by setting the ECMAScript version to 6 in your ESLint configuration.\n你可以在你的 ESLint 配置 中通过设置 ECMAScript 为 6 ，来使这些标志被有效地识别。\nIf you want to allow additional constructor flags for any reason, you can specify them using an allowConstructorFlags option in .eslintrc. These flags will then be ignored by the rule regardless of the ecmaVersion setting.\n如果你想允许使用额外的标志，也不论出于什么目的，你可以在 .eslintrc 使用 allowConstructorFlags 选项指定它们。这样，不管是否有 ecmaVersion 设置，这些标记将会被该规则忽略。\nOptions\nThis rule has an object option for exceptions:\n该规则有例外情况，是个对象：\n\n\"allowConstructorFlags\" is an array of flags\n\"allowConstructorFlags\" 是个标志的数组\n\nallowConstructorFlags\nExamples of correct code for this rule with the { \"allowConstructorFlags\": [\"u\", \"y\"] } option:\n选项 { \"allowConstructorFlags\": [\"u\", \"y\"] } 的 正确 代码示例：\n/*eslint no-invalid-regexp: [\"error\", { \"allowConstructorFlags\": [\"u\", \"y\"] }]*/\n\nnew RegExp('.', 'y')\n\nnew RegExp('.', 'yu')\n\n\nFurther Reading\n\nAnnotated ES5 §7.8.5 - Regular Expression Literals\n\nVersion\nThis rule was introduced in ESLint 0.1.4.\n该规则在 ESLint 0.1.4 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-invalid-regexp",
                "disable": false
            },
            {
                "real_name": "no-invalid-this",
                "display_name": "no-invalid-this",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow this keywords outside of classes or class-like objects. (no-invalid-this).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow this keywords outside of classes or class-like objects. (no-invalid-this)\n禁止 this 关键字在类或类对象之外出现 (no-invalid-this)\nUnder the strict mode, this keywords outside of classes or class-like objects might be undefined and raise a TypeError.\n在严格模式下，类或者类对象之外的 this 关键字可能是 undefined 并且引发 TypeError。\nRule Details\nThis rule aims to flag usage of this keywords outside of classes or class-like objects.\n此规则目的在于标记类或者类对象之外的 this 关键字的使用。\nBasically this rule checks whether or not a function which are containing this keywords is a constructor or a method.\n基本上该规则检查一个包含 this 关键字的函数是一个构造函数还是方法。\nThis rule judges from following conditions whether or not the function is a constructor:\n此规则从以下条件中判断函数是否是一个构造函数：\n\nThe name of the function starts with uppercase.\n该函数的名字以大写字母开头。\nThe function is assigned to a variable which starts with an uppercase letter.\n该函数被赋值给一个以大小字母开头的变量。\nThe function is a constructor of ES2015 Classes.\n该函数是 ES2015 类构造函数。\n\nThis rule judges from following conditions whether or not the function is a method:\n此规则从以下条件中判断函数是否是一个方法：\n\nThe function is on an object literal.\n该函数在对象字面量上。\nThe function is assigned to a property.\n该函数被赋值给一个属性。\nThe function is a method/getter/setter of ES2015 Classes. (excepts static methods)\n该函数是一个 ES2015 类的方法、getter 或 setter。(除静态方法)\n\nAnd this rule allows this keywords in functions below:\n此规则允许在以下函数中出现 this 关键字：\n\nThe call/apply/bind method of the function is called directly.\n该函数的 call/apply/bind 方法被直接调用。\nThe function is a callback of array methods (such as .forEach()) if thisArg is given.\n如果给出 thisArg，该函数是数组方法的一个回调（比如.forEach()）。\nThe function has @this tag in its JSDoc comment.\n函数在 JSDoc 注释标记中有 @this 标签。\n\nOtherwise are considered problems.\n其它情况被认为是有问题的。\nThis rule applies only in strict mode.\nWith \"parserOptions\": { \"sourceType\": \"module\" } in the ESLint configuration, your code is in strict mode even without a \"use strict\" directive.\n该规则 只 在严格模式下生效。如果在 ESLint 配置中设置了 \"parserOptions\": { \"sourceType\": \"module\" }，你的代码即使没有使用 \"use strict\"指令，也是处于严格模式下的。\nExamples of incorrect code for this rule in strict mode:\n在严格模式下，错误 代码示例：\n/*eslint no-invalid-this: \"error\"*/\n/*eslint-env es6*/\n\n\"use strict\";\n\nthis.a = 0;\nbaz(() => this);\n\n(function() {\n    this.a = 0;\n    baz(() => this);\n})();\n\nfunction foo() {\n    this.a = 0;\n    baz(() => this);\n}\n\nvar foo = function() {\n    this.a = 0;\n    baz(() => this);\n};\n\nfoo(function() {\n    this.a = 0;\n    baz(() => this);\n});\n\nobj.foo = () => {\n    // `this` of arrow functions is the outer scope's.\n    this.a = 0;\n};\n\nvar obj = {\n    aaa: function() {\n        return function foo() {\n            // There is in a method `aaa`, but `foo` is not a method.\n            this.a = 0;\n            baz(() => this);\n        };\n    }\n};\n\nfoo.forEach(function() {\n    this.a = 0;\n    baz(() => this);\n});\n\n\nExamples of correct code for this rule in strict mode:\n在严格模式下，正确 代码示例：\n/*eslint no-invalid-this: \"error\"*/\n/*eslint-env es6*/\n\n\"use strict\";\n\nfunction Foo() {\n    // OK, this is in a legacy style constructor.\n    this.a = 0;\n    baz(() => this);\n}\n\nclass Foo {\n    constructor() {\n        // OK, this is in a constructor.\n        this.a = 0;\n        baz(() => this);\n    }\n}\n\nvar obj = {\n    foo: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n};\n\nvar obj = {\n    foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n};\n\nvar obj = {\n    get foo() {\n        // OK, this is in a method (this function is on object literal).\n        return this.a;\n    }\n};\n\nvar obj = Object.create(null, {\n    foo: {value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }}\n});\n\nObject.defineProperty(obj, \"foo\", {\n    value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n});\n\nObject.defineProperties(obj, {\n    foo: {value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }}\n});\n\nfunction Foo() {\n    this.foo = function foo() {\n        // OK, this is in a method (this function assigns to a property).\n        this.a = 0;\n        baz(() => this);\n    };\n}\n\nobj.foo = function foo() {\n    // OK, this is in a method (this function assigns to a property).\n    this.a = 0;\n};\n\nFoo.prototype.foo = function foo() {\n    // OK, this is in a method (this function assigns to a property).\n    this.a = 0;\n};\n\nclass Foo {\n    foo() {\n        // OK, this is in a method.\n        this.a = 0;\n        baz(() => this);\n    }\n\n    static foo() {\n        // OK, this is in a method (static methods also have valid this).\n        this.a = 0;\n        baz(() => this);\n    }\n}\n\nvar foo = (function foo() {\n    // OK, the `bind` method of this function is called directly.\n    this.a = 0;\n}).bind(obj);\n\nfoo.forEach(function() {\n    // OK, `thisArg` of `.forEach()` is given.\n    this.a = 0;\n    baz(() => this);\n}, thisArg);\n\n/** @this Foo */\nfunction foo() {\n    // OK, this function has a `@this` tag in its JSDoc comment.\n    this.a = 0;\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about usage of this keyword outside of classes or class-like objects, you can safely disable this rule.\n如果你不想收到 this 关键字在类或者类对象之外使用的通知，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-2.\n该规则在 ESLint 1.0.0-rc-2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-invalid-this",
                "disable": false
            },
            {
                "real_name": "no-irregular-whitespace",
                "display_name": "no-irregular-whitespace",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止不规则的空白 (no-irregular-whitespace)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow irregular whitespace (no-irregular-whitespace)\n禁止不规则的空白 (no-irregular-whitespace)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nInvalid or irregular whitespace causes issues with ECMAScript 5 parsers and also makes code harder to debug in a similar nature to mixed tabs and spaces.\n无效的或不规则的空白会导致 ECMAScript 5 解析问题，也会使代码难以调试（类似于混合 tab 和空格的情况）。\nVarious whitespace characters can be inputted by programmers by mistake for example from copying or keyboard shortcuts. Pressing Alt + Space on OS X adds in a non breaking space character for example.\n各种空白字符可能是由程序员误输入的，比如拷贝或键盘快捷键。例如，在 OS X 系统按下 Alt + Space，增加了一个不间断空格。\nKnown issues these spaces cause:\n这些空格引起的已知的问题:\n\nZero Width Space\n零宽空格\n    \nIs NOT considered a separator for tokens and is often parsed as an Unexpected token ILLEGAL\n不被认为是分隔符，经常被解析为 Unexpected token ILLEGAL\nIs NOT shown in modern browsers making code repository software expected to resolve the visualisation\n不在现代浏览器中显示，期待使用代码存储软件解决其可视化问题\n\n\nLine Separator\n行分隔符\n    \nIs NOT a valid character within JSON which would cause parse errors\n在 JSON 中不是一个有效的字符，会引起解析错误\n\n\n\nRule Details\nThis rule is aimed at catching invalid whitespace that is not a normal tab and space. Some of these characters may cause issues in modern browsers and others will be a debugging issue to spot.\n该规则旨在捕获无效的不是正常的tab和空格的空白。这些字符有的会在现代浏览器中引发问题，其它的会引起调试问题。\nThis rule disallows the following characters except where the options allow:\n该规则禁止出现以下字符，除非该规则选项允许：\n\\u000B - Line Tabulation (\\v) - <VT>\n\\u000C - Form Feed (\\f) - <FF>\n\\u00A0 - No-Break Space - <NBSP>\n\\u0085 - Next Line\n\\u1680 - Ogham Space Mark\n\\u180E - Mongolian Vowel Separator - <MVS>\n\\ufeff - Zero Width No-Break Space - <BOM>\n\\u2000 - En Quad\n\\u2001 - Em Quad\n\\u2002 - En Space - <ENSP>\n\\u2003 - Em Space - <EMSP>\n\\u2004 - Tree-Per-Em\n\\u2005 - Four-Per-Em\n\\u2006 - Six-Per-Em\n\\u2007 - Figure Space\n\\u2008 - Punctuation Space - <PUNCSP>\n\\u2009 - Thin Space\n\\u200A - Hair Space\n\\u200B - Zero Width Space - <ZWSP>\n\\u2028 - Line Separator\n\\u2029 - Paragraph Separator\n\\u202F - Narrow No-Break Space\n\\u205f - Medium Mathematical Space\n\\u3000 - Ideographic Space\n\n\nOptions\nThis rule has an object option for exceptions:\n该规则有例外情况，是个对象：\n\n\"skipStrings\": true (default) allows any whitespace characters in string literals\n\"skipStrings\": true (默认) 允许在字符串字面量中出现任何空白字符\n\"skipComments\": true allows any whitespace characters in comments\n\"skipComments\": true 允许在注释中出现任何空白字符\n\"skipRegExps\": true allows any whitespace characters in regular expression literals\n\"skipRegExps\": true 允许在正则表达式中出现任何空白字符\n\"skipTemplates\": true allows any whitespace characters in template literals\n\"skipTemplates\": true 允许在模板字面量中出现任何空白字符\n\nskipStrings\nExamples of incorrect code for this rule with the default { \"skipStrings\": true } option:\n默认选项 { \"skipStrings\": true } 的 错误 代码示例：\n/*eslint no-irregular-whitespace: \"error\"*/\n\nfunction thing() /*<NBSP>*/{\n    return 'test';\n}\n\nfunction thing( /*<NBSP>*/){\n    return 'test';\n}\n\nfunction thing /*<NBSP>*/(){\n    return 'test';\n}\n\nfunction thing᠎/*<MVS>*/(){\n    return 'test';\n}\n\nfunction thing() {\n    return 'test'; /*<ENSP>*/\n}\n\nfunction thing() {\n    return 'test'; /*<NBSP>*/\n}\n\nfunction thing() {\n    // Description <NBSP>: some descriptive text\n}\n\n/*\nDescription <NBSP>: some descriptive text\n*/\n\nfunction thing() {\n    return / <NBSP>regexp/;\n}\n\n/*eslint-env es6*/\nfunction thing() {\n    return `template <NBSP>string`;\n}\n\n\nExamples of correct code for this rule with the default { \"skipStrings\": true } option:\n默认选项 { \"skipStrings\": true } 正确 代码示例：\n/*eslint no-irregular-whitespace: \"error\"*/\n\nfunction thing() {\n    return ' <NBSP>thing';\n}\n\nfunction thing() {\n    return '​<ZWSP>thing';\n}\n\nfunction thing() {\n    return 'th <NBSP>ing';\n}\n\n\nskipComments\nExamples of additional correct code for this rule with the { \"skipComments\": true } option:\n选项 { \"skipComments\": true } 的 正确 代码示例：\n/*eslint no-irregular-whitespace: [\"error\", { \"skipComments\": true }]*/\n\nfunction thing() {\n    // Description <NBSP>: some descriptive text\n}\n\n/*\nDescription <NBSP>: some descriptive text\n*/\n\n\nskipRegExps\nExamples of additional correct code for this rule with the { \"skipRegExps\": true } option:\n选项 { \"skipRegExps\": true } 的 正确 代码示例：\n/*eslint no-irregular-whitespace: [\"error\", { \"skipRegExps\": true }]*/\n\nfunction thing() {\n    return / <NBSP>regexp/;\n}\n\n\nskipTemplates\nExamples of additional correct code for this rule with the { \"skipTemplates\": true } option:\n选项 { \"skipTemplates\": true } 的 正确 代码示例：\n/*eslint no-irregular-whitespace: [\"error\", { \"skipTemplates\": true }]*/\n/*eslint-env es6*/\n\nfunction thing() {\n    return `template <NBSP>string`;\n}\n\n\nWhen Not To Use It\nIf you decide that you wish to use whitespace other than tabs and spaces outside of strings in your application.\n如果你想在你的应用中使用 tab 和空格之外的空白字符，可以关闭此规则。\nFurther Reading\n\nECMA whitespace\nJSON whitespace issues\n\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-irregular-whitespace",
                "disable": false
            },
            {
                "real_name": "no-iterator",
                "display_name": "no-iterator",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用迭代器 (no-iterator)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Iterator (no-iterator)\n禁用迭代器 (no-iterator)\nThe __iterator__ property was a SpiderMonkey extension to JavaScript that could be used to create custom iterators that are compatible with JavaScript’s for in and for each constructs. However, this property is now obsolete, so it should not be used. Here’s an example of how this used to work:\n__iterator__ 属性曾是 SpiderMonkey 对 JavaScript 的扩展，被用来创建自定义迭代器，兼容JavaScript的 for in 和 for each。然而，这个属性现在废弃了，所以不应再使用它。这里有个例子，展示它是如何使用的：\nFoo.prototype.__iterator__ = function() {\n    return new FooIterator(this);\n}\n\n\nYou should use ECMAScript 6 iterators and generators instead.\n你应该使用 ECMAScript 6 迭代器和生成器。\nRule Details\nThis rule is aimed at preventing errors that may arise from using the __iterator__ property, which is not implemented in several browsers. As such, it will warn whenever it encounters the __iterator__ property.\n此规则目的在于防止因使用 __iterator__属性而出现的错误，并不是所有浏览器都实现了这个属性。因此，当遇到 __iterator__属性时，该规则将会发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-iterator: \"error\"*/\n\nFoo.prototype.__iterator__ = function() {\n    return new FooIterator(this);\n};\n\nfoo.__iterator__ = function () {};\n\nfoo[\"__iterator__\"] = function () {};\n\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-iterator: \"error\"*/\n\nvar __iterator__ = foo; // Not using the `__iterator__` property.\n\n\nFurther Reading\n\nMDN - Iterators and Generators\nECMAScript 6 compatibility table - Iterators\nDeprecated and Obsolete Features\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-iterator",
                "disable": false
            },
            {
                "real_name": "no-label-var",
                "display_name": "no-label-var",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用与变量同名的标签 (no-label-var)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Labels That Are Variables Names (no-label-var)\n禁用与变量同名的标签 (no-label-var)\nRule Details\nThis rule aims to create clearer code by disallowing the bad practice of creating a label that shares a name with a variable that is in scope.\n该规则旨在通过禁止使用同一作用域下的同名的变量做为标签，来创建更清晰的代码。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-label-var: \"error\"*/\n\nvar x = foo;\nfunction bar() {\nx:\n  for (;;) {\n    break x;\n  }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-label-var: \"error\"*/\n\n// The variable that has the same name as the label is not in scope.\n\nfunction foo() {\n  var q = t;\n}\n\nfunction bar() {\nq:\n  for(;;) {\n    break q;\n  }\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about usage of labels, then it’s safe to disable this rule.\n如果你不想收到标签的使用情况的通知，可以关闭此规则。\nFurther Reading\n\n‘{a}’ is a statement label\n\nRelated Rules\n\nno-extra-label\nno-labels\nno-unused-labels\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-label-var",
                "disable": false
            },
            {
                "real_name": "no-labels",
                "display_name": "no-labels",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用标签语句 (no-labels)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Labeled Statements (no-labels)\n禁用标签语句 (no-labels)\nLabeled statements in JavaScript are used in conjunction with break and continue to control flow around multiple loops. For example:\nJavaScript 中的标签语句连同 break 和 continue 一样用来控制循环流程。例如：\nouter:\n    while (true) {\n\n        while (true) {\n            break outer;\n        }\n    }\n\n\nThe break outer statement ensures that this code will not result in an infinite loop because control is returned to the next statement after the outer label was applied. If this statement was changed to be just break, control would flow back to the outer while statement and an infinite loop would result.\nbreak outer 语句确保代码不会无限循环，因为应用 outer 标签之后，将会进入下一条语句。如果这个语句变为 break，控制流程会回到外层 while 语句，并会导致无限循环。\nWhile convenient in some cases, labels tend to be used only rarely and are frowned upon by some as a remedial form of flow control that is more error prone and harder to understand.\n虽然在某些情况下很方便，标签往往很少使用，很多人不赞成将标签作为一种复杂流程控制的补救措施。\nRule Details\nThis rule aims to eliminate the use of labeled statements in JavaScript. It will warn whenever a labeled statement is encountered and whenever break or continue are used with a label.\n此规则旨在消除 JavaScript 中标签的使用。当遇到标签语句时，该规则将发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-labels: \"error\"*/\n\nlabel:\n    while(true) {\n        // ...\n    }\n\nlabel:\n    while(true) {\n        break label;\n    }\n\nlabel:\n    while(true) {\n        continue label;\n    }\n\nlabel:\n    switch (a) {\n    case 0:\n        break label;\n    }\n\nlabel:\n    {\n        break label;\n    }\n\nlabel:\n    if (a) {\n        break label;\n    }\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-labels: \"error\"*/\n\nvar f = {\n    label: \"foo\"\n};\n\nwhile (true) {\n    break;\n}\n\nwhile (true) {\n    continue;\n}\n\n\nOptions\nThe options allow labels with loop or switch statements:\n以下选项允许在循环和 switch 语句中使用标签。\n\n\"allowLoop\" (boolean, default is false) - If this option was set true, this rule ignores labels which are sticking to loop statements.\n\"allowLoop\" (boolean，默认是 false) - 如果这个选项被设置为 true，该规则忽略循环语句中的标签。\n\"allowSwitch\" (boolean, default is false) - If this option was set true, this rule ignores labels which are sticking to switch statements.\n\"allowSwitch\" (boolean，默认是 false) - 如果这个选项被设置为 true，该规则忽略 switch 语句中的标签。\n\nActually labeled statements in JavaScript can be used with other than loop and switch statements.\nHowever, this way is ultra rare, not well-known, so this would be confusing developers.\n实际上，在 JavaScript 中，标签语句可以用在除循环和 switch语句之外的地方。然而，这种方式是非常罕见的，所以会令开发中感到困惑。\nallowLoop\nExamples of correct code for the { \"allowLoop\": true } option:\n选项 { \"allowLoop\": true } 的 正确 代码示例：\n/*eslint no-labels: [\"error\", { \"allowLoop\": true }]*/\n\nlabel:\n    while (true) {\n        break label;\n    }\n\n\nallowSwitch\nExamples of correct code for the { \"allowSwitch\": true } option:\n选项 { \"allowSwitch\": true } 的 正确 代码示例：\n/*eslint no-labels: [\"error\", { \"allowSwitch\": true }]*/\n\nlabel:\n    switch (a) {\n        case 0:\n            break label;\n    }\n\n\nWhen Not To Use It\nIf you need to use labeled statements everywhere, then you can safely disable this rule.\n如果你需要在任何地方都使用标签语句，你可以禁用此规则。\nRelated Rules\n\nno-extra-label\nno-label-var\nno-unused-labels\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-labels",
                "disable": false
            },
            {
                "real_name": "no-lone-blocks",
                "display_name": "no-lone-blocks",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用不必要的嵌套块 (no-lone-blocks)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Unnecessary Nested Blocks (no-lone-blocks)\n禁用不必要的嵌套块 (no-lone-blocks)\nIn JavaScript, prior to ES6, standalone code blocks delimited by curly braces do not create a new scope and have no use. For example, these curly braces do nothing to foo:\n在 JavaScript 中，ES6 之前，由花括号分隔开的独立代码块不会创建新的作用域，也就不起什么作用。例如，这些花括号对 foo 不起任何作用：\n{\n    var foo = bar();\n}\n\n\nIn ES6, code blocks may create a new scope if a block-level binding (let and const), a class declaration or a function declaration (in strict mode) are present. A block is not considered redundant in these cases.\n在 ES6 中，如果出现一个块级绑定 (let 和 const)，类声明或函数声明（在严格模式下），代码块就会创建一个新的作用域。在这些情况下，代码块不会被认为是多余的。\nRule Details\nThis rule aims to eliminate unnecessary and potentially confusing blocks at the top level of a script or within other blocks.\n该规则旨在消除脚本顶部或其它块中不必要的和潜在的令人困惑的代码块。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-lone-blocks: \"error\"*/\n\n{}\n\nif (foo) {\n    bar();\n    {\n        baz();\n    }\n}\n\nfunction bar() {\n    {\n        baz();\n    }\n}\n\n{\n    function foo() {}\n}\n\n{\n    aLabel: {\n    }\n}\n\n\nExamples of correct code for this rule with es6 environment:\n正确 代码示例：\n/*eslint no-lone-blocks: \"error\"*/\n/*eslint-env es6*/\n\nwhile (foo) {\n    bar();\n}\n\nif (foo) {\n    if (bar) {\n        baz();\n    }\n}\n\nfunction bar() {\n    baz();\n}\n\n{\n    let x = 1;\n}\n\n{\n    const y = 1;\n}\n\n{\n    class Foo {}\n}\n\naLabel: {\n}\n\n\nExamples of correct code for this rule with es6 environment and strict mode via \"parserOptions\": { \"sourceType\": \"module\" } in the ESLint configuration or \"use strict\" directive in the code:\n在严格模式下，设置 ecmaFeatures: { blockBindings: true }，以下的模式不会发出警告：\n/*eslint no-lone-blocks: \"error\"*/\n/*eslint-env es6*/\n\n\"use strict\";\n\n{\n    function foo() {}\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-lone-blocks",
                "disable": false
            },
            {
                "real_name": "no-lonely-if",
                "display_name": "no-lonely-if",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow if statements as the only statement in else blocks (no-lonely-if).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow if statements as the only statement in else blocks (no-lonely-if)\n禁止 if 语句作为唯一语句出现在 else 语句块中 (no-lonely-if)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIf an if statement is the only statement in the else block, it is often clearer to use an else if form.\n如果 if 语句作为唯一的语句出现在 else 语句块中，往往使用 else if 形式会使代码更清晰。\nif (foo) {\n    // ...\n} else {\n    if (bar) {\n        // ...\n    }\n}\n\n\nshould be rewritten as\n应该被重写为：\nif (foo) {\n    // ...\n} else if (bar) {\n    // ...\n}\n\n\nRule Details\nThis rule disallows if statements as the only statement in else blocks.\n该规则禁止 if 语句作为唯一语句出现在 else 语句块中。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-lonely-if: \"error\"*/\n\nif (condition) {\n    // ...\n} else {\n    if (anotherCondition) {\n        // ...\n    }\n}\n\nif (condition) {\n    // ...\n} else {\n    if (anotherCondition) {\n        // ...\n    } else {\n        // ...\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-lonely-if: \"error\"*/\n\nif (condition) {\n    // ...\n} else if (anotherCondition) {\n    // ...\n}\n\nif (condition) {\n    // ...\n} else if (anotherCondition) {\n    // ...\n} else {\n    // ...\n}\n\nif (condition) {\n    // ...\n} else {\n    if (anotherCondition) {\n        // ...\n    }\n    doSomething();\n}\n\n\nWhen Not To Use It\nDisable this rule if the code is clearer without requiring the else if form.\n如果不使用else if也能使代码比较清晰，禁用此规则即可。\nVersion\nThis rule was introduced in ESLint 0.6.0.\n该规则在 ESLint 0.6.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-lonely-if",
                "disable": false
            },
            {
                "real_name": "no-loop-func",
                "display_name": "no-loop-func",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止循环中存在函数 (no-loop-func)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Functions in Loops (no-loop-func)\n禁止循环中存在函数 (no-loop-func)\nWriting functions within loops tends to result in errors due to the way the function creates a closure around the loop. For example:\n在循环中创建函数往往会出现错误，因为这种情况下，函数会创建一个闭包。例如：\nfor (var i = 0; i < 10; i++) {\n    funcs[i] = function() {\n        return i;\n    };\n}\n\n\nIn this case, you would expect each function created within the loop to return a different number. In reality, each function returns 10, because that was the last value of i in the scope.\n在这个例子中，你希望在循环中创建的每个函数返回一个不同的数字。实际上，每个函数都返回作用域中 i 的最后一个值 10。\nlet or const mitigate this problem.\nlet 或 const 规避了这个问题。\n/*eslint-env es6*/\n\nfor (let i = 0; i < 10; i++) {\n    funcs[i] = function() {\n        return i;\n    };\n}\n\n\nIn this case, each function created within the loop returns a different number as expected.\n在这个例子中，在循环中创建的每一个函数会如你期望的那样返回一个不同的数字。\nRule Details\nThis error is raised to highlight a piece of code that may not work as you expect it to and could also indicate a misunderstanding of how the language works. Your code may run without any problems if you do not fix this error, but in some situations it could behave unexpectedly.\n这个错误的出现会导致代码不能如你期望的那样运行，也表明你对 JavaScript 这门语言存在误解。\n如果你不修复这个错误，你的代码可能会正常运行，带在某些情况下，可能会出现意想不到的行为。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-loop-func: \"error\"*/\n/*eslint-env es6*/\n\nfor (var i=10; i; i--) {\n    (function() { return i; })();\n}\n\nwhile(i) {\n    var a = function() { return i; };\n    a();\n}\n\ndo {\n    function a() { return i; };\n    a();\n} while (i);\n\nlet foo = 0;\nfor (let i=10; i; i--) {\n    // Bad, function is referencing block scoped variable in the outer scope.\n    var a = function() { return foo; };\n    a();\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-loop-func: \"error\"*/\n/*eslint-env es6*/\n\nvar a = function() {};\n\nfor (var i=10; i; i--) {\n    a();\n}\n\nfor (var i=10; i; i--) {\n    var a = function() {}; // OK, no references to variables in the outer scopes.\n    a();\n}\n\nfor (let i=10; i; i--) {\n    var a = function() { return i; }; // OK, all references are referring to block scoped variables in the loop.\n    a();\n}\n\nvar foo = 100;\nfor (let i=10; i; i--) {\n    var a = function() { return foo; }; // OK, all references are referring to never modified variables.\n    a();\n}\n//... no modifications of foo after this loop ...\n\n\nFurther Reading\n\nDon’t make functions within a loop\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-loop-func",
                "disable": false
            },
            {
                "real_name": "no-magic-numbers",
                "display_name": "no-magic-numbers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用魔术数字 (no-magic-numbers)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Magic Numbers (no-magic-numbers)\n禁止使用魔术数字 (no-magic-numbers)\n‘Magic numbers’ are numbers that occur multiple time in code without an explicit meaning.\nThey should preferably be replaced by named constants.\n魔术数字是在代码中多次出现的没有明确含义的数字。它最好由命名常量取代。\nvar now = Date.now(),\n    inOneHour = now + (60 * 60 * 1000);\n\n\nRule Details\nThe no-magic-numbers rule aims to make code more readable and refactoring easier by ensuring that special numbers\nare declared as constants to make their meaning explicit.\n该规则旨在确保将具体的数字声明为意义明确的常量，从而使代码更加可读并且易于重构。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-magic-numbers: \"error\"*/\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * 0.25);\n\n\n/*eslint no-magic-numbers: \"error\"*/\n\nvar data = ['foo', 'bar', 'baz'];\n\nvar dataLast = data[2];\n\n\n/*eslint no-magic-numbers: \"error\"*/\n\nvar SECONDS;\n\nSECONDS = 60;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-magic-numbers: \"error\"*/\n\nvar TAX = 0.25;\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * TAX);\n\n\nOptions\nignore\nAn array of numbers to ignore. It’s set to [] by default.\nIf provided, it must be an Array.\n一个数字数组，指定检测中可以忽略的数字。默认为 []。如果设置该选项，它必须是 Array。\nExamples of correct code for the sample { \"ignore\": [1] } option:\n选项 { \"ignore\": [1] } 的 错误 代码示例：\n/*eslint no-magic-numbers: [\"error\", { \"ignore\": [1] }]*/\n\nvar data = ['foo', 'bar', 'baz'];\nvar dataLast = data.length && data[data.length - 1];\n\n\nignoreArrayIndexes\nA boolean to specify if numbers used as array indexes are considered okay. false by default.\n一个布尔值，指定数字用作数组的索引是否是可以的。默认为 false。\nExamples of correct code for the { \"ignoreArrayIndexes\": true } option:\n选项 { \"ignoreArrayIndexes\": true } 的 正确 代码示例：\n/*eslint no-magic-numbers: [\"error\", { \"ignoreArrayIndexes\": true }]*/\n\nvar data = ['foo', 'bar', 'baz'];\nvar dataLast = data[2];\n\n\nenforceConst\nA boolean to specify if we should check for the const keyword in variable declaration of numbers. false by default.\n一个布尔值，指定是否应该在数字变量的声明中检测 const 关键字。默认为false。\nExamples of incorrect code for the { \"enforceConst\": true } option:\n选项 { \"enforceConst\": true } 的 错误 代码示例：\n/*eslint no-magic-numbers: [\"error\", { \"enforceConst\": true }]*/\n\nvar TAX = 0.25;\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * TAX);\n\n\ndetectObjects\nA boolean to specify if we should detect numbers when setting object properties for example. false by default.\n一个布尔值，指定是否应该在设置对象属性时检测数字。默认为 false。\nExamples of incorrect code for the { \"detectObjects\": true } option:\n选项 { \"detectObjects\": true } 的 错误 代码示例：\n/*eslint no-magic-numbers: [\"error\", { \"detectObjects\": true }]*/\n\nvar magic = {\n  tax: 0.25\n};\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * magic.tax);\n\n\nExamples of correct code for the { \"detectObjects\": true } option:\n选项 { \"detectObjects\": true } 的 正确 代码示例：\n/*eslint no-magic-numbers: [\"error\", { \"detectObjects\": true }]*/\n\nvar TAX = 0.25;\n\nvar magic = {\n  tax: TAX\n};\n\nvar dutyFreePrice = 100,\n    finalPrice = dutyFreePrice + (dutyFreePrice * magic.tax);\n\n\nVersion\nThis rule was introduced in ESLint 1.7.0.\n该规则在 ESLint 1.7.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-magic-numbers",
                "disable": false
            },
            {
                "real_name": "no-mixed-operators",
                "display_name": "no-mixed-operators",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止混合使用不同的操作符 (no-mixed-operators)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow mixes of different operators (no-mixed-operators)\n禁止混合使用不同的操作符 (no-mixed-operators)\nEnclosing complex expressions by parentheses clarifies the developer’s intention, which makes the code more readable.\nThis rule warns when different operators are used consecutively without parentheses in an expression.\n封闭的复杂表达式使用括号括起来明确了开发者的意图，使代码更具可读性。当表达式中连续的不同的操作符没有使用括号括起来，该规则将发出警告。\nvar foo = a && b || c || d;    /*BAD: Unexpected mix of '&&' and '||'.*/\nvar foo = (a && b) || c || d;  /*GOOD*/\nvar foo = a && (b || c || d);  /*GOOD*/\n\n\nRule Details\nThis rule checks BinaryExpression and LogicalExpression.\n该规则检查 BinaryExpression 和 LogicalExpression。\nThis rule may conflict with no-extra-parens rule.\nIf you use both this and no-extra-parens rule together, you need to use the nestedBinaryExpressions option of no-extra-parens rule.\n该规则可能与 no-extra-parens 规则。如果你同时使用该规则和no-extra-parens 规则，你需要使用 no-extra-parens 规则的 nestedBinaryExpressions 的选项。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-mixed-operators: \"error\"*/\n\nvar foo = a && b < 0 || c > 0 || d + 1 === 0;\nvar foo = a + b * c;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-mixed-operators: \"error\"*/\n\nvar foo = a || b || c;\nvar foo = a && b && c;\nvar foo = (a && b < 0) || c > 0 || d + 1 === 0;\nvar foo = a && (b < 0 || c > 0 || d + 1 === 0);\nvar foo = a + (b * c);\nvar foo = (a + b) * c;\n\n\nOptions\n{\n    \"no-mixed-operators\": [\n        \"error\",\n        {\n            \"groups\": [\n                [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"],\n                [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"],\n                [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"],\n                [\"&&\", \"||\"],\n                [\"in\", \"instanceof\"]\n            ],\n            \"allowSamePrecedence\": true\n        }\n    ]\n}\n\n\nThis rule has 2 options.\n该规则有两个选项。\n\ngroups (string[][]) - specifies groups to compare operators.\nWhen this rule compares two operators, if both operators are included in a same group, this rule checks it. Otherwise, this rule ignores it.\nThis value is a list of groups. The group is a list of binary operators.\nDefault is the groups for each kind of operators.\ngroups (string[][]) - 指定要比较的操作符分组。\n当该规则比较两个操作符时，，如果操作符在同一分组内，该规则会进行检查。否则这规则忽略它。它值是个列表组。这个组是二元操作符列表。默认为各种操作符的组。\nallowSamePrecedence (boolean) - specifies to allow mix of 2 operators if those have the same precedence. Default is true.\nallowSamePrecedence (boolean) - 指定允许使用混合的两个操作符，前提是它们有同样的优先级。 默认为 true.\n\ngroups\nThe following operators can be used in groups option:\n下面的操作符可以在 groups 选项中使用：\n\nArithmetic Operators: \"+\", \"-\", \"*\", \"/\", \"%\", \"**\"\n算数操作符：\"+\"、\"-\"、\"*\"、\"/\"、\"%\"、\"**\"\nBitwise Operators: \"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"\n位操作符：\"&\"、\"|\"、\"^\"、\"~\"、\"<<\"、\">>\"、\">>>\"\nComparison Operators: \"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"\n比较操作符：\"==\"、\"!=\"、\"===\"、\"!==\"、\">\"、\">=\"、\"<\"、\"<=\"\nLogical Operators: \"&&\", \"||\"\n逻辑操作符：\"&&\"、\"||\"\nRelational Operators: \"in\", \"instanceof\"\n关系操作符：\"in\"、\"instanceof\"\n\nNow, considers about {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]} configure.\n现在，考虑一下 {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]} 配置。\nThis configure has 2 groups: bitwise operators and logical operators.\nThis rule checks only if both operators are included in a same group.\nSo, in this case, this rule comes to check between bitwise operators and between logical operators.\n该配置有两个分组：位操作符和逻辑操作符。该规则只检查同一分组内的操作符。所以，在这种情况下，该规则检查位操作符和逻辑操作符。\nThis rule ignores other operators.\n该规则忽略其它操作符。\nExamples of incorrect code for this rule with {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]} option:\n选项 {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]} 的 错误 代码示例：\n/*eslint no-mixed-operators: [\"error\", {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]}]*/\n\nvar foo = a && b < 0 || c > 0 || d + 1 === 0;\nvar foo = a & b | c;\n\n\nExamples of correct code for this rule with {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]} option:\n选项 {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]} 的 正确 代码示例：\n/*eslint no-mixed-operators: [\"error\", {\"groups\": [[\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"], [\"&&\", \"||\"]]}]*/\n\nvar foo = a || b > 0 || c + 1 === 0;\nvar foo = a && b > 0 && c + 1 === 0;\nvar foo = (a && b < 0) || c > 0 || d + 1 === 0;\nvar foo = a && (b < 0 ||  c > 0 || d + 1 === 0);\nvar foo = (a & b) | c;\nvar foo = a & (b | c);\nvar foo = a + b * c;\nvar foo = a + (b * c);\nvar foo = (a + b) * c;\n\n\nallowSamePrecedence\nExamples of correct code for this rule with {\"allowSamePrecedence\": true} option:\n选项 {\"allowSamePrecedence\": true} 的 正确 代码示例：\n/*eslint no-mixed-operators: [\"error\", {\"allowSamePrecedence\": true}]*/\n\n// + and - have the same precedence.\nvar foo = a + b - c;\n\n\nExamples of incorrect code for this rule with {\"allowSamePrecedence\": false} option:\n选项 {\"allowSamePrecedence\": false} 的 错误 代码示例：\n/*eslint no-mixed-operators: [\"error\", {\"allowSamePrecedence\": false}]*/\n\n// + and - have the same precedence.\nvar foo = a + b - c;\n\n\nWhen Not To Use It\nIf you don’t want to be notified about mixed operators, then it’s safe to disable this rule.\n如果你不想收到关于混合操作的通知，你可以关闭此规则。\nRelated Rules\n\nno-extra-parens\n\nVersion\nThis rule was introduced in ESLint 2.12.0.\n该规则在 ESLint 2.12.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-mixed-operators",
                "disable": false
            },
            {
                "real_name": "no-mixed-requires",
                "display_name": "no-mixed-requires",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow require calls to be mixed with regular variable declarations (no-mixed-requires).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow require calls to be mixed with regular variable declarations (no-mixed-requires)\n禁止 require 调用与普通变量声明混合使用 (no-mixed-requires)\nIn the Node.js community it is often customary to separate initializations with calls to require modules from other variable declarations, sometimes also grouping them by the type of module. This rule helps you enforce this convention.\n在 Node.js 社区，通常习惯把调用 require 模块的初始化和其它变量声明分开，有时也根据模块类型对它们进行分组。该规则帮助你强制执行这种约定。\nRule Details\nWhen this rule is enabled, each var statement must satisfy the following conditions:\n当启用该规则时，每个 var 语句必须满足以下条件：\n\neither none or all variable declarations must be require declarations (default)\n所有的变量要么全是 require 声明（默认），要么全不是 require 声明\nall require declarations must be of the same type (grouping)\n所有的 require 声明必须是同一类型（grouping)\n\nThis rule distinguishes between six kinds of variable declaration types:\n该规则区分六种类型的变量声明：\n\ncore: declaration of a required core module\ncore: require 核心模块的声明\nfile: declaration of a required file module\nfile: require 文件模块的声明\nmodule: declaration of a required module from the node_modules folder\nmodule: 从node_modules 文件夹 require 一个模块的声明\ncomputed: declaration of a required module whose type could not be determined (either because it is computed or because require was called without an argument)\ncomputed: require 一个不能确定类型的模块的声明 (要么是因为它是推算出来的，要么是因为调用了无参的 require)\nuninitialized: a declaration that is not initialized\nuninitialized: 未初始化的声明\nother: any other kind of declaration\nother: 其它类型的声明\n\nIn this document, the first four types are summed up under the term require declaration.\n在本文中，前四个类型属于 require declaration。\nvar fs = require('fs'),        // \"core\"     \\\n    async = require('async'),  // \"module\"   |- these are \"require declaration\"s\n    foo = require('./foo'),    // \"file\"     |\n    bar = require(getName()),  // \"computed\" /\n    baz = 42,                  // \"other\"\n    bam;                       // \"uninitialized\"\n\n\nOptions\nThis rule can have an object literal option whose two properties have false values by default.\n该规则有一个选项，是个对象，它的两个属性值默认为 false。\nConfiguring this rule with one boolean option true is deprecated.\n使用一个布尔类型的选项 true 配置此规则已被弃用。\nExamples of incorrect code for this rule with the default { \"grouping\": false, \"allowCall\": false } options:\n默认选项 { \"grouping\": false, \"allowCall\": false } 的 错误 代码示例：\n/*eslint no-mixed-requires: \"error\"*/\n\nvar fs = require('fs'),\n    i = 0;\n\nvar async = require('async'),\n    debug = require('diagnostics').someFunction('my-module'),\n    eslint = require('eslint');\n\n\nExamples of correct code for this rule with the default { \"grouping\": false, \"allowCall\": false } options:\n默认选项 { \"grouping\": false, \"allowCall\": false } 的 正确 代码示例：\n/*eslint no-mixed-requires: \"error\"*/\n\n// only require declarations (grouping off)\nvar eventEmitter = require('events').EventEmitter,\n    myUtils = require('./utils'),\n    util = require('util'),\n    bar = require(getBarModuleName());\n\n// only non-require declarations\nvar foo = 42,\n    bar = 'baz';\n\n// always valid regardless of grouping because all declarations are of the same type\nvar foo = require('foo' + VERSION),\n    bar = require(getBarModuleName()),\n    baz = require();\n\n\ngrouping\nExamples of incorrect code for this rule with the { \"grouping\": true } option:\n选项 { \"grouping\": true } 的 错误 代码示例：\n/*eslint no-mixed-requires: [\"error\", { \"grouping\": true }]*/\n\n// invalid because of mixed types \"core\" and \"module\"\nvar fs = require('fs'),\n    async = require('async');\n\n// invalid because of mixed types \"file\" and \"unknown\"\nvar foo = require('foo'),\n    bar = require(getBarModuleName());\n\n\nallowCall\nExamples of incorrect code for this rule with the { \"allowCall\": true } option:\n选项 { \"allowCall\": true } 的 错误 代码示例：\n/*eslint no-mixed-requires: [\"error\", { \"allowCall\": true }]*/\n\nvar async = require('async'),\n    debug = require('diagnostics').someFunction('my-module'), /* allowCall doesn't allow calling any function */\n    eslint = require('eslint');\n\n\nExamples of correct code for this rule with the { \"allowCall\": true } option:\n选项 { \"allowCall\": true } 的 正确 代码示例：\n/*eslint no-mixed-requires: [\"error\", { \"allowCall\": true }]*/\n\nvar async = require('async'),\n    debug = require('diagnostics')('my-module'),\n    eslint = require('eslint');\n\n\nKnown Limitations\n\nThe implementation is not aware of any local functions with the name require that may shadow Node.js’ global require.\n该规则的实现不考虑本地名为require的函数可能会遮蔽 Node.js 的全局的require。\nInternally, the list of core modules is retrieved via require(\"repl\")._builtinLibs. If you use different versions of Node.js for ESLint and your application, the list of core modules for each version may be different.\nThe above mentioned _builtinLibs property became available in 0.8, for earlier versions a hardcoded list of module names is used as a fallback. If your version of Node.js is older than 0.6 that list may be inaccurate.\n在内部，核心模块列表是通过require(\"repl\")._builtinLibs检索的。如果你在 ESLint 和你的应用中使用不同的 Node.js 版本，每个版本的核心模块列表可能会不一样。上面提到的 _builtinLibs 在 0.8 版本中有效，在更早的版本中，将模块名一一列出作为一种回退机制。如果你的 Node.js 版本低于 0.6，则那个模块列表可能是不准确的。\n\nWhen Not To Use It\nIf you use a pattern such as UMD where the required modules are not loaded in variable declarations, this rule will obviously do nothing for you.\n如果你使用了类似 UMD 的模式，其 require 的模块在变量声明时不会被加载，该规则明显对你没什么用。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-mixed-requires",
                "disable": false
            },
            {
                "real_name": "no-mixed-spaces-and-tabs",
                "display_name": "no-mixed-spaces-and-tabs",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用 空格 和 tab 混合缩进 (no-mixed-spaces-and-tabs)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow mixed spaces and tabs for indentation (no-mixed-spaces-and-tabs)\n禁止使用 空格 和 tab 混合缩进 (no-mixed-spaces-and-tabs)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nMost code conventions require either tabs or spaces be used for indentation. As such, it’s usually an error if a single line of code is indented with both tabs and spaces.\n大多数代码约定要求使用空格或 tab 进行缩进。因此，一行代码同时混有 tab 缩进和空格缩进，通常是错误的。\nRule Details\nThis rule disallows mixed spaces and tabs for indentation.\n该规则禁止使用 空格 和 tab 混合缩进。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-mixed-spaces-and-tabs: \"error\"*/\n\nfunction add(x, y) {\n// --->..return x + y;\n\n      return x + y;\n}\n\nfunction main() {\n// --->var x = 5,\n// --->....y = 7;\n\n    var x = 5,\n        y = 7;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-mixed-spaces-and-tabs: \"error\"*/\n\nfunction add(x, y) {\n// --->return x + y;\n    return x + y;\n}\n\n\nOptions\nThis rule has a string option.\n该规则有一个字符串选项。\n\n\"smart-tabs\" allows mixed spaces and tabs when the latter are used for alignment.\n\"smart-tabs\" 当 tab 是为了对齐，允许混合使用空格和 tab。\n\nsmart-tabs\nExamples of correct code for this rule with the \"smart-tabs\" option:\n选项 \"smart-tabs\" 的 正确 代码示例：\n/*eslint no-mixed-spaces-and-tabs: [\"error\", \"smart-tabs\"]*/\n\nfunction main() {\n// --->var x = 5,\n// --->....y = 7;\n\n    var x = 5,\n        y = 7;\n}\n\n\nFurther Reading\n\nSmart Tabs\n\nVersion\nThis rule was introduced in ESLint 0.7.1.\n该规则在 ESLint 0.7.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-mixed-spaces-and-tabs",
                "disable": false
            },
            {
                "real_name": "no-multi-assign",
                "display_name": "no-multi-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow Use of Chained Assignment Expressions (no-multi-assign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Use of Chained Assignment Expressions (no-multi-assign)\nChaining the assignment of variables can lead to unexpected results and be difficult to read.\na = b = c = d;\n\n\nRule Details\nThis rule disallows using multiple assignments within a single statement.\nExamples of incorrect code for this rule:\n/*eslint no-multi-assign: \"error\"*/\n\nvar a = b = c = 5;\n\nvar foo = bar = \"baz\";\n\nvar a =\n    b =\n    c;\n\n\nExamples of correct code for this rule:\n/*eslint no-multi-assign: \"error\"*/\nvar a = 5;\nvar b = 5;\nvar c = 5;\n\nvar foo = \"baz\";\nvar bar = \"baz\";\n\nvar a = c;\nvar b = c;\n\n\nRelated Rules\n\nmax-statements-per-line\n\nVersion\nThis rule was introduced in ESLint 3.14.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-multi-assign",
                "disable": false
            },
            {
                "real_name": "no-multi-spaces",
                "display_name": "no-multi-spaces",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止出现多个空格 (no-multi-spaces)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow multiple spaces (no-multi-spaces)\n禁止出现多个空格 (no-multi-spaces)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nMultiple spaces in a row that are not used for indentation are typically mistakes. For example:\n在某行中，出现多个空格而且不是用来作缩进的，通常是个错误。例如：\n\nif(foo  === \"bar\") {}\n\n\n\nIt’s hard to tell, but there are two spaces between foo and ===. Multiple spaces such as this are generally frowned upon in favor of single spaces:\n很难说，但是在 foo 和 === 之间有两个空格。支持使用单一空格的，是不赞成使用像这样的多个空格的。\n\nif(foo === \"bar\") {}\n\n\n\nRule Details\nThis rule aims to disallow multiple whitespace around logical expressions, conditional expressions, declarations, array elements, object properties, sequences and function parameters.\n此规则目的在于禁止在逻辑表达式、条件表达式、声明、数组元素、对象属性、序列和函数参数周围使用多个空格。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-multi-spaces: \"error\"*/\n\nvar a =  1;\n\nif(foo   === \"bar\") {}\n\na <<  b\n\nvar arr = [1,  2];\n\na ?  b: c\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-multi-spaces: \"error\"*/\n\nvar a = 1;\n\nif(foo === \"bar\") {}\n\na << b\n\nvar arr = [1, 2];\n\na ? b: c\n\n\nOptions\nThis rule’s configuration consists of an object with the following properties:\n该规则的配置是个对象，包含以下属性：\n\n\"ignoreEOLComments\": true (defaults to false) ignores multiple spaces before comments that occur at the end of lines\n\"ignoreEOLComments\": true (默认 false) 忽略行尾注释前的多个空格\n\"exceptions\": { \"Property\": true } (\"Property\" is the only node specified by default) specifies nodes to ignore\n\"exceptions\": { \"Property\": true } (\"Property\" 是为一个默认指定的节点) 指定要忽略的节点\n\nignoreEOLComments\nExamples of incorrect code for this rule with the { \"ignoreEOLComments\": false } (default) option:\n默认选项 { \"ignoreEOLComments\": false } 的 错误 代码示例：\n/*eslint no-multi-spaces: [\"error\", { ignoreEOLComments: false }]*/\n\nvar x = 5;      // comment\nvar x = 5;      /* multiline\n * comment\n */\n\n\nExamples of correct code for this rule with the { \"ignoreEOLComments\": false } (default) option:\n选项 { \"ignoreEOLComments\": false } 的 正确 代码示例：\n/*eslint no-multi-spaces: [\"error\", { ignoreEOLComments: false }]*/\n\nvar x = 5; // comment\nvar x = 5; /* multiline\n * comment\n */\n\n\nExamples of correct code for this rule with the { \"ignoreEOLComments\": true } option:\n选项 { \"ignoreEOLComments\": true } 的 正确 代码示例：\n/*eslint no-multi-spaces: [\"error\", { ignoreEOLComments: true }]*/\n\nvar x = 5; // comment\nvar x = 5;      // comment\nvar x = 5; /* multiline\n * comment\n */\nvar x = 5;      /* multiline\n * comment\n */\n\n\nexceptions\nTo avoid contradictions with other rules that require multiple spaces, this rule has an exceptions option to ignore certain nodes.\n为了避免与其他需要多个空格的规则发生冲突，该规则有一个 exceptions 选项可以忽略特定的节点。\nThis option is an object that expects property names to be AST node types as defined by ESTree. The easiest way to determine the node types for exceptions is to use the online demo.\n该选项是个对象，属性名是 AST 节点类型，这些类型被定义在 ESTree。确定节点类型的最简单的方法是使用 online demo。\nOnly the Property node type is ignored by default, because for the key-spacing rule some alignment options require multiple spaces in properties of object literals.\n默认情况下，只忽略 Property 节点类型，因为 key-spacing 规则的对其选项要求对象中的属性有多个空格。\nExamples of correct code for the default \"exceptions\": { \"Property\": true } option:\n默认选项 \"exceptions\": { \"Property\": true } 的 正确 代码示例：\n/*eslint no-multi-spaces: \"error\"*/\n/*eslint key-spacing: [\"error\", { align: \"value\" }]*/\n\nvar obj = {\n    first:  \"first\",\n    second: \"second\"\n};\n\n\nExamples of incorrect code for the \"exceptions\": { \"Property\": false } option:\n选项 \"exceptions\": { \"Property\": false } 的 错误 代码示例：\n/*eslint no-multi-spaces: [\"error\", { exceptions: { \"Property\": false } }]*/\n/*eslint key-spacing: [\"error\", { align: \"value\" }]*/\n\nvar obj = {\n    first:  \"first\",\n    second: \"second\"\n};\n\n\nExamples of correct code for the \"exceptions\": { \"BinaryExpression\": true } option:\n选项 \"exceptions\": { \"BinaryExpression\": true } 的 正确 代码示例：\n/*eslint no-multi-spaces: [\"error\", { exceptions: { \"BinaryExpression\": true } }]*/\n\nvar a = 1  *  2;\n\n\nExamples of correct code for the \"exceptions\": { \"VariableDeclarator\": true } option:\n选项 \"exceptions\": { \"VariableDeclarator\": true } 的 正确 代码示例：\n/*eslint no-multi-spaces: [\"error\", { exceptions: { \"VariableDeclarator\": true } }]*/\n\nvar someVar      = 'foo';\nvar someOtherVar = 'barBaz';\n\n\nExamples of correct code for the \"exceptions\": { \"ImportDeclaration\": true } option:\n选项 \"exceptions\": { \"ImportDeclaration\": true } 的 正确 代码示例：\n/*eslint no-multi-spaces: [\"error\", { exceptions: { \"ImportDeclaration\": true } }]*/\n\nimport mod          from 'mod';\nimport someOtherMod from 'some-other-mod';\n\n\nWhen Not To Use It\nIf you don’t want to check and disallow multiple spaces, then you should turn this rule off.\n如果你不想检查或禁止出现多个空格，你可以关闭此规则。\nRelated Rules\n\nkey-spacing\nspace-infix-ops\nspace-in-brackets (deprecated)\nspace-in-parens\nspace-after-keywords\nspace-unary-ops\nspace-return-throw-case\n\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-multi-spaces",
                "disable": false
            },
            {
                "real_name": "no-multi-str",
                "display_name": "no-multi-str",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止多行字符串 (no-multi-str)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Multiline Strings (no-multi-str)\n禁止多行字符串 (no-multi-str)\nIt’s possible to create multiline strings in JavaScript by using a slash before a newline, such as:\n在 JavaScript 中，可以在新行之前使用斜线创建多行字符串，例如：\nvar x = \"Line 1 \\\n         Line 2\";\n\n\nSome consider this to be a bad practice as it was an undocumented feature of JavaScript that was only formalized later.\n一些人认为这不是一个好的做法，因为它是 JavaScript 中的一个非正式的特性。\nRule Details\nThis rule is aimed at preventing the use of multiline strings.\n该规则是为了防止多行字符串的使用。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-multi-str: \"error\"*/\nvar x = \"Line 1 \\\n         Line 2\";\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-multi-str: \"error\"*/\n\nvar x = \"Line 1\\n\" +\n        \"Line 2\";\n\n\nFurther Reading\n\nBad escapement of EOL\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-multi-str",
                "disable": false
            },
            {
                "real_name": "no-multiple-empty-lines",
                "display_name": "no-multiple-empty-lines",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许多个空行 (no-multiple-empty-lines)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow multiple empty lines (no-multiple-empty-lines)\n不允许多个空行 (no-multiple-empty-lines)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSome developers prefer to have multiple blank lines removed, while others feel that it helps improve readability. Whitespace is useful for separating logical sections of code, but excess whitespace takes up more of the screen.\n一些开发者喜欢删除多个空行，然而其他人认为多个空行可以提高可读性。空白对于分离代码代码段逻辑是有帮助的，但过量的空白会占用更多的屏幕。\nRule Details\nThis rule aims to reduce the scrolling required when reading through your code. It will warn when the maximum amount of empty lines has been exceeded.\n该规则目的在于，当你读代码时，减少滚动。当超过最大空行数，该规则将发出警告。\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"max\" (default: 2) enforces a maximum number of consecutive empty lines.\n\"max\" (默认为 2) 强制最大连续空行数。\n\"maxEOF\" enforces a maximum number of consecutive empty lines at the end of files.\n\"maxEOF\" 强制文件末尾的最大连续空行数。\n\"maxBOF\" enforces a maximum number of consecutive empty lines at the beginning of files.\n\"maxBOF\" 强制文件开始的最大连续空行数。\n\nmax\nExamples of incorrect code for this rule with the default { \"max\": 2 } option:\n默认选项 { \"max\": 2 } 的 错误 代码示例：\n/*eslint no-multiple-empty-lines: \"error\"*/\n\nvar foo = 5;\n\n\n\nvar bar = 3;\n\n\nExamples of correct code for this rule with the default { \"max\": 2 } option:\n默认选项 { \"max\": 2 } 的 正确 代码示例：\n/*eslint no-multiple-empty-lines: \"error\"*/\n\nvar foo = 5;\n\n\nvar bar = 3;\n\n\nmaxEOF\nExamples of incorrect code for this rule with the { max: 2, maxEOF: 1 } options:\n选项 { max: 2, maxEOF: 1 } 的 错误 代码示例：\n/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxEOF\": 1 }]*/\n\nvar foo = 5;\n\n\nvar bar = 3;\n\n\n\n\nExamples of correct code for this rule with the { max: 2, maxEOF: 1 } options:\n选项 { max: 2, maxEOF: 1 } 的 正确 代码示例：\n/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxEOF\": 1 }]*/\n\nvar foo = 5;\n\n\nvar bar = 3;\n\n\n\nmaxBOF\nExamples of incorrect code for this rule with the { max: 2, maxBOF: 1 } options:\n选项 { max: 2, maxBOF: 1 } 的 错误 代码示例：\n/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxBOF\": 1 }]*/\n\n\nvar foo = 5;\n\n\nvar bar = 3;\n\n\nExamples of correct code for this rule with the { max: 2, maxBOF: 1 } options:\n选项 { max: 2, maxBOF: 1 } 的 正确 代码示例：\n/*eslint no-multiple-empty-lines: [\"error\", { \"max\": 2, \"maxBOF\": 1}]*/\n\nvar foo = 5;\n\n\nvar bar = 3;\n\n\nWhen Not To Use It\nIf you do not care about extra blank lines, turn this off.\n如果你不关心额外的空行，关闭此规则即可。\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-multiple-empty-lines",
                "disable": false
            },
            {
                "real_name": "no-native-reassign",
                "display_name": "no-native-reassign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow Reassignment of Native Objects (no-native-reassign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Reassignment of Native Objects (no-native-reassign)\nThis rule was deprecated in ESLint v3.3.0 and replaced by the no-global-assign rule.\nJavaScript environments contain a number of built-in global variables, such as window in browsers and process in Node.js. In almost all cases, you don’t want to assign a value to these global variables as doing so could result in losing access to important functionality. For example, you probably don’t want to do this in browser code:\nwindow = {};\n\n\nWhile examples such as window are obvious, there are often hundreds of built-in global objects provided by JavaScript environments. It can be hard to know if you’re assigning to a global variable or not.\nRule Details\nThis rule disallows modifications to read-only global variables.\nESLint has the capability to configure global variables as read-only.\n\nSpecifying Environments\nSpecifying Globals\n\nExamples of incorrect code for this rule:\n/*eslint no-native-reassign: \"error\"*/\n\nObject = null\nundefined = 1\n\n\n/*eslint no-native-reassign: \"error\"*/\n/*eslint-env browser*/\n\nwindow = {}\nlength = 1\ntop = 1\n\n\n/*eslint no-native-reassign: \"error\"*/\n/*globals a:false*/\n\na = 1\n\n\nExamples of correct code for this rule:\n/*eslint no-native-reassign: \"error\"*/\n\na = 1\nvar b = 1\nb = 2\n\n\n/*eslint no-native-reassign: \"error\"*/\n/*eslint-env browser*/\n\nonload = function() {}\n\n\n/*eslint no-native-reassign: \"error\"*/\n/*globals a:true*/\n\na = 1\n\n\nOptions\nThis rule accepts an exceptions option, which can be used to specify a list of builtins for which reassignments will be allowed:\n{\n    \"rules\": {\n        \"no-native-reassign\": [\"error\", {\"exceptions\": [\"Object\"]}]\n    }\n}\n\n\nWhen Not To Use It\nIf you are trying to override one of the native objects.\nRelated Rules\n\nno-extend-native\nno-redeclare\nno-shadow\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-native-reassign",
                "disable": false
            },
            {
                "real_name": "no-negated-condition",
                "display_name": "no-negated-condition",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用否定表达式 (no-negated-condition)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow negated conditions (no-negated-condition)\n禁用否定表达式 (no-negated-condition)\nNegated conditions are more difficult to understand. Code can be made more readable by inverting the condition instead.\n否定表达式更难以理解。如果将条件反过来，代码会更具可读性。\nRule Details\nThis rule disallows negated conditions in either of the following:\n该规则禁止在以下情况使用否定表达式：\n\nif statements which have an else branch\n含有  else 分支的 if 语句\nternary expressions\n三元表达式\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-negated-condition: \"error\"*/\n\nif (!a) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\nif (a != b) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\nif (a !== b) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\n!a ? c : b\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-negated-condition: \"error\"*/\n\nif (!a) {\n    doSomething();\n}\n\nif (!a) {\n    doSomething();\n} else if (b) {\n    doSomething();\n}\n\nif (a != b) {\n    doSomething();\n}\n\na ? b : c\n\n\nVersion\nThis rule was introduced in ESLint 1.6.0.\n该规则在 ESLint 1.6.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-negated-condition",
                "disable": false
            },
            {
                "real_name": "no-negated-in-lhs",
                "display_name": "no-negated-in-lhs",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow negating the left operand in in expressions (no-negated-in-lhs).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow negating the left operand in in expressions (no-negated-in-lhs)\nThis rule was deprecated in ESLint v3.3.0 and replaced by the no-unsafe-negation rule.\nRule Details\nJust as developers might type -a + b when they mean -(a + b) for the negative of a sum, they might type !key in object by mistake when they almost certainly mean !(key in object) to test that a key is not in an object.\nRule Details\nThis rule disallows negating the left operand in in expressions.\nExamples of incorrect code for this rule:\n/*eslint no-negated-in-lhs: \"error\"*/\n\nif(!key in object) {\n    // operator precedence makes it equivalent to (!key) in object\n    // and type conversion makes it equivalent to (key ? \"false\" : \"true\") in object\n}\n\n\nExamples of correct code for this rule:\n/*eslint no-negated-in-lhs: \"error\"*/\n\nif(!(key in object)) {\n    // key is not in object\n}\n\nif(('' + !key) in object) {\n    // make operator precedence and type conversion explicit\n    // in a rare situation when that is the intended meaning\n}\n\n\nWhen Not To Use It\nNever.\nVersion\nThis rule was introduced in ESLint 0.1.2.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-negated-in-lhs",
                "disable": false
            },
            {
                "real_name": "no-nested-ternary",
                "display_name": "no-nested-ternary",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用嵌套的三元表达式 (no-nested-ternary)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow nested ternary expressions (no-nested-ternary)\n禁止使用嵌套的三元表达式 (no-nested-ternary)\nNesting ternary expressions can make code more difficult to understand.\n嵌套的三元表达式使代码更加难以理解。\nvar foo = bar ? baz : qux === quxx ? bing : bam;\n\n\nRule Details\nThe no-nested-ternary rule disallows nested ternary expressions.\n该规则禁止使用嵌套的三元表达式。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-nested-ternary: \"error\"*/\n\nvar thing = foo ? bar : baz === qux ? quxx : foobar;\n\nfoo ? baz === qux ? quxx() : foobar() : bar();\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-nested-ternary: \"error\"*/\n\nvar thing = foo ? bar : foobar;\n\nvar thing;\n\nif (foo) {\n  thing = bar;\n} else if (baz === qux) {\n  thing = quxx;\n} else {\n  thing = foobar;\n}\n\n\nRelated Rules\n\nno-ternary\nno-unneeded-ternary\n\nVersion\nThis rule was introduced in ESLint 0.2.0.\n该规则在 ESLint 0.2.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-nested-ternary",
                "disable": false
            },
            {
                "real_name": "no-new",
                "display_name": "no-new",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用new产生副作用 (no-new)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow new For Side Effects (no-new)\n禁止使用new产生副作用 (no-new)\nThe goal of using new with a constructor is typically to create an object of a particular type and store that object in a variable, such as:\n对构造函数使用 new 的目的通常是创建一个特定类型的对象并且将该对象存储在变量中，比如：\nvar person = new Person();\n\n\nIt’s less common to use new and not store the result, such as:\n使用 new 却不存储结果这种情况是不太常见的，比如：\nnew Person();\n\n\nIn this case, the created object is thrown away because its reference isn’t stored anywhere, and in many cases, this means that the constructor should be replaced with a function that doesn’t require new to be used.\n在这个例子中，创建的对象被销毁因为它的引用没有被存储在任何地方，并且在许多场景中，这意味着构造函数应该被一个不需要使用 new 的函数所替代。\nRule Details\nThis rule is aimed at maintaining consistency and convention by disallowing constructor calls using the new keyword that do not assign the resulting object to a variable.\n此规则旨在通过禁止使用 new 关键字调用构造函数但却不将结果赋值给一个变量来保持一致性和约定。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-new: \"error\"*/\n\nnew Thing();\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-new: \"error\"*/\n\nvar thing = new Thing();\n\nThing();\n\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-new",
                "disable": false
            },
            {
                "real_name": "no-new-func",
                "display_name": "no-new-func",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用Function构造函数 (no-new-func)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Function Constructor (no-new-func)\n禁用Function构造函数 (no-new-func)\nIt’s possible to create functions in JavaScript using the Function constructor, such as:\n在 JavaScript 中可以使用 Function 构造函数创建一个函数，例如：\nvar x = new Function(\"a\", \"b\", \"return a + b\");\n\n\nThis is considered by many to be a bad practice due to the difficulty in debugging and reading these types of functions.\n由于调试和阅读这种类型的函数比较困难，许多人认为这并不是一个好的做法，\nRule Details\nThis error is raised to highlight the use of a bad practice. By passing a string to the Function constructor, you are requiring the engine to parse that string much in the way it has to when you call the eval function.\n该规则会高亮标记出不好的实践的使用。把一个字符串传给 Function 构造函数，你需要引擎解析该字符串，这一点同调用 eval 函数一样。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-new-func: \"error\"*/\n\nvar x = new Function(\"a\", \"b\", \"return a + b\");\nvar x = Function(\"a\", \"b\", \"return a + b\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-new-func: \"error\"*/\n\nvar x = function (a, b) {\n    return a + b;\n};\n\n\nWhen Not To Use It\nIn more advanced cases where you really need to use the Function constructor.\n在一些更高级的情况下，你确实需要使用 Function 构造函数。\nFurther Reading\n\nThe Function constructor is eval\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-new-func",
                "disable": false
            },
            {
                "real_name": "no-new-object",
                "display_name": "no-new-object",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow Object constructors (no-new-object).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow Object constructors (no-new-object)\n禁止使用  Object 构造函数 (no-new-object)\nThe Object constructor is used to create new generic objects in JavaScript, such as:\n在 JavaScript 中，Object的构造函数用来创建新的通用对象，例如：\nvar myObject = new Object();\n\n\nHowever, this is no different from using the more concise object literal syntax:\n然而，这与使用更为简洁的字面量没有什么区别：\nvar myObject = {};\n\n\nFor this reason, many prefer to always use the object literal syntax and never use the Object constructor.\n为此，很多人更青睐使用对象字面量而非 Object 的构造函数。\nWhile there are no performance differences between the two approaches, the byte savings and conciseness of the object literal form is what has made it the de facto way of creating new objects.\n虽然这两种方式没有性能上的差别，当对象字面量节省字节、简洁的特点，让它成为事实上的创建新对象的方式。\nRule Details\nThis rule disallows Object constructors.\n该规则禁止使用 Object 构造函数。。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-new-object: \"error\"*/\n\nvar myObject = new Object();\n\nvar myObject = new Object;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-new-object: \"error\"*/\n\nvar myObject = new CustomObject();\n\nvar myObject = {};\n\n\nWhen Not To Use It\nIf you wish to allow the use of the Object constructor, you can safely turn this rule off.\n如果你允许 Object 构造函数的使用，你可以关闭此规则。\nRelated Rules\n\nno-array-constructor\nno-new-wrappers\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-new-object",
                "disable": false
            },
            {
                "real_name": "no-new-require",
                "display_name": "no-new-require",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许 new require (no-new-require)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow new require (no-new-require)\n不允许 new require (no-new-require)\nThe require function is used to include modules that exist in separate files, such as:\nrequire 方法被用来引入不同文件中模块，例如：\nvar appHeader = require('app-header');\n\n\nSome modules return a constructor which can potentially lead to code such as:\n某些模块返回一个构造函数，可能导致代码如：\nvar appHeader = new require('app-header');\n\n\nUnfortunately, this introduces a high potential for confusion since the code author likely meant to write:\n不幸的是，这引入了潜在的混乱，因为作者可能要这样：\nvar appHeader = new (require('app-header'));\n\n\nFor this reason, it is usually best to disallow this particular expression.\n处于这个原因，最好禁止使用这种特殊的表达式。\nRule Details\nThis rule aims to eliminate use of the new require expression.\n此规则旨在消除使用 new require 的表达方式。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-new-require: \"error\"*/\n\nvar appHeader = new require('app-header');\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-new-require: \"error\"*/\n\nvar AppHeader = require('app-header');\nvar appHeader = new AppHeader();\n\n\nWhen Not To Use It\nIf you are using a custom implementation of require and your code will never be used in projects where a standard require (CommonJS, Node.js, AMD) is expected, you can safely turn this rule off.\n如果你使用一个自定义的 require 方法，而且代码永远不会在项目中使用标准 require  (CommonJS、Node.js、AMD)，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.6.0.\n该规则在 ESLint 0.6.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-new-require",
                "disable": false
            },
            {
                "real_name": "no-new-symbol",
                "display_name": "no-new-symbol",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow Symbol Constructor (no-new-symbol)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Symbol Constructor (no-new-symbol)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\nSymbol is not intended to be used with the new operator, but to be called as a function.\nvar foo = new Symbol(\"foo\");\n\n\nThis throws a TypeError exception.\nRule Details\nThis rule is aimed at preventing the accidental calling of Symbol with the new operator.\nExamples\nExamples of incorrect code for this rule:\n/*eslint no-new-symbol: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = new Symbol('foo');\n\n\nExamples of correct code for this rule:\n/*eslint no-new-symbol: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = Symbol('foo');\n\n\n// Ignores shadowed Symbol.\nfunction bar(Symbol) {\n    const baz = new Symbol(\"baz\");\n}\n\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\nFurther Reading\n\nSymbol Objects specification\n\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.1.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-new-symbol",
                "disable": false
            },
            {
                "real_name": "no-new-wrappers",
                "display_name": "no-new-wrappers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止原始包装实例 (no-new-wrappers)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Primitive Wrapper Instances (no-new-wrappers)\n禁止原始包装实例 (no-new-wrappers)\nThere are three primitive types in JavaScript that have wrapper objects: string, number, and boolean. These are represented by the constructors String, Number, and Boolean, respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods. Behind the scenes, an object of the associated wrapper type is created and then destroyed, which is why you can call methods on primitive values, such as:\n在 JavaScript 中有3种原始类型包装对象：字符串，数字和布尔值。它们所代表的构造器分别为 String、Number 和 Boolean。当读取原始类型的值或者为它们提供如方法等类似对象的功能时，原始包装类型将被使用。在幕后，相关包装器类型的一个对象被创建，然后销毁，这就是为什么你可以在原始值上调用方法，例如：\nvar text = \"Hello world\".substring(2);\n\n\nBehind the scenes in this example, a String object is constructed. The substring() method exists on String.prototype and so is accessible to the string instance.\n在本例中幕后，一个 String 对象被创建。substring() 方法存在于 String.prototype中，所以可以访问字符实例。\nIt’s also possible to manually create a new wrapper instance:\n还可以手动创建一个新的包装器实例：\nvar stringObject = new String(\"Hello world\");\nvar numberObject = new Number(33);\nvar booleanObject = new Boolean(false);\n\n\nAlthough possible, there aren’t any good reasons to use these primitive wrappers as constructors. They tend to confuse other developers more than anything else because they seem like they should act as primitives, but they do not. For example:\n虽然这么做是可行的，没有任何好的理由使用这些原始包装器作为构造函数。这会是其它开发者感到困惑，因为它们看起像是原始类型，但实际上不是这样的。例如：\nvar stringObject = new String(\"Hello world\");\nconsole.log(typeof stringObject);       // \"object\"\n\nvar text = \"Hello world\";\nconsole.log(typeof text);               // \"string\"\n\nvar booleanObject = new Boolean(false);\nif (booleanObject) {    // all objects are truthy!\n    console.log(\"This executes\");\n}\n\n\nThe first problem is that primitive wrapper objects are, in fact, objects. That means typeof will return \"object\" instead of \"string\", \"number\", or \"boolean\". The second problem comes with boolean objects. Every object is truthy, that means an instance of Boolean always resolves to true even when its actual value is false.\n第一个问题是原始包装对象实际上是对象。这意味着 typeod 将返回 \"object\" 而不是 \"string\"、\"number\" 或者 \"boolean\"。第二个问题来自布尔型对象。每个对象都是真，这以为着每个 Boolean 的实例都会返回 true，即使它们实际的值是 false。\nFor these reasons, it’s considered a best practice to avoid using primitive wrapper types with new.\n由于这些原因，最佳实践认为使用 new 来避免使用原始包装类型。\nRule Details\nThis rule aims to eliminate the use of String, Number, and Boolean with the new operator. As such, it warns whenever it sees new String, new Number, or new Boolean.\n此规则目的在于消除通过 new 操作符使用 String、Number 和 Boolean 。因此，每当遇到 new String、new Number 或者 new Boolean，该规则都会发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-new-wrappers: \"error\"*/\n\nvar stringObject = new String(\"Hello world\");\nvar numberObject = new Number(33);\nvar booleanObject = new Boolean(false);\n\nvar stringObject = new String;\nvar numberObject = new Number;\nvar booleanObject = new Boolean;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-new-wrappers: \"error\"*/\n\nvar text = String(someValue);\nvar num = Number(someValue);\n\nvar object = new MyString();\n\n\nWhen Not To Use It\nIf you want to allow the use of primitive wrapper objects, then you can safely disable this rule.\n如果你想允许使用原始包装器对象，那么你可以关闭此规则。\nFurther Reading\n\nWrapper objects\n\nRelated Rules\n\nno-array-constructor\nno-new-object\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-new-wrappers",
                "disable": false
            },
            {
                "real_name": "no-obj-calls",
                "display_name": "no-obj-calls",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止将全局对象当作函数进行调用 (no-obj-calls)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow calling global object properties as functions (no-obj-calls)\n禁止将全局对象当作函数进行调用 (no-obj-calls)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nECMAScript provides several global objects that are intended to be used as-is. Some of these objects look as if they could be constructors due their capitalization (such as Math and JSON) but will throw an error if you try to execute them as functions.\nECMAScript 提供了几个全局对象，旨在直接调用。这些对象由于是大写的（比如 Math 和 JSON）看起来像是构造函数，但是如果你尝试像函数一样执行它们，将会抛出错误。\nThe ECMAScript 5 specification makes it clear that both Math and JSON cannot be invoked:\nECMAScript 5 规范明确表示 Math 和 JSON 是不能被调用的：\n\nThe Math object does not have a [[Call]] internal property; it is not possible to invoke the Math object as a function.\n\n\nMath 对象没有 [[Call]] 内部属性，不能像一个函数一样调用 Math 对象\n\nAnd the ECMAScript 2015 specification makes it clear that Reflect cannot be invoked:\nECMAScript 2015 specification 明确表明 Reflect 不能被调用：\n\nThe Reflect object also does not have a [[Call]] internal method; it is not possible to invoke the Reflect object as a function.\n\n\nReflect 对象没有 [[Call]] 内置方法；无法像调用函数一样调用 Reflect 对象。\n\nRule Details\nThis rule disallows calling the Math, JSON and Reflect objects as functions.\n该规则禁止将 Math、JSON 和 Reflect 对象当作函数进行调用。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-obj-calls: \"error\"*/\n\nvar math = Math();\nvar json = JSON();\nvar reflect = Reflect();\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-obj-calls: \"error\"*/\n\nfunction area(r) {\n    return Math.PI * r * r;\n}\nvar object = JSON.parse(\"{}\");\nvar value = Reflect.get({ x: 1, y: 2 }, \"x\");\n\n\nFurther Reading\n\nThe Math Object\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-obj-calls",
                "disable": false
            },
            {
                "real_name": "no-octal",
                "display_name": "no-octal",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用八进制字面量 (no-octal)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow octal literals (no-octal)\n禁用八进制字面量 (no-octal)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nOctal literals are numerals that begin with a leading zero, such as:\n八进制自面量是指那些以 0 开始的数字，比如：\nvar num = 071;      // 57\n\n\nBecause the leading zero which identifies an octal literal has been a source of confusion and error in JavaScript code, ECMAScript 5 deprecates the use of octal numeric literals.\n在 JavaScript 代码中，八进制的前导数字零作为其标示一致是导致混淆和错误的来源，ECMAScript 5 已经弃用了八进制字面量。\nRule Details\nThe rule disallows octal literals.\n该规则禁用八进制字面量。\nIf ESLint parses code in strict mode, the parser (instead of this rule) reports the error.\n如果 ESLint 是在严格模式下解析代码，解析器（而不是该规则）会报告错误。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-octal: \"error\"*/\n\nvar num = 071;\nvar result = 5 + 07;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-octal: \"error\"*/\n\nvar num  = \"071\";\n\n\nCompatibility\n\nJSHint: W115\n\nFurther Reading\n\nOctal literals not allowed in strict mode\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-octal",
                "disable": false
            },
            {
                "real_name": "no-octal-escape",
                "display_name": "no-octal-escape",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在字符串字面量中使用八进制转义序列 (no-octal-escape)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow octal escape sequences in string literals (no-octal-escape)\n禁止在字符串字面量中使用八进制转义序列 (no-octal-escape)\nAs of the ECMAScript 5 specification, octal escape sequences in string literals are deprecated and should not be used. Unicode escape sequences should be used instead.\n自 ECMAScript 规范第5版起，字符串字面量中的八进制转义序列已经被弃用，不应该被使用。应该使用 Unicode 转义序列。\nvar foo = \"Copyright \\251\";\n\n\nRule Details\nThis rule disallows octal escape sequences in string literals.\n该规则禁止在字符串字面量中使用八进制转义序列。\nIf ESLint parses code in strict mode, the parser (instead of this rule) reports the error.\n如果 ESLint 是在严格模式下解析代码，解析器（而不是该规则）会报告错误。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-octal-escape: \"error\"*/\n\nvar foo = \"Copyright \\251\";\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-octal-escape: \"error\"*/\n\nvar foo = \"Copyright \\u00A9\";   // unicode\n\nvar foo = \"Copyright \\xA9\";     // hexadecimal\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-octal-escape",
                "disable": false
            },
            {
                "real_name": "no-param-reassign",
                "display_name": "no-param-reassign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止对函数参数再赋值 (no-param-reassign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Reassignment of Function Parameters (no-param-reassign)\n禁止对函数参数再赋值 (no-param-reassign)\nAssignment to variables declared as function parameters can be misleading and lead to confusing behavior, as modifying function parameters will also mutate the arguments object. Often, assignment to function parameters is unintended and indicative of a mistake or programmer error.\n对函数参数中的变量进行赋值可能会误导读者，导致混乱，也会改变 arguments 对象。通常，对函数参数进行赋值并非有意为之，更多的是程序员的书写错误做成的。\nThis rule can be also configured to fail when function parameters are modified. Side effects on parameters can cause counter-intuitive execution flow and make errors difficult to track down.\n当函数参数被修改时，该规则也可能会失效。由此造成的副作用可能导致不直观的执行流程，使错误难以跟踪。\nRule Details\nThis rule aims to prevent unintended behavior caused by modification or reassignment of function parameters.\n该规则旨在避免出现对函数参数的修改或重新赋值造成的非自主行为。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-param-reassign: \"error\"*/\n\nfunction foo(bar) {\n    bar = 13;\n}\n\nfunction foo(bar) {\n    bar++;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-param-reassign: \"error\"*/\n\nfunction foo(bar) {\n    var baz = bar;\n}\n\n\nOptions\nThis rule takes one option, an object, with a boolean property \"props\" and an array \"ignorePropertyModificationsFor\". \"props\" is false by default. If \"props\" is set to true, this rule warns against the modification of parameter properties unless they’re included in \"ignorePropertyModificationsFor\", which is an empty array by default.\n该规则有一个选项，是个对象，其中有一个 \"props\" 的布尔属性和一个数组属性\"ignorePropertyModificationsFor\"。\"props\" 默认为 false。如果 \"props\" 设置为true，对参数的任何属性的修改，该规则都将发出警告， 除非在 \"ignorePropertyModificationsFor\"（默认为空数组） 有该参数。\nprops\nExamples of correct code for the default { \"props\": false } option:\n默认选项 { \"props\": false }的 正确 代码示例：\n/*eslint no-param-reassign: [\"error\", { \"props\": false }]*/\n\nfunction foo(bar) {\n    bar.prop = \"value\";\n}\n\nfunction foo(bar) {\n    delete bar.aaa;\n}\n\nfunction foo(bar) {\n    bar.aaa++;\n}\n\n\nExamples of incorrect code for the { \"props\": true } option:\n选项 { \"props\": true } 的 错误 代码示例：\n/*eslint no-param-reassign: [\"error\", { \"props\": true }]*/\n\nfunction foo(bar) {\n    bar.prop = \"value\";\n}\n\nfunction foo(bar) {\n    delete bar.aaa;\n}\n\nfunction foo(bar) {\n    bar.aaa++;\n}\n\n\nExamples of correct code for the { \"props\": true } option with \"ignorePropertyModificationsFor\" set:\n选项 { \"props\": true } 并设置了 \"ignorePropertyModificationsFor\" 的 正确 代码示例：\n/*eslint no-param-reassign: [\"error\", { \"props\": true, \"ignorePropertyModificationsFor\": [\"bar\"] }]*/\n\nfunction foo(bar) {\n    bar.prop = \"value\";\n}\n\nfunction foo(bar) {\n    delete bar.aaa;\n}\n\nfunction foo(bar) {\n    bar.aaa++;\n}\n\n\nWhen Not To Use It\nIf you want to allow assignment to function parameters, then you can safely disable this rule.\n如果你想允许对函数参数重新赋值，你可以禁用此规则。\nFurther Reading\n\nJavaScript: Don’t Reassign Your Function Arguments\n\nVersion\nThis rule was introduced in ESLint 0.18.0.\n该规则在 ESLint 0.18.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-param-reassign",
                "disable": false
            },
            {
                "real_name": "no-path-concat",
                "display_name": "no-path-concat",
                "severity": "error",
                "category": "correctness",
                "rule_title": "当使用 _dirname 和 _filename 时不允许字符串拼接 (no-path-concat).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow string concatenation when using __dirname and __filename (no-path-concat)\n当使用 _dirname 和 _filename 时不允许字符串拼接 (no-path-concat)\nIn Node.js, the __dirname and __filename global variables contain the directory path and the file path of the currently executing script file, respectively. Sometimes, developers try to use these variables to create paths to other files, such as:\n在 Node.js 中，全局变量 _dirname 和 _filename 分别代表当前执行脚本的目录路径以及文件路径。有时候开发者尝试使用这些变量去创建路径或者其他的文件，比如:\nvar fullPath = __dirname + \"/foo.js\";\n\n\nHowever, there are a few problems with this. First, you can’t be sure what type of system the script is running on. Node.js can be run on any computer, including Windows, which uses a different path separator. It’s very easy, therefore, to create an invalid path using string concatenation and assuming Unix-style separators. There’s also the possibility of having double separators, or otherwise ending up with an invalid path.\n但是，这样做存在一些问题。首先，不能确定脚本在哪种系统中运行。Node.js 可以在任何电脑，包括windows，它使用不同路径分隔符。这是很容易的事情，然而很可能会使用 Unix 路径分隔符拼接处的路径会创建出一个无效的路径。也有可能有两种分隔符或者拼接出其他无效的路径。\nIn order to avoid any confusion as to how to create the correct path, Node.js provides the path module. This module uses system-specific information to always return the correct value. So you can rewrite the previous example as:\n为了避免混淆并且创建正确的路径，Node.js 提供了 path模块。这个模块使用特殊的系统信息来返回正确的值。可以修改下面的例子，例如:\nvar fullPath = path.join(__dirname, \"foo.js\");\n\n\nThis example doesn’t need to include separators as path.join() will do it in the most appropriate manner. Alternately, you can use path.resolve() to retrieve the fully-qualified path:\n这个例子不需要引入分隔符因为 path.join() 将会用最合适的方式引入分隔符。或者，你可以使用 path.resolve() 得到有效的完整路径。\nvar fullPath = path.resolve(__dirname, \"foo.js\");\n\n\nBoth path.join() and path.resolve() are suitable replacements for string concatenation wherever file or directory paths are being created.\npath.jonin() 和 path.reslove() 非常适合替换字符串拼接来创建文件和目录路径。\nRule Details\nThis rule aims to prevent string concatenation of directory paths in Node.js\n该规则旨在阻止在 Node.js 中使用字符串拼接路径。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-path-concat: \"error\"*/\n\nvar fullPath = __dirname + \"/foo.js\";\n\nvar fullPath = __filename + \"/foo.js\";\n\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-path-concat: \"error\"*/\n\nvar fullPath = dirname + \"/foo.js\";\n\n\nWhen Not To Use It\nIf you want to allow string concatenation of path names.\n当你想允许字符串拼接路径时，可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-path-concat",
                "disable": false
            },
            {
                "real_name": "no-plusplus",
                "display_name": "no-plusplus",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow the unary operators ++ and -- (no-plusplus)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow the unary operators ++ and -- (no-plusplus)\n禁止使用一元操作符 ++ 和 -- (no-plusplus)\nBecause the unary ++ and -- operators are subject to automatic semicolon insertion, differences in whitespace can change semantics of source code.\n因为一元操作符 ++ 和 -- 会自动添加分号，不同的空白可能会改变源代码的语义。\nvar i = 10;\nvar j = 20;\n\ni ++\nj\n// i = 11, j = 20\n\n\nvar i = 10;\nvar j = 20;\n\ni\n++\nj\n// i = 10, j = 21\n\n\nRule Details\nThis rule disallows the unary operators ++ and --.\n该规则禁止使用一元操作符 ++ 和 --。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-plusplus: \"error\"*/\n\nvar foo = 0;\nfoo++;\n\nvar bar = 42;\nbar--;\n\nfor (i = 0; i < l; i++) {\n    return;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-plusplus: \"error\"*/\n\nvar foo = 0;\nfoo += 1;\n\nvar bar = 42;\nbar -= 1;\n\nfor (i = 0; i < l; i += 1) {\n    return;\n}\n\n\nOptions\nThis rule has an object option.\n该规则有一个对象选项。\n\n\"allowForLoopAfterthoughts\": true allows unary operators ++ and -- in the afterthought (final expression) of a for loop.\n\"allowForLoopAfterthoughts\": true 允许在 for 循环的最后一个表达式中使用 ++ 和 -- 。\n\nallowForLoopAfterthoughts\nExamples of correct code for this rule with the { \"allowForLoopAfterthoughts\": true } option:\n选项 { \"allowForLoopAfterthoughts\": true } 的 正确 代码示例：\n/*eslint no-plusplus: [\"error\", { \"allowForLoopAfterthoughts\": true }]*/\n\nfor (i = 0; i < l; i++) {\n    return;\n}\n\nfor (i = 0; i < l; i--) {\n    return;\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-plusplus",
                "disable": false
            },
            {
                "real_name": "no-process-env",
                "display_name": "no-process-env",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 process.env (no-process-env)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow process.env (no-process-env)\n禁用 process.env (no-process-env)\nThe process.env object in Node.js is used to store deployment/configuration parameters. Littering it through out a project could lead to maintenance issues as it’s another kind of global dependency. As such, it could lead to merge conflicts in a multi-user setup and deployment issues in a multi-server setup. Instead, one of the best practices is to define all those parameters in a single configuration/settings file which could be accessed throughout the project.\nNode.js 中的 process.env 对象用于存储部署或配置参数。在项目中随意使用它会作为另一个全局依赖会导致维护问题。因此，它可能会在一个多用户的设置中导致合并冲突和导致一个多服务器设置中的部署问题。相反，最好的做法是定义所有这些参数在一个配置/设置文件，这个文件可以在整个项目中访问。\nRule Details\nThis rule is aimed at discouraging use of process.env to avoid global dependencies. As such, it will warn whenever process.env is used.\n此规则旨在阻止 process.env 的使用而避免全局依赖关系。因此，每当 process.env被使用时会给出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-process-env: \"error\"*/\n\nif(process.env.NODE_ENV === \"development\") {\n    //...\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-process-env: \"error\"*/\n\nvar config = require(\"./config\");\n\nif(config.env === \"development\") {\n    //...\n}\n\n\nWhen Not To Use It\nIf prefer to use process.env throughout your project to retrieve values from environment variables, then you can safely disable this rule.\n如果你更愿意在整个项目中使用 process.env 从环境变量中检索值，你可以安全地禁用此规则。\nFurther Reading\n\nHow to store Node.js deployment settings/configuration files? - Stack Overflow\nStoring Node.js application config data - Ben Hall’s blog\n\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-process-env",
                "disable": false
            },
            {
                "real_name": "no-process-exit",
                "display_name": "no-process-exit",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 process.exit() (no-process-exit)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow process.exit() (no-process-exit)\n禁用 process.exit() (no-process-exit)\nThe process.exit() method in Node.js is used to immediately stop the Node.js process and exit. This is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. For example:\nprocess.exit() 方法在 Node.js 中被用于立即终止 Node.js 进程且退出。这是非常危险的操作，因为他能在任何方法任何时候出现，当发生错误时可能完全停止 Node.js 应用。如：\nif (somethingBadHappened) {\n    console.error(\"Something bad happened!\");\n    process.exit(1);\n}\n\n\nThis code could appear in any module and will stop the entire application when somethingBadHappened is truthy. This doesn’t give the application any chance to respond to the error. It’s usually better to throw an error and allow the application to handle it appropriately:\n这段代码能出现在任何模块中，当 somethingBadHappened 为 true 时，将停止整个应用。不给应用任何相应错误的机会。通常较好地做法是抛出一个错误，允许应用妥善处理这个错误。\nif (somethingBadHappened) {\n    throw new Error(\"Something bad happened!\");\n}\n\n\nBy throwing an error in this way, other parts of the application have an opportunity to handle the error rather than stopping the application altogether. If the error bubbles all the way up to the process without being handled, then the process will exit and a non-zero exit code will returned, so the end result is the same.\n以这种方式抛出错误，应用程序的其他部分有机会处理错误，而不是全部终止程序。如果这个错误向上回退到进程顶部而未被处理，进程将退出并返回异常退出的错误码，所以最终的结果是一样的。\nRule Details\nThis rule aims to prevent the use of process.exit() in Node.js JavaScript. As such, it warns whenever process.exit() is found in code.\n此规则旨在阻止在 Node.js 中使用 process.exit()。当在代码中发现 process.exit()，该规则会发出警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-process-exit: \"error\"*/\n\nprocess.exit(1);\nprocess.exit(0);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-process-exit: \"error\"*/\n\nProcess.exit();\nvar exit = process.exit;\n\n\nWhen Not To Use It\nThere may be a part of a Node.js application that is responsible for determining the correct exit code to return upon exiting. In that case, you should turn this rule off to allow proper handling of the exit code.\nNode.js 应用中可以能有一部分是负责正确的退出码返回退出。在这种情况下，你应该关闭规则来允许适当处理退出码。\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-process-exit",
                "disable": false
            },
            {
                "real_name": "no-proto",
                "display_name": "no-proto",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow Use of __proto__ (no-proto).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Use of __proto__ (no-proto)\n禁用__proto__（no-proto）\n__proto__ property has been deprecated as of ECMAScript 3.1 and shouldn’t be used in the code. Use getPrototypeOf method instead.\n__proto__ 属性在 ECMAScript 3.1 中已经被弃用，并且不应该在代码中使用。使用 getPrototypeOf 方法替代 __proto__。\nRule Details\nWhen an object is created __proto__ is set to the original prototype property of the object’s constructor function. getPrototypeOf is the preferred method of getting “the prototype”.\n当一个对象被创建，__proto__ 被设置为对象构造方法的原始原型属性。getPrototypeOf是获取原型的首选方法。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-proto: \"error\"*/\n\nvar a = obj.__proto__;\n\nvar a = obj[\"__proto__\"];\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-proto: \"error\"*/\n\nvar a = Object.getPrototypeOf(obj);\n\n\nWhen Not To Use It\nIf you need to support legacy browsers, you might want to turn this rule off, since support for getPrototypeOf is not yet universal.\n如果你需要支持老版本的浏览器，你可能会想要关闭此规则，因为 getPrototypeOf 还没有被广泛支持。\nFurther Reading\n\nObject.getPrototypeOf\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-proto",
                "disable": false
            },
            {
                "real_name": "no-prototype-builtins",
                "display_name": "no-prototype-builtins",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止直接使用 Object.prototypes 的内置属性 (no-prototype-builtins)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow use of Object.prototypes builtins directly (no-prototype-builtins)\n禁止直接使用 Object.prototypes 的内置属性 (no-prototype-builtins)\nIn ECMAScript 5.1, Object.create was added, which enables the creation of objects with a specified [[Prototype]]. Object.create(null) is a common pattern used to create objects that will be used as a Map. This can lead to errors when it is assumed that objects will have properties from Object.prototype. This rule prevents calling Object.prototype methods directly from an object.\nECMAScript 5.1 新增了 Object.create，可以通过它创建带有指定的 [[Prototype]] 的对象。Object.create(null) 是的一种常见模式，用来创建键值对对象。当创建的对象有从 Object.prototype 继承来的属性时，可能会导致错误出现。该规则防止在一个对象中直接调用 Object.prototype 的方法。\nRule Details\nThis rule disallows calling some Object.prototype methods directly on object instances.\n该规则禁止直接在对象实例上调用 Object.prototype 的一些方法。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-prototype-builtins: \"error\"*/\n\nvar hasBarProperty = foo.hasOwnProperty(\"bar\");\n\nvar isPrototypeOfBar = foo.isPrototypeOf(bar);\n\nvar barIsEnumerable = foo.propertyIsEnumerable(\"bar\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-prototype-builtins: \"error\"*/\n\nvar hasBarProperty = Object.prototype.hasOwnProperty.call(foo, \"bar\");\n\nvar isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);\n\nvar barIsEnumerable = {}.propertyIsEnumerable.call(foo, \"bar\");\n\n\nWhen Not To Use It\nYou may want to turn this rule off if you will never use an object that shadows an Object.prototype method or which does not inherit from Object.prototype.\n如果你从不使用覆盖了 Object.prototype 方法的对象或不是从 Object.prototype 继承来的方法，你可能想关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.11.0.\n该规则在 ESLint 2.11.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-prototype-builtins",
                "disable": false
            },
            {
                "real_name": "no-redeclare",
                "display_name": "no-redeclare",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止重新声明变量 (no-redeclare)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow variable redeclaration (no-redeclare)\n禁止重新声明变量 (no-redeclare)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIn JavaScript, it’s possible to redeclare the same variable name using var. This can lead to confusion as to where the variable is actually declared and initialized.\n在 JavaScript 中，使用 var 可以对同一个变量再次声明。这会使变量实际声明和定义的位置混乱不堪。\nRule Details\nThis rule is aimed at eliminating variables that have multiple declarations in the same scope.\n此规则目旨在消除同一作用域中多次声明同一变量。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-redeclare: \"error\"*/\n\nvar a = 3;\nvar a = 10;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-redeclare: \"error\"*/\n\nvar a = 3;\n// ...\na = 10;\n\n\nOptions\nThis rule takes one optional argument, an object with a boolean property \"builtinGlobals\". It defaults to false.\n该规则有一个选项参数，是个对象，该对象有个布尔属性为\"builtinGlobals\"。默认为false。\nIf set to true, this rule also checks redeclaration of built-in globals, such as Object, Array, Number…\n如果设置为 true，该规则也会检查全局内建对象，比如Object、Array、Number…\nbuiltinGlobals\nExamples of incorrect code for the { \"builtinGlobals\": true } option:\n选项 { \"builtinGlobals\": true } 的 错误 代码示例：\n/*eslint no-redeclare: [\"error\", { \"builtinGlobals\": true }]*/\n\nvar Object = 0;\n\n\nExamples of incorrect code for the { \"builtinGlobals\": true } option and the browser environment:\n在 browser 环境下，选项 {\"builtinGlobals\": true} 的 错误 代码示例：\n/*eslint no-redeclare: [\"error\", { \"builtinGlobals\": true }]*/\n/*eslint-env browser*/\n\nvar top = 0;\n\n\nThe browser environment has many built-in global variables (for example, top). Some of built-in global variables cannot be redeclared.\nbrowser 环境有很多内建的全局变量（例如，top）。一些内建的全局变量不能被重新声明。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-redeclare",
                "disable": false
            },
            {
                "real_name": "no-regex-spaces",
                "display_name": "no-regex-spaces",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止正则表达式字面量中出现多个空格 (no-regex-spaces)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow multiple spaces in regular expression literals (no-regex-spaces)\n禁止正则表达式字面量中出现多个空格 (no-regex-spaces)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nRegular expressions can be very complex and difficult to understand, which is why it’s important to keep them as simple as possible in order to avoid mistakes. One of the more error-prone things you can do with a regular expression is to use more than one space, such as:\n正则表达式可以很复杂和难以理解，这就是为什么要保持它们尽可能的简单，以避免出现错误。你在使用正则表达式时最容易出错的是使用了多个空格，例如：\nvar re = /foo   bar/;\n\n\nIn this regular expression, it’s very hard to tell how many spaces are intended to be matched. It’s better to use only one space and then specify how many spaces are expected, such as:\n在这个正则表达式中，很难断定想要匹配多少个空格。最好是只使用一个空格，然后指定需要多少个，例如：\nvar re = /foo {3}bar/;\n\n\nNow it is very clear that three spaces are expected to be matched.\n现在非常清楚地知道需要匹配 3 个空格。\nRule Details\nThis rule disallows multiple spaces in regular expression literals.\n该规则禁止在正则表达式字面量中出现多个空格。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-regex-spaces: \"error\"*/\n\nvar re = /foo   bar/;\nvar re = new RegExp(\"foo   bar\");\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-regex-spaces: \"error\"*/\n\nvar re = /foo {3}bar/;\nvar re = new RegExp(\"foo {3}bar\");\n\n\nWhen Not To Use It\nIf you want to allow multiple spaces in a regular expression, then you can safely turn this rule off.\n如果你允许多个空格出现在正则表达式中，你可以关闭此规则。\nFurther Reading\n\nSpaces are hard to count\n\nRelated Rules\n\nno-div-regex\nno-control-regex\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-regex-spaces",
                "disable": false
            },
            {
                "real_name": "no-restricted-globals",
                "display_name": "no-restricted-globals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用特定的全局变量 (no-restricted-globals)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow specific global variables (no-restricted-globals)\n禁用特定的全局变量 (no-restricted-globals)\nDisallowing usage of specific global variables can be useful if you want to allow a set of global\nvariables by enabling an environment, but still want to disallow some of those.\n如果你通过启用一个环境想允许使用一组全局变量，但想禁用其中的一部分，那么该规则会很有用。\nFor instance, early Internet Explorer versions exposed the current DOM event as a global variable\nevent, but using this variable has been considered as a bad practice for a long time. Restricting\nthis will make sure this variable isn’t used in browser code.\n例如，早期的 IE 版本暴露了当前 DOM 事件 event 作为一个全局变量，但是使用这个变量长时间内被认为不是一个好的实践。限制它的使用需要确保这个变量没有被用在浏览器端的代码中。\nRule Details\nThis rule allows you to specify global variable names that you don’t want to use in your application.\n该规则允许你指定你不想在你的应用中使用的全局变量的名称。\nOptions\nThis rule takes a list of strings which are the global variable names.\n该规则使用全局变量名的字符串列表作为选项。\nExamples of incorrect code for sample \"event\", \"fdescribe\" global variable names:\n全局变量 \"event\", \"fdescribe\" 的 错误 代码示例：\n/*global event, fdescribe*/\n/*eslint no-restricted-globals: [\"error\", \"event\", \"fdescribe\"]*/\n\nfunction onClick() {\n    console.log(event);\n}\n\nfdescribe(\"foo\", function() {\n});\n\n\nExamples of correct code for a sample \"event\" global variable name:\n全局变量 \"event\" 的 正确 代码示例：\n/*global event*/\n/*eslint no-restricted-globals: [\"error\", \"event\"]*/\n\nimport event from \"event-module\";\n\n\n/*global event*/\n/*eslint no-restricted-globals: [\"error\", \"event\"]*/\n\nvar event = 1;\n\n\nRelated Rules\n\nno-restricted-properties\nno-restricted-syntax\n\nVersion\nThis rule was introduced in ESLint 2.3.0.\n该规则在 ESLint 2.3.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-restricted-globals",
                "disable": false
            },
            {
                "real_name": "no-restricted-imports",
                "display_name": "no-restricted-imports",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow specific imports (no-restricted-imports)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow specific imports (no-restricted-imports)\nImports are an ES6/ES2015 standard for making the functionality of other modules available in your current module. In CommonJS this is implemented through the require() call which makes this ESLint rule roughly equivalent to its CommonJS counterpart no-restricted-modules.\nWhy would you want to restrict imports?\n\n\nSome imports might not make sense in a particular environment. For example, Node.js’ fs module would not make sense in an environment that didn’t have a file system.\n\n\nSome modules provide similar or identical functionality, think lodash and underscore. Your project may have standardized on a module. You want to make sure that the other alternatives are not being used as this would unnecessarily bloat the project and provide a higher maintenance cost of two dependencies when one would suffice.\n\n\nRule Details\nThis rule allows you to specify imports that you don’t want to use in your application.\nOptions\nThe syntax to specify restricted imports looks like this:\n\"no-restricted-imports\": [\"error\", \"import1\", \"import2\"]\n\n\nor like this:\n\"no-restricted-imports\": [\"error\", { \"paths\": [\"import1\", \"import2\"] }]\n\n\nWhen using the object form, you can also specify an array of gitignore-style patterns:\n\"no-restricted-imports\": [\"error\", {\n    \"paths\": [\"import1\", \"import2\"],\n    \"patterns\": [\"import1/private/*\", \"import2/*\", \"!import2/good\"]\n}]\n\n\nTo restrict the use of all Node.js core imports (via https://github.com/nodejs/node/tree/master/lib):\n    \"no-restricted-imports\": [\"error\",\n         \"assert\",\"buffer\",\"child_process\",\"cluster\",\"crypto\",\"dgram\",\"dns\",\"domain\",\"events\",\"freelist\",\"fs\",\"http\",\"https\",\"module\",\"net\",\"os\",\"path\",\"punycode\",\"querystring\",\"readline\",\"repl\",\"smalloc\",\"stream\",\"string_decoder\",\"sys\",\"timers\",\"tls\",\"tracing\",\"tty\",\"url\",\"util\",\"vm\",\"zlib\"\n    ],\n\n\nExamples\nExamples of incorrect code for this rule:\n/*eslint no-restricted-imports: [\"error\", \"fs\"]*/\n\nimport fs from 'fs';\n\n\n/*eslint no-restricted-imports: [\"error\", { \"paths\": [\"cluster\"] }]*/\n\nimport cluster from 'cluster';\n\n\n/*eslint no-restricted-imports: [\"error\", { \"patterns\": [\"lodash/*\"] }]*/\n\nimport pick from 'lodash/pick';\n\n\nExamples of correct code for this rule:\n/*eslint no-restricted-imports: [\"error\", \"fs\"]*/\n\nimport crypto from 'crypto';\n\n\n/*eslint no-restricted-imports: [\"error\", { \"paths\": [\"fs\"], \"patterns\": [\"eslint/*\"] }]*/\n\nimport crypto from 'crypto';\nimport eslint from 'eslint';\n\n\nWhen Not To Use It\nDon’t use this rule or don’t include a module in the list for this rule if you want to be able to import a module in your project without an ESLint error or warning.\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-1.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-restricted-imports",
                "disable": false
            },
            {
                "real_name": "no-restricted-modules",
                "display_name": "no-restricted-modules",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 Node.js 模块 (no-restricted-modules)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Node.js modules (no-restricted-modules)\n禁用 Node.js 模块 (no-restricted-modules)\nDisallowing usage of specific Node.js modules can be useful if you want to control the available methods, a developer can use, to implement a feature.\n如果你想控制可用的方法，限制开发者的使用范围，或者实现一个特性，可以通过禁用指定的 Node.js 模块来实现。\nThis way you can block usage of the fs module if you want to disallow file system access.\nBlocking the os module can be useful if you don’t want to allow any operating system specific code.\n如果你想禁止访问文件系统，可以禁用 fs 模块的使用。\n如果你想禁止一些特殊的系统操作，禁用 os 模块将会起作用。\nRule Details\nThis rule allows you to specify modules that you don’t want to use in your application.\n这条规则允许你可以在程序中指定你不想使用的模块。\nOptions\nThe rule takes one or more strings as options: the names of restricted modules.\n该规则可以用一个或多个字符串作为选项：限制的模块的名称。\nIt can also take an object with lists of “paths” and gitignore-style “patterns” strings.\n也可以使用一个包含路径列表或 gitignore 风格模式的字符串的列表的对象。\nFor example, to restrict the use of all Node.js core modules (via https://github.com/nodejs/node/tree/master/lib):\n例如，限制使用 Node.js 所有核心模块 (查看):\n{\n    \"no-restricted-modules\": [\"error\",\n        \"assert\",\"buffer\",\"child_process\",\"cluster\",\"crypto\",\"dgram\",\"dns\",\"domain\",\"events\",\"freelist\",\"fs\",\"http\",\"https\",\"module\",\"net\",\"os\",\"path\",\"punycode\",\"querystring\",\"readline\",\"repl\",\"smalloc\",\"stream\",\"string_decoder\",\"sys\",\"timers\",\"tls\",\"tracing\",\"tty\",\"url\",\"util\",\"vm\",\"zlib\"\n    ]\n}\n\n\nExamples of incorrect code for this rule with sample \"fs\", \"cluster\" restricted modules:\n限制 \"fs\", \"cluster\" 模块的 错误 代码示例：\n/*eslint no-restricted-modules: [\"error\", \"fs\", \"cluster\"]*/\n\nvar fs = require('fs');\nvar cluster = require('cluster');\n\n\n/*eslint no-restricted-modules: [\"error\", { \"paths\": [\"cluster\"] }]*/\n\nvar cluster = require('cluster');\n\n\n/*eslint no-restricted-modules: [\"error\", { \"patterns\": [\"lodash/*\"] }]*/\n\nvar cluster = require('lodash/pick');\n\n\nExamples of correct code for this rule with sample \"fs\", \"cluster\" restricted modules:\n限制 \"fs\", \"cluster\" 模块的 正确 代码示例：\n/*eslint no-restricted-modules: [\"error\", \"fs\", \"cluster\"]*/\n\nvar crypto = require('crypto');\n\n\n/*eslint no-restricted-modules: [\"error\", {\n    \"paths\": [\"fs\", \"cluster\"],\n    \"patterns\": [\"lodash/*\", \"!lodash/pick\"]\n}]*/\n\nvar crypto = require('crypto');\nvar eslint = require('lodash/pick');\n\n\nVersion\nThis rule was introduced in ESLint 0.6.0.\n该规则在 ESlint 0.6.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-restricted-modules",
                "disable": false
            },
            {
                "real_name": "no-restricted-properties",
                "display_name": "no-restricted-properties",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow certain object properties (no-restricted-properties)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow certain object properties (no-restricted-properties)\nCertain properties on objects may be disallowed in a codebase. This is useful for deprecating an API or restricting usage of a module’s methods. For example, you may want to disallow using describe.only when using Mocha or telling people to use Object.assign instead of _.extend.\nRule Details\nThis rule looks for accessing a given property key on a given object name, either when reading the property’s value or invoking it as a function. You may specify an optional message to indicate an alternative API or a reason for the restriction.\nOptions\nThis rule takes a list of objects, where the object name and property names are specified:\n{\n    \"rules\": {\n        \"no-restricted-properties\": [2, {\n            \"object\": \"disallowedObjectName\",\n            \"property\": \"disallowedPropertyName\"\n        }]\n    }\n}\n\n\nMultiple object/property values can be disallowed, and you can specify an optional message:\n{\n    \"rules\": {\n        \"no-restricted-properties\": [2, {\n            \"object\": \"disallowedObjectName\",\n            \"property\": \"disallowedPropertyName\"\n        }, {\n            \"object\": \"disallowedObjectName\",\n            \"property\": \"anotherDisallowedPropertyName\",\n            \"message\": \"Please use allowedObjectName.allowedPropertyName.\"\n        }]\n    }\n}\n\n\nIf the object name is omitted, the property is disallowed for all objects:\n{\n    \"rules\": {\n        \"no-restricted-properties\": [2, {\n            \"property\": \"__defineGetter__\",\n            \"message\": \"Please use Object.defineProperty instead.\"\n        }]\n    }\n}\n\n\nIf the property name is omitted, accessing any property of the given object is disallowed:\n{\n    \"rules\": {\n        \"no-restricted-properties\": [2, {\n            \"object\": \"require\",\n            \"message\": \"Please call require() directly.\"\n        }]\n    }\n}\n\n\nExamples of incorrect code for this rule:\n/* eslint no-restricted-properties: [2, {\n    \"object\": \"disallowedObjectName\",\n    \"property\": \"disallowedPropertyName\"\n}] */\n\nvar example = disallowedObjectName.disallowedPropertyName; /*error Disallowed object property: disallowedObjectName.disallowedPropertyName.*/\n\ndisallowedObjectName.disallowedPropertyName(); /*error Disallowed object property: disallowedObjectName.disallowedPropertyName.*/\n\n\n/* eslint no-restricted-properties: [2, {\n    \"property\": \"__defineGetter__\"\n}] */\n\nfoo.__defineGetter__(bar, baz);\n\n\n/* eslint no-restricted-properties: [2, {\n    \"object\": \"require\"\n}] */\n\nrequire.resolve('foo');\n\n\nExamples of correct code for this rule:\n/* eslint no-restricted-properties: [2, {\n    \"object\": \"disallowedObjectName\",\n    \"property\": \"disallowedPropertyName\"\n}] */\n\nvar example = disallowedObjectName.somePropertyName;\n\nallowedObjectName.disallowedPropertyName();\n\n\n/* eslint no-restricted-properties: [2, {\n    \"object\": \"require\"\n}] */\n\nrequire('foo');\n\n\nWhen Not To Use It\nIf you don’t have any object/property combinations to restrict, you should not use this rule.\nRelated Rules\n\nno-restricted-globals\nno-restricted-syntax\n\nVersion\nThis rule was introduced in ESLint 3.5.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-restricted-properties",
                "disable": false
            },
            {
                "real_name": "no-restricted-syntax",
                "display_name": "no-restricted-syntax",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用特定的语法 (no-restricted-syntax)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow specified syntax (no-restricted-syntax)\n禁止使用特定的语法 (no-restricted-syntax)\nJavaScript has a lot of language features, and not everyone likes all of them. As a result, some projects choose to disallow the use of certain language features altogether. For instance, you might decide to disallow the use of try-catch or class, or you might decide to disallow the use of the in operator.\nJavaScript 有很多语言特征，并不是每个人都喜欢所有的特征。因此，一些项目选择完全禁用某些特定的语言特征。例如，你可以禁止 try-catch 或 class 的使用，或者你可以决定是否禁用 in 操作符。\nYou can also specify AST selectors to restrict, allowing much more precise control over syntax patterns.\n你也可以指定AST 选择器来进行限制，允许对语法模式进行更精确的控制。\nRule Details\nThis rule disallows specified (that is, user-defined) syntax.\n该规则禁止使用特定的（由用户来指定）语法。\nOptions\nThis rule takes a list of strings, where each string is an AST selector:\n该规则有一个选项，是个字符串列表，列表中的每个字符串都是一个 AST 选择器。\n{\n    \"rules\": {\n        \"no-restricted-syntax\": [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"]\n    }\n}\n\n\nAlternatively, the rule also accepts objects, where the selector and an optional custom message are specified:\n另外，该规则还接受对象作为选项，指定选择器和可选的自定义消息：\n{\n    \"rules\": {\n        \"no-restricted-syntax\": [\n            \"error\",\n            {\n                \"selector\": \"FunctionExpression\",\n                \"message\": \"Function expressions are not allowed.\"\n            },\n            {\n                \"selector\": \"CallExpression[callee.name='setTimeout'][arguments.length!=2]\",\n                \"message\": \"setTimeout must always be invoked with two arguments.\"\n            }\n        ]\n    }\n}\n\n\nIf a custom message is specified with the message property, ESLint will use that message when reporting occurrences of the syntax specified in the selector property.\n如果使用 message 属性指定了一个自定义消息，ESLint 在报告 selector 属性中指定的语法时将使用该消息。\nThe string and object formats can be freely mixed in the configuration as needed.\n字符串选项和对象格式的选项可以自由的根据需要混合使用。\nExamples of incorrect code for this rule with the \"FunctionExpression\", \"WithStatement\", BinaryExpression[operator='in'] options:\n选项 \"FunctionExpression\", \"WithStatement\", BinaryExpression[operator='in'] 的 错误 代码示例：\n/* eslint no-restricted-syntax: [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"] */\n\nwith (me) {\n    dontMess();\n}\n\nvar doSomething = function () {};\n\nfoo in bar;\n\n\nExamples of correct code for this rule with the \"FunctionExpression\", \"WithStatement\", BinaryExpression[operator='in'] options:\n选项 \"FunctionExpression\", \"WithStatement\" 的 正确 代码示例：\n/* eslint no-restricted-syntax: [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"] */\n\nme.dontMess();\n\nfunction doSomething() {};\n\nfoo instanceof bar;\n\n\nWhen Not To Use It\nIf you don’t want to restrict your code from using any JavaScript features or syntax, you should not use this rule.\n如果你不想限制你的代码使用 JavaScript 任何的特征或语法，不应使用此规则。\nRelated Rules\n\nno-alert\nno-console\nno-debugger\nno-restricted-properties\n\nVersion\nThis rule was introduced in ESLint 1.4.0.\n该规则在 ESLint 1.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-restricted-syntax",
                "disable": false
            },
            {
                "real_name": "no-return-assign",
                "display_name": "no-return-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在返回语句中赋值 (no-return-assign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Assignment in return Statement (no-return-assign)\n禁止在返回语句中赋值 (no-return-assign)\nOne of the interesting, and sometimes confusing, aspects of JavaScript is that assignment can happen at almost any point. Because of this, an errant equals sign can end up causing assignment when the true intent was to do a comparison. This is especially true when using a return statement. For example:\n在 JavaScript 中一个有趣有时有令人感到困惑的是几乎可以在任何位置进行赋值操作。正因为如此，本想进行比较操作，结果由于手误，变成了赋值操作。这种情况常见于 return 语句。例如：\nfunction doSomething() {\n    return foo = bar + 2;\n}\n\n\nIt is difficult to tell the intent of the return statement here. It’s possible that the function is meant to return the result of bar + 2, but then why is it assigning to foo? It’s also possible that the intent was to use a comparison operator such as == and that this code is an error.\n在这个例子中，很难断定 return 语句的意图。很有可能这个函数是为了返回 bar + 2，但是如果是这样的话，为什么赋值给 foo 呢？也很有可能使用比较运算符比如 ==，如果是这样的话代码是错误的。\nBecause of this ambiguity, it’s considered a best practice to not use assignment in return statements.\n正是由于这种模棱两可，在 return 语句中不使用赋值，被认为是一个最佳实践。\nRule Details\nThis rule aims to eliminate assignments from return statements. As such, it will warn whenever an assignment is found as part of return.\n此规则目的在于移除 return 语句中的赋值语句。因此，当在return中发现赋值，该规则将发出警告。\nOptions\nThe rule takes one option, a string, which must contain one of the following values:\n此规则带有一个字符串选项，它必须包含下列值之一：\n\nexcept-parens (default): Disallow assignments unless they are enclosed in parentheses.\nexcept-parens（默认）：禁止出现赋值语句，除非使用括号把它们括起来。\nalways: Disallow all assignments.\nalways：禁止所有赋值\n\nexcept-parens\nThis is the default option.\nIt disallows assignments unless they are enclosed in parentheses.\n这是默认的选项。除非赋值语句是在圆括号中，否则不允许在返回语句中出现赋值语句。\nExamples of incorrect code for the default \"except-parens\" option:\n默认选项 \"except-parens\" 的 错误 代码示例：\n/*eslint no-return-assign: \"error\"*/\n\nfunction doSomething() {\n    return foo = bar + 2;\n}\n\nfunction doSomething() {\n    return foo += 2;\n}\n\n\nExamples of correct code for the default \"except-parens\" option:\n默认选项 \"except-parens\" 的 正确 代码示例：\n/*eslint no-return-assign: \"error\"*/\n\nfunction doSomething() {\n    return foo == bar + 2;\n}\n\nfunction doSomething() {\n    return foo === bar + 2;\n}\n\nfunction doSomething() {\n    return (foo = bar + 2);\n}\n\n\nalways\nThis option disallows all assignments in return statements.\nAll assignments are treated as problems.\n此选项禁止 return 中所有的赋值。所有的赋值均被认为是有问题的。\nExamples of incorrect code for the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint no-return-assign: [\"error\", \"always\"]*/\n\nfunction doSomething() {\n    return foo = bar + 2;\n}\n\nfunction doSomething() {\n    return foo += 2;\n}\n\nfunction doSomething() {\n    return (foo = bar + 2);\n}\n\n\nExamples of correct code for the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint no-return-assign: [\"error\", \"always\"]*/\n\nfunction doSomething() {\n    return foo == bar + 2;\n}\n\nfunction doSomething() {\n    return foo === bar + 2;\n}\n\n\nWhen Not To Use It\nIf you want to allow the use of assignment operators in a return statement, then you can safely disable this rule.\n如果你想允许 return 语句中赋值操作符的使用，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-return-assign",
                "disable": false
            },
            {
                "real_name": "no-return-await",
                "display_name": "no-return-await",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallows unnecessary return await (no-return-await).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallows unnecessary return await (no-return-await)\nInside an async function, return await is useless. Since the return value of an async function is always wrapped in Promise.resolve, return await doesn’t actually do anything except add extra time before the overarching Promise resolves or rejects. This pattern is almost certainly due to programmer ignorance of the return semantics of async functions.\nRule Details\nThis rule aims to prevent a likely common performance hazard due to a lack of understanding of the semantics of async function.\nThe following patterns are considered warnings:\nasync function foo() {\n  return await bar();\n}\n\n\nThe following patterns are not warnings:\nasync function foo() {\n  return bar();\n}\n\nasync function foo() {\n  await bar();\n  return;\n}\n\nasync function foo() {\n  const x = await bar();\n  return x;\n}\n\n\nWhen Not To Use It\nIf you want to use await to denote a value that is a thenable, even when it is not necessary; or if you do not want the performance benefit of avoiding return await, you can turn off this rule.\nFurther Reading\nasync function on MDN\nVersion\nThis rule was introduced in ESLint 3.10.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-return-await",
                "disable": false
            },
            {
                "real_name": "no-script-url",
                "display_name": "no-script-url",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 Script URL (no-script-url)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Script URLs (no-script-url)\n禁用 Script URL (no-script-url)\nUsing javascript: URLs is considered by some as a form of eval. Code passed in javascript: URLs has to be parsed and evaluated by the browser in the same way that eval is processed.\n在链接地址中使用 javascript: 被有些人认为是 eval 的一种形式。在 javascript: 链接中的代码必须由浏览器解析和赋值，其处理方式与 eval 一样。\nRule Details\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-script-url: \"error\"*/\n\nlocation.href = \"javascript:void(0)\";\n\n\nCompatibility\n\n\nJSHint: This rule corresponds to scripturl rule of JSHint.\n\n\nJSHint：此规则对应JSHint中的scripturl规则。\n\n\nFurther Reading\n\nWhat is the matter with script-targeted URLs?\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-script-url",
                "disable": false
            },
            {
                "real_name": "no-self-assign",
                "display_name": "no-self-assign",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止自身赋值 (no-self-assign)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Self Assignment (no-self-assign)\n禁止自身赋值 (no-self-assign)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nSelf assignments have no effect, so probably those are an error due to incomplete refactoring.\nThose indicate that what you should do is still remaining.\n自身赋值不起任何作用，可能是由于不完整的重构造成的错误。也表明你的工作还没做完。\nfoo = foo;\n[bar, baz] = [bar, qiz];\n\n\nRule Details\nThis rule is aimed at eliminating self assignments.\n该规则旨在消除自身赋值的情况。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-self-assign: \"error\"*/\n\nfoo = foo;\n\n[a, b] = [a, b];\n\n[a, ...b] = [x, ...b];\n\n({a, b} = {a, x});\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-self-assign: \"error\"*/\n\nfoo = bar;\n[a, b] = [b, a];\n\n// This pattern is warned by the `no-use-before-define` rule.\nlet foo = foo;\n\n// The default values have an effect.\n[foo = 1] = [foo];\n\n\nOptions\nThis rule has the option to check properties as well.\n该规则也有可以检查属性的选项。\n{\n    \"no-self-assign\": [\"error\", {\"props\": false}]\n}\n\n\n\nprops - if this is true, no-self-assign rule warns self-assignments of properties. Default is false.\nprops - 如果为 true，no-self-assign 规则将对属性的自我赋值发出警告。默认为 false.\n\nprops\nExamples of incorrect code for the { \"props\": true } option:\n选项 { \"props\": true } 的 错误 代码示例：\n/*eslint no-self-assign: [error, {props: true}]*/\n\n// self-assignments with properties.\nobj.a = obj.a;\nobj.a.b = obj.a.b;\nobj[\"a\"] = obj[\"a\"];\nobj[a] = obj[a];\n\n\nExamples of correct code for the { \"props\": true } option:\n选项 { \"props\": true } 的 正确 代码示例：\n/*eslint no-self-assign: [error, {props: true}]*/\n\n// non-self-assignments with properties.\nobj.a = obj.b;\nobj.a.b = obj.c.b;\nobj.a.b = obj.a.c;\nobj[a] = obj[\"a\"]\n\n// This ignores if there is a function call.\nobj.a().b = obj.a().b\na().b = a().b\n\n// Known limitation: this does not support computed properties except single literal or single identifier.\nobj[a + b] = obj[a + b];\nobj[\"a\" + \"b\"] = obj[\"a\" + \"b\"];\n\n\nWhen Not To Use It\nIf you don’t want to notify about self assignments, then it’s safe to disable this rule.\n如果你不想收到关于自身赋值的通知，关闭此规则即可。\nVersion\nThis rule was introduced in ESLint 2.0.0-rc.0.\n该规则在 ESLint 2.0.0-rc.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-self-assign",
                "disable": false
            },
            {
                "real_name": "no-self-compare",
                "display_name": "no-self-compare",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止自身比较（no-self-compare）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Self Compare (no-self-compare)\n禁止自身比较（no-self-compare）\nComparing a variable against itself is usually an error, either a typo or refactoring error. It is confusing to the reader and may potentially introduce a runtime error.\n变量与其自身进行比较通常来说是一个错误，要么是打字错误要么是重构错误。它都会给读者造成困扰并且可能会引入运行错误。\nThe only time you would compare a variable against itself is when you are testing for NaN. However, it is far more appropriate to use typeof x === 'number' && isNaN(x) or the Number.isNaN ES2015 function for that use case rather than leaving the reader of the code to determine the intent of self comparison.\n唯一肯能会对变量自身做比较时候是当你在测试变量是否是 NaN。然而，在这种情况下，更适合使用 typeof x === 'number' && isNaN(x) 或者 Number.isNaN ES2015 函数 而不是变量自身比较。\nRule Details\nThis error is raised to highlight a potentially confusing and potentially pointless piece of code. There are almost no situations in which you would need to compare something to itself.\n该规则为了突出一个潜在的令人困惑的、无意义的代码。几乎没有场景需要你比较变量本身。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-self-compare: \"error\"*/\n\nvar x = 10;\nif (x === x) {\n    x = 20;\n}\n\n\nFurther Reading\n\nWeird Relation\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-self-compare",
                "disable": false
            },
            {
                "real_name": "no-sequences",
                "display_name": "no-sequences",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许使用逗号操作符 (no-sequences)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Use of the Comma Operator (no-sequences)\n不允许使用逗号操作符 (no-sequences)\nThe comma operator includes multiple expressions where only one is expected. It evaluates each operand from left to right and returns the value of the last operand. However, this frequently obscures side effects, and its use is often an accident. Here are some examples of sequences:\n逗号操作符包含多个表达式，其中只有一个是可使用的。它从左到右计算每一个操作数并且返回最后一个操作数的值。然而，这往往掩盖了它的副作用，它的使用经常会发生事故。例如：\nvar a = (3, 5); // a = 5\n\na = b += 5, a + b;\n\nwhile (a = next(), a && a.length);\n\n(0, eval)(\"doSomething();\");\n\n\nRule Details\nThis rule forbids the use of the comma operator, with the following exceptions:\n此规则禁止逗号操作符的使用，以下情况除外：\n\nIn the initialization or update portions of a for statement.\n在初始化或者更新部分 for 语句时。\nIf the expression sequence is explicitly wrapped in parentheses.\n如果表达式序列被明确包裹在括号中。\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-sequences: \"error\"*/\n\nfoo = doSomething(), val;\n\n0, eval(\"doSomething();\");\n\ndo {} while (doSomething(), !!test);\n\nfor (; doSomething(), !!test; );\n\nif (doSomething(), !!test);\n\nswitch (val = foo(), val) {}\n\nwhile (val = foo(), val < 42);\n\nwith (doSomething(), val) {}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-sequences: \"error\"*/\n\nfoo = (doSomething(), val);\n\n(0, eval)(\"doSomething();\");\n\ndo {} while ((doSomething(), !!test));\n\nfor (i = 0, j = 10; i < j; i++, j--);\n\nif ((doSomething(), !!test));\n\nswitch ((val = foo(), val)) {}\n\nwhile ((val = foo(), val < 42));\n\n// with ((doSomething(), val)) {}\n\n\nWhen Not To Use It\nDisable this rule if sequence expressions with the comma operator are acceptable.\n如果逗号操作符在有序的表达式中使用是可接受的，禁用此规则。\nVersion\nThis rule was introduced in ESLint 0.5.1.\n该规则在 ESLint 0.5.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-sequences",
                "disable": false
            },
            {
                "real_name": "no-shadow",
                "display_name": "no-shadow",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止变量声明覆盖外层作用域的变量 (no-shadow)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow variable declarations from shadowing variables declared in the outer scope (no-shadow)\n禁止变量声明覆盖外层作用域的变量 (no-shadow)\nShadowing is the process by which a local variable shares the same name as a variable in its containing scope. For example:\n覆盖是指在同一作用域里局部变量和全局变量同名，比如：\nvar a = 3;\nfunction b() {\n    var a = 10;\n}\n\n\nIn this case, the variable a inside of b() is shadowing the variable a in the global scope. This can cause confusion while reading the code and it’s impossible to access the global variable.\n在这种情况中，b() 作用域中的 a 覆盖了全局环境中的 a。这会混淆读者并且在 b中不能获取全局变量。\nRule Details\nThis rule aims to eliminate shadowed variable declarations.\n此规则旨在消除变量声明覆盖。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-shadow: \"error\"*/\n/*eslint-env es6*/\n\nvar a = 3;\nfunction b() {\n    var a = 10;\n}\n\nvar b = function () {\n    var a = 10;\n}\n\nfunction b(a) {\n    a = 10;\n}\nb(a);\n\nif (true) {\n    let a = 5;\n}\n\n\nOptions\nThis rule takes one option, an object, with properties \"builtinGlobals\", \"hoist\" and \"allow\".\n对象配置项，包含属性 \"builtinGlobals\"、\"hoist\" 和 \"allow\".\n{\n    \"no-shadow\": [\"error\", { \"builtinGlobals\": false, \"hoist\": \"functions\", \"allow\": [] }]\n}\n\n\nbuiltinGlobals\nThe builtinGlobals option is false by default.\nIf it is true, the rule prevents shadowing of built-in global variables: Object, Array, Number, and so on.\n默认值是 false，如果 builtinGlobals 是 true，会检测内置对象如 Object，Array、Number 等等。\nExamples of incorrect code for the { \"builtinGlobals\": true } option:\n选项 {\"builtinGlobals\": true} 的 错误 代码示例：\n/*eslint no-shadow: [\"error\", { \"builtinGlobals\": true }]*/\n\nfunction foo() {\n    var Object = 0;\n}\n\n\nhoist\nThe hoist option has three settings:\n此配置项有三个值：\n\nfunctions (by default) - reports shadowing before the outer functions are defined.\nfunctions (默认值)-在被覆盖前呈报函数覆盖错误。\nall - reports all shadowing before the outer variables/functions are defined.\nall-在被覆盖之前呈报函数和变量的覆盖错误。\nnever - never report shadowing before the outer variables/functions are defined.\nnever-不呈报覆盖错误。\n\nhoist: functions\nExamples of incorrect code for the default { \"hoist\": \"functions\" } option:\n默认选项  { \"hoist\": \"functions\" } 的 错误 代码示例：\n/*eslint no-shadow: [\"error\", { \"hoist\": \"functions\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let b = 6;\n}\n\nfunction b() {}\n\n\nAlthough let b in the if statement is before the function declaration in the outer scope, it is incorrect.\n虽然 if 语句中的 let b 在 function声明之前，该示例是正确的。\nExamples of correct code for the default { \"hoist\": \"functions\" } option:\n默认选项 { \"hoist\": \"functions\" } 的 正确 代码示例：\n/*eslint no-shadow: [\"error\", { \"hoist\": \"functions\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let a = 3;\n}\n\nlet a = 5;\n\n\nBecause let a in the if statement is before the variable declaration in the outer scope, it is correct.\n因为在 if 语句中 let a 在外层作用域声明语句之前，所以是正确的。\nhoist: all\nExamples of incorrect code for the { \"hoist\": \"all\" } option:\n选项 { \"hoist\": \"all\" } 的 错误 代码示例：\n/*eslint no-shadow: [\"error\", { \"hoist\": \"all\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let a = 3;\n    let b = 6;\n}\n\nlet a = 5;\nfunction b() {}\n\n\nhoist: never\nExamples of correct code for the { \"hoist\": \"never\" } option:\n选项 { \"hoist\": \"never\" } 的 正确 代码示例：\n/*eslint no-shadow: [\"error\", { \"hoist\": \"never\" }]*/\n/*eslint-env es6*/\n\nif (true) {\n    let a = 3;\n    let b = 6;\n}\n\nlet a = 5;\nfunction b() {}\n\n\nBecause let a and let b in the if statement are before the declarations in the outer scope, they are correct.\n因为在 if 语句中 let a 和 let b 在外层作用域声明语句之前，所以是正确的。\nallow\nThe allow option is an array of identifier names for which shadowing is allowed. For example, \"resolve\", \"reject\", \"done\", \"cb\".\nallow 选项是个标识符名称的数组，以允许他们被重写。例如：\"resolve\"， \"reject\"， \"done\"， \"cb\"。\nExamples of correct code for the { \"allow\": [\"done\"] } option:\n选项 { \"allow\": [\"done\"] } 的 正确 代码示例：\n/*eslint no-shadow: [\"error\", { \"allow\": [\"done\"] }]*/\n/*eslint-env es6*/\n\nimport async from 'async';\n\nfunction foo(done) {\n  async.map([1, 2], function (e, done) {\n    done(null, e * 2)\n  }, done);\n}\n\nfoo(function (err, result) {\n  console.log({ err, result });\n});\n\n\nFurther Reading\n\nVariable Shadowing\n\nRelated Rules\n\nno-shadow-restricted-names\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-shadow",
                "disable": false
            },
            {
                "real_name": "no-shadow-restricted-names",
                "display_name": "no-shadow-restricted-names",
                "severity": "error",
                "category": "correctness",
                "rule_title": "关键字不能被遮蔽 (no-shadow-restricted-names)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Shadowing of Restricted Names (no-shadow-restricted-names)\n关键字不能被遮蔽 (no-shadow-restricted-names)\nES5 §15.1.1 Value Properties of the Global Object (NaN, Infinity, undefined) as well as strict mode restricted identifiers eval and arguments are considered to be restricted names in JavaScript. Defining them to mean something else can have unintended consequences and confuse others reading the code. For example, there’s nothing prevent you from writing:\nES5 §15.1.1 中全局对象的属性值 (NaN、Infinity、undefined)和严格模式下被限定的标识符 eval、arguments 也被认为是关键字。重定义关键字会产生意想不到的后果且易迷惑其他读者。比如：\nvar undefined = \"foo\";\n\n\nThen any code used within the same scope would not get the global undefined, but rather the local version with a very different meaning.\n以上不能得到全局 undefined，但在本作用域中却具有不同于全局的意思。\nRule Details\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-shadow-restricted-names: \"error\"*/\n\nfunction NaN(){}\n\n!function(Infinity){};\n\nvar undefined;\n\ntry {} catch(eval){}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-shadow-restricted-names: \"error\"*/\n\nvar Object;\n\nfunction f(a, b){}\n\n\nFurther Reading\n\nAnnotated ES5 - §15.1.1\nAnnotated ES5 - Annex C\n\nRelated Rules\n\nno-shadow\n\nVersion\nThis rule was introduced in ESLint 0.1.4.\n该规则在 ESLint 0.1.4 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-shadow-restricted-names",
                "disable": false
            },
            {
                "real_name": "no-spaced-func",
                "display_name": "no-spaced-func",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow spacing between function identifiers and their applications (no-spaced-func)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow spacing between function identifiers and their applications (no-spaced-func)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nThis rule was deprecated in ESLint v3.3.0 and replaced by the func-call-spacing rule.\nWhile it’s possible to have whitespace between the name of a function and the parentheses that execute it, such patterns tend to look more like errors.\nRule Details\nThis rule disallows spacing between function identifiers and their applications.\nExamples of incorrect code for this rule:\n/*eslint no-spaced-func: \"error\"*/\n\nfn ()\n\nfn\n()\n\n\nExamples of correct code for this rule:\n/*eslint no-spaced-func: \"error\"*/\n\nfn()\n\n\nVersion\nThis rule was introduced in ESLint 0.1.2.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-spaced-func",
                "disable": false
            },
            {
                "real_name": "no-sparse-arrays",
                "display_name": "no-sparse-arrays",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用稀疏数组",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow sparse arrays (no-sparse-arrays)\n禁用稀疏数组\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nSparse arrays contain empty slots, most frequently due to multiple commas being used in an array literal, such as:\n稀疏数组包括很多空位置，经常是由于在数组字面量中使用多个逗号造成的，例如：\nvar items = [,,];\n\n\nWhile the items array in this example has a length of 2, there are actually no values in items[0] or items[1]. The fact that the array literal is valid with only commas inside, coupled with the length being set and actual item values not being set, make sparse arrays confusing for many developers. Consider the following:\n在这个例子中，item 数组的 length 为 2，实际上，items[0] 或 items[1]并没有值。数组中只有逗号是有效的，再加上 length 被设置，没有实际的值被设置，这些情况让很多开发者对稀疏数组感到困惑。考虑下面的情况：\nvar colors = [ \"red\",, \"blue\" ];\n\n\nIn this example, the colors array has a length of 3. But did the developer intend for there to be an empty spot in the middle of the array? Or is it a typo?\n在这个例子中，colors 数值的 length 是 3。但是否是开发者想让数组中间出现一个空元素？或者只是一个书写错误？\nThe confusion around sparse arrays defined in this manner is enough that it’s recommended to avoid using them unless you are certain that they are useful in your code.\n稀疏数组的定义方式造成了很大的困惑，建议避免使用它们，除非你确定它们在你的代码中很有用。\nRule Details\nThis rule disallows sparse array literals which have “holes” where commas are not preceded by elements. It does not apply to a trailing comma following the last element.\n该规则禁止使用稀疏数组，也就是逗号之前没有任何元素的数组。该规则不适用于紧随最后一个元素的拖尾逗号的情况。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-sparse-arrays: \"error\"*/\n\nvar items = [,];\nvar colors = [ \"red\",, \"blue\" ];\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-sparse-arrays: \"error\"*/\n\nvar items = [];\nvar items = new Array(23);\n\n// trailing comma (after the last element) is not a problem\nvar colors = [ \"red\", \"blue\", ];\n\n\nWhen Not To Use It\nIf you want to use sparse arrays, then it is safe to disable this rule.\n如果你想使用稀疏数组，可以关闭此规则。\nFurther Reading\n\nInconsistent array literals\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-sparse-arrays",
                "disable": false
            },
            {
                "real_name": "no-sync",
                "display_name": "no-sync",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用同步方法 (no-sync)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Synchronous Methods (no-sync)\n禁止使用同步方法 (no-sync)\nIn Node.js, most I/O is done through asynchronous methods. However, there are often synchronous versions of the asynchronous methods. For example, fs.exists() and fs.existsSync(). In some contexts, using synchronous operations is okay (if, as with ESLint, you are writing a command line utility). However, in other contexts the use of synchronous operations is considered a bad practice that should be avoided. For example, if you are running a high-travel web server on Node.js, you should consider carefully if you want to allow any synchronous operations that could lock up the server.\n在 Node.js 中，大多数的 I/O 操作是通过异步方法执行的。但是，经常有一些异步方法的同步版本。比如 fs.exists() 和 fs.exitsSync()。在一些环境中，使用这些同步方法是没有问题的(比如用当用命令行的方式使用 ESLint 比较实用)。但是在某些环境中，使用这些同步方法被认为是一个糟糕的习惯，这些习惯应该被避免。比如你在一个正在高并发的web服务器上运行 Node.js，你应该仔细考虑下需要下，如果你想使用这些同步方法，确保这些同步操作不会阻塞服务器。\nRule Details\nThis rule is aimed at preventing synchronous methods from being called in Node.js. It looks specifically for the method suffix “Sync” (as is the convention with Node.js operations).\n这条规则旨在阻止使用 Node.js 中的同步方法。这些方法看起来比较特别，会在后缀加 Sync(这是 Node.js 中的约定)。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-sync: \"error\"*/\n\nfs.existsSync(somePath);\n\nvar contents = fs.readFileSync(somePath).toString();\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-sync: \"error\"*/\n\nobj.sync();\n\nasync(function() {\n    // ...\n});\n\n\nWhen Not To Use It\nIf you want to allow synchronous operations in your script.\n如果你想在你的脚本中使用同步操作。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n此规则在 ESlint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-sync",
                "disable": false
            },
            {
                "real_name": "no-tabs",
                "display_name": "no-tabs",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow all tabs (no-tabs)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow all tabs (no-tabs)\nSome style guides don’t allow the use of tab characters at all, including within comments.\nRule Details\nThis rule looks for tabs anywhere inside a file: code, comments or anything else.\nExamples of incorrect code for this rule:\nvar a /t= 2;\n\n/**\n* /t/t it's a test function\n*/\nfunction test(){}\n\nvar x = 1; // /t test\n\n\nExamples of correct code for this rule:\nvar a = 2;\n\n/**\n* it's a test function\n*/\nfunction test(){}\n\nvar x = 1; // test\n\n\nWhen Not To Use It\nIf you have established a standard where having tabs is fine.\nCompatibility\n\nJSCS: disallowTabs\n\nVersion\nThis rule was introduced in ESLint 3.2.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-tabs",
                "disable": false
            },
            {
                "real_name": "no-template-curly-in-string",
                "display_name": "no-template-curly-in-string",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow template literal placeholder syntax in regular strings (no-template-curly-in-string)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow template literal placeholder syntax in regular strings (no-template-curly-in-string)\nECMAScript 6 allows programmers to create strings containing variable or expressions using template literals, instead of string concatenation, by writing expressions like ${variable} between two backtick quotes (`). It can be easy to use the wrong quotes when wanting to use template literals, by writing \"${variable}\", and end up with the literal value \"${variable}\" instead of a string containing the value of the injected expressions.\nRule Details\nThis rule aims to warn when a regular string contains what looks like a template literal placeholder. It will warn when it finds a string containing the template literal place holder (${something}) that uses either \" or ' for the quotes.\nExamples\nExamples of incorrect code for this rule:\n/*eslint no-template-curly-in-string: \"error\"*/\n\"Hello ${name}!\";\n'Hello ${name}!';\n\"Time: ${12 * 60 * 60 * 1000}\";\n\n\nExamples of correct code for this rule:\n/*eslint no-template-curly-in-string: \"error\"*/\n`Hello ${name}!`;\n`Time: ${12 * 60 * 60 * 1000}`;\n\ntemplateFunction`Hello ${name}`;\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\nVersion\nThis rule was introduced in ESLint 3.3.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-template-curly-in-string",
                "disable": false
            },
            {
                "real_name": "no-ternary",
                "display_name": "no-ternary",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用三元操作符 (no-ternary)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow ternary operators (no-ternary)\n禁止使用三元操作符 (no-ternary)\nThe ternary operator is used to conditionally assign a value to a variable. Some believe that the use of ternary operators leads to unclear code.\n三元操作符通过条件操作为一个变量赋值。一些人认为使用三元操作符会导致代码不清晰。\nvar foo = isBar ? baz : qux;\n\n\nRule Details\nThis rule disallows ternary operators.\n该规则禁止使用三元操作符。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-ternary: \"error\"*/\n\nvar foo = isBar ? baz : qux;\n\nfunction quux() {\n  return foo ? bar() : baz();\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-ternary: \"error\"*/\n\nvar foo;\n\nif (isBar) {\n    foo = baz;\n} else {\n    foo = qux;\n}\n\nfunction quux() {\n    if (foo) {\n        return bar();\n    } else {\n        return baz();\n    }\n}\n\n\nRelated Rules\n\nno-nested-ternary\nno-unneeded-ternary\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-ternary",
                "disable": false
            },
            {
                "real_name": "no-this-before-super",
                "display_name": "no-this-before-super",
                "severity": "error",
                "category": "correctness",
                "rule_title": "在构造函数中禁止在调用super()之前使用this或super。 (no-this-before-super)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow use of this/super before calling super() in constructors. (no-this-before-super)\n在构造函数中禁止在调用super()之前使用this或super。 (no-this-before-super)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIn the constructor of derived classes, if this/super are used before super() calls, it raises a reference error.\n在派生类的构造函数中，如果在调用 super() 之前使用 this 或 super，它将会引发一个引用错误。\nThis rule checks this/super keywords in constructors, then reports those that are before super().\n该规则检测构造函数中的 this 或 super 关键字，然后报告那些在 super() 之前使用 this 或 super 的情况。\nRule Details\nThis rule is aimed to flag this/super keywords before super() callings.\n该规则旨在标记出在调用 super() 之前使用 this 或 super 的情况。\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-this-before-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A extends B {\n    constructor() {\n        this.a = 0;\n        super();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        this.foo();\n        super();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super.foo();\n        super();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super(this.foo());\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-this-before-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() {\n        this.a = 0; // OK, this class doesn't have an `extends` clause.\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super();\n        this.a = 0; // OK, this is after `super()`.\n    }\n}\n\nclass A extends B {\n    foo() {\n        this.a = 0; // OK. this is not in a constructor.\n    }\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about using this/super before super() in constructors, you can safely disable this rule.\n如果你不想收到关于构造函数中调用 super() 之前使用 this 或 super 情况的通知，关闭此规则即可。\nVersion\nThis rule was introduced in ESLint 0.24.0.\n该规则在 ESLint 0.24.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-this-before-super",
                "disable": false
            },
            {
                "real_name": "no-throw-literal",
                "display_name": "no-throw-literal",
                "severity": "error",
                "category": "correctness",
                "rule_title": "限制可以被抛出的异常 (no-throw-literal)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Restrict what can be thrown as an exception (no-throw-literal)\n限制可以被抛出的异常 (no-throw-literal)\nIt is considered good practice to only throw the Error object itself or an object using the Error object as base objects for user-defined exceptions.\nThe fundamental benefit of Error objects is that they automatically keep track of where they were built and originated.\n仅仅 抛出(throw) Error 对象本身或者用户自定义的以 Error 对象为基础的异常，被认为是一个很好的实践。使用 Error 对象最基本的好处是它们能自动地追踪到异常产生和起源的地方。\nThis rule restricts what can be thrown as an exception.  When it was first created, it only prevented literals from being thrown (hence the name), but it has now been expanded to only allow expressions which have a possibility of being an Error object.\n此规则限制了能被抛出的异常。当初次被创建时，它只是阻止字面量被抛出，但是现在已经被扩展到只允许具有 Error 对象能力的表达式。\nRule Details\nThis rule is aimed at maintaining consistency when throwing exception by disallowing to throw literals and other expressions which cannot possibly be an Error object.\n此规则目的在于保持异常抛出的一致性，通过禁止抛出字面量和那些不可能是 Error 对象的表达式。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-throw-literal: \"error\"*/\n/*eslint-env es6*/\n\nthrow \"error\";\n\nthrow 0;\n\nthrow undefined;\n\nthrow null;\n\nvar err = new Error();\nthrow \"an \" + err;\n// err is recast to a string literal\n\nvar err = new Error();\nthrow `${err}`\n\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-throw-literal: \"error\"*/\n\nthrow new Error();\n\nthrow new Error(\"error\");\n\nvar e = new Error(\"error\");\nthrow e;\n\ntry {\n    throw new Error(\"error\");\n} catch (e) {\n    throw e;\n}\n\n\nKnown Limitations\nDue to the limits of static analysis, this rule cannot guarantee that you will only throw Error objects.\n由于静态分析的局限性，此规则不能保证你只会抛出 Error 对象。\nExamples of correct code for this rule, but which do not throw an Error object:\n正确 代码示例如下，该示例不会抛出 Error 对象：\n/*eslint no-throw-literal: \"error\"*/\n\nvar err = \"error\";\nthrow err;\n\nfunction foo(bar) {\n    console.log(bar);\n}\nthrow foo(\"error\");\n\nthrow new String(\"error\");\n\nvar foo = {\n    bar: \"error\"\n};\nthrow foo.bar;\n\n\nVersion\nThis rule was introduced in ESLint 0.15.0.\n该规则在 ESLint 0.15.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-throw-literal",
                "disable": false
            },
            {
                "real_name": "no-trailing-spaces",
                "display_name": "no-trailing-spaces",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用行尾空白 (no-trailing-spaces)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow trailing whitespace at the end of lines (no-trailing-spaces)\n禁用行尾空白 (no-trailing-spaces)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSometimes in the course of editing files, you can end up with extra whitespace at the end of lines. These whitespace differences can be picked up by source control systems and flagged as diffs, causing frustration for developers. While this extra whitespace causes no functional issues, many code conventions require that trailing spaces be removed before check-in.\n有时在编辑文件的过程中，你可以在行的末尾以额外的空格作为结束。这些空格差异可以被源码控制系统识别出并被标记为差异，给开发人员带来挫败感。虽然这种额外的空格并不会造成功能性的问题，许多编码规范要求在提交代码之前删除尾部空格。\nRule Details\nThis rule disallows trailing whitespace (spaces, tabs, and other Unicode whitespace characters) at the end of lines.\n该规则禁止使用行尾空白（空格、tab 和其它 Unicode 空白字符）。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-trailing-spaces: \"error\"*/\n\nvar foo = 0;//•••••\nvar baz = 5;//••\n//•••••\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-trailing-spaces: \"error\"*/\n\nvar foo = 0;\n\nvar baz = 5;\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"skipBlankLines\": false (default) disallows trailing whitespace on empty lines\n\"skipBlankLines\": false (默认) 禁止在空行使用空白符\n\"skipBlankLines\": true allows trailing whitespace on empty lines\n\"skipBlankLines\": true 允许在空行使用空白符\n\"ignoreComments\": false (default) disallows trailing whitespace in comment blocks\n\"ignoreComments\": false (默认) 禁止在注释块中使用空白符\n\"ignoreComments\": true allows trailing whitespace in comment blocks\n\"ignoreComments\": true 允许在注释块中使用空白符\n\nskipBlankLines\nExamples of correct code for this rule with the { \"skipBlankLines\": true } option:\n选项 { \"skipBlankLines\": true } 的 正确 代码示例：\n/*eslint no-trailing-spaces: [\"error\", { \"skipBlankLines\": true }]*/\n\nvar foo = 0;\nvar baz = 5;\n//•••••\n\n\nignoreComments\nExamples of correct code for this rule with the { \"ignoreComments\": true } option:\n选项 { \"ignoreComments\": true } 的 正确 代码示例：\n/*eslint no-trailing-spaces: [\"error\", { \"ignoreComments\": true }]*/\n\n//foo•\n//•••••\n/**\n *•baz\n *••\n *•bar\n */\n\n\nVersion\nThis rule was introduced in ESLint 0.7.1.\n该规则在 ESLint 0.7.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-trailing-spaces",
                "disable": false
            },
            {
                "real_name": "no-undef",
                "display_name": "no-undef",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用未声明的变量 (no-undef)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Undeclared Variables (no-undef)\n禁用未声明的变量 (no-undef)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThis rule can help you locate potential ReferenceErrors resulting from misspellings of variable and parameter names, or accidental implicit globals (for example, from forgetting the var keyword in a for loop initializer).\n此规则可帮助你定位由变量漏写、参数名漏写和意外的隐式全局变量声明所导致的潜在引用错误（比如，在 for 循环语句中初始化变量忘写 var 关键字）\nRule Details\nAny reference to an undeclared variable causes a warning, unless the variable is explicitly mentioned in a /*global ...*/ comment.\n对任何未声明的变量的引用都会引起一个警告，除非显式地在 /*global ...*/ 注释中指定。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-undef: \"error\"*/\n\nvar a = someFunction();\nb = 10;\n\n\nExamples of correct code for this rule with global declaration:\n有 global 声明时，该规则的 正确 代码示例：\n/*global someFunction b:true*/\n/*eslint no-undef: \"error\"*/\n\nvar a = someFunction();\nb = 10;\n\n\nThe b:true syntax in /*global */ indicates that assignment to b is correct.\n/*global */ 中的 b:true 表明对 b 继续赋值是正确的。\nExamples of incorrect code for this rule with global declaration:\n有 global 声明时，该规则的 错误 代码示例：\n/*global b*/\n/*eslint no-undef: \"error\"*/\n\nb = 10;\n\n\nBy default, variables declared in /*global */ are read-only, therefore assignment is incorrect.\n默认情况下，/*global */ 中声明的变量是只读的，因此对其进行赋值是错误的。\nOptions\n\ntypeof set to true will warn for variables used inside typeof check (Default false).\ntypeof 设置为 true，将对 typeof 中用到的变量发出警告（默认为false）。\n\ntypeof\nExamples of correct code for the default { \"typeof\": false } option:\n默认选项 { \"typeof\": false } 的 正确 代码示例：\n/*eslint no-undef: \"error\"*/\n\nif (typeof UndefinedIdentifier === \"undefined\") {\n    // do something ...\n}\n\n\nYou can use this option if you want to prevent typeof check on a variable which has not been declared.\n如果想阻止在 typeof 运算中有未申明的变量导致的警告，可以用此项。\nExamples of incorrect code for the { \"typeof\": true } option:\n选项 { \"typeof\": true } 的 错误 代码示例：\n/*eslint no-undef: [\"error\", { \"typeof\": true }] */\n\nif(typeof a === \"string\"){}\n\n\nExamples of correct code for the { \"typeof\": true } option with global declaration:\n有 global 声明时，选项 { \"typeof\": true } 的 正确 代码示例：\n/*global a*/\n/*eslint no-undef: [\"error\", { \"typeof\": true }] */\n\nif(typeof a === \"string\"){}\n\n\nEnvironments\nFor convenience, ESLint provides shortcuts that pre-define global variables exposed by popular libraries and runtime environments. This rule supports these environments, as listed in Specifying Environments.  A few examples are given below.\n为了方便，ESlint 提供了预定义流行类库和运行时环境暴露的全局变量的快捷方式。该规则支持这些环境。使用如下：\nbrowser\nExamples of correct code for this rule with browser environment:\nbrowser 环境下的 正确 代码示例：\n/*eslint no-undef: \"error\"*/\n/*eslint-env browser*/\n\nsetTimeout(function() {\n    alert(\"Hello\");\n});\n\n\nnode\nExamples of correct code for this rule with node environment:\nnode 环境下的 正确 代码示例：\n/*eslint no-undef: \"error\"*/\n/*eslint-env node*/\n\nvar fs = require(\"fs\");\nmodule.exports = function() {\n    console.log(fs);\n};\n\n\nWhen Not To Use It\nIf explicit declaration of global variables is not to your taste.\n如果你不需要明确声明全局变量，可以关闭此规则。\nCompatibility\nThis rule provides compatibility with treatment of global variables in JSHint and JSLint.\n该规则提供了合适对待全局变量的方法。 它在 JSHint 和JSLint。\nFurther Reading\n\n‘{a}’ is not defined\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-undef",
                "disable": false
            },
            {
                "real_name": "no-undef-init",
                "display_name": "no-undef-init",
                "severity": "error",
                "category": "correctness",
                "rule_title": "不允许初始化变量值为 undefined (no-undef-init)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Initializing to undefined (no-undef-init)\n不允许初始化变量值为 undefined (no-undef-init)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIn JavaScript, a variable that is declared and not initialized to any value automatically gets the value of undefined. For example:\n在 JavaScript 中，声明一个变量但未初始化，变量会自动获得 undefined 作为初始值。比如：\nvar foo;\n\nconsole.log(foo === undefined);     // true\n\n\nIt’s therefore unnecessary to initialize a variable to undefined, such as:\n因此，初始化变量值为 undefined 是多余的，如：\nvar foo = undefined;\n\n\nIt’s considered a best practice to avoid initializing variables to undefined.\n最好的做法是避免初始化变量值为 undefined。\nRule Details\nThis rule aims to eliminate variable declarations that initialize to undefined.\n此规则旨在限制变量声明后被初始化为 undefined。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-undef-init: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = undefined;\nlet bar = undefined;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-undef-init: \"error\"*/\n/*eslint-env es6*/\n\nvar foo;\nlet bar;\nconst baz = undefined;\n\n\nWhen Not To Use It\nThere is one situation where initializing to undefined behaves differently than omitting the initialization, and that’s when a var declaration occurs inside of a loop. For example:\n当在一个循环中用 var 声明一个变量的时候，这种情况下给变量赋值为 undefined 与省略初始化的结果不同。比如：\nExample of incorrect code for this rule:\n错误 代码示例：\nfor (i = 0; i < 10; i++) {\n    var x = undefined;\n    console.log(x);\n    x = i;\n}\n\n\nIn this case, the var x is hoisted out of the loop, effectively creating:\n在这种情况下，var x 被提升到循环外。\nvar x;\n\nfor (i = 0; i < 10; i++) {\n    x = undefined;\n    console.log(x);\n    x = i;\n}\n\n\nIf you were to remove the initialization, then the behavior of the loop changes:\n如果删除初始化语句，循环语句的行为会改变：\nfor (i = 0; i < 10; i++) {\n    var x;\n    console.log(x);\n    x = i;\n}\n\n\nThis code is equivalent to:\n此代码等价于下面代码：\nvar x;\n\nfor (i = 0; i < 10; i++) {\n    console.log(x);\n    x = i;\n}\n\n\nThis produces a different outcome than defining var x = undefined in the loop, as x is no longer reset to undefined each time through the loop.\n于在循环语句中使用 var x = undefined 相比，这样产生了一个不同结果 ，因为每次循环后 x 不在赋值为 undefined。\nIf you’re using such an initialization inside of a loop, then you should disable this rule.\n如果你有在循环语句中初始化变量，你应该禁用此规则。\nExample of correct code for this rule, because it is disabled on a specific line:\n正确 代码示例，因为它在特定的行上被禁用。\n/*eslint no-undef-init: \"error\"*/\n\nfor (i = 0; i < 10; i++) {\n    var x = undefined; // eslint-disable-line no-undef-init\n    console.log(x);\n    x = i;\n}\n\n\nRelated Rules\n\nno-undefined\nno-void\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-undef-init",
                "disable": false
            },
            {
                "real_name": "no-undefined",
                "display_name": "no-undefined",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow Use of undefined Variable (no-undefined).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Use of undefined Variable (no-undefined)\n不允许使用undefined变量 (no-undefined)\nThe undefined variable in JavaScript is actually a property of the global object. As such, in ECMAScript 3 it was possible to overwrite the value of undefined. While ECMAScript 5 disallows overwriting undefined, it’s still possible to shadow undefined, such as:\nundefined 变量在 JavaScript 中是独一无二的，因为它实际上是一个全局对象属性。在 ECMAScript 3 中，可重写 undefined 的值，然而 ECMAScript 5 不允许重写 undefined ，但仍然可能遮盖原来的 undefined，例如：\nfunction doSomething(data) {\n    var undefined = \"hi\";\n\n    // doesn't do what you think it does\n    if (data === undefined) {\n        // ...\n    }\n\n}\n\n\nBecause undefined can be overwritten or shadowed, reading undefined can give an unexpected value. (This is not the case for null, which is a keyword that always produces the same value.) To guard against this, you can avoid all uses of undefined, which is what some style guides recommend and what this rule enforces. Those style guides then also recommend:\n由于 undefined 会被覆盖和遮蔽，所以读取 undefined 会给你一个意想不到的值。（这种情况还不同于 null， null 会始终产生同一个值。）为了防止这种情况凡是，你可以避免对 undefined 的所有使用，这也是一项风格指南所推荐的，也是该规则强制的。那些风格指南也推荐：\n\nVariables that should be undefined are simply left uninitialized. (All uninitialized variables automatically get the value of undefined in JavaScript.)\n要使变量值为 undefined，不初始化即可。 (在 JavaScript 中，所有未经初始化的变量会自动地获得值为 undefined)\nChecking if a value is undefined should be done with typeof.\n应该使用 typeof 检测一个值是否是 undefined。\nUsing the void operator to generate the value of undefined if necessary.\n如果有必要，使用 void 操作符生成 undefined。\n\nAs an alternative, you can use the no-global-assign and no-shadow-restricted-names rules to prevent undefined from being shadowed or assigned a different value. This ensures that undefined will always hold its original, expected value.\n作为另外一种宣泄，你可以使用 no-global-assign 和 no-shadow-restricted-names 规则来阻止遮蔽 undefined 或被赋值为一个不同的值。这会保证 undefined 将总是保持它的原始的和所期望的值。\nRule Details\nThis rule aims to eliminate the use of undefined, and as such, generates a warning whenever it is used.\n此规则的目的在于消除使用 undefined，使用 undefined 会产生一个警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-undefined: \"error\"*/\n\nvar foo = undefined;\n\nvar undefined = \"foo\";\n\nif (foo === undefined) {\n    // ...\n}\n\nfunction foo(undefined) {\n    // ...\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-undefined: \"error\"*/\n\nvar foo = void 0;\n\nvar Undefined = \"foo\";\n\nif (typeof foo === \"undefined\") {\n    // ...\n}\n\nglobal.undefined = \"foo\";\n\n\nWhen Not To Use It\nIf you want to allow the use of undefined in your code, then you can safely turn this rule off.\n如果想在代码中使用 undefined，应关闭此规则。\nFurther Reading\n\nundefined - JavaScript | MDN\nUnderstanding JavaScript’s ‘undefined’ | JavaScript, JavaScript…\nECMA262 edition 5.1 §15.1.1.3: undefined\n\nRelated Rules\n\nno-undef-init\nno-void\nno-shadow-restricted-names\nno-global-assign\n\nVersion\nThis rule was introduced in ESLint 0.7.1.\n该规则在 ESLint 0.7.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-undefined",
                "disable": false
            },
            {
                "real_name": "no-underscore-dangle",
                "display_name": "no-underscore-dangle",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止标识符中有悬空下划线 (no-underscore-dangle)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow dangling underscores in identifiers (no-underscore-dangle)\n禁止标识符中有悬空下划线 (no-underscore-dangle)\nAs far as naming conventions for identifiers go, dangling underscores may be the most polarizing in JavaScript. Dangling underscores are underscores at either the beginning or end of an identifier, such as:\n在 JavaScript 中，就标识符命名规范而言，悬空下划线可能是最两极分化的了。悬空下划线是在标识符的开头或末尾的下划线，例如:\nvar _foo;\n\n\nThere is actually a long history of using dangling underscores to indicate “private” members of objects in JavaScript (though JavaScript doesn’t have truly private members, this convention served as a warning). This began with SpiderMonkey adding nonstandard methods such as __defineGetter__(). The intent with the underscores was to make it obvious that this method was special in some way. Since that time, using a single underscore prefix has become popular as a way to indicate “private” members of objects.\n事实上，在 JavaScript 中有很长一段历史使用悬空下划线来表示对象中的“私有”成员(虽然 JavaScript 并没有正真的私有成员，这个约定起警示作用)。这始于 SpiderMonkey 添加的非标准方法，比如 __defineGetter__()。下划线的意图是让它很明显的看出这个方法在某种程度上很特别。从那时起，使用单个下划线作为前缀来表示对象的“私有”成员变得流行起来。\nWhether or not you choose to allow dangling underscores in identifiers is purely a convention and has no effect on performance, readability, or complexity. It’s purely a preference.\n是否选择允许悬空下划线出现在标识符中纯粹只是个约定，不会影响性能，可读性或复杂性。它纯粹是个人偏好。\nRule Details\nThis rule disallows dangling underscores in identifiers.\n该规则旨在消除标识符中悬空下划线的使用。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-underscore-dangle: \"error\"*/\n\nvar foo_;\nvar __proto__ = {};\nfoo._bar();\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-underscore-dangle: \"error\"*/\n\nvar _ = require('underscore');\nvar obj = _.contains(items, item);\nobj.__proto__ = {};\nvar file = __filename;\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"allow\" allows specified identifiers to have dangling underscores\n\"allow\" 允许指定标识符使用悬空下划线\n\"allowAfterThis\": false (default) disallows dangling underscores in members of the this object\n\"allowAfterThis\": false (默认) 禁止在 this 对象的成员变量上使用悬空下划线\n\"allowAfterSuper\": false (default) disallows dangling underscores in members of the super object\n\"allowAfterSuper\": false (默认) 禁止在 super 对象的成员变量上使用悬空下划线\n\nallow\nExamples of additional correct code for this rule with the { \"allow\": [\"foo_\", \"_bar\"] } option:\n选项 { \"allow\": [\"foo_\", \"_bar\"] } 的 正确 代码示例：\n/*eslint no-underscore-dangle: [\"error\", { \"allow\": [\"foo_\", \"_bar\"] }]*/\n\nvar foo_;\nfoo._bar();\n\n\nallowAfterThis\nExamples of correct code for this rule with the { \"allowAfterThis\": true } option:\n选项 { \"allowAfterThis\": true } 的 正确 代码示例：\n/*eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }]*/\n\nvar a = this.foo_;\nthis._bar();\n\n\nallowAfterSuper\nExamples of correct code for this rule with the { \"allowAfterSuper\": true } option:\n选项 { \"allowAfterSuper\": true } 的 正确 代码示例：\n/*eslint no-underscore-dangle: [\"error\", { \"allowAfterSuper\": true }]*/\n\nvar a = super.foo_;\nsuper._bar();\n\n\nWhen Not To Use It\nIf you want to allow dangling underscores in identifiers, then you can safely turn this rule off.\n如果你允许标识符中有悬空下划线，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-underscore-dangle",
                "disable": false
            },
            {
                "real_name": "no-unexpected-multiline",
                "display_name": "no-unexpected-multiline",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用令人困惑的多行表达式 (no-unexpected-multiline)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow confusing multiline expressions (no-unexpected-multiline)\n禁止使用令人困惑的多行表达式 (no-unexpected-multiline)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nSemicolons are usually optional in JavaScript, because of automatic semicolon insertion (ASI). You can require or disallow semicolons with the semi rule.\n在 JavaScript 中，分号通常是可选的，因为会自动插入分号（ASI)。你可以使用 semi 规则要求或禁止分号。\nThe rules for ASI are relatively straightforward: As once described by Isaac Schlueter, a newline character always ends a statement, just like a semicolon, except where one of the following is true:\nASI 的规则是相对简单的：正如 Isaac Schlueter 曾经描述的那样，一个 \\n 字符总是一个语句的结尾(像分号一样)，除非下面之一为真：\n\nThe statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with . or ,.)\n该语句有一个没有闭合的括号，数组字面量或对象字面量或其他某种方式，不是有效结束一个语句的方式。（比如，以 . 或 , 结尾）\nThe line is -- or ++ (in which case it will decrement/increment the next token.)\n该行是 -- 或 ++（在这种情况下它将减量/增量的下一个标记）\nIt is a for(), while(), do, if(), or else, and there is no {\n它是个 for()、while()、do、if() 或 else，并且没有 {\nThe next line starts with [, (, +, *, /, -, ,, ., or some other binary operator that can only be found between two tokens in a single expression.\n下一行以 [、(、+、*、/、-、,、. 或一些其它在单个表达式中两个标记之间的二元操作符。\n\nIn the exceptions where a newline does not end a statement, a typing mistake to omit a semicolon causes two unrelated consecutive lines to be interpreted as one expression. Especially for a coding style without semicolons, readers might overlook the mistake. Although syntactically correct, the code might throw exceptions when it is executed.\n换行不结束语句，书写错误遗漏了分号，这些异常会导致两个不相干的连续的行被解释为一个表达式。特别是对于一个没有分号的代码风格，读者可能会忽略这些错误。尽管语法上是正确的，代码执行时可能会抛出异常。\nRule Details\nThis rule disallows confusing multiline expressions where a newline looks like it is ending a statement, but is not.\n该规则禁止使用令人困惑的多行表达式。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-unexpected-multiline: \"error\"*/\n\nvar foo = bar\n(1 || 2).baz();\n\nvar hello = 'world'\n[1, 2, 3].forEach(addNumber);\n\nlet x = function() {}\n`hello`\n\nlet x = function() {}\nx\n`hello`\n\nlet x = foo\n/regex/g.test(bar)\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-unexpected-multiline: \"error\"*/\n\nvar foo = bar;\n(1 || 2).baz();\n\nvar foo = bar\n;(1 || 2).baz()\n\nvar hello = 'world';\n[1, 2, 3].forEach(addNumber);\n\nvar hello = 'world'\nvoid [1, 2, 3].forEach(addNumber);\n\nlet x = function() {};\n`hello`\n\nlet tag = function() {}\ntag `hello`\n\n\nWhen Not To Use It\nYou can turn this rule off if you are confident that you will not accidentally introduce code like this.\n如果你有信心你不会意外地引入这样的代码，你可以关闭此规则。\nNote that the patterns considered problems are not flagged by the semi rule.\n注意，被认为有问题的模式 不被 semi 规则标记。\nRelated Rules\n\nfunc-call-spacing\nsemi\nno-spaced-func\nspace-unary-ops\n\nVersion\nThis rule was introduced in ESLint 0.24.0.\n该规则在 ESLint 0.24.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unexpected-multiline",
                "disable": false
            },
            {
                "real_name": "no-unmodified-loop-condition",
                "display_name": "no-unmodified-loop-condition",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用一成不变的循环条件 (no-unmodified-loop-condition)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow unmodified conditions of loops (no-unmodified-loop-condition)\n禁用一成不变的循环条件 (no-unmodified-loop-condition)\nVariables in a loop condition often are modified in the loop.\nIf not, it’s possibly a mistake.\n循环条件中的变量在循环中是要经常改变的。如果不是这样，那么可能是个错误。\nwhile (node) {\n    doSomething(node);\n}\n\n\nwhile (node) {\n    doSomething(node);\n    node = node.parent;\n}\n\n\nRule Details\nThis rule finds references which are inside of loop conditions, then checks the\nvariables of those references are modified in the loop.\n该规则发现循环条件的引用，检查这些引用的变量在循环过程中是否发生改变。\nIf a reference is inside of a binary expression or a ternary expression, this rule checks the result of the expression instead.\n如果一个引用是在一个二元表达式或三元表达式中，该规则改为检查表达式结果。\nIf a reference is inside of a dynamic expression (e.g. CallExpression,\nYieldExpression, …), this rule ignores it.\n如果一个引用是一个动态表达式中(如 CallExpression，YieldExpression, …)，该规则将忽略这种情况。\nExamples of incorrect code for this rule:\n错误 代码示例：\nwhile (node) {\n    doSomething(node);\n}\nnode = other;\n\nfor (var j = 0; j < items.length; ++i) {\n    doSomething(items[j]);\n}\n\nwhile (node !== root) {\n    doSomething(node);\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\nwhile (node) {\n    doSomething(node);\n    node = node.parent;\n}\n\nfor (var j = 0; j < items.length; ++j) {\n    doSomething(items[j]);\n}\n\n// OK, the result of this binary expression is changed in this loop.\nwhile (node !== root) {\n    doSomething(node);\n    node = node.parent;\n}\n\n// OK, the result of this ternary expression is changed in this loop.\nwhile (node ? A : B) {\n    doSomething(node);\n    node = node.parent;\n}\n\n// A property might be a getter which has side effect...\n// Or \"doSomething\" can modify \"obj.foo\".\nwhile (obj.foo) {\n    doSomething(obj);\n}\n\n// A function call can return various values.\nwhile (check(obj)) {\n    doSomething(obj);\n}\n\n\nWhen Not To Use It\nIf you don’t want to notified about references inside of loop conditions, then it’s safe to disable this rule.\n如果你不想收到关于循环条件中引用的通知，可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-2.\n该规则在 ESLint 2.0.0-alpha-2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unmodified-loop-condition",
                "disable": false
            },
            {
                "real_name": "no-unneeded-ternary",
                "display_name": "no-unneeded-ternary",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止可以表达为更简单结构的三元操作符 (no-unneeded-ternary)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow ternary operators when simpler alternatives exist (no-unneeded-ternary)\n禁止可以表达为更简单结构的三元操作符 (no-unneeded-ternary)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIt’s a common mistake in JavaScript to use a conditional expression to select between two Boolean values instead of using ! to convert the test to a Boolean.\nHere are some examples:\n在 JavaScript 中一个常见的错误是使用一个条件表达式在两个 Boolean 值之间进行选择而不是使用！将测试条件转为一个 Boolean 类型。如以下示例：\n// Bad\nvar isYes = answer === 1 ? true : false;\n\n// Good\nvar isYes = answer === 1;\n\n\n// Bad\nvar isNo = answer === 1 ? false : true;\n\n// Good\nvar isNo = answer !== 1;\n\n\nThis rule disallows the use of ‘Boolean’ literals inside conditional expressions.\n该规则禁止在条件表达式中使用布尔型字面量。\nAnother common mistake is using a single variable as both the conditional test and the consequent. In such cases, the logical OR can be used to provide the same functionality.\nHere is an example:\n另一个常见的错误是使用单个变量同时作为测试条件和结果。在这种情况下，逻辑或操作符可以实现相同的功能。如下所示：\n// Bad\nvar foo = bar ? bar : 1;\n\n// Good\nvar foo = bar || 1;\n\n\nRule Details\nThis rule disallow ternary operators when simpler alternatives exist.\n当有更简单的结构可以代替三元操作符时，该规则禁止使用三元操作符。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-unneeded-ternary: \"error\"*/\n\nvar a = x === 2 ? true : false;\n\nvar a = x ? true : false;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-unneeded-ternary: \"error\"*/\n\nvar a = x === 2 ? \"Yes\" : \"No\";\n\nvar a = x !== false;\n\nvar a = x ? \"Yes\" : \"No\";\n\nvar a = x ? y : x;\n\nvar a = x ? x : 1;\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"defaultAssignment\": true (default) allows the conditional expression as a default assignment pattern\n\"defaultAssignment\": true (默认) 允许条件表达式作为默认的赋值模式\n\"defaultAssignment\": false disallows the conditional expression as a default assignment pattern\n\"defaultAssignment\": false 禁止条件表达式作为默认的赋值模式\n\ndefaultAssignment\nExamples of additional incorrect code for this rule with the { \"defaultAssignment\": false } option:\n选项 { \"defaultAssignment\": false } 的 错误 代码示例：\n/*eslint no-unneeded-ternary: [\"error\", { \"defaultAssignment\": false }]*/\n\nvar a = x ? x : 1;\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with unnecessary complexity in conditional expressions.\n如果你不关心条件表达式中不必要的复杂性的话，你可以关闭此规则。\nRelated Rules\n\nno-ternary\nno-nested-ternary\n\nVersion\nThis rule was introduced in ESLint 0.21.0.\n该规则在 ESLint 0.21.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unneeded-ternary",
                "disable": false
            },
            {
                "real_name": "no-unreachable",
                "display_name": "no-unreachable",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow unreachable code after return, throw, continue, and break statements (no-unreachable).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow unreachable code after return, throw, continue, and break statements (no-unreachable)\n禁止在 return、throw、continue 和 break 语句后出现不可达代码 (no-unreachable)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nBecause the return, throw, break, and continue statements unconditionally exit a block of code, any statements after them cannot be executed. Unreachable statements are usually a mistake.\n因为 return、throw、continue 和 break 语句无条件地退出代码块，其之后的任何语句都不会被执行。不可达语句通常是个错误。\nfunction fn() {\n    x = 1;\n    return x;\n    x = 3; // this will never execute\n}\n\n\nRule Details\nThis rule disallows unreachable code after return, throw, continue, and break statements.\n该规则禁止在 return、throw、continue 和 break 语句后出现不可达代码。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-unreachable: \"error\"*/\n\nfunction foo() {\n    return true;\n    console.log(\"done\");\n}\n\nfunction bar() {\n    throw new Error(\"Oops!\");\n    console.log(\"done\");\n}\n\nwhile(value) {\n    break;\n    console.log(\"done\");\n}\n\nthrow new Error(\"Oops!\");\nconsole.log(\"done\");\n\nfunction baz() {\n    if (Math.random() < 0.5) {\n        return;\n    } else {\n        throw new Error();\n    }\n    console.log(\"done\");\n}\n\nfor (;;) {}\nconsole.log(\"done\");\n\n\nExamples of correct code for this rule, because of JavaScript function and variable hoisting:\n正确 代码示例，因为 JavaScript 函数和变量提升：\n/*eslint no-unreachable: \"error\"*/\n\nfunction foo() {\n    return bar();\n    function bar() {\n        return 1;\n    }\n}\n\nfunction bar() {\n    return x;\n    var x;\n}\n\nswitch (foo) {\n    case 1:\n        break;\n        var x;\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unreachable",
                "disable": false
            },
            {
                "real_name": "no-unsafe-finally",
                "display_name": "no-unsafe-finally",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在 finally 语句块中出现控制流语句 (no-unsafe-finally)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow control flow statements in finally blocks (no-unsafe-finally)\n禁止在 finally 语句块中出现控制流语句 (no-unsafe-finally)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nJavaScript suspends the control flow statements of try and catch blocks until the execution of finally block finishes. So, when return, throw, break, or continue is used in finally, control flow statements inside try and catch are overwritten, which is considered as unexpected behavior. Such as:\nJavaScript 暂停 try 和 catch 语句块中的控制流语句，直到 finally 语句块执行完毕。所以，当 return、throw、break 和 continue 出现在 finally  中时， try 和 catch 语句块中的控制流语句将被覆盖，这被认为是意外的行为。比如：\n// We expect this function to return 1;\n(() => {\n    try {\n        return 1; // 1 is returned but suspended until finally block ends\n    } catch(err) {\n        return 2;\n    } finally {\n        return 3; // 3 is returned before 1, which we did not expect\n    }\n})();\n\n// > 3\n\n\n// We expect this function to throw an error, then return\n(() => {\n    try {\n        throw new Error(\"Try\"); // error is thrown but suspended until finally block ends\n    } finally {\n        return 3; // 3 is returned before the error is thrown, which we did not expect\n    }\n})();\n\n// > 3\n\n\n// We expect this function to throw Try(...) error from the catch block\n(() => {\n    try {\n        throw new Error(\"Try\")\n    } catch(err) {\n        throw err; // The error thrown from try block is caught and rethrown\n    } finally {\n        throw new Error(\"Finally\"); // Finally(...) is thrown, which we did not expect\n    }\n})();\n\n// > Uncaught Error: Finally(...)\n\n\n// We expect this function to return 0 from try block.\n(() => {\n  label: try {\n    return 0; // 1 is returned but suspended until finally block ends\n  } finally {\n    break label; // It breaks out the try-finally block, before 0 is returned.\n  }\n  return 1;\n})();\n\n// > 1\n\n\nRule Details\nThis rule disallows return, throw, break, and continue statements inside finally blocks. It allows indirect usages, such as in function or class definitions.\n该规则禁止在 finally 语句块中出现 return、throw、break 和 continue 语句。它允许间接使用，比如在 function 或 class 的定义中。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        return 3;\n    }\n};\n\n\n/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        throw new Error;\n    }\n};\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        console.log(\"hola!\");\n    }\n};\n\n\n/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function() {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        let a = function() {\n            return \"hola!\";\n        }\n    }\n};\n\n\n/*eslint no-unsafe-finally: \"error\"*/\nlet foo = function(a) {\n    try {\n        return 1;\n    } catch(err) {\n        return 2;\n    } finally {\n        switch(a) {\n            case 1: {\n                console.log(\"hola!\")\n                break;\n            }\n        }\n    }\n};\n\n\nWhen Not To Use It\nIf you want to allow control flow operations in finally blocks, you can turn this rule off.\n如果你想允许在 finally 语句块中出现控制流语操作，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.9.0.\n该规则在 ESLint 2.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unsafe-finally",
                "disable": false
            },
            {
                "real_name": "no-unsafe-negation",
                "display_name": "no-unsafe-negation",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow negating the left operand of relational operators (no-unsafe-negation)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow negating the left operand of relational operators (no-unsafe-negation)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nJust as developers might type -a + b when they mean -(a + b) for the negative of a sum, they might type !key in object by mistake when they almost certainly mean !(key in object) to test that a key is not in an object. !obj instanceof Ctor is similar.\nRule Details\nThis rule disallows negating the left operand of Relational Operators.\nRelational Operators are:\n\nin operator.\ninstanceof operator.\n\nExamples of incorrect code for this rule:\n/*eslint no-unsafe-negation: \"error\"*/\n\nif (!key in object) {\n    // operator precedence makes it equivalent to (!key) in object\n    // and type conversion makes it equivalent to (key ? \"false\" : \"true\") in object\n}\n\nif (!obj instanceof Ctor) {\n    // operator precedence makes it equivalent to (!obj) instanceof Ctor\n    // and it equivalent to always false since boolean values are not objects.\n}\n\n\nExamples of correct code for this rule:\n/*eslint no-unsafe-negation: \"error\"*/\n\nif (!(key in object)) {\n    // key is not in object\n}\n\nif (!(obj instanceof Ctor)) {\n    // obj is not an instance of Ctor\n}\n\nif((\"\" + !key) in object) {\n    // make operator precedence and type conversion explicit\n    // in a rare situation when that is the intended meaning\n}\n\n\nOptions\nNothing.\nWhen Not To Use It\nIf you don’t want to notify unsafe logical negations, then it’s safe to disable this rule.\nVersion\nThis rule was introduced in ESLint 3.3.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unsafe-negation",
                "disable": false
            },
            {
                "real_name": "no-unused-expressions",
                "display_name": "no-unused-expressions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止未使用过的表达式 (no-unused-expressions)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Unused Expressions (no-unused-expressions)\n禁止未使用过的表达式 (no-unused-expressions)\nAn unused expression which has no effect on the state of the program indicates a logic error.\n未使用过的表达式在程序中不起任何作用，通常是个逻辑错误。\nFor example, n + 1; is not a syntax error, but it might be a typing mistake where a programmer meant an assignment statement n += 1; instead.\n例如，n + 1; 不是语法错误，但它可能是程序员的书写错误，原本是想写赋值语句 n += 1;。\nRule Details\nThis rule aims to eliminate unused expressions which have no effect on the state of the program.\n此规则的目的在于消除未使用过的表达式，它们在程序中不起任何作用。\nThis rule does not apply to function calls or constructor calls with the new operator, because they could have side effects on the state of the program.\n该规则不适用于使用 new 操作符的函数或构造函数调用，因为它们可能会有副作用。\nvar i = 0;\nfunction increment() { i += 1; }\nincrement(); // return value is unused, but i changed as a side effect\n\nvar nThings = 0;\nfunction Thing() { nThings += 1; }\nnew Thing(); // constructed object is unused, but nThings changed as a side effect\n\n\nThis rule does not apply to directives (which are in the form of literal string expressions such as \"use strict\"; at the beginning of a script, module, or function).\n该规则不适用于指令（比如在脚本（模块或函数）顶部的 \"use strict\";）。\nSequence expressions (those using a comma, such as a = 1, b = 2) are always considered unused unless their return value is assigned or used in a condition evaluation, or a function call is made with the sequence expression value.\n连续的表达式（使用逗号分隔，比如 a = 1, b = 2）总是被认为为被使用过的，除非它们的返回值被赋值给一个变量或被用在条件表达式中或函数调用。\nOptions\nThis rule, in its default state, does not require any arguments. If you would like to enable one or more of the following you may pass an object with the options set as follows:\n此规则在默认情况下，不需要任何参数。如果你想要开启一个或者更多的设置你可以通过一个如下所示的选项对象实现：\n\nallowShortCircuit set to true will allow you to use short circuit evaluations in your expressions (Default: false).\nallowShortCircuit 设置为 true 将允许你在表达式中使用逻辑短路求值。（默认为 false）\nallowTernary set to true will enable you to use ternary operators in your expressions similarly to short circuit evaluations (Default: false).\nallowTernary 设置为 true 将允许你在表达式中使用类似逻辑短路求值的三元运算符。（默认为 false）。\nallowTaggedTemplates set to true will enable you to use tagged template literals in your expressions (Default: false).\nallowTaggedTemplates 设置为 true 将允许你在表达式中使用带标签的模板字面量 (默认: false)。\n\nThese options allow unused expressions only if all of the code paths either directly change the state (for example, assignment statement) or could have side effects (for example, function call).\n这些选项只有在所有的代码路径要么直接改变状态（比如，赋值语句）或可以有 副作用（例如，函数调用）才允许出现未使用过的表达式。\nExamples of incorrect code for the default { \"allowShortCircuit\": false, \"allowTernary\": false } options:\n默认选项 { \"allowShortCircuit\": false, \"allowTernary\": false } 的 错误 代码示例：\n/*eslint no-unused-expressions: \"error\"*/\n\n0\n\nif(0) 0\n\n{0}\n\nf(0), {}\n\na && b()\n\na, b()\n\nc = a, b;\n\na() && function namedFunctionInExpressionContext () {f();}\n\n(function anIncompleteIIFE () {});\n\ninjectGlobal`body{ color: red; }`\n\n\n\nNote that one or more string expression statements (with or without semi-colons) will only be considered as unused if they are not in the beginning of a script, module, or function (alone and uninterrupted by other statements). Otherwise, they will be treated as part of a “directive prologue”, a section potentially usable by JavaScript engines. This includes “strict mode” directives.\n注意，一个或多个字符串表达式（无论有无分号）如果不是在脚本、模块或函数（单独的，不被其它语句打断的）顶部都被认为是未使用过的。否则，它们将被视为对 JavaScript 引擎很有用的指令的一部分。包括严格模式指令：\n\"use strict\";\n\"use asm\"\n\"use stricter\";\n\"use babel\"\n\"any other strings like this in the prologue\";\n\n\nExamples of correct code for the default { \"allowShortCircuit\": false, \"allowTernary\": false } options:\n默认选项 { \"allowShortCircuit\": false, \"allowTernary\": false } 的 正确 代码示例：\n/*eslint no-unused-expressions: \"error\"*/\n\n{} // In this context, this is a block statement, not an object literal\n\n{myLabel: someVar} // In this context, this is a block statement with a label and expression, not an object literal\n\nfunction namedFunctionDeclaration () {}\n\n(function aGenuineIIFE () {}());\n\nf()\n\na = 0\n\nnew C\n\ndelete a.b\n\nvoid a\n\n\nallowShortCircuit\nExamples of incorrect code for the { \"allowShortCircuit\": true } option:\n选项 { \"allowShortCircuit\": true } 的 错误 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }]*/\n\na || b\n\n\nExamples of correct code for the { \"allowShortCircuit\": true } option:\n选项 { \"allowShortCircuit\": true } 的 正确 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }]*/\n\na && b()\na() || (b = c)\n\n\nallowTernary\nExamples of incorrect code for the { \"allowTernary\": true } option:\n选项 { \"allowTernary\": true } 的 错误 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowTernary\": true }]*/\n\na ? b : 0\na ? b : c()\n\n\nExamples of correct code for the { \"allowTernary\": true } option:\n选项 { \"allowTernary\": true } 的 正确 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowTernary\": true }]*/\n\na ? b() : c()\na ? (b = c) : d()\n\n\nallowShortCircuit and allowTernary\nExamples of correct code for the { \"allowShortCircuit\": true, \"allowTernary\": true } options:\n选项 { \"allowShortCircuit\": true, \"allowTernary\": true } 的 正确 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true, \"allowTernary\": true }]*/\n\na ? b() || (c = d) : e()\n\n\nallowTaggedTemplates\nExamples of incorrect code for the { \"allowTaggedTemplates\": true } option:\n选项 { \"allowTaggedTemplates\": true } 的 错误 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowTaggedTemplates\": true }]*/\n\n`some untagged template string`;\n\n\nExamples of correct code for the { \"allowTaggedTemplates\": true } option:\n选项 { \"allowTaggedTemplates\": true } 的 正确 代码示例：\n/*eslint no-unused-expressions: [\"error\", { \"allowTaggedTemplates\": true }]*/\n\ntag`some tagged template string`;\n\n\nVersion\nThis rule was introduced in ESLint 0.1.0.\n该规则在 ESLint 0.1.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unused-expressions",
                "disable": false
            },
            {
                "real_name": "no-unused-labels",
                "display_name": "no-unused-labels",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用未使用过的标签 (no-unused-labels)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Unused Labels (no-unused-labels)\n禁用未使用过的标签 (no-unused-labels)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nLabels that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring.\n只声明却没有使用的标签可能是由于不完全的重构造成的错误。\nOUTER_LOOP:\nfor (const student of students) {\n    if (checkScores(student.scores)) {\n        continue;\n    }\n    doSomething(student);\n}\n\n\nIn this case, probably removing OUTER_LOOP: had been forgotten.\nSuch labels take up space in the code and can lead to confusion by readers.\n在这个例子中，可能是忘记了移除 OUTER_LOOP: 。这样的标签不仅占据代码空间，而且会使读者感到迷惑。\nRule Details\nThis rule is aimed at eliminating unused labels.\n该规则旨在消除未使用过的标签。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-unused-labels: \"error\"*/\n\nA: var foo = 0;\n\nB: {\n    foo();\n}\n\nC:\nfor (let i = 0; i < 10; ++i) {\n    foo();\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-unused-labels: \"error\"*/\n\nA: {\n    if (foo()) {\n        break A;\n    }\n    bar();\n}\n\nB:\nfor (let i = 0; i < 10; ++i) {\n    if (foo()) {\n        break B;\n    }\n    bar();\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unused labels, then it’s safe to disable this rule.\n如果你不想收到关于未使用的标签的通知，禁用此规则即可。\nRelated Rules\n\nno-extra-label\nno-labels\nno-label-var\n\nVersion\nThis rule was introduced in ESLint 2.0.0-rc.0.\n该规则在 ESLint 2.0.0-rc.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unused-labels",
                "disable": false
            },
            {
                "real_name": "no-unused-vars",
                "display_name": "no-unused-vars",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止未使用过的变量 (no-unused-vars)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Unused Variables (no-unused-vars)\n禁止未使用过的变量 (no-unused-vars)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nVariables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers.\n已声明的变量在代码里未被使用过，就像是由于不完整的重构而导致的遗漏错误。这样的变量增加了代码量，并且混淆读者。\nRule Details\nThis rule is aimed at eliminating unused variables, functions, and parameters of functions.\n此规则旨在消除未使用过的变量，方法和方法中的参数名，当发现这些存在，发出警告。\nA variable is considered to be used if any of the following are true:\n符合下面条件的变量被认为是可以使用的:\n\nIt represents a function that is called (doSomething())\n作为回调函数\nIt is read (var y = x)\n被读取 (var y = x)\nIt is passed into a function as an argument (doSomething(x))\n传入函数中作为argument对象(doSomething(x))\nIt is read inside of a function that is passed to another function (doSomething(function() { foo(); }))\n在传入到另一个函数的函数中被读取\n\nA variable is not considered to be used if it is only ever assigned to (var x = 5) or declared.\n一个变量仅仅是被赋值为 (var x = 5) 或者是被声明过，则认为它是没被考虑使用。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-unused-vars: \"error\"*/\n/*global some_unused_var*/\n\n// It checks variables you have defined as global\nsome_unused_var = 42;\n\nvar x;\n\n// Write-only variables are not considered as used.\nvar y = 10;\ny = 5;\n\n// A read for a modification of itself is not considered as used.\nvar z = 0;\nz = z + 1;\n\n// By default, unused arguments cause warnings.\n(function(foo) {\n    return 5;\n})();\n\n// Unused recursive functions also cause warnings.\nfunction fact(n) {\n    if (n < 2) return 1;\n    return n * fact(n - 1);\n}\n\n// When a function definition destructures an array, unused entries from the array also cause warnings.\nfunction getY([x, y]) {\n    return y;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-unused-vars: \"error\"*/\n\nvar x = 10;\nalert(x);\n\n// foo is considered used here\nmyFunc(function foo() {\n    // ...\n}.bind(this));\n\n(function(foo) {\n    return foo;\n})();\n\nvar myFunc;\nmyFunc = setTimeout(function() {\n    // myFunc is considered used\n    myFunc();\n}, 50);\n\n// Only the second argument from the descructured array is used.\nfunction getY([, y]) {\n    return y;\n}\n\n\nexported\nIn environments outside of CommonJS or ECMAScript modules, you may use var to create a global variable that may be used by other scripts. You can use the /* exported variableName */ comment block to indicate that this variable is being exported and therefore should not be considered unused.\n在 CommonJS 或者 ECMAScript 模块外部，可用 var创建一个被其他模块代码引用的变量。你也可以用 /* exported variableName */ 注释快表明此变量已导出，因此此变量不会被认为是未被使用过的。\nNote that /* exported */ has no effect for any of the following:\n需要注意的是 /* exported */ 在下列情况下是无效的：\n\nwhen the environment is node or commonjs\nnode 或 commonjs 环境\nwhen parserOptions.sourceType is module\nparserOptions.sourceType 是 module\nwhen ecmaFeatures.globalReturn is true\necmaFeatures.globalReturn 为 true\n\nThe line comment // exported variableName will not work as exported is not line-specific.\n行注释 // exported variableName 将不起作用，因为 exported 不是特定于行的。\nExamples of correct code for /* exported variableName */ operation:\n选项 /* exported variableName */ 的 正确 代码示例：\n/* exported global_var */\n\nvar global_var = 42;\n\n\nOptions\nThis rule takes one argument which can be a string or an object. The string settings are the same as those of the vars property (explained below).\n该规则接受一个字符串或者对像类型的参数。字符串设置正如同 vars 一样（如下所示）。\nBy default this rule is enabled with all option for variables and after-used for arguments.\n配置项的默认值，变量选项是 all，参数的选项是 after-used 。\n{\n    \"rules\": {\n        \"no-unused-vars\": [\"error\", { \"vars\": \"all\", \"args\": \"after-used\", \"ignoreRestSiblings\": false }]\n    }\n}\n\n\nvars\nThe vars option has two settings:\n此配置项有两个值：\n\nall checks all variables for usage, including those in the global scope. This is the default setting.\nall 检测所有变量，包括全局环境中的变量。这是默认值。\nlocal checks only that locally-declared variables are used but will allow global variables to be unused.\nlocal 仅仅检测本作用域中声明的变量是否使用，允许不使用全局环境中的变量。\n\nvars: local\nExamples of correct code for the { \"vars\": \"local\" } option:\n选项 { \"vars\": \"local\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"vars\": \"local\" }]*/\n/*global some_unused_var */\n\nsome_unused_var = 42;\n\n\nvarsIgnorePattern\nThe varsIgnorePattern option specifies exceptions not to check for usage: variables whose names match a regexp pattern. For example, variables whose names contain ignored or Ignored.\n这个 varsIgnorePattern 选项指定了不需要检测的异常：变量名称匹配正则模式。例如，变量的名字包含 ignored 或者 Ignored。\nExamples of correct code for the { \"varsIgnorePattern\": \"[iI]gnored\" } option:\n选项 { \"varsIgnorePattern\": \"[iI]gnored\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"[iI]gnored\" }]*/\n\nvar firstVarIgnored = 1;\nvar secondVar = 2;\nconsole.log(secondVar);\n\n\nargs\nThe args option has three settings:\nargs 选项有三个值：\n\nafter-used - only the last argument must be used. This allows you, for instance, to have two named parameters to a function and as long as you use the second argument, ESLint will not warn you about the first. This is the default setting.\nafter-used - 最后一个参数必须使用。如：一个函数有两个参数，你使用了第二个参数，ESLint 不会报警告。\nall - all named arguments must be used.\nall - 所有命名参数必须使用。\nnone - do not check arguments.\nnone - 不检查参数。\n\nargs: after-used\nExamples of incorrect code for the default { \"args\": \"after-used\" } option:\n选项 { \"args\": \"after-used\" } 的 错误 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"args\": \"after-used\" }]*/\n\n// 1 error\n// \"baz\" is defined but never used\n(function(foo, bar, baz) {\n    return bar;\n})();\n\n\nExamples of correct code for the default { \"args\": \"after-used\" } option:\n选项 { \"args\": \"after-used\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", {\"args\": \"after-used\"}]*/\n\n(function(foo, bar, baz) {\n    return baz;\n})();\n\n\nargs: all\nExamples of incorrect code for the { \"args\": \"all\" } option:\n选项 { \"args\": \"all\" } 的 错误 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"args\": \"all\" }]*/\n\n// 2 errors\n// \"foo\" is defined but never used\n// \"baz\" is defined but never used\n(function(foo, bar, baz) {\n    return bar;\n})();\n\n\nargs: none\nExamples of correct code for the { \"args\": \"none\" } option:\n选项 { \"args\": \"none\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"args\": \"none\" }]*/\n\n(function(foo, bar, baz) {\n    return bar;\n})();\n\n\nignoreRestSiblings\nThe ignoreRestSiblings option is a boolean (default: false). Using a Rest Property it is possible to “omit” properties from an object, but by default the sibling properties are marked as “unused”. With this option enabled the rest property’s siblings are ignored.\nignoreRestSiblings 选项是个布尔类型 (默认: false)。使用 Rest 属性 可能会“省略”对象中的属性，但是默认情况下，其兄弟属性被标记为 “unused”。使用该选项可以使 rest 属性的兄弟属性被忽略。\nExamples of correct code for the { \"ignoreRestSiblings\": true } option:\n选项 { \"ignoreRestSiblings\": true } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"ignoreRestSiblings\": true }]*/\n// 'type' is ignored because it has a rest property sibling.\nvar { type, ...coords } = data;\n\n\nargsIgnorePattern\nThe argsIgnorePattern option specifies exceptions not to check for usage: arguments whose names match a regexp pattern. For example, variables whose names begin with an underscore.\nargsIgnorePattern 选项指定排除不需要检测：这些参数的名字符合正则匹配。例如，下划线开头的变量。\nExamples of correct code for the { \"argsIgnorePattern\": \"^_\" } option:\n选项 { \"argsIgnorePattern\": \"^_\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nfunction foo(x, _y) {\n    return x + 1;\n}\nfoo();\n\n\ncaughtErrors\nThe caughtErrors option is used for catch block arguments validation.\ncaughtErrors 选项被用来验证 catch 块的参数。\nIt has two settings:\n它有两个设置：\n\nnone - do not check error objects. This is the default setting.\nnone - 不检查错误对象。这是默认设置。\nall - all named arguments must be used.\nall - 所有参数必须被使用。\n\ncaughtErrors: none\nNot specifying this rule is equivalent of assigning it to none.\n没有指定该规则，相当于将它赋值为 none。\nExamples of correct code for the { \"caughtErrors\": \"none\" } option:\n选项 { \"caughtErrors\": \"none\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"none\" }]*/\n\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}\n\n\ncaughtErrors: all\nExamples of incorrect code for the { \"caughtErrors\": \"all\" } option:\n选项 { \"caughtErrors\": \"all\" } 的 错误 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"all\" }]*/\n\n// 1 error\n// \"err\" is defined but never used\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}\n\n\ncaughtErrorsIgnorePattern\nThe caughtErrorsIgnorePattern option specifies exceptions not to check for usage: catch arguments whose names match a regexp pattern. For example, variables whose names begin with a string ‘ignore’.\ncaughtErrorsIgnorePattern 选项指定例外情况，不会检查匹配正则表达式 catch 参数。例如，名字以 ‘ignore’ 开头的变量。\nExamples of correct code for the { \"caughtErrorsIgnorePattern\": \"^ignore\" } option:\n选项 { \"caughtErrorsIgnorePattern\": \"^ignore\" } 的 正确 代码示例：\n/*eslint no-unused-vars: [\"error\", { \"caughtErrorsIgnorePattern\": \"^ignore\" }]*/\n\ntry {\n    //...\n} catch (ignoreErr) {\n    console.error(\"errors\");\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unused variables or function arguments, you can safely turn this rule off.\n如果你不想受到关于未使用的变量或函数参数的通知，你可关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-unused-vars",
                "disable": false
            },
            {
                "real_name": "no-use-before-define",
                "display_name": "no-use-before-define",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止定义前使用 (no-use-before-define)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Early Use (no-use-before-define)\n禁止定义前使用 (no-use-before-define)\nIn JavaScript, prior to ES6, variable and function declarations are hoisted to the top of a scope, so it’s possible to use identifiers before their formal declarations in code. This can be confusing and some believe it is best to always declare variables and functions before using them.\n在 ES6 标准之前的 JavaScript 中，某个作用域中变量和函数的声明会被提前到作用域顶部，所以可能存在这种情况：此变量在声明前被使用。这会扰乱读者，部分人认为最好的做法是使用变量之前先声明变量。\nIn ES6, block-level bindings (let and const) introduce a “temporal dead zone” where a ReferenceError will be thrown with any attempt to access the variable before its declaration.\n在 ES6 中，块级绑定 (let 和 const) 引入 “temporal dead zone”，当企图使用未声明的变量会抛出 ReferenceError。\nRule Details\nThis rule will warn when it encounters a reference to an identifier that has not yet been declared.\n当使用一个还未声明的标示符是会报警告。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-use-before-define: \"error\"*/\n/*eslint-env es6*/\n\nalert(a);\nvar a = 10;\n\nf();\nfunction f() {}\n\nfunction g() {\n    return b;\n}\nvar b = 1;\n\n// With blockBindings: true\n{\n    alert(c);\n    let c = 1;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-use-before-define: \"error\"*/\n/*eslint-env es6*/\n\nvar a;\na = 10;\nalert(a);\n\nfunction f() {}\nf(1);\n\nvar b = 1;\nfunction g() {\n    return b;\n}\n\n// With blockBindings: true\n{\n    let C;\n    c++;\n}\n\n\nOptions\n{\n    \"no-use-before-define\": [\"error\", { \"functions\": true, \"classes\": true }]\n}\n\n\n\nfunctions (boolean) -\nThe flag which shows whether or not this rule checks function declarations.\nIf this is true, this rule warns every reference to a function before the function declaration.\nOtherwise, ignores those references.\nFunction declarations are hoisted, so it’s safe.\nDefault is true.\nfunctions (boolean) -\n这个参数表示该规则是否要检测函数的声明。\n如果参数是 true，该规则会在引用一个未提前声明的函数时发出警报。\n否则，忽略这些引用。因为函数声明作用域会被提升，所以这样做是安全的。\n参数默认值是 true。\nclasses (boolean) -\nThe flag which shows whether or not this rule checks class declarations of upper scopes.\nIf this is true, this rule warns every reference to a class before the class declaration.\nOtherwise, ignores those references if the declaration is in upper function scopes.\nClass declarations are not hoisted, so it might be danger.\nDefault is true.\nclasses (boolean) -\n这个参数表示是否要检测上层作用域中的类声明。\n如果参数是 true，该规则会在引用一个未提前声明的类时发出警报。\n否则，该规则会忽略对上层作用域中的类声明的引用。\n因为类声明作用域不会被提升，所以这样做可能是危险的。\n参数默认是 true。\nvariables (boolean) -\nThis flag determines whether or not the rule checks variable declarations in upper scopes.\nIf this is true, the rule warns every reference to a variable before the variable declaration.\nOtherwise, the rule ignores a reference if the declaration is in an upper scope, while still reporting the reference if it’s in the same scope as the declaration.\nDefault is true.\nvariables (boolean) -\n这个参数表示是否要在上层作用域内检测变量声明。\n如果参数是 true，该规则会在引用一个未提前声明的变量时发出警报。\n否则，该规则会忽略在上层作用域中变量声明的引用，然而仍然会报告对同一作用域中的变量声明的引用。\n参数默认是 true。\n\nThis rule accepts \"nofunc\" string as an option.\n\"nofunc\" is the same as { \"functions\": false, \"classes\": true }.\n该规则接受 \"nofunc\" 字符串作为一个选项。\n\"nofunc\" 和 { \"functions\": false, \"classes\": true } 的效果相同。\nfunctions\nExamples of correct code for the { \"functions\": false } option:\n选项{ \"functions\": false }的 正确 代码示例：\n/*eslint no-use-before-define: [\"error\", { \"functions\": false }]*/\n\nf();\nfunction f() {}\n\n\nclasses\nExamples of incorrect code for the { \"classes\": false } option:\n选项{ \"classes\": false }的 错误 代码示例：\n/*eslint no-use-before-define: [\"error\", { \"classes\": false }]*/\n/*eslint-env es6*/\n\nnew A();\nclass A {\n}\n\n\nExamples of correct code for the { \"classes\": false } option:\n选项{ \"classes\": false }的 正确 代码示例：\n/*eslint no-use-before-define: [\"error\", { \"classes\": false }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    return new A();\n}\n\nclass A {\n}\n\n\nvariables\nExamples of incorrect code for the { \"variables\": false } option:\n选项 { \"variables\": false } 的 错误 代码示例：\n/*eslint no-use-before-define: [\"error\", { \"variables\": false }]*/\n\nconsole.log(foo);\nvar foo = 1;\n\n\nExamples of correct code for the { \"variables\": false } option:\n选项 { \"variables\": false } 的 正确 代码示例：\n/*eslint no-use-before-define: [\"error\", { \"variables\": false }]*/\n\nfunction baz() {\n    console.log(foo);\n}\n\nvar foo = 1;\n\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-use-before-define",
                "disable": false
            },
            {
                "real_name": "no-useless-call",
                "display_name": "no-useless-call",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用不必要的 .call() 和 .apply()（no-useless-call）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow unnecessary .call() and .apply(). (no-useless-call)\n禁用不必要的 .call() 和 .apply()（no-useless-call）\nThe function invocation can be written by Function.prototype.call() and Function.prototype.apply().\nBut Function.prototype.call() and Function.prototype.apply() are slower than the normal function invocation.\n函数的调用可以写成 Function.prototype.call() 和 Function.prototype.apply()，但是 Function.prototype.call() 和 Function.prototype.apply() 比正常的函数调用效率低。\nRule Details\nThis rule is aimed to flag usage of Function.prototype.call() and Function.prototype.apply() that can be replaced with the normal function invocation.\n此规则的目的在于标记出可以被正常函数调用所替代的 Function.prototype.call() 和 Function.prototype.apply() 的使用。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-useless-call: \"error\"*/\n\n// These are same as `foo(1, 2, 3);`\nfoo.call(undefined, 1, 2, 3);\nfoo.apply(undefined, [1, 2, 3]);\nfoo.call(null, 1, 2, 3);\nfoo.apply(null, [1, 2, 3]);\n\n// These are same as `obj.foo(1, 2, 3);`\nobj.foo.call(obj, 1, 2, 3);\nobj.foo.apply(obj, [1, 2, 3]);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-useless-call: \"error\"*/\n\n// The `this` binding is different.\nfoo.call(obj, 1, 2, 3);\nfoo.apply(obj, [1, 2, 3]);\nobj.foo.call(null, 1, 2, 3);\nobj.foo.apply(null, [1, 2, 3]);\nobj.foo.call(otherObj, 1, 2, 3);\nobj.foo.apply(otherObj, [1, 2, 3]);\n\n// The argument list is variadic.\nfoo.apply(undefined, args);\nfoo.apply(null, args);\nobj.foo.apply(obj, args);\n\n\nKnown Limitations\nThis rule compares code statically to check whether or not thisArg is changed.\nSo if the code about thisArg is a dynamic expression, this rule cannot judge correctly.\n此规则通过静态地对比代码检测 thisArg 是否被改变。所以如果 thisArg 是个动态表达式，此规则不能作出正确的判断。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-useless-call: \"error\"*/\n\na[i++].foo.call(a[i++], 1, 2, 3);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-useless-call: \"error\"*/\n\na[++i].foo.call(a[i], 1, 2, 3);\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unnecessary .call() and .apply(), you can safely disable this rule.\n如果你不想收到关于不必要的 .call() 和 .apply()的通知，你可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-call",
                "disable": false
            },
            {
                "real_name": "no-useless-catch",
                "display_name": "no-useless-catch",
                "severity": "error",
                "category": "convention",
                "rule_title": "Disallow unnecessary catch clauses (no-useless-catch)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "The \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.A catch clause that only rethrows the original error is redundant, and has no effect on the runtime behavior of the program. These redundant clauses can be a source of confusion and code bloat, so it’s better to disallow these unnecessary catch clauses.",
                "owner": null,
                "labels": [],
                "description": "The \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.A catch clause that only rethrows the original error is redundant, and has no effect on the runtime behavior of the program. These redundant clauses can be a source of confusion and code bloat, so it’s better to disallow these unnecessary catch clauses.",
                "disable": false
            },
            {
                "real_name": "no-useless-computed-key",
                "display_name": "no-useless-computed-key",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow unnecessary computed property keys on objects (no-useless-computed-key)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow unnecessary computed property keys on objects (no-useless-computed-key)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nIt’s unnecessary to use computed properties with literals such as:\nvar foo = {[\"a\"]: \"b\"};\n\n\nThe code can be rewritten as:\nvar foo = {\"a\": \"b\"};\n\n\nRule Details\nThis rule disallows unnecessary usage of computed property keys.\nExamples\nExamples of incorrect code for this rule:\n/*eslint no-useless-computed-key: \"error\"*/\n/*eslint-env es6*/\n\nvar a = { ['0']: 0 };\nvar a = { ['0+1,234']: 0 };\nvar a = { [0]: 0 };\nvar a = { ['x']: 0 };\nvar a = { ['x']() {} };\n\n\nExamples of correct code for this rule:\n/*eslint no-useless-computed-key: \"error\"*/\n\nvar c = { 'a': 0 };\nvar c = { 0: 0 };\nvar a = { x() {} };\nvar c = { a: 0 };\nvar c = { '0+1,234': 0 };\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unnecessary computed property keys, you can safely disable this rule.\nVersion\nThis rule was introduced in ESLint 2.9.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-computed-key",
                "disable": false
            },
            {
                "real_name": "no-useless-concat",
                "display_name": "no-useless-concat",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止没有必要的字符拼接 (no-useless-concat)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow unnecessary concatenation of strings (no-useless-concat)\n禁止没有必要的字符拼接 (no-useless-concat)\nIt’s unnecessary to concatenate two strings together, such as:\n把两个字符拼接在一起是没有必要的，比如：\nvar foo = \"a\" + \"b\";\n\n\nThis code is likely the result of refactoring where a variable was removed from the concatenation (such as \"a\" + b + \"b\"). In such a case, the concatenation isn’t important and the code can be rewritten as:\n这段代码像是在拼接中移除了某个变量的重构造成的（比如 \"a\" + b + \"b\"）。在这种情况下，拼接不是重要的，代码可以被写成如下形式:\nvar foo = \"ab\";\n\n\nRule Details\nThis rule aims to flag the concatenation of 2 literals when they could be combined into a single literal. Literals can be strings or template literals.\n此规则目的在于标记可以组合成单个字面量的两个字面量的拼接。字面量可以是字符串或者模板字面量。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-useless-concat: \"error\"*/\n/*eslint-env es6*/\n\n// these are the same as \"10\"\nvar a = `some` + `string`;\nvar a = '1' + '0';\nvar a = '1' + `0`;\nvar a = `1` + '0';\nvar a = `1` + `0`;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-useless-concat: \"error\"*/\n\n// when a non string is included\nvar c = a + b;\nvar c = '1' + a;\nvar a = 1 + '1';\nvar c = 1 - 2;\n// when the string concatenation is multiline\nvar c = \"foo\" +\n    \"bar\";\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unnecessary string concatenation, you can safely disable this rule.\n如果不想收到关于不必要的字符拼接的通知，你可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 1.3.0.\n该规则在 ESLint 1.3.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-concat",
                "disable": false
            },
            {
                "real_name": "no-useless-constructor",
                "display_name": "no-useless-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用不必要的构造函数 (no-useless-constructor)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "ES2015 为没有指定构造函数的类提供了默认构造函数。",
                "owner": null,
                "labels": [],
                "description": "Disallow unnecessary constructor (no-useless-constructor)\n禁用不必要的构造函数 (no-useless-constructor)\nES2015 provides a default class constructor if one is not specified. As such, it is unnecessary to provide an empty constructor or one that simply delegates into its parent class, as in the following examples:\nES2015 为没有指定构造函数的类提供了默认构造函数。因此，没有必要提供一个空的构造函数或只是简单的调用父类这样的构造函数，如下面的列子所示：\nclass A {\n    constructor () {\n    }\n}\n\nclass A extends B {\n    constructor (value) {\n      super(value);\n    }\n}\n\n\nRule Details\nThis rule flags class constructors that can be safely removed without changing how the class works.\n该规则标记可以被安全移除但又不改变类的行为的构造函数。\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-useless-constructor: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor () {\n    }\n}\n\nclass A extends B {\n    constructor (...args) {\n      super(...args);\n    }\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-useless-constructor: \"error\"*/\n\nclass A { }\n\nclass A {\n    constructor () {\n        doSomething();\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super('foo');\n    }\n}\n\nclass A extends B {\n    constructor() {\n        super();\n        doSomething();\n    }\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unnecessary constructors, you can safely disable this rule.\n如果你不想收到关于不必要的构造函数的通知，你也可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.1.\n该规则在 ESLint 2.0.0-beta.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-constructor",
                "disable": false
            },
            {
                "real_name": "no-useless-escape",
                "display_name": "no-useless-escape",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用不必要的转义 (no-useless-escape)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow unnecessary escape usage (no-useless-escape)\n禁用不必要的转义 (no-useless-escape)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nEscaping non-special characters in strings, template literals, and regular expressions doesn’t have any effect, as demonstrated in the following example:\n对字符串、模板字面量和正则表达式中的常规字符进行转义，不会对结果产生任何影响，例如：\nlet foo = \"hol\\a\"; // > foo = \"hola\"\nlet bar = `${foo}\\!`; // > bar = \"hola!\"\nlet baz = /\\:/ // same functionality with /:/\n\n\nRule Details\nThis rule flags escapes that can be safely removed without changing behavior.\n该规则标记在不改变代码行为的情况下可以安全移除的转义。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-useless-escape: \"error\"*/\n\n\"\\'\";\n'\\\"';\n\"\\#\";\n\"\\e\";\n`\\\"`;\n`\\\"${foo}\\\"`;\n`\\#{foo}`;\n/\\!/;\n/\\@/;\n\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-useless-escape: \"error\"*/\n\n\"\\\"\";\n'\\'';\n\"\\x12\";\n\"\\u00a9\";\n\"\\371\";\n\"xs\\u2111\";\n`\\``;\n`\\${${foo}\\}`;\n`$\\{${foo}\\}`;\n/\\\\/g;\n/\\t/g;\n/\\w\\$\\*\\^\\./;\n\n\n\nWhen Not To Use It\nIf you don’t want to be notified about unnecessary escapes, you can safely disable this rule.\n如果你不想收到关于不必要的转义字符的通知，可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.5.0.\n该规则在 ESLint 2.5.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-escape",
                "disable": false
            },
            {
                "real_name": "no-useless-rename",
                "display_name": "no-useless-rename",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow renaming import, export, and destructured assignments to the same name (no-useless-rename)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow renaming import, export, and destructured assignments to the same name (no-useless-rename)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nES2015 allows for the renaming of references in import and export statements as well as destructuring assignments. This gives programmers a concise syntax for performing these operations while renaming these references:\nimport { foo as bar } from \"baz\";\nexport { foo as bar };\nlet { foo: bar } = baz;\n\n\nWith this syntax, it is possible to rename a reference to the same name. This is a completely redundant operation, as this is the same as not renaming at all. For example, this:\nimport { foo as foo } from \"bar\";\nexport { foo as foo };\nlet { foo: foo } = bar;\n\n\nis the same as:\nimport { foo } from \"bar\";\nexport { foo };\nlet { foo } = bar;\n\n\nRule Details\nThis rule disallows the renaming of import, export, and destructured assignments to the same name.\nOptions\nThis rule allows for more fine-grained control with the following options:\n\nignoreImport: When set to true, this rule does not check imports\nignoreExport: When set to true, this rule does not check exports\nignoreDestructuring: When set to true, this rule does not check destructuring assignments\n\nBy default, all options are set to false:\n\"no-useless-rename\": [\"error\", {\n    \"ignoreDestructuring\": false,\n    \"ignoreImport\": false,\n    \"ignoreExport\": false\n}]\n\n\nExamples of incorrect code for this rule by default:\n/*eslint no-useless-rename: \"error\"*/\n\nimport { foo as foo } from \"bar\";\nexport { foo as foo };\nexport { foo as foo } from \"bar\";\nlet { foo: foo } = bar;\nlet { 'foo': foo } = bar;\nfunction foo({ bar: bar }) {}\n({ foo: foo }) => {}\n\n\nExamples of correct code for this rule by default:\n/*eslint no-useless-rename: \"error\"*/\n\nimport * as foo from \"foo\";\nimport { foo } from \"bar\";\nimport { foo as bar } from \"baz\";\n\nexport { foo };\nexport { foo as bar };\nexport { foo as bar } from \"foo\";\n\nlet { foo } = bar;\nlet { foo: bar } = baz;\nlet { [foo]: foo } = bar;\n\nfunction foo({ bar }) {}\nfunction foo({ bar: baz }) {}\n\n({ foo }) => {}\n({ foo: bar }) => {}\n\n\nExamples of correct code for this rule with { ignoreImport: true }:\n/*eslint no-useless-rename: [\"error\", { ignoreImport: true }]*/\n\nimport { foo as foo } from \"bar\";\n\n\nExamples of correct code for this rule with { ignoreExport: true }:\n/*eslint no-useless-rename: [\"error\", { ignoreExport: true }]*/\n\nexport { foo as foo };\nexport { foo as foo } from \"bar\";\n\n\nExamples of correct code for this rule with { ignoreDestructuring: true }:\n/*eslint no-useless-rename: [\"error\", { ignoreDestructuring: true }]*/\n\nlet { foo: foo } = bar;\nfunction foo({ bar: bar }) {}\n({ foo: foo }) => {}\n\n\nWhen Not To Use It\nYou can safely disable this rule if you do not care about redundantly renaming import, export, and destructuring assignments.\nCompatibility\n\nJSCS: disallowIdenticalDestructuringNames\n\nVersion\nThis rule was introduced in ESLint 2.11.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-rename",
                "disable": false
            },
            {
                "real_name": "no-useless-return",
                "display_name": "no-useless-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow redundant return statements (no-useless-return)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow redundant return statements (no-useless-return)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nA return; statement with nothing after it is redundant, and has no effect on the runtime behavior of a function. This can be confusing, so it’s better to disallow these redundant statements.\nRule Details\nThis rule aims to report redundant return statements.\nExamples of incorrect code for this rule:\n/* eslint no-useless-return: \"error\" */\n\nfunction foo() { return; }\n\nfunction foo() {\n  doSomething();\n  return;\n}\n\nfunction foo() {\n  if (condition) {\n    bar();\n    return;\n  } else {\n    baz();\n  }\n}\n\nfunction foo() {\n  switch (bar) {\n    case 1:\n      doSomething();\n    default:\n      doSomethingElse();\n      return;\n  }\n}\n\n\n\nExamples of correct code for this rule:\n/* eslint no-useless-return: \"error\" */\n\nfunction foo() { return 5; }\n\nfunction foo() {\n  return doSomething();\n}\n\nfunction foo() {\n  if (condition) {\n    bar();\n    return;\n  } else {\n    baz();\n  }\n  qux();\n}\n\nfunction foo() {\n  switch (bar) {\n    case 1:\n      doSomething();\n      return;\n    default:\n      doSomethingElse();\n  }\n}\n\nfunction foo() {\n  for (const foo of bar) {\n    return;\n  }\n}\n\n\n\nWhen Not To Use It\nIf you don’t care about disallowing redundant return statements, you can turn off this rule.\nVersion\nThis rule was introduced in ESLint 3.9.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-useless-return",
                "disable": false
            },
            {
                "real_name": "no-var",
                "display_name": "no-var",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require let or const instead of var (no-var).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require let or const instead of var (no-var)\n要求使用 let 或 const 而不是 var\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the let\nand const keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\nECMAScript 6 允许程序员使用 let 和 const 关键字在块级作用域而非函数作用域下声明变量。块级作用域在很多其他编程语言中很普遍，能帮助程序员避免错误，例如：\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n\n\nRule Details\nThis rule is aimed at discouraging the use of var and encouraging the use of const or let instead.\n该规则旨在阻止 var 的使用，推荐使用 const 或 let。\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n\n\nWhen Not To Use It\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from var to let is too costly.\n除了非 ES6 环境外，那些现有 Javascript 项目开始在他们的代码库中引入 ES6 的，如果从 var 迁移到 let 代价高的话，可能并不适用于此规则。\nVersion\nThis rule was introduced in ESLint 0.12.0.\n该规则在 ESLint 0.12.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-var",
                "disable": false
            },
            {
                "real_name": "no-void",
                "display_name": "no-void",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用void操作符 (no-void)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow use of the void operator. (no-void)\n禁止使用void操作符 (no-void)\nThe void operator takes an operand and returns undefined: void expression will evaluate expression and return undefined. It can be used to ignore any side effects expression may produce:\nvoid 操作符需要一个运算对象并且返回 undefined：void expression 会计算 expression 并返回 undefined。它可以用来忽略 expression 产生的任何副作用。\nThe common case of using void operator is to get a “pure” undefined value as prior to ES5 the undefined variable was mutable:\n使用 void 操作符的通常情况是要得到一个单纯的 undefined 值，因为之前的 ES5 undefined 值是可变的:\n// will always return undefined\n(function(){\n    return void 0;\n})();\n\n// will return 1 in ES3 and undefined in ES5+\n(function(){\n    undefined = 1;\n    return undefined;\n})();\n\n// will throw TypeError in ES5+\n(function(){\n    'use strict';\n    undefined = 1;\n})();\n\n\nAnother common case is to minify code as void 0 is shorter than undefined:\n另外一种情况是缩减代码量因为 void 0 比 undefined 要简短:\nfoo = void 0;\nfoo = undefined;\n\n\nWhen used with IIFE (immediately-invoked function expression), void can be used to force the function keyword to be treated as an expression instead of a declaration:\n当在 IIFE (立即调用函数表达式)时被使用时,void 可以用来强制 function 关键字被当作成表达式而不是声明:\nvar foo = 1;\nvoid function(){ foo = 1; }() // will assign foo a value of 1\n+function(){ foo = 1; }() // same as above\n\n\nfunction(){ foo = 1; }() // will throw SyntaxError\n\n\nSome code styles prohibit void operator, marking it as non-obvious and hard to read.\n一些代码风格禁止使用 void 操作符，把它标记为不明显的，难以阅读的。\nRule Details\nThis rule aims to eliminate use of void operator.\n此规则目的在于排除使用 void 操作符。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-void: \"error\"*/\n\nvoid foo\n\nvar foo = void bar();\n\n\nWhen Not To Use It\nIf you intentionally use the void operator then you can disable this rule.\n如果你有意使用 void 操作符，可以禁用此规则。\nFurther Reading\n\nMozilla Developer Network\nBad Parts: Appendix B - JavaScript: The Good Parts by Douglas Crockford\n\nRelated Rules\n\nno-undef-init\nno-undefined\n\nVersion\nThis rule was introduced in ESLint 0.8.0.\n该规则在 ESLint 0.8.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-void",
                "disable": false
            },
            {
                "real_name": "no-warning-comments",
                "display_name": "no-warning-comments",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用警告注释 (no-warning-comments)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow Warning Comments (no-warning-comments)\n禁用警告注释 (no-warning-comments)\nDevelopers often add comments to code which is not complete or needs review. Most likely you want to fix or review the code, and then remove the comment, before you consider the code to be production ready.\n开发者经常给代码添加注释，标明哪些没有完成或需要审查。在你认为代码可以发布之前，你很有可能想修复或审查代码，然后删除注释。\n// TODO: do something\n// FIXME: this is not a good idea\n\n\nRule Details\nThis rule reports comments that include any of the predefined terms specified in its configuration.\n该规则报告含有配置中预定义的项的注释。\nOptions\nThis rule has an options object literal:\n该规则有一个对象选项：\n\n\"terms\": optional array of terms to match. Defaults to [\"todo\", \"fixme\", \"xxx\"]. Terms are matched case-insensitive and as whole words: fix would match FIX but not fixing. Terms can consist of multiple words: really bad idea.\n\"terms\": 可选的供匹配的数组。默认为 [\"todo\", \"fixme\", \"xxx\"]。它们是大写敏感的并且匹配整个词： fix 匹配 FIX 但不匹配 fixing。也可以由多个单词组成：really bad idea。\n\"location\": optional string that configures where in your comments to check for matches. Defaults to \"start\". The other value is match anywhere in comments.\n\"location\": 可选的字符串用于在注释中检测匹配。默认为 \"start\"。另一个值是anywhere。\n\nExample of incorrect code for the default { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" } options:\n默认选项 { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" } 的 错误 代码示例：\n/*eslint no-warning-comments: \"error\"*/\n\nfunction callback(err, results) {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  // TODO\n}\n\n\nExample of correct code for the default { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" } options:\n默认选项 { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" } 的 正确 代码示例：\n/*eslint no-warning-comments: \"error\"*/\n\nfunction callback(err, results) {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  // NOT READY FOR PRIME TIME\n  // but too bad, it is not a predefined warning term\n}\n\n\nterms and location\nExamples of incorrect code for the { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" } options:\n选项 { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" } 的 错误 代码示例：\n/*eslint no-warning-comments: [\"error\", { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" }]*/\n\n// TODO: this\n// todo: this too\n// Even this: TODO\n/* /*\n * The same goes for this TODO comment\n * Or a fixme\n * as well as any other term\n */\n\n\nExamples of correct code for the { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" } options:\n选项 { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" } 的 正确 代码示例：\n/*eslint no-warning-comments: [\"error\", { \"terms\": [\"todo\", \"fixme\", \"any other term\"], \"location\": \"anywhere\" }]*/\n\n// This is to do\n// even not any other    term\n// any other terminal\n/*\n * The same goes for block comments\n * with any other interesting term\n * or fix me this\n */\n\n\nWhen Not To Use It\n\nIf you have a large code base that was not developed with a policy to not use such warning terms, you might get hundreds of warnings / errors which might be counter-productive if you can’t fix all of them (e.g. if you don’t get the time to do it) as you might overlook other warnings / errors or get used to many of them and don’t pay attention on it anymore.\n如果你有一个大型的代码库，没有使用这种警告条款进行开发，在非生产环境下，如果你不能修复所有这些问题，你可能会得到数以百计的警告或错误（例如，如果你没有时间去做），你可能会忽略其他警告或错误，或者习惯了，不在过多关注它们了。\nSame reason as the point above: You shouldn’t configure terms that are used very often (e.g. central parts of the native language used in your comments).\n正如上面说那样：你不应配置那些经常被使用的条款（例如，在你的注释中使用本地语言）。\n\nVersion\nThis rule was introduced in ESLint 0.4.4.\n该规则在 ESLint 0.4.4 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-warning-comments",
                "disable": false
            },
            {
                "real_name": "no-whitespace-before-property",
                "display_name": "no-whitespace-before-property",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止属性前有空白 (no-whitespace-before-property)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow whitespace before properties (no-whitespace-before-property)\n禁止属性前有空白 (no-whitespace-before-property)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript allows whitespace between objects and their properties. However, inconsistent spacing can make code harder to read and can lead to errors.\nJavaScript 允许在对象和它们的属性中间存在空白。然而，不一致的空格会使代码难以阅读，而且可能导致出错。\nfoo. bar .baz . quz\n\n\nRule Details\nThis rule disallows whitespace around the dot or before the opening bracket before properties of objects if they are on the same line. This rule allows whitespace when the object and property are on separate lines, as it is common to add newlines to longer chains of properties:\n该规则禁止在点号周围或对象属性之前的左括号前出现空白。如果对象和属性不在同一行上，这种情况，该规则允许使用空白，因为对级联的属性增加新行是一种很普遍的行为。\nfoo\n  .bar()\n  .baz()\n  .qux()\n\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-whitespace-before-property: \"error\"*/\n\nfoo [bar]\n\nfoo. bar\n\nfoo .bar\n\nfoo. bar. baz\n\nfoo. bar()\n  .baz()\n\nfoo\n  .bar(). baz()\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-whitespace-before-property: \"error\"*/\n\nfoo.bar\n\nfoo[bar]\n\nfoo[ bar ]\n\nfoo.bar.baz\n\nfoo\n  .bar().baz()\n\nfoo\n  .bar()\n  .baz()\n\nfoo.\n  bar().\n  baz()\n\n\nWhen Not To Use It\nTurn this rule off if you do not care about allowing whitespace around the dot or before the opening bracket before properties of objects if they are on the same line.\n如果你并不关心点号操作符周围的空白或者在与对象属性在同一行的左括号之前的空白，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.1.\n该规则在 ESLint 2.0.0-beta.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-whitespace-before-property",
                "disable": false
            },
            {
                "real_name": "no-with",
                "display_name": "no-with",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用 with 语句 (no-with)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow with statements (no-with)\n禁用 with 语句 (no-with)\nThe with statement is potentially problematic because it adds members of an object to the current scope, making it impossible to tell what a variable inside the block actually refers to.\nwith 是潜在的问题，因为它会在当前的域中增加对象成员，使得区分实际块中的变量指的是什么变的不可能。\nRule Details\nThis rule disallows with statements.\n此规则目的在于排除 with 语句。\nIf ESLint parses code in strict mode, the parser (instead of this rule) reports the error.\n如果 ESLint 在严格模式下解析代码，解析器（不是该规则）将报告这样的错误。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint no-with: \"error\"*/\n\nwith (point) {\n    r = Math.sqrt(x * x + y * y); // is r a member of point?\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint no-with: \"error\"*/\n/*eslint-env es6*/\n\nconst r = ({x, y}) => Math.sqrt(x * x + y * y);\n\n\nWhen Not To Use It\nIf you intentionally use with statements then you can disable this rule.\n如果你有意要使用 with 语句，可以禁用此规则。\nFurther Reading\n\nwith Statement Considered Harmful\n\nVersion\nThis rule was introduced in ESLint 0.0.2.\n该规则在 ESLint 0.0.2 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/no-with",
                "disable": false
            },
            {
                "real_name": "nonblock-statement-body-position",
                "display_name": "nonblock-statement-body-position",
                "severity": "error",
                "category": "correctness",
                "rule_title": "enforce the location of single-line statements (nonblock-statement-body-position)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce the location of single-line statements (nonblock-statement-body-position)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nWhen writing if, else, while, do-while, and for statements, the body can be a single statement instead of a block. It can be useful to enforce a consistent location for these single statements.\nFor example, some developers avoid writing code like this:\nif (foo)\n  bar();\n\n\nIf another developer attempts to add baz(); to the if statement, they might mistakenly change the code to\nif (foo)\n  bar();\n  baz(); // this line is not in the `if` statement!\n\n\nTo avoid this issue, one might require all single-line if statements to appear directly after the conditional, without a linebreak:\nif (foo) bar();\n\n\nRule Details\nThis rule aims to enforce a consistent location for single-line statements.\nNote that this rule does not enforce the usage of single-line statements in general. If you would like to disallow single-line statements, use the curly rule instead.\nOptions\nThis rule accepts a string option:\n\n\"beside\" (default) disallows a newline before a single-line statement.\n\"below\" requires a newline before a single-line statement.\n\"any\" does not enforce the position of a single-line statement.\n\nAdditionally, the rule accepts an optional object option with an \"overrides\" key. This can be used to specify a location for particular statements that override the default. For example:\n\n\"beside\", { \"overrides\": { \"while\": \"below\" } } requires all single-line statements to appear on the same line as their parent, unless the parent is a while statement, in which case the single-line statement must not be on the same line.\n\"below\", { \"overrides\": { \"do\": \"any\" } } disallows all single-line statements from appearing on the same line as their parent, unless the parent is a do-while statement, in which case the position of the single-line statement is not enforced.\n\nExamples of incorrect code for this rule with the default \"beside\" option:\n/* eslint nonblock-statement-body-position: [\"error\", \"beside\"] */\n\nif (foo)\n  bar();\nelse\n  baz();\n\nwhile (foo)\n  bar();\n\nfor (let i = 1; i < foo; i++)\n  bar();\n\ndo\n  bar();\nwhile (foo)\n\n\n\nExamples of correct code for this rule with the default \"beside\" option:\n/* eslint nonblock-statement-body-position: [\"error\", \"beside\"] */\n\nif (foo) bar();\nelse baz();\n\nwhile (foo) bar();\n\nfor (let i = 1; i < foo; i++) bar();\n\ndo bar(); while (foo)\n\nif (foo) { // block statements are always allowed with this rule\n  bar();\n} else {\n  baz();\n}\n\n\nExamples of incorrect code for this rule with the \"below\" option:\n/* eslint nonblock-statement-body-position: [\"error\", \"below\"] */\n\nif (foo) bar();\nelse baz();\n\nwhile (foo) bar();\n\nfor (let i = 1; i < foo; i++) bar();\n\ndo bar(); while (foo)\n\n\nExamples of correct code for this rule with the \"below\" option:\n/* eslint nonblock-statement-body-position: [\"error\", \"below\"] */\n\nif (foo)\n  bar();\nelse\n  baz();\n\nwhile (foo)\n  bar();\n\nfor (let i = 1; i < foo; i++)\n  bar();\n\ndo\n  bar();\nwhile (foo)\n\nif (foo) {\n  // Although the second `if` statement is on the same line as the `else`, this is a very common\n  // pattern, so it's not checked by this rule.\n} else if (bar) {\n}\n\n\nExamples of incorrect code for this rule with the \"beside\", { \"overrides\": { \"while\": \"below\" } } rule:\n/* eslint nonblock-statement-body-position: [\"error\", \"beside\", { \"overrides\": { \"while\": \"below\" } }] */\n\nif (foo)\n  bar();\n\nwhile (foo) bar();\n\n\nExamples of correct code for this rule with the \"beside\", { \"overrides\": { \"while\": \"below\" } } rule:\n/* eslint nonblock-statement-body-position: [\"error\", \"beside\", { \"overrides\": { \"while\": \"below\" } }] */\n\nif (foo) bar();\n\nwhile (foo)\n  bar();\n\n\nWhen Not To Use It\nIf you’re not concerned about consistent locations of single-line statements, you should not turn on this rule. You can also disable this rule if you’re using the \"all\" option for the curly rule, because this will disallow single-line statements entirely.\nFurther Reading\n\nJSCS: requireNewlineBeforeSingleStatementsInIf\n\nVersion\nThis rule was introduced in ESLint 3.17.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/nonblock-statement-body-position",
                "disable": false
            },
            {
                "real_name": "object-curly-newline",
                "display_name": "object-curly-newline",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在花括号内使用一致的换行符 (object-curly-newline)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent line breaks inside braces (object-curly-newline)\n强制在花括号内使用一致的换行符 (object-curly-newline)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nA number of style guides require or disallow line breaks inside of object braces and other tokens.\n一些风格指南要求或禁止对象的花括号和其它符号之间出现换行符。\nRule Details\nThis rule enforces consistent line breaks inside braces of object literals or destructuring assignments.\n该规则强制花括号内使用换行符的一致性。该规则同时适用于对象字面量和解构赋值。\nOptions\nThis rule has either a string option:\n该规则有一个字符串选项\n\n\"always\" requires line breaks inside braces\n\"always\" 要求花括号内有换行符\n\"never\" disallows line breaks inside braces\n\"never\" 禁止花括号内有换行符\n\nOr an object option:\n或一个对象选项：\n\n\"multiline\": true (default) requires line breaks if there are line breaks inside properties or between properties\n\"multiline\": true (默认)如果在属性内部或属性之间有换行符，就要求有换行符\n\"minProperties\" requires line breaks if the number of properties is more than the given integer. By default, an error will also be reported if an object contains linebreaks and has fewer properties than the given integer. However, the second behavior is disabled if the consistent option is set to true\n\"minProperties\" 如果属性的数量超过了给定的数值，要求有换行符。默认情况下，如果一个对象包含换行符并且属性的数量少于给定的数量，该规则也会报错误。然而，如果设置 consistent 选项为 true，则该选项将不起作用。\n\"consistent\": true requires that either both curly braces, or neither, directly enclose newlines. Note that enabling this option will also change the behavior of the minProperties option. (See minProperties above for more information)\n\"consistent\": true 要求使用花括号，或者不使用或括号直接使用换行。注意启用该选项将改变 minProperties 选项的行为。(查看上面的 minProperties，获取更多信息)\n\nYou can specify different options for object literals and destructuring assignments:\n你可以为字面量和解构赋值指定不同的选项：\n{\n    \"object-curly-newline\": [\"error\", {\n        \"ObjectExpression\": \"always\",\n        \"ObjectPattern\": { \"multiline\": true }\n    }]\n}\n\n\n\n\"ObjectExpression\" configuration for object literals\n\"ObjectExpression\" 对象字面量的配置。\n\"ObjectPattern\" configuration for object patterns of destructuring assignments\n\"ObjectPattern\" 对象的解构赋值模式的配置。\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint object-curly-newline: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo() {\n    dosomething();\n}};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint object-curly-newline: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint object-curly-newline: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint object-curly-newline: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;\n\n\nmultiline\nExamples of incorrect code for this rule with the default { \"multiline\": true } option:\n默认选项 { \"multiline\": true } 的 错误 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"multiline\": true }]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;\n\n\nExamples of correct code for this rule with the default { \"multiline\": true } option:\n默认选项 { \"multiline\": true } 的 正确 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"multiline\": true }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;\n\n\nminProperties\nExamples of incorrect code for this rule with the { \"minProperties\": 2 } option:\n选项 { \"minProperties\": 2 } 的 错误 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"minProperties\": 2 }]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;\n\n\nExamples of correct code for this rule with the { \"minProperties\": 2 } option:\n选项 { \"minProperties\": 2 } 的 正确 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"minProperties\": 2 }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {} = obj;\nlet {f} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;\n\n\nconsistent\nExamples of incorrect code for this rule with the { \"consistent\": true } option:\n选项 { \"consistent\": true } 的 错误 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"consistent\": true }]*/\n/*eslint-env es6*/\n\nlet a = {foo: 1\n};\nlet b = {\n    foo: 1};\nlet c = {foo: 1, bar: 2\n};\nlet d = {\n    foo: 1, bar: 2};\nlet e = {foo: 1,\n    bar: 2};\nlet f = {foo: function() {\n    dosomething();\n}};\n\nlet {g\n} = obj;\nlet {\n    h} = obj;\nlet {i, j\n} = obj;\nlet {\n    k, l} = obj;\nlet {m,\n    n} = obj;\nlet {o = function() {\n    dosomething();\n}} = obj;\n\n\nExamples of correct code for this rule with the { \"consistent\": true } option:\n选项 { \"consistent\": true } 的 正确 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"consistent\": true }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {\n    foo: 1\n};\nlet d = {\n    foo: 1, bar: 2\n};\nlet e = {\n    foo: 1,\n    bar: 2\n};\nlet f = {foo: function() {dosomething();}};\nlet g = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {} = obj;\nlet {h} = obj;\nlet {i, j} = obj;\nlet {\n    k, l\n} = obj;\nlet {\n    m,\n    n\n} = obj;\nlet {o = function() {dosomething();}} = obj;\nlet {\n    p = function() {\n        dosomething();\n    }\n} = obj;\n\n\nObjectExpression and ObjectPattern\nExamples of incorrect code for this rule with the { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" } options:\n选项 { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" } 的 错误 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" }]*/\n/*eslint-env es6*/\n\nlet a = {};\nlet b = {foo: 1};\nlet c = {foo: 1, bar: 2};\nlet d = {foo: 1,\n    bar: 2};\nlet e = {foo: function() {\n    dosomething();\n}};\n\nlet {\n} = obj;\nlet {\n    f\n} = obj;\nlet {\n    g, h\n} = obj;\nlet {\n    i,\n    j\n} = obj;\nlet {\n    k = function() {\n        dosomething();\n    }\n} = obj;\n\n\nExamples of correct code for this rule with the { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" } options:\n选项 { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" } 的 正确 代码示例：\n/*eslint object-curly-newline: [\"error\", { \"ObjectExpression\": \"always\", \"ObjectPattern\": \"never\" }]*/\n/*eslint-env es6*/\n\nlet a = {\n};\nlet b = {\n    foo: 1\n};\nlet c = {\n    foo: 1, bar: 2\n};\nlet d = {\n    foo: 1,\n    bar: 2\n};\nlet e = {\n    foo: function() {\n        dosomething();\n    }\n};\n\nlet {} = obj;\nlet {f} = obj;\nlet {g, h} = obj;\nlet {i,\n    j} = obj;\nlet {k = function() {\n    dosomething();\n}} = obj;\n\n\nCompatibility\n\nJSCS: requirePaddingNewLinesInObjects and disallowPaddingNewLinesInObjects\n\nWhen Not To Use It\nIf you don’t want to enforce consistent line breaks inside braces, then it’s safe to disable this rule.\n如果你不想强制花括号内换行符的一致性，可以关闭此规则。\nRelated Rules\n\ncomma-spacing\nkey-spacing\nobject-curly-spacing\nobject-property-newline\n\nVersion\nThis rule was introduced in ESLint 2.12.0.\n该规则在 ESLint 2.12.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/object-curly-newline",
                "disable": false
            },
            {
                "real_name": "object-curly-spacing",
                "display_name": "object-curly-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在花括号中使用一致的空格 (object-curly-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent spacing inside braces (object-curly-spacing)\n强制在花括号中使用一致的空格 (object-curly-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhile formatting preferences are very personal, a number of style guides require\nor disallow spaces between curly braces in the following situations:\n虽然格式化首选项都非常个人化，大量的风格指南要求或禁止在下列情况下的花括号之间有空格：\n// simple object literals\nvar obj = { foo: \"bar\" };\n\n// nested object literals\nvar obj = { foo: { zoo: \"bar\" } };\n\n// destructuring assignment (EcmaScript 6)\nvar { x, y } = y;\n\n// import/export declarations (EcmaScript 6)\nimport { foo } from \"bar\";\nexport { foo };\n\n\nRule Details\nThis rule enforce consistent spacing inside braces of object literals, destructuring assignments, and import/export specifiers.\n该规则强制在对象字面量、解构赋值 和 import/export 说明符的花括号中使用一致的空格。\nOptions\nThis rule has two options, a string option and an object option.\n该规则有两个选项，一个是字符串，一个是对象。\nString option:\n字符串选项：\n\n\"never\" (default) disallows spacing inside of braces\n\"never\" (默认) 不允许花括号中有空格\n\"always\" requires spacing inside of braces (except {})\n\"always\" 要求花括号内有空格 (除了 {})\n\nObject option:\n对象选项：\n\n\"arraysInObjects\": true requires spacing inside of braces of objects beginning and/or ending with an array element (applies when the first option is set to never)\n\"arraysInObjects\": true 要求以数组元素开始或结尾的对象的花括号中有空格 (当第一个选项为 never 时生效)\n\"arraysInObjects\": false disallows spacing inside of braces of objects beginning and/or ending with an array element (applies when the first option is set to always)\n\"arraysInObjects\": false 禁止以数组元素开始或结尾的对象的花括号中有空格 (当第一个选项为 always 时生效)\n\"objectsInObjects\": true requires spacing inside of braces of objects beginning and/or ending with an object element (applies when the first option is set to never)\n\"objectsInObjects\": true 要求以对象元素开始或结尾的对象的花括号中有空格 (当第一个选项为 never 时生效)\n\"objectsInObjects\": false disallows spacing inside of braces of objects beginning and/or ending with an object element (applies when the first option is set to always)\n\"objectsInObjects\": false 禁止以对象元素开始或结尾的对象的花括号中有空格 (当第一个选项为 always 时生效)\n\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 错误 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"never\"]*/\n\nvar obj = { 'foo': 'bar' };\nvar obj = {'foo': 'bar' };\nvar obj = { baz: {'foo': 'qux'}, bar};\nvar obj = {baz: { 'foo': 'qux'}, bar};\nvar {x } = y;\nimport { foo } from 'bar';\n\n\nExamples of correct code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 正确 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"never\"]*/\n\nvar obj = {'foo': 'bar'};\nvar obj = {'foo': {'bar': 'baz'}, 'qux': 'quxx'};\nvar obj = {\n  'foo': 'bar'\n};\nvar obj = {'foo': 'bar'\n};\nvar obj = {\n  'foo':'bar'};\nvar obj = {};\nvar {x} = y;\nimport {foo} from 'bar';\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"always\"]*/\n\nvar obj = {'foo': 'bar'};\nvar obj = {'foo': 'bar' };\nvar obj = { baz: {'foo': 'qux'}, bar};\nvar obj = {baz: { 'foo': 'qux' }, bar};\nvar obj = {'foo': 'bar'\n};\nvar obj = {\n  'foo':'bar'};\nvar {x} = y;\nimport {foo } from 'bar';\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"always\"]*/\n\nvar obj = {};\nvar obj = { 'foo': 'bar' };\nvar obj = { 'foo': { 'bar': 'baz' }, 'qux': 'quxx' };\nvar obj = {\n  'foo': 'bar'\n};\nvar { x } = y;\nimport { foo } from 'bar';\n\n\narraysInObjects\nExamples of additional correct code for this rule with the \"never\", { \"arraysInObjects\": true } options:\n选项 \"never\", { \"arraysInObjects\": true } 的 正确 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"never\", { \"arraysInObjects\": true }]*/\n\nvar obj = {\"foo\": [ 1, 2 ] };\nvar obj = {\"foo\": [ \"baz\", \"bar\" ] };\n\n\nExamples of additional correct code for this rule with the \"always\", { \"arraysInObjects\": false } options:\n选项 \"always\", { \"arraysInObjects\": false } 的 正确 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"always\", { \"arraysInObjects\": false }]*/\n\nvar obj = { \"foo\": [ 1, 2 ]};\nvar obj = { \"foo\": [ \"baz\", \"bar\" ]};\n\n\nobjectsInObjects\nExamples of additional correct code for this rule with the \"never\", { \"objectsInObjects\": true } options:\n选项 \"never\", { \"objectsInObjects\": true } 的 正确 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"never\", { \"objectsInObjects\": true }]*/\n\nvar obj = {\"foo\": {\"baz\": 1, \"bar\": 2} };\n\n\nExamples of additional correct code for this rule with the \"always\", { \"objectsInObjects\": false } options:\n选项 \"always\", { \"objectsInObjects\": false } 的 正确 代码示例：\n/*eslint object-curly-spacing: [\"error\", \"always\", { \"objectsInObjects\": false }]*/\n\nvar obj = { \"foo\": { \"baz\": 1, \"bar\": 2 }};\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of spacing between curly braces.\n如果你并不关心花括号之间空格的一致性，可以关闭此规则。\nRelated Rules\n\ncomma-spacing\nspace-in-parens\nspace-in-brackets (deprecated)\n\nVersion\nThis rule was introduced in ESLint 0.22.0.\n该规则在 ESLint 0.22.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/object-curly-spacing",
                "disable": false
            },
            {
                "real_name": "object-property-newline",
                "display_name": "object-property-newline",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制将对象的属性放在不同的行上 (object-property-newline)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce placing object properties on separate lines (object-property-newline)\n强制将对象的属性放在不同的行上 (object-property-newline)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhile formatting preferences are very personal, a number of style guides require that object properties be placed on separate lines for better readability.\n虽然代码风格纯属个人偏好，一些代码风格规范为了更好的可读性要求将对象的属性放在不同的行上。\nAnother argument in favor of this style is that it improves the readability of diffs when a property is changed:\n另一种赞成这种风格的观点是，当属性变化时，可以提高差异的可读性：\n// More readable\n var obj = {\n     foo: \"foo\",\n-    bar: \"bar\",\n+    bar: \"bazz\",\n     baz: \"baz\"\n };\n\n\n// Less readable\n-var obj = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n+var obj = { foo: \"foo\", bar: \"bazz\", baz: \"baz\" };\n\n\nRule Details\nThis rule aims to maintain consistency of newlines between object properties.\n本规则旨在维护对象属性之间换行一致性。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint object-property-newline: \"error\"*/\n\nvar obj = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n\nvar obj2 = {\n    foo: \"foo\", bar: \"bar\", baz: \"baz\"\n};\n\nvar obj3 = {\n    foo: \"foo\", bar: \"bar\",\n    baz: \"baz\"\n};\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint object-property-newline: \"error\"*/\n\nvar obj = {\n    foo: \"foo\",\n    bar: \"bar\",\n    baz: \"baz\"\n};\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"allowMultiplePropertiesPerLine\": true allows all keys and values to be on the same line\n\"allowMultiplePropertiesPerLine\": 当为 true 时，允许所有的 key 和 value 在同一行\n\nallowMultiplePropertiesPerLine\nExamples of additional correct code for this rule with the { \"allowMultiplePropertiesPerLine\": true } option:\n选项 { \"allowMultiplePropertiesPerLine\": true } 的 正确 代码示例：\n/*eslint object-property-newline: [\"error\", { \"allowMultiplePropertiesPerLine\": true }]*/\n\nvar obj = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n\nvar obj2 = {\n    foo: \"foo\", bar: \"bar\", baz: \"baz\"\n};\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of newlines between object properties.\n如果你并不关心对象属性之间换行的一致性，你可以关闭此规则。\nCompatibility\n\nJSCS: requireObjectKeysOnNewLine\n\nRelated Rules\n\nbrace-style\ncomma-dangle\nkey-spacing\nobject-curly-spacing\n\nVersion\nThis rule was introduced in ESLint 2.10.0.\n该规则在 ESLint 2.10.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/object-property-newline",
                "disable": false
            },
            {
                "real_name": "object-shorthand",
                "display_name": "object-shorthand",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求对象字面量简写语法 (object-shorthand)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Object Literal Shorthand Syntax (object-shorthand)\n要求对象字面量简写语法 (object-shorthand)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nEcmaScript 6 provides a concise form for defining object literal methods and properties. This\nsyntax can make defining complex object literals much cleaner.\nEcmaScript 6 提供了简写的形式去定义对象中的方法和属性。这个语法可以更清洁地定义复杂对象字面量。\nHere are a few common examples using the ES5 syntax:\n以下几个常见的例子，使用 ES5 语法：\n// properties\nvar foo = {\n    x: x,\n    y: y,\n    z: z,\n};\n\n// methods\nvar foo = {\n    a: function() {},\n    b: function() {}\n};\n\n\nNow here are ES6 equivalents:\n下面是等效的 ES6 语法：\n/*eslint-env es6*/\n\n// properties\nvar foo = {x, y, z};\n\n// methods\nvar foo = {\n    a() {},\n    b() {}\n};\n\n\nRule Details\nThis rule enforces the use of the shorthand syntax. This applies\nto all methods (including generators) defined in object literals and any\nproperties defined where the key name matches name of the assigned variable.\n该规则强制简写语法的使用。这适用于对象字面量中的所有方法（包括 generators ）以及键名与已赋值的变量名相匹配的任何属性。\nEach of the following properties would warn:\n以下的每个属性都将发出警告：\n/*eslint object-shorthand: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = {\n    w: function() {},\n    x: function *() {},\n    [y]: function() {},\n    z: z\n};\n\n\nIn that case the expected syntax would have been:\n这种情况下，期望的语法应该是这样：\n/*eslint object-shorthand: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = {\n    w() {},\n    *x() {},\n    [y]() {},\n    z\n};\n\n\nThis rule does not flag arrow functions inside of object literals.\nThe following will not warn:\n该规则不标记对象字面量中的箭头函数。下面的示例将 不发出警告：\n/*eslint object-shorthand: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = {\n    x: (y) => y\n};\n\n\nOptions\nThe rule takes an option which specifies when it should be applied. It can be set to one of the following values:\n该规则有一个选项。可以设置为下列值之一：\n\n\"always\" (default) expects that the shorthand will be used whenever possible.\n\"always\" (默认) 只要有可能，简写就应该被使用。\n\"methods\" ensures the method shorthand is used (also applies to generators).\n\"methods\" 保证方法简写被使用（同样适用于 generators ）。\n\"properties\" ensures the property shorthand is used (where the key and variable name match).\n\"properties\" 保证属性简写被使用 (键和变量名称相匹配的情况).\n\"never\" ensures that no property or method shorthand is used in any object literal.\n\"never\" 保证对象字面量中的任何属性和方法都不使用简写。\n\"consistent\" ensures that either all shorthand or all longform will be used in an object literal.\n\"consistent\" 保证对象字面量的简写或非简写一致性。\n\"consistent-as-needed\" ensures that either all shorthand or all longform will be used in an object literal, but ensures all shorthand whenever possible.\n\"consistent-as-needed\" 保证对象字面量的简写或非简写一致性，但尽可能的全部使用简写。\n\nYou can set the option in configuration like this:\n你可以在配置中这样设置：\n{\n    \"object-shorthand\": [\"error\", \"always\"]\n}\n\n\nAdditionally, the rule takes an optional object configuration:\n另外，该规则有个可选配置对象：\n\n\"avoidQuotes\": true indicates that longform syntax is preferred whenever the object key is a string literal (default: false). Note that this option can only be enabled when the string option is set to \"always\", \"methods\", or \"properties\".\n\"avoidQuotes\": true 表示对象的键是字符串时，倾向于长格式的语法。(默认: false)。注意该选项只在 \"always\"、\"methods\" 或 \"properties\" 选项下才有效。\n\"ignoreConstructors\": true can be used to prevent the rule from reporting errors for constructor functions. (By default, the rule treats constructors the same way as other functions.) Note that this option can only be enabled when the string option is set to \"always\" or \"methods\".\n\"ignoreConstructors\": true 可以用来阻止报告构造函数出现的错误。 (默认情况下，该规则把构造函数当成普通的函数。) 注意该选项只在 \"always\" 或 \"methods\" 选项下才有效。\n\"avoidExplicitReturnArrows\": true indicates that methods are preferred over explicit-return arrow functions for function properties. (By default, the rule allows either of these.) Note that this option can only be enabled when the string option is set to \"always\" or \"methods\".\n\"avoidExplicitReturnArrows\": true 表示函数属性相对于显式返回的箭头函数更倾向于方法。 (默认情况下，两者皆可)注意该选项只在 \"always\" 或 \"methods\" 选项下才有效。\n\navoidQuotes\n{\n    \"object-shorthand\": [\"error\", \"always\", { \"avoidQuotes\": true }]\n}\n\n\nExample of incorrect code for this rule with the \"always\", { \"avoidQuotes\": true } option:\n选项 \"always\", { \"avoidQuotes\": true } 的 错误 代码示例：\n/*eslint object-shorthand: [\"error\", \"always\", { \"avoidQuotes\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n    \"bar-baz\"() {}\n};\n\n\nExample of correct code for this rule with the \"always\", { \"avoidQuotes\": true } option:\n选项 \"always\", { \"avoidQuotes\": true } 的 正确 代码示例：\n/*eslint object-shorthand: [\"error\", \"always\", { \"avoidQuotes\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n    \"bar-baz\": function() {},\n    \"qux\": qux\n};\n\n\nignoreConstructors\n{\n    \"object-shorthand\": [\"error\", \"always\", { \"ignoreConstructors\": true }]\n}\n\n\nExample of correct code for this rule with the \"always\", { \"ignoreConstructors\": true } option:\n选项  \"always\", { \"ignoreConstructors\": true } 的 正确 代码示例：\n/*eslint object-shorthand: [\"error\", \"always\", { \"ignoreConstructors\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n    ConstructorFunction: function() {}\n};\n\n\navoidExplicitReturnArrows\n{\n    \"object-shorthand\": [\"error\", \"always\", { \"avoidExplicitReturnArrows\": true }]\n}\n\n\nExample of incorrect code for this rule with the \"always\", { \"avoidExplicitReturnArrows\": true } option:\n选项 \"always\", { \"avoidExplicitReturnArrows\": true } 的 错误 代码示例：\n/*eslint object-shorthand: [\"error\", \"always\", { \"avoidExplicitReturnArrows\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n  foo: (bar, baz) => {\n    return bar + baz;\n  },\n\n  qux: (foobar) => {\n    return foobar * 2;\n  }\n};\n\n\nExample of correct code for this rule with the \"always\", { \"avoidExplicitReturnArrows\": true } option:\n选项 \"always\", { \"avoidExplicitReturnArrows\": true } 的 正确 代码示例：\n/*eslint object-shorthand: [\"error\", \"always\", { \"avoidExplicitReturnArrows\": true }]*/\n/*eslint-env es6*/\n\nvar foo = {\n  foo(bar, baz) {\n    return bar + baz;\n  },\n\n  qux: foobar => foobar * 2\n};\n\n\nExample of incorrect code for this rule with the \"consistent\" option:\n选项 \"consistent\" 的 错误 代码示例：\n/*eslint object-shorthand: [2, \"consistent\"]*/\n/*eslint-env es6*/\n\nvar foo = {\n    a,\n    b: \"foo\",\n};\n\n\nExamples of correct code for this rule with the \"consistent\" option:\n选项 \"consistent\" 的 正确 代码示例：\n/*eslint object-shorthand: [2, \"consistent\"]*/\n/*eslint-env es6*/\n\nvar foo = {\n    a: a,\n    b: \"foo\"\n};\n\nvar bar = {\n    a,\n    b,\n};\n\n\nExample of incorrect code with the \"consistent-as-needed\" option, which is very similar to \"consistent\":\n选项 \"consistent-as-needed\"（ 类似于 \"consistent\"） 的 错误 代码示例：\n/*eslint object-shorthand: [2, \"consistent-as-needed\"]*/\n/*eslint-env es6*/\n\nvar foo = {\n    a: a,\n    b: b,\n};\n\n\nWhen Not To Use It\nAnyone not yet in an ES6 environment would not want to apply this rule. Others may find the terseness of the shorthand\nsyntax harder to read and may not want to encourage it with this rule.\n非 ES6 环境不适用于此规则。其他人发现简洁的简写语法更难阅读，可能不鼓励使用此规则。\nFurther Reading\nObject initializer - MDN\nVersion\nThis rule was introduced in ESLint 0.20.0.\n该规则在 ESLint 0.20.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/object-shorthand",
                "disable": false
            },
            {
                "real_name": "one-var",
                "display_name": "one-var",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制函数中的变量在一起声明或分开声明 (one-var)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce variables to be declared either together or separately in functions (one-var)\n强制函数中的变量在一起声明或分开声明 (one-var)\nVariables can be declared at any point in JavaScript code using var, let, or const. There are many styles and preferences related to the declaration of variables, and one of those is deciding on how many variable declarations should be allowed in a single function.\n变量可以在 JavaScript 的任何地方通过使用 var、let 或 const 进行声明。有很多风格和首选项都与变量声明有关，其中之一就是决定在一个方法中应该允许多少个变量声明。\nThere are two schools of thought in this regard:\n在这个方面有两个思想流派：\n\nThere should be just one variable declaration for all variables in the function. That declaration typically appears at the top of the function.\n在方法中所有的变量应该只有一个声明。这个声明通常出现在方法顶部。\nYou should use one variable declaration for each variable you want to define.\n你应该为每个你想定义的变量进行声明。\n\nFor instance:\n例如：\n// one variable declaration per function\nfunction foo() {\n    var bar, baz;\n}\n\n// multiple variable declarations per function\nfunction foo() {\n    var bar;\n    var baz;\n}\n\n\nThe single-declaration school of thought is based in pre-ECMAScript 6 behaviors, where there was no such thing as block scope, only function scope. Since all var statements are hoisted to the top of the function anyway, some believe that declaring all variables in a single declaration at the top of the function removes confusion around scoping rules.\n单一声明的思想流派是基于 ECMAScript 6 之前版本的行为，没有块作用域，只有方法作用域。由于所有的 var 语句都会被提升到函数顶部，有些人认为将所有的变量一一条语句声明在函数顶部，避免了函数范围内的混乱。\nRule Details\nThis rule enforces variables to be declared either together or separately per function ( for var) or block (for let and const) scope.\n该规则旨在强制在函数 (var) 或块 (let 和 const) 范围使用单一声明还是多条声明。\nOptions\nThis rule has one option, which can be a string option or an object option.\n该规则有一个选项，可以是字符串或对象。\nString option:\n字符串选项：\n\n\"always\" (default) requires one variable declaration per scope\n\"always\" (默认) 要求每个作用域有一个变量声明\n\"never\" requires multiple variable declarations per scope\n\"never\" 要求每个作用域有多个变量声明\n\nObject option:\n对象选项：\n\n\"var\": \"always\" requires one var declaration per function\n\"var\": \"always\" 要求每个函数有一个 var 声明\n\"var\": \"never\" requires multiple var declarations per function\n\"var\": \"never\" 要求每个函数有多个 var 声明\n\"let\": \"always\" requires one let declaration per block\n\"let\": \"always\" 要求每个块有一个 let 声明\n\"let\": \"never\" requires multiple let declarations per block\n\"let\": \"never\" 要求每个块有多个 let 声明\n\"const\": \"always\" requires one const declaration per block\n\"const\": \"always\" 要求每个块有一个 const 声明\n\"const\": \"never\" requires multiple const declarations per block\n\"const\": \"never\" 要求每个块有多个 const 声明\n\nAlternate object option:\n对象选项：\n\n\"initialized\": \"always\" requires one variable declaration for initialized variables per scope\n\"initialized\": \"always\" 要求每个作用域的初始化的变量有一个变量声明\n\"initialized\": \"never\" requires multiple variable declarations for initialized variables per scope\n\"initialized\": \"never\" 要求每个作用域的初始化的变量有多个变量声明\n\"uninitialized\": \"always\" requires one variable declaration for uninitialized variables per scope\n\"uninitialized\": \"always\" 要求每个作用域的未初始化的变量有一个变量声明\n\"uninitialized\": \"never\" requires multiple variable declarations for uninitialized variables per scope\n\"uninitialized\": \"never\" 要求每个作用域的未初始化的变量有多个变量声明\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint one-var: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    var baz;\n    let qux;\n    let norf;\n}\n\nfunction foo(){\n    const bar = false;\n    const baz = true;\n    let qux;\n    let norf;\n}\n\nfunction foo() {\n    var bar;\n\n    if (baz) {\n        var qux = true;\n    }\n}\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint one-var: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n    let qux,\n        norf;\n}\n\nfunction foo(){\n    const bar = true,\n        baz = false;\n    let qux,\n        norf;\n}\n\nfunction foo() {\n    var bar,\n        qux;\n\n    if (baz) {\n        qux = true;\n    }\n}\n\nfunction foo(){\n    let bar;\n\n    if (baz) {\n        let qux;\n    }\n}\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint one-var: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n    const bar = true,\n        baz = false;\n}\n\nfunction foo() {\n    var bar,\n        qux;\n\n    if (baz) {\n        qux = true;\n    }\n}\n\nfunction foo(){\n    let bar = true,\n        baz = false;\n}\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint one-var: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    var baz;\n}\n\nfunction foo() {\n    var bar;\n\n    if (baz) {\n        var qux = true;\n    }\n}\n\nfunction foo() {\n    let bar;\n\n    if (baz) {\n        let qux = true;\n    }\n}\n\n\nvar, let, and const\nExamples of incorrect code for this rule with the { var: \"always\", let: \"never\", const: \"never\" } option:\n选项 { var: \"always\", let: \"never\", const: \"never\" } 的 错误 代码示例：\n/*eslint one-var: [\"error\", { var: \"always\", let: \"never\", const: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar;\n    var baz;\n    let qux,\n        norf;\n}\n\nfunction foo() {\n    const bar = 1,\n          baz = 2;\n    let qux,\n        norf;\n}\n\n\nExamples of correct code for this rule with the { var: \"always\", let: \"never\", const: \"never\" } option:\n选项 { var: \"always\", let: \"never\", const: \"never\" } 的 正确 代码示例：\n/*eslint one-var: [\"error\", { var: \"always\", let: \"never\", const: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n    let qux;\n    let norf;\n}\n\nfunction foo() {\n    const bar = 1;\n    const baz = 2;\n    let qux;\n    let norf;\n}\n\n\nExamples of incorrect code for this rule with the { var: \"never\" } option:\n选项 { var: \"never\" } 的 错误 代码示例：\n/*eslint one-var: [\"error\", { var: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n}\n\n\nExamples of correct code for this rule with the { var: \"never\" } option:\n选项 { var: \"never\" } 的 正确 代码示例：\n/*eslint one-var: [\"error\", { var: \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var bar,\n        baz;\n    const bar = 1; // `const` and `let` declarations are ignored if they are not specified\n    const baz = 2;\n    let qux;\n    let norf;\n}\n\n\ninitialized and uninitialized\nExamples of incorrect code for this rule with the { \"initialized\": \"always\", \"uninitialized\": \"never\" } option:\n选项 { \"initialized\": \"always\", \"uninitialized\": \"never\" } 的 错误 代码示例：\n/*eslint one-var: [\"error\", { \"initialized\": \"always\", \"uninitialized\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var a, b, c;\n    var foo = true;\n    var bar = false;\n}\n\n\nExamples of correct code for this rule with the { \"initialized\": \"always\", \"uninitialized\": \"never\" } option:\n选项 { \"initialized\": \"always\", \"uninitialized\": \"never\" } 的 正确 代码示例：\n/*eslint one-var: [\"error\", { \"initialized\": \"always\", \"uninitialized\": \"never\" }]*/\n\nfunction foo() {\n    var a;\n    var b;\n    var c;\n    var foo = true,\n        bar = false;\n}\n\nfor (let z of foo) {\n    doSomething(z);\n}\n\nlet z;\nfor (z of foo) {\n    doSomething(z);\n}\n\n\nExamples of incorrect code for this rule with the { \"initialized\": \"never\" } option:\n选项 { \"initialized\": \"never\" } 的 错误 代码示例：\n/*eslint one-var: [\"error\", { \"initialized\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    var foo = true,\n        bar = false;\n}\n\n\nExamples of correct code for this rule with the { \"initialized\": \"never\" } option:\n选项 { \"initialized\": \"never\" } 的 正确 代码示例：\n/*eslint one-var: [\"error\", { initialized: \"never\" }]*/\n\nfunction foo() {\n    var foo = true;\n    var bar = false;\n    var a, b, c; // Uninitialized variables are ignored\n}\n\n\nCompatibility\n\nJSHint: This rule maps to the onevar JSHint rule, but allows let and const to be configured separately.\nJSCS: This rule roughly maps to disallowMultipleVarDecl\n\nVersion\nThis rule was introduced in ESLint 0.0.9.\n该规则在 ESLint 0.0.9 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/one-var",
                "disable": false
            },
            {
                "real_name": "one-var-declaration-per-line",
                "display_name": "one-var-declaration-per-line",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止在变量声明周围换行 (one-var-declaration-per-line)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow newlines around variable declarations (one-var-declaration-per-line)\n要求或禁止在变量声明周围换行 (one-var-declaration-per-line)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSome developers declare multiple var statements on the same line:\n一些开发者在同一行上声明多个变量：\nvar foo, bar, baz;\n\n\nOthers prefer to declare one var per line.\n另一些人更喜欢声明每个变量单独成行。\nvar foo,\n    bar,\n    baz;\n\n\nKeeping to one of these styles across a project’s codebase can help with maintaining code consistency.\n在整个项目中保持使用一种风格有利于保持代码一致性。\nRule Details\nThis rule enforces a consistent newlines around variable declarations. This rule ignores variable declarations inside for loop conditionals.\n该规则强制变量声明使用一致的的换行。该规则忽略 for 循环语句中的变量声明。\nOptions\nThis rule has a single string option:\n该规则有一个字符串选项，可以是：\n\n\"initializations\" (default) enforces a newline around variable initializations\n\"initializations\" (默认) 强制每个变量初始化语句换行\n\"always\" enforces a newline around variable declarations\n\"always\" 强制每个变量声明都换行\n\ninitializations\nExamples of incorrect code for this rule with the default \"initializations\" option:\n默认选项 \"initializations\" 的 错误 代码示例：\n/*eslint one-var-declaration-per-line: [\"error\", \"initializations\"]*/\n/*eslint-env es6*/\n\nvar a, b, c = 0;\n\nlet a,\n    b = 0, c;\n\n\nExamples of correct code for this rule with the default \"initializations\" option:\n默认选项 \"initializations\" 的 正确 代码示例：\n/*eslint one-var-declaration-per-line: [\"error\", \"initializations\"]*/\n/*eslint-env es6*/\n\nvar a, b;\n\nlet a,\n    b;\n\nlet a,\n    b = 0;\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint one-var-declaration-per-line: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar a, b;\n\nlet a, b = 0;\n\nconst a = 0, b = 0;\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint one-var-declaration-per-line: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar a,\n    b;\n\nlet a,\n    b = 0;\n\n\nRelated Rules\n\none-var\n\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.3.\n该规则在 ESLint 2.0.0-beta.3 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/one-var-declaration-per-line",
                "disable": false
            },
            {
                "real_name": "operator-assignment",
                "display_name": "operator-assignment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止尽可能地简化赋值操作 (operator-assignment)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow assignment operator shorthand where possible (operator-assignment)\n要求或禁止尽可能地简化赋值操作 (operator-assignment)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript provides shorthand operators that combine variable assignment and some simple mathematical operations. For example, x = x + 4 can be shortened to x += 4. The supported shorthand forms are as follows:\nJavaScript 为变量赋值和一些简单的数学运算提供了速记运算符。例如，x = x + 4 可以简化为 x += 4。支持的简化形式如下：\n Shorthand | Separate\n-----------|------------\n x += y    | x = x + y\n x -= y    | x = x - y\n x *= y    | x = x * y\n x /= y    | x = x / y\n x %= y    | x = x % y\n x <<= y   | x = x << y\n x >>= y   | x = x >> y\n x >>>= y  | x = x >>> y\n x &= y    | x = x & y\n x ^= y    | x = x ^ y\n x |= y    | x = x | y\n\n\nRule Details\nThis rule requires or disallows assignment operator shorthand where possible.\n该规则要求或禁止尽可能地简化赋值操作\nOptions\nThis rule has a single string option:\n该规则有一个字符串选项：\n\n\"always\" (default)  requires assignment operator shorthand where possible\n\"always\" (默认)  要求尽可能地简化赋值操作\n\"never\" disallows assignment operator shorthand\n\"never\" 禁止简化赋值操作\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint operator-assignment: [\"error\", \"always\"]*/\n\nx = x + y;\nx = y * x;\nx[0] = x[0] / y;\nx.y = x.y << z;\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint operator-assignment: [\"error\", \"always\"]*/\n\nx = y;\nx += y;\nx = y * z;\nx = (x * y) * z;\nx[0] /= y;\nx[foo()] = x[foo()] % 2;\nx = y + x; // `+` is not always commutative (e.g. x = \"abc\")\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint operator-assignment: [\"error\", \"never\"]*/\n\nx *= y;\nx ^= (y + z) / foo();\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint operator-assignment: [\"error\", \"never\"]*/\n\nx = x + y;\nx.y = x.y / a.b;\n\n\nWhen Not To Use It\nUse of operator assignment shorthand is a stylistic choice. Leaving this rule turned off would allow developers to choose which style is more readable on a case-by-case basis.\n使用简化的赋值操作符是一个格式上的选择。关闭此规则将允许开发者在个案的基础上选择哪种风格更具可读性。\nVersion\nThis rule was introduced in ESLint 0.10.0.\n该规则在 ESLint 0.10.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/operator-assignment",
                "disable": false
            },
            {
                "real_name": "operator-linebreak",
                "display_name": "operator-linebreak",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制操作符使用一致的换行符风格 (operator-linebreak)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce consistent linebreak style for operators (operator-linebreak)\n强制操作符使用一致的换行符风格 (operator-linebreak)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhen a statement is too long to fit on a single line, line breaks are generally inserted next to the operators separating expressions. The first style coming to mind would be to place the operator at the end of the line, following the English punctuation rules.\n当一条语句太长不能放在一行时，换行符一般插入到分离表达式的操作符后面。第一种想到的风格是把操作符放在行末，紧跟在英文标点符号规则之后。\nvar fullHeight = borderTop +\n                 innerHeight +\n                 borderBottom;\n\n\nSome developers find that placing operators at the beginning of the line makes the code more readable.\n一些开发者发现，将操作符放在行首位置使代码更具可读性。\nvar fullHeight = borderTop\n               + innerHeight\n               + borderBottom;\n\n\nRule Details\nThis rule enforces a consistent linebreak style for operators.\n该规则旨在强制一个特定的换行符风格。\nOptions\nThis rule has one option, which can be a string option or an object option.\n该规则有一个可选项，可以是字符串或对象：\nString option:\n字符串选项：\n\n\"after\" requires linebreaks to be placed after the operator\n\"after\" 要求把换行符放在操作符后面\n\"before\" requires linebreaks to be placed before the operator\n\"before\" 要求把换行符放在操作符前面\n\"none\" disallows linebreaks on either side of the operator\n\"none\" 禁止在操作前后有换行符\n\nObject option:\n对象选项：\n\n\"overrides\" overrides the global setting for specified operators\n\"overrides\" 覆盖对指定的操作的全局设置\n\nThe default configuration is \"after\", { \"overrides\": { \"?\": \"before\", \":\": \"before\" } }\n默认配置为 \"after\", { \"overrides\": { \"?\": \"before\", \":\": \"before\" } }\nafter\nExamples of incorrect code for this rule with the default \"after\" option:\n默认选项 \"after\" 的 错误 代码示例：\n/*eslint operator-linebreak: [\"error\", \"after\"]*/\n\nfoo = 1\n+\n2;\n\nfoo = 1\n    + 2;\n\nfoo\n    = 5;\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;\n\n\nExamples of correct code for this rule with the default \"after\" option:\n默认选项 \"after\" 的 正确 代码示例：\n/*eslint operator-linebreak: [\"error\", \"after\"]*/\n\nfoo = 1 + 2;\n\nfoo = 1 +\n      2;\n\nfoo =\n    5;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nanswer = everything ?\n  42 :\n  foo;\n\n\nbefore\nExamples of incorrect code for this rule with the \"before\" option:\n选项 \"before\" 的 错误 代码示例：\n/*eslint operator-linebreak: [\"error\", \"before\"]*/\n\nfoo = 1 +\n      2;\n\nfoo =\n    5;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nanswer = everything ?\n  42 :\n  foo;\n\n\nExamples of correct code for this rule with the \"before\" option:\n选项 \"before\" 的 正确 代码示例：\n/*eslint operator-linebreak: [\"error\", \"before\"]*/\n\nfoo = 1 + 2;\n\nfoo = 1\n    + 2;\n\nfoo\n    = 5;\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;\n\n\nnone\nExamples of incorrect code for this rule with the \"none\" option:\n选项 \"none\" 的 错误 代码示例：\n/*eslint operator-linebreak: [\"error\", \"none\"]*/\n\nfoo = 1 +\n      2;\n\nfoo = 1\n    + 2;\n\nif (someCondition ||\n    otherCondition) {\n}\n\nif (someCondition\n    || otherCondition) {\n}\n\nanswer = everything\n  ? 42\n  : foo;\n\nanswer = everything ?\n  42 :\n  foo;\n\n\nExamples of correct code for this rule with the \"none\" option:\n选项 \"none\" 的 正确 代码示例：\n/*eslint operator-linebreak: [\"error\", \"none\"]*/\n\nfoo = 1 + 2;\n\nfoo = 5;\n\nif (someCondition || otherCondition) {\n}\n\nanswer = everything ? 42 : foo;\n\n\noverrides\nExamples of additional correct code for this rule with the { \"overrides\": { \"+=\": \"before\" } } option:\n选项 { \"overrides\": { \"+=\": \"before\" } } 的 正确 代码示例：\n/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"+=\": \"before\" } }]*/\n\nvar thing\n  += 'thing';\n\n\nExamples of additional correct code for this rule with the { \"overrides\": { \"?\": \"ignore\", \":\": \"ignore\" } } option:\n选项 { \"overrides\": { \"?\": \"ignore\", \":\": \"ignore\" } } 的 正确 代码示例：\n/*eslint operator-linebreak: [\"error\", \"after\", { \"overrides\": { \"?\": \"ignore\", \":\": \"ignore\" } }]*/\n\nanswer = everything ?\n  42\n  : foo;\n\nanswer = everything\n  ?\n  42\n  :\n  foo;\n\n\nWhen Not To Use It\nIf your project will not be using a common operator line break style, turn this rule off.\n如果你的项目不使用一种通用的换行符风格，可以关闭此规则。\nRelated Rules\n\ncomma-style\n\nVersion\nThis rule was introduced in ESLint 0.19.0.\n该规则在 ESLint 0.19.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/operator-linebreak",
                "disable": false
            },
            {
                "real_name": "padded-blocks",
                "display_name": "padded-blocks",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止块内填充 (padded-blocks)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow padding within blocks (padded-blocks)\n要求或禁止块内填充 (padded-blocks)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSome style guides require block statements to start and end with blank lines. The goal is\nto improve readability by visually separating the block content and the surrounding code.\n一些风格指南要求块语句以空行开始并且以空行结束。目标是通过块内容和周围代码视觉上地分离来提高可读性。\nif (a) {\n\n    b();\n\n}\n\n\nSince it’s good to have a consistent code style, you should either always write\npadded blocks or never do it.\n代码风格统一是非常有好处的，你应总是写填充的块或永远不这么做。\nRule Details\nThis rule enforces consistent empty line padding within blocks.\n该规则强制块内空行填充的一致性。\nOptions\nThis rule has one option, which can be a string option or an object option.\n该规则有一个选项，可以是字符串或对象。\nString option:\n字符串选项：\n\n\"always\" (default) requires empty lines at the beginning and ending of block statements and classes\n\"always\" (默认) 要求块语句和类的开始或末尾有空行\n\"never\" disallows empty lines at the beginning and ending of block statements and classes\n\"never\" 禁止块语句和类的开始或末尾有空行\n\nObject option:\n对象选项：\n\n\"blocks\" require or disallow padding within block statements\n\"blocks\" 要求或禁止块内填充\n\"classes\" require or disallow padding within classes\n\"classes\" 要求或禁止类内填充\n\"switches\" require or disallow padding within switch statements\n\"switches\" 要求或禁止在 switch 语句中填充\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", \"always\"]*/\n\nif (a) {\n    b();\n}\n\nif (a) { b(); }\n\nif (a)\n{\n    b();\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\nif (a) {\n    // comment\n    b();\n\n}\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", \"always\"]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    // comment\n    b();\n\n}\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", \"never\"]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", \"never\"]*/\n\nif (a) {\n    b();\n}\n\nif (a)\n{\n    b();\n}\n\n\nblocks\nExamples of incorrect code for this rule with the { \"blocks\": \"always\" } option:\n选项 { \"blocks\": \"always\" } 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", { \"blocks\": \"always\" }]*/\n\nif (a) {\n    b();\n}\n\nif (a) { b(); }\n\nif (a)\n{\n    b();\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\nif (a) {\n    // comment\n    b();\n\n}\n\n\nExamples of correct code for this rule with the { \"blocks\": \"always\" } option:\n选项  { \"blocks\": \"always\" } 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", { \"blocks\": \"always\" }]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    // comment\n    b();\n\n}\n\n\nExamples of incorrect code for this rule with the { \"blocks\": \"never\" } option:\n选项 { \"blocks\": \"never\" } 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", { \"blocks\": \"never\" }]*/\n\nif (a) {\n\n    b();\n\n}\n\nif (a)\n{\n\n    b();\n\n}\n\nif (a) {\n\n    b();\n}\n\nif (a) {\n    b();\n\n}\n\n\nExamples of correct code for this rule with the { \"blocks\": \"never\" } option:\n选项 { \"blocks\": \"never\" } 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", { \"blocks\": \"never\" }]*/\n\nif (a) {\n    b();\n}\n\nif (a)\n{\n    b();\n}\n\n\nclasses\nExamples of incorrect code for this rule with the { \"classes\": \"always\" } option:\n选项 { \"classes\": \"always\" } 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", { \"classes\": \"always\" }]*/\n\nclass  A {\n    constructor(){\n    }\n}\n\n\nExamples of correct code for this rule with the { \"classes\": \"always\" } option:\n选项 { \"classes\": \"always\" } 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", { \"classes\": \"always\" }]*/\n\nclass  A {\n\n    constructor(){\n    }\n\n}\n\n\nExamples of incorrect code for this rule with the { \"classes\": \"never\" } option:\n选项 { \"classes\": \"never\" } 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", { \"classes\": \"never\" }]*/\n\nclass  A {\n\n    constructor(){\n    }\n\n}\n\n\nExamples of correct code for this rule with the { \"classes\": \"never\" } option:\n选项 { \"classes\": \"never\" } 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", { \"classes\": \"never\" }]*/\n\nclass  A {\n    constructor(){\n    }\n}\n\n\nswitches\nExamples of incorrect code for this rule with the { \"switches\": \"always\" } option:\n选项 { \"switches\": \"always\" } 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", { \"switches\": \"always\" }]*/\n\nswitch (a) {\n    case 0: foo();\n}\n\n\nExamples of correct code for this rule with the { \"switches\": \"always\" } option:\n选项 { \"switches\": \"always\" } 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", { \"switches\": \"always\" }]*/\n\nswitch (a) {\n\n    case 0: foo();\n\n}\n\nif (a) {\n    b();\n}\n\n\nExamples of incorrect code for this rule with the { \"switches\": \"never\" } option:\n选项 { \"switches\": \"never\" } 的 错误 代码示例：\n/*eslint padded-blocks: [\"error\", { \"switches\": \"never\" }]*/\n\nswitch (a) {\n\n    case 0: foo();\n\n}\n\n\nExamples of correct code for this rule with the { \"switches\": \"never\" } option:\n选项 { \"switches\": \"never\" } 的 正确 代码示例：\n/*eslint padded-blocks: [\"error\", { \"switches\": \"never\" }]*/\n\nswitch (a) {\n    case 0: foo();\n}\n\nif (a) {\n\n    b();\n\n}\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of padding within blocks.\n如果你并不关心块内填充的一致性，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/padded-blocks",
                "disable": false
            },
            {
                "real_name": "padding-line-between-statements",
                "display_name": "padding-line-between-statements",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Require or disallow padding lines between statements (padding-line-between-statements)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow padding lines between statements (padding-line-between-statements)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nThis rule requires or disallows blank lines between the given 2 kinds of statements.\nProperly blank lines help developers to understand the code.\nFor example, the following configuration requires a blank line between a variable declaration and a return statement.\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"var\", next: \"return\" }\n]*/\n\nfunction foo() {\n    var a = 1;\n\n    return a;\n}\n\n\nRule Details\nThis rule does nothing if no configuration.\nA configuration is an object which has 3 properties; blankLine, prev and next. For example, { blankLine: \"always\", prev: \"var\", next: \"return\" } is meaning “it requires one or more blank lines between a variable declaration and a return statement.”\nYou can supply any number of configurations. If an statement pair matches multiple configurations, the last matched configuration will be used.\n{\n    \"padding-line-between-statements\": [\n        \"error\",\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        ...\n    ]\n}\n\n\n\nLINEBREAK_TYPE is one of the following.\n    \n\"any\" just ignores the statement pair.\n\"never\" disallows blank lines.\n\"always\" requires one or more blank lines. Note it does not count lines that comments exist as blank lines.\n\n\nSTATEMENT_TYPE is one of the following, or an array of the following.\n    \n\"*\" is wildcard. This matches any statements.\n\"block\" is lonely blocks.\n\"block-like\" is block like statements. This matches statements that the last token is the closing brace of blocks; e.g. { }, if (a) { }, and while (a) { }.\n\"break\" is break statements.\n\"case\" is case labels.\n\"cjs-export\" is export statements of CommonJS; e.g. module.exports = 0, module.exports.foo = 1, and exports.foo = 2. This is the special cases of assignment.\n\"cjs-import\" is import statements of CommonJS; e.g. const foo = require(\"foo\"). This is the special cases of variable declarations.\n\"class\" is class declarations.\n\"const\" is const variable declarations.\n\"continue\" is continue statements.\n\"debugger\" is debugger statements.\n\"default\" is default labels.\n\"directive\" is directive prologues. This matches directives; e.g. \"use strict\".\n\"do\" is do-while statements. This matches all statements that the first token is do keyword.\n\"empty\" is empty statements.\n\"export\" is export declarations.\n\"expression\" is expression statements.\n\"for\" is for loop families. This matches all statements that the first token is for keyword.\n\"function\" is function declarations.\n\"if\" is if statements.\n\"import\" is import declarations.\n\"let\" is let variable declarations.\n\"multiline-block-like\" is block like statements. This is the same as block-like type, but only the block is multiline.\n\"return\" is return statements.\n\"switch\" is switch statements.\n\"throw\" is throw statements.\n\"try\" is try statements.\n\"var\" is var variable declarations.\n\"while\" is while loop statements.\n\"with\" is with statements.\n\n\n\nExamples\nThis configuration would require blank lines before all return statements, like the newline-before-return rule.\nExamples of incorrect code for the [{ blankLine: \"always\", prev: \"*\", next: \"return\" }] configuration:\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"*\", next: \"return\" }\n]*/\n\nfunction foo() {\n    bar();\n    return;\n}\n\n\nExamples of correct code for the [{ blankLine: \"always\", prev: \"*\", next: \"return\" }] configuration:\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"*\", next: \"return\" }\n]*/\n\nfunction foo() {\n    bar();\n\n    return;\n}\n\nfunction foo() {\n    return;\n}\n\n\n\nThis configuration would require blank lines after every sequence of variable declarations, like the newline-after-var rule.\nExamples of incorrect code for the [{ blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"}, { blankLine: \"any\", prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}] configuration:\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"},\n    { blankLine: \"any\",    prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}\n]*/\n\nfunction foo() {\n    var a = 0;\n    bar();\n}\n\nfunction foo() {\n    let a = 0;\n    bar();\n}\n\nfunction foo() {\n    const a = 0;\n    bar();\n}\n\n\nExamples of correct code for the [{ blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"}, { blankLine: \"any\", prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}] configuration:\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"},\n    { blankLine: \"any\",    prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}\n]*/\n\nfunction foo() {\n    var a = 0;\n    var b = 0;\n\n    bar();\n}\n\nfunction foo() {\n    let a = 0;\n    const b = 0;\n\n    bar();\n}\n\nfunction foo() {\n    const a = 0;\n    const b = 0;\n\n    bar();\n}\n\n\n\nThis configuration would require blank lines after all directive prologues, like the lines-around-directive rule.\nExamples of incorrect code for the [{ blankLine: \"always\", prev: \"directive\", next: \"*\" }, { blankLine: \"any\", prev: \"directive\", next: \"directive\" }] configuration:\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"directive\", next: \"*\" },\n    { blankLine: \"any\",    prev: \"directive\", next: \"directive\" }\n]*/\n\n\"use strict\";\nfoo();\n\n\nExamples of correct code for the [{ blankLine: \"always\", prev: \"directive\", next: \"*\" }, { blankLine: \"any\", prev: \"directive\", next: \"directive\" }] configuration:\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"directive\", next: \"*\" },\n    { blankLine: \"any\",    prev: \"directive\", next: \"directive\" }\n]*/\n\n\"use strict\";\n\"use asm\";\n\nfoo();\n\n\nCompatibility\n\nJSCS: requirePaddingNewLineAfterVariableDeclaration\nJSCS: requirePaddingNewLinesAfterBlocks\nJSCS: disallowPaddingNewLinesAfterBlocks\nJSCS: requirePaddingNewLinesAfterUseStrict\nJSCS: disallowPaddingNewLinesAfterUseStrict\nJSCS: requirePaddingNewLinesBeforeExport\nJSCS: disallowPaddingNewLinesBeforeExport\nJSCS: requirePaddingNewlinesBeforeKeywords\nJSCS: disallowPaddingNewlinesBeforeKeywords\n\nWhen Not To Use It\nIf you don’t want to notify warnings about linebreaks, then it’s safe to disable this rule.\nVersion\nThis rule was introduced in ESLint 4.0.0-beta.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/padding-line-between-statements",
                "disable": false
            },
            {
                "real_name": "parse-error",
                "display_name": "parse-error",
                "severity": "error",
                "category": "correctness",
                "rule_title": "解析js错误，请检查js代码是否有问题",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "### 问题\n工具扫描js代码时候，会对js代码进行解析，若无法解析成功，便会报出解析错误的问题。\n### 解决方案\n检查js代码是否出错。",
                "disable": false
            },
            {
                "real_name": "prefer-arrow-callback",
                "display_name": "prefer-arrow-callback",
                "severity": "error",
                "category": "correctness",
                "rule_title": "推荐使用箭头函数作为回调。 (prefer-arrow-callback)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Suggest using arrow functions as callbacks. (prefer-arrow-callback)\n推荐使用箭头函数作为回调。 (prefer-arrow-callback)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nArrow functions are suited to callbacks, because:\n箭头函数适合做回调函数，因为：\n\nthis keywords in arrow functions bind to the upper scope’s.\nthis 关键字再箭头函数中绑定到了外层的作用域的 this。\nThe notation of the arrow function is shorter than function expression’s.\n箭头函数的符号比函数表达式的短。\n\nRule Details\nThis rule is aimed to flag usage of function expressions in an argument list.\n该规则旨在标记函数表达式在参数列表中的用法。\nThe following patterns are considered problems:\n以下模式被认为是有问题的：\n/*eslint prefer-arrow-callback: \"error\"*/\n\nfoo(function(a) { return a; });\nfoo(function() { return this.a; }.bind(this));\n\n\nThe following patterns are not considered problems:\n以下模式本认为是没有问题的：\n/*eslint prefer-arrow-callback: \"error\"*/\n/*eslint-env es6*/\n\nfoo(a => a);\nfoo(function*() { yield; });\n\n// this is not a callback.\nvar foo = function foo(a) { return a; };\n\n// using `this` without `.bind(this)`.\nfoo(function() { return this.a; });\n\n// recursively.\nfoo(function bar(n) { return n && n + bar(n - 1); });\n\n\nOptions\nThis rule takes one optional argument, an object which is an options object.\n该规则有个对象选项。\nallowNamedFunctions\nThis is a boolean option and it is false by default. When set to true, the rule doesn’t warn on named functions used as callbacks.\n这是一个布尔选项，默认为 false。当设置为 true，该规则不对作为回调函数的命名函数发出警告。\nExamples of correct code for the { \"allowNamedFunctions\": true } option:\n选项 { \"allowNamedFunctions\": true } 的 正确 代码示例：\n/*eslint prefer-arrow-callback: [\"error\", { \"allowNamedFunctions\": true }]*/\n\nfoo(function bar() {});\n\n\nallowUnboundThis\nThis is a boolean option and it is true by default. When set to false, this option allows the use of this without restriction and checks for dynamically assigned this values such as when using Array.prototype.map with a context argument. Normally, the rule will flag the use of this whenever a function does not use bind() to specify the value of this constantly.\n这是一个布尔选项，默认为 true。当设置为 false，该选项允许不受限制地使用 this，检测动态地分配 this，比如使用带有 context 的 Array.prototype.map。通常，该规则将标记 this 的使用，只要函数不使用 bind() 指定 this 的值。\nExamples of incorrect code for the { \"allowUnboundThis\": false } option:\n选项 { \"allowUnboundThis\": false } 的 错误 代码示例：\n/*eslint prefer-arrow-callback: [\"error\", { \"allowUnboundThis\": false }]*/\n/*eslint-env es6*/\n\nfoo(function() { this.a; });\n\nfoo(function() { (() => this); });\n\nsomeArray.map(function (itm) { return this.doSomething(itm); }, someObject);\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\n此规则不应在 ES3/5 环境中使用。\nIn ES2015 (ES6) or later, if you don’t want to be notified about function expressions in an argument list, you can safely disable this rule.\n在 ES2015 (ES6) 或以后的版本中，如果你不希望收到关于函数表达式出现在参数列表中通知，关闭此规则即可。\nVersion\nThis rule was introduced in ESLint 1.2.0.\n该规则在 ESLint 1.2.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-arrow-callback",
                "disable": false
            },
            {
                "real_name": "prefer-const",
                "display_name": "prefer-const",
                "severity": "error",
                "category": "correctness",
                "rule_title": "建议使用const (prefer-const).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Suggest using const (prefer-const)\n建议使用const (prefer-const)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIf a variable is never reassigned, using the const declaration is better.\n如果一个变量不会被重新赋值，最好使用const进行声明。\nconst declaration tells readers, “this variable is never reassigned,” reducing cognitive load and improving maintainability.\nconst 声明告诉读者，“这个变量从不会被重新赋值”，从而减少认知负荷，提高可维护性。\nRule Details\nThis rule is aimed at flagging variables that are declared using let keyword, but never reassigned after the initial assignment.\n该规则旨在标记那些使用 let 声明，但在初始化赋值后从未被修改过的变量。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint prefer-const: \"error\"*/\n/*eslint-env es6*/\n\n// it's initialized and never reassigned.\nlet a = 3;\nconsole.log(a);\n\nlet a;\na = 0;\nconsole.log(a);\n\n// `i` is redefined (not reassigned) on each loop step.\nfor (let i in [1, 2, 3]) {\n    console.log(i);\n}\n\n// `a` is redefined (not reassigned) on each loop step.\nfor (let a of [1, 2, 3]) {\n    console.log(a);\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint prefer-const: \"error\"*/\n/*eslint-env es6*/\n\n// using const.\nconst a = 0;\n\n// it's never initialized.\nlet a;\nconsole.log(a);\n\n// it's reassigned after initialized.\nlet a;\na = 0;\na = 1;\nconsole.log(a);\n\n// it's initialized in a different block from the declaration.\nlet a;\nif (true) {\n    a = 0;\n}\nconsole.log(a);\n\n// it's initialized at a place that we cannot write a variable declaration.\nlet a;\nif (true) a = 0;\nconsole.log(a);\n\n// `i` gets a new binding each iteration\nfor (const i in [1, 2, 3]) {\n  console.log(i);\n}\n\n// `a` gets a new binding each iteration\nfor (const a of [1, 2, 3]) {\n  console.log(a);\n}\n\n// `end` is never reassigned, but we cannot separate the declarations without modifying the scope.\nfor (let i = 0, end = 10; i < end; ++i) {\n    console.log(a);\n}\n\n// suggest to use `no-var` rule.\nvar b = 3;\nconsole.log(b);\n\n\nOptions\n{\n    \"prefer-const\": [\"error\", {\n        \"destructuring\": \"any\",\n        \"ignoreReadBeforeAssign\": false\n    }]\n}\n\n\ndestructuring\nThe kind of the way to address variables in destructuring.\n在解构中有多种方式处理变量。\nThere are 2 values:\n有 2 个值：\n\n\"any\" (default) - If any variables in destructuring should be const, this rule warns for those variables.\n\"any\" (默认) - 在解构中，任何变量都应该是const，该规则将发出警告。\n\"all\" - If all variables in destructuring should be const, this rule warns the variables. Otherwise, ignores them.\n\"all\" - 在解构中，所有变量都应该是const，该规则将发出警告。否则，忽略它们。\n\nExamples of incorrect code for the default {\"destructuring\": \"any\"} option:\n默认选项{\"destructuring\": \"any\"}的 错误 代码示例：\n/*eslint prefer-const: \"error\"*/\n/*eslint-env es6*/\n\nlet {a, b} = obj;    /*error 'b' is never reassigned, use 'const' instead.*/\na = a + 1;\n\n\nExamples of correct code for the default {\"destructuring\": \"any\"} option:\n默认选项 {\"destructuring\": \"any\"} 的 正确 代码示例：\n/*eslint prefer-const: \"error\"*/\n/*eslint-env es6*/\n\n// using const.\nconst {a: a0, b} = obj;\nconst a = a0 + 1;\n\n// all variables are reassigned.\nlet {a, b} = obj;\na = a + 1;\nb = b + 1;\n\n\nExamples of incorrect code for the {\"destructuring\": \"all\"} option:\n选项 {\"destructuring\": \"all\"} 的 错误 代码示例：\n/*eslint prefer-const: [\"error\", {\"destructuring\": \"all\"}]*/\n/*eslint-env es6*/\n\n// all of `a` and `b` should be const, so those are warned.\nlet {a, b} = obj;    /*error 'a' is never reassigned, use 'const' instead.\n                             'b' is never reassigned, use 'const' instead.*/\n\n\nExamples of correct code for the {\"destructuring\": \"all\"} option:\n选项 {\"destructuring\": \"all\"} 的 正确 代码示例：\n/*eslint prefer-const: [\"error\", {\"destructuring\": \"all\"}]*/\n/*eslint-env es6*/\n\n// 'b' is never reassigned, but all of `a` and `b` should not be const, so those are ignored.\nlet {a, b} = obj;\na = a + 1;\n\n\nignoreReadBeforeAssign\nThis is an option to avoid conflicting with no-use-before-define rule (without \"nofunc\" option).\nIf true is specified, this rule will ignore variables that are read between the declaration and the first assignment.\nDefault is false.\n这是一个避免与 no-use-before-define 规则（不带 \"nofunc\" 选项）产生冲突的选项。如果为 true，该规则将忽略声明和第一次赋值之间的变量。默认为 false。\nExamples of correct code for the {\"ignoreReadBeforeAssign\": true} option:\n选项 {\"ignoreReadBeforeAssign\": true} 的 正确 代码示例：\n/*eslint prefer-const: [\"error\", {\"ignoreReadBeforeAssign\": true}]*/\n/*eslint-env es6*/\n\nlet timer;\nfunction initialize() {\n    if (foo()) {\n        clearInterval(timer);\n    }\n}\ntimer = setInterval(initialize, 100);\n\n\nExamples of correct code for the default {\"ignoreReadBeforeAssign\": false} option:\n默认选项 {\"ignoreReadBeforeAssign\": false} 的 正确 代码示例：\n/*eslint prefer-const: [\"error\", {\"ignoreReadBeforeAssign\": false}]*/\n/*eslint-env es6*/\n\nconst timer = setInterval(initialize, 100);\nfunction initialize() {\n    if (foo()) {\n        clearInterval(timer);\n    }\n}\n\n\nWhen Not To Use It\nIf you don’t want to be notified about variables that are never reassigned after initial assignment, you can safely disable this rule.\n如果你不想被通知哪些变量初始化赋值后再没有被修改过，禁用此规则即可。\nRelated Rules\n\nno-var\nno-use-before-define\n\nVersion\nThis rule was introduced in ESLint 0.23.0.\n该规则在 ESLint 0.23.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-const",
                "disable": false
            },
            {
                "real_name": "prefer-destructuring",
                "display_name": "prefer-destructuring",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prefer destructuring from arrays and objects (prefer-destructuring)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Prefer destructuring from arrays and objects (prefer-destructuring)\nWith JavaScript ES6, a new syntax was added for creating variables from an array index or object property, called destructuring.  This rule enforces usage of destructuring instead of accessing a property through a member expression.\nRule Details\nExamples of incorrect code for this rule:\n// With `array` enabled\nvar foo = array[0];\n\n// With `object` enabled\nvar foo = object.foo;\nvar foo = object['foo'];\n\n\nExamples of correct code for this rule:\n// With `array` enabled\nvar [ foo ] = array;\nvar foo = array[someIndex];\n\n// With `object` enabled\nvar { foo } = object;\nvar foo = object.bar;\n\n\nOptions\nThis rule takes two sets of configuration objects; the first controls the types that the rule is applied to, and the second controls the way those objects are evaluated.\nThe first has two properties, array and object, which can be used to turn on or off the destructuring requirement for each of those types independently.  By default, both are true.\nThe second has a single property, enforceForRenamedProperties, that controls whether or not the object destructuring rules are applied in cases where the variable requires the property being access to be renamed.\nExamples of incorrect code when enforceForRenamedProperties is enabled:\nvar foo = object.bar;\n\n\nExamples of correct code when enforceForRenamedProperties is enabled:\nvar { bar: foo } = object;\n\n\nAn example configuration, with the defaults filled in, looks like this:\n{\n  \"rules\": {\n    \"prefer-destructuring\": [\"error\", {\n      \"array\": true,\n      \"object\": true\n    }, {\n      \"enforceForRenamedProperties\": false\n    }]\n  }\n}\n\n\nWhen Not To Use It\nIf you want to be able to access array indices or object properties directly, you can either configure the rule to your tastes or disable the rule entirely.\nAdditionally, if you intend to access large array indices directly, like:\nvar foo = array[100];\n\n\nThen the array part of this rule is not recommended, as destructuring does not match this use case very well.\nFurther Reading\nIf you want to learn more about destructuring, check out the links below:\n\nDestructuring Assignment (MDN)\nDestructuring and parameter handling in ECMAScript 6 (2ality blog)\n\nVersion\nThis rule was introduced in ESLint 3.13.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-destructuring",
                "disable": false
            },
            {
                "real_name": "prefer-numeric-literals",
                "display_name": "prefer-numeric-literals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "disallow parseInt() in favor of binary, octal, and hexadecimal literals (prefer-numeric-literals)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "disallow parseInt() in favor of binary, octal, and hexadecimal literals (prefer-numeric-literals)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nThe parseInt() function can be used to turn binary, octal, and hexadecimal strings into integers. As binary, octal, and hexadecimal literals are supported in ES6, this rule encourages use of those numeric literals instead of parseInt().\n0b111110111 === 503;\n0o767 === 503;\n\n\nRule Details\nThis rule disallows parseInt() if it is called with two arguments: a string and a radix option of 2 (binary), 8 (octal), or 16 (hexadecimal).\nExamples of incorrect code for this rule:\n/*eslint prefer-numeric-literals: \"error\"*/\n\nparseInt(\"111110111\", 2) === 503;\nparseInt(\"767\", 8) === 503;\nparseInt(\"1F7\", 16) === 255;\n\n\nExamples of correct code for this rule:\n/*eslint prefer-numeric-literals: \"error\"*/\n/*eslint-env es6*/\n\nparseInt(1);\nparseInt(1, 3);\n\n0b111110111 === 503;\n0o767 === 503;\n0x1F7 === 503;\n\na[parseInt](1,2);\n\nparseInt(foo);\nparseInt(foo, 2);\n\n\nWhen Not To Use It\nIf you want to allow use of parseInt() for binary, octal, or hexadecimal integers. If you are not using ES6 (because binary and octal literals are not supported in ES5 and below).\nCompatibility\n\nJSCS: requireNumericLiterals\n\nVersion\nThis rule was introduced in ESLint 3.5.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-numeric-literals",
                "disable": false
            },
            {
                "real_name": "prefer-object-spread",
                "display_name": "prefer-object-spread",
                "severity": "warning",
                "category": "convention",
                "rule_title": "优先使用对象扩展而不是 Object.assign",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "当使用对象字面量作为 Object.assign 第一个参数时，此规则要求使用对象扩展语法。这条规则还对只有一个对象字面量作为唯一参数时调用 Object.assign 的情况发出警告，这种情况下，不需要调用 Object.assign。",
                "owner": null,
                "labels": [],
                "description": "命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\n当使用对象字面量作为 Object.assign 第一个参数时，此规则要求使用对象扩展语法。这条规则还对只有一个对象字面量作为唯一参数时调用 Object.assign 的情况发出警告，这种情况下，不需要调用 Object.assign。\n\n\t对象扩展是在 ES2018 中引入的一种声明性替代方法，它可能比更具动态性的命令式 Object.assign 执行得更好。",
                "disable": false
            },
            {
                "real_name": "prefer-promise-reject-errors",
                "display_name": "prefer-promise-reject-errors",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require using Error objects as Promise rejection reasons (prefer-promise-reject-errors)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require using Error objects as Promise rejection reasons (prefer-promise-reject-errors)\nIt is considered good practice to only pass instances of the built-in Error object to the reject() function for user-defined errors in Promises. Error objects automatically store a stack trace, which can be used to debug an error by determining where it came from. If a Promise is rejected with a non-Error value, it can be difficult to determine where the rejection occurred.\nRule Details\nThis rule aims to ensure that Promises are only rejected with Error objects.\nOptions\nThis rule takes one optional object argument:\n\nallowEmptyReject: true (false by default) allows calls to Promise.reject() with no arguments.\n\nExamples of incorrect code for this rule:\n/*eslint prefer-promise-reject-errors: \"error\"*/\n\nPromise.reject(\"something bad happened\");\n\nPromise.reject(5);\n\nPromise.reject();\n\nnew Promise(function(resolve, reject) {\n  reject(\"something bad happened\");\n});\n\nnew Promise(function(resolve, reject) {\n  reject();\n});\n\n\n\nExamples of correct code for this rule:\n/*eslint prefer-promise-reject-errors: \"error\"*/\n\nPromise.reject(new Error(\"something bad happened\"));\n\nPromise.reject(new TypeError(\"something bad happened\"));\n\nnew Promise(function(resolve, reject) {\n  reject(new Error(\"something bad happened\"));\n});\n\nvar foo = getUnknownValue();\nPromise.reject(foo);\n\n\nExamples of correct code for this rule with the allowEmptyReject: true option:\n/*eslint prefer-promise-reject-errors: [\"error\", {\"allowEmptyReject\": true}]*/\n\nPromise.reject();\n\nnew Promise(function(resolve, reject) {\n  reject();\n});\n\n\nKnown Limitations\nDue to the limits of static analysis, this rule cannot guarantee that you will only reject Promises with Error objects. While the rule will report cases where it can guarantee that the rejection reason is clearly not an Error, it will not report cases where there is uncertainty about whether a given reason is an Error. For more information on this caveat, see the similar limitations in the no-throw-literal rule.\nTo avoid conflicts between rules, this rule does not report non-error values used in throw statements in async functions, even though these lead to Promise rejections. To lint for these cases, use the no-throw-literal rule.\nWhen Not To Use It\nIf you’re using custom non-error values as Promise rejection reasons, you can turn off this rule.\nFurther Reading\n\nno-throw-literal\nWarning: a promise was rejected with a non-error\n\nVersion\nThis rule was introduced in ESLint 3.14.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-promise-reject-errors",
                "disable": false
            },
            {
                "real_name": "prefer-reflect",
                "display_name": "prefer-reflect",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Suggest using Reflect methods where applicable (prefer-reflect)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Suggest using Reflect methods where applicable (prefer-reflect)\nThis rule was deprecated in ESLint v3.9.0 and will not be replaced. The original intent of this rule now seems misguided as we have come to understand that Reflect methods are not actually intended to replace the Object counterparts the rule suggests, but rather exist as low-level primitives to be used with proxies in order to replicate the default behavior of various previously existing functionality.\nThe ES6 Reflect API comes with a handful of methods which somewhat deprecate methods on old constructors:\n\nReflect.apply effectively deprecates Function.prototype.apply and Function.prototype.call\nReflect.deleteProperty effectively deprecates the delete keyword\nReflect.getOwnPropertyDescriptor effectively deprecates Object.getOwnPropertyDescriptor\nReflect.getPrototypeOf effectively deprecates Object.getPrototypeOf\nReflect.setPrototypeOf effectively deprecates Object.setPrototypeOf\nReflect.preventExtensions  effectively deprecates Object.preventExtensions\n\nThe prefer-reflect rule will flag usage of any older method, suggesting to instead use the newer Reflect version.\nRule Details\nOptions\nExceptions\n\"prefer-reflect\": [<enabled>, { \"exceptions\": [<...exceptions>] }]\n\n\nThe exceptions option allows you to pass an array of methods names you’d like to continue to use in the old style.\nFor example if you wish to use all Reflect methods, except for Function.prototype.apply then your config would look like prefer-reflect: [2, { \"exceptions\": [\"apply\"] }].\nIf you want to use Reflect methods, but keep using the delete keyword, then your config would look like prefer-reflect: [2, { \"exceptions\": [\"delete\"] }].\nThese can be combined as much as you like. To make all methods exceptions (thereby rendering this rule useless), use prefer-reflect: [2, { \"exceptions\": [\"apply\", \"call\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"getPrototypeOf\", \"setPrototypeOf\", \"isExtensible\", \"getOwnPropertyNames\", \"preventExtensions\", \"delete\"] }]\nReflect.apply\nDeprecates Function.prototype.apply() and Function.prototype.call()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nmyFunction.apply(undefined, args);\nmyFunction.apply(null, args);\nobj.myMethod.apply(obj, args);\nobj.myMethod.apply(other, args);\n\nmyFunction.call(undefined, arg);\nmyFunction.call(null, arg);\nobj.myMethod.call(obj, arg);\nobj.myMethod.call(other, arg);\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.apply(myFunction, undefined, args);\nReflect.apply(myFunction, null, args);\nReflect.apply(obj.myMethod, obj, args);\nReflect.apply(obj.myMethod, other, args);\nReflect.apply(myFunction, undefined, [arg]);\nReflect.apply(myFunction, null, [arg]);\nReflect.apply(obj.myMethod, obj, [arg]);\nReflect.apply(obj.myMethod, other, [arg]);\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"apply\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"apply\"] }]*/\n\n// in addition to Reflect.apply(...):\nmyFunction.apply(undefined, args);\nmyFunction.apply(null, args);\nobj.myMethod.apply(obj, args);\nobj.myMethod.apply(other, args);\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"call\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"call\"] }]*/\n\n// in addition to Reflect.apply(...):\nmyFunction.call(undefined, arg);\nmyFunction.call(null, arg);\nobj.myMethod.call(obj, arg);\nobj.myMethod.call(other, arg);\n\n\nReflect.defineProperty\nDeprecates Object.defineProperty()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.defineProperty({}, 'foo', {value: 1})\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.defineProperty({}, 'foo', {value: 1})\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"defineProperty\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"defineProperty\"] }]*/\n\nObject.defineProperty({}, 'foo', {value: 1})\nReflect.defineProperty({}, 'foo', {value: 1})\n\n\nReflect.getOwnPropertyDescriptor\nDeprecates Object.getOwnPropertyDescriptor()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.getOwnPropertyDescriptor({}, 'foo')\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.getOwnPropertyDescriptor({}, 'foo')\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"getOwnPropertyDescriptor\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"getOwnPropertyDescriptor\"] }]*/\n\nObject.getOwnPropertyDescriptor({}, 'foo')\nReflect.getOwnPropertyDescriptor({}, 'foo')\n\n\nReflect.getPrototypeOf\nDeprecates Object.getPrototypeOf()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.getPrototypeOf({}, 'foo')\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.getPrototypeOf({}, 'foo')\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"getPrototypeOf\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"getPrototypeOf\"] }]*/\n\nObject.getPrototypeOf({}, 'foo')\nReflect.getPrototypeOf({}, 'foo')\n\n\nReflect.setPrototypeOf\nDeprecates Object.setPrototypeOf()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.setPrototypeOf({}, Object.prototype)\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.setPrototypeOf({}, Object.prototype)\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"setPrototypeOf\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"setPrototypeOf\"] }]*/\n\nObject.setPrototypeOf({}, Object.prototype)\nReflect.setPrototypeOf({}, Object.prototype)\n\n\nReflect.isExtensible\nDeprecates Object.isExtensible\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.isExtensible({})\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.isExtensible({})\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"isExtensible\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"isExtensible\"] }]*/\n\nObject.isExtensible({})\nReflect.isExtensible({})\n\n\nReflect.getOwnPropertyNames\nDeprecates Object.getOwnPropertyNames()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.getOwnPropertyNames({})\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.getOwnPropertyNames({})\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"getOwnPropertyNames\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"getOwnPropertyNames\"] }]*/\n\nObject.getOwnPropertyNames({})\nReflect.getOwnPropertyNames({})\n\n\nReflect.preventExtensions\nDeprecates Object.preventExtensions()\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nObject.preventExtensions({})\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\nReflect.preventExtensions({})\n\n\nExamples of correct code for this rule with the { \"exceptions\": [\"preventExtensions\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"preventExtensions\"] }]*/\n\nObject.preventExtensions({})\nReflect.preventExtensions({})\n\n\nReflect.deleteProperty\nDeprecates the delete keyword\nExamples of incorrect code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\ndelete foo.bar; // deleting object property\n\n\nExamples of correct code for this rule when used without exceptions:\n/*eslint prefer-reflect: \"error\"*/\n\ndelete bar; // deleting variable\nReflect.deleteProperty(foo, 'bar');\n\n\nNote: For a rule preventing deletion of variables, see no-delete-var instead\nExamples of correct code for this rule with the { \"exceptions\": [\"delete\"] } option:\n/*eslint prefer-reflect: [\"error\", { \"exceptions\": [\"delete\"] }]*/\n\ndelete bar\ndelete foo.bar\nReflect.deleteProperty(foo, 'bar');\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\nIn ES2015 (ES6) or later, if you don’t want to be notified about places where Reflect could be used, you can safely disable this rule.\nRelated Rules\n\nno-useless-call\nprefer-spread\nno-delete-var\n\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-2.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-reflect",
                "disable": false
            },
            {
                "real_name": "prefer-rest-params",
                "display_name": "prefer-rest-params",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Suggest using the rest parameters instead of arguments (prefer-rest-params).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Suggest using the rest parameters instead of arguments (prefer-rest-params)\nThere are rest parameters in ES2015.\nWe can use that feature for variadic functions instead of the arguments variable.\narguments does not have methods of Array.prototype, so it’s a bit of an inconvenience.\nRule Details\nThis rule is aimed to flag usage of arguments variables.\nExamples\nExamples of incorrect code for this rule:\nfunction foo() {\n    console.log(arguments);\n}\n\nfunction foo(action) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    action.apply(null, args);\n}\n\nfunction foo(action) {\n    var args = [].slice.call(arguments, 1);\n    action.apply(null, args);\n}\n\n\nExamples of correct code for this rule:\nfunction foo(...args) {\n    console.log(args);\n}\n\nfunction foo(action, ...args) {\n    action.apply(null, args); // or `action(...args)`, related to the `prefer-spread` rule.\n}\n\n// Note: the implicit arguments can be overwritten.\nfunction foo(arguments) {\n    console.log(arguments); // This is the first argument.\n}\nfunction foo() {\n    var arguments = 0;\n    console.log(arguments); // This is a local variable.\n}\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\nIn ES2015 (ES6) or later, if you don’t want to be notified about arguments variables, then it’s safe to disable this rule.\nRelated Rules\n\nprefer-spread\n\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-1.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-rest-params",
                "disable": false
            },
            {
                "real_name": "prefer-spread",
                "display_name": "prefer-spread",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Suggest using the spread operator instead of .apply(). (prefer-spread).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Suggest using the spread operator instead of .apply(). (prefer-spread)\n建议使用扩展运算符而非.apply() (prefer-spread)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nBefore ES2015, one must use Function.prototype.apply() to call variadic functions.\n在 ES2015 之前，必须使用 Function.prototype.apply() 调用可变参数函数。\nvar args = [1, 2, 3, 4];\nMath.max.apply(Math, args);\n\n\nIn ES2015, one can use the spread operator to call variadic functions.\n在 ES2015 中，可以使用扩展运算符调用可变参数函数。\n/*eslint-env es6*/\n\nvar args = [1, 2, 3, 4];\nMath.max(...args);\n\n\nRule Details\nThis rule is aimed to flag usage of Function.prototype.apply() in situations where the spread operator could be used instead.\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint prefer-spread: \"error\"*/\n\nfoo.apply(undefined, args);\n\nfoo.apply(null, args);\n\nobj.foo.apply(obj, args);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint prefer-spread: \"error\"*/\n\n// Using the spread operator\nfoo(...args);\nobj.foo(...args);\n\n// The `this` binding is different.\nfoo.apply(obj, args);\nobj.foo.apply(null, args);\nobj.foo.apply(otherObj, args);\n\n// The argument list is not variadic.\n// Those are warned by the `no-useless-call` rule.\nfoo.apply(undefined, [1, 2, 3]);\nfoo.apply(null, [1, 2, 3]);\nobj.foo.apply(obj, [1, 2, 3]);\n\n\nKnown limitations:\n已知的限制：\nThis rule analyzes code statically to check whether or not the this argument is changed. So, if the this argument is computed in a dynamic expression, this rule cannot detect a violation.\n该规则通过静态分析代码的方式检查this参数是否有改变。因此，如果在动态表达式中有 this 参数，该规则不会检查这种情况。\n/*eslint prefer-spread: \"error\"*/\n\n// This warns.\na[i++].foo.apply(a[i++], args);\n\n// This does not warn.\na[++i].foo.apply(a[i], args);\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\n此规则不应在 ES3/5 环境中使用。\nIn ES2015 (ES6) or later, if you don’t want to be notified about Function.prototype.apply() callings, you can safely disable this rule.\n在 ES2015 (ES6) 或以后的版本，如果你不希望收到关于 Function.prototype.apply() 调用的通知，关闭此规则即可。\nRelated Rules\n\nno-useless-call\n\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-spread",
                "disable": false
            },
            {
                "real_name": "prefer-template",
                "display_name": "prefer-template",
                "severity": "error",
                "category": "correctness",
                "rule_title": "建议使用模板而非字符串连接 (prefer-template)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Suggest using template literals instead of string concatenation. (prefer-template)\n建议使用模板而非字符串连接 (prefer-template)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nIn ES2015 (ES6), we can use template literals instead of string concatenation.\n在 ES2015 (ES6) 中，我们可以使用模板而非字符串连接。\nvar str = \"Hello, \" + name + \"!\";\n\n\n/*eslint-env es6*/\n\nvar str = `Hello, ${name}!`;\n\n\nRule Details\nThis rule is aimed to flag usage of + operators with strings.\n该规则旨在标记字符串间 + 操作符的使用。\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint prefer-template: \"error\"*/\n\nvar str = \"Hello, \" + name + \"!\";\nvar str = \"Time: \" + (12 * 60 * 60 * 1000);\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint prefer-template: \"error\"*/\n/*eslint-env es6*/\n\nvar str = \"Hello World!\";\nvar str = `Hello, ${name}!`;\nvar str = `Time: ${12 * 60 * 60 * 1000}`;\n\n// This is reported by `no-useless-concat`.\nvar str = \"Hello, \" + \"World!\";\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\n此规则不应在 ES3/5 环境中使用。\nIn ES2015 (ES6) or later, if you don’t want to be notified about string concatenation, you can safely disable this rule.\n在 ES2015 (ES6) 或以后的版本，如果你不希望收到关于字符串连接的通知，关闭此规则即可。\nRelated Rules\n\nno-useless-concat\nquotes\n\nVersion\nThis rule was introduced in ESLint 1.2.0.\n该规则在 ESLint 1.2.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/prefer-template",
                "disable": false
            },
            {
                "real_name": "quote-props",
                "display_name": "quote-props",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求对象字面量属性名称使用引号 (quote-props)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require quotes around object literal property names (quote-props)\n要求对象字面量属性名称使用引号 (quote-props)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nObject literal property names can be defined in two ways: using literals or using strings. For example, these two objects are equivalent:\n对象字面量的属性名称可以用两种方式进行定义：使用文本或字符串。例如，这两个对象是等效的：\nvar object1 = {\n    property: true\n};\n\nvar object2 = {\n    \"property\": true\n};\n\n\nIn many cases, it doesn’t matter if you choose to use an identifier instead of a string or vice-versa. Even so, you might decide to enforce a consistent style in your code.\n在很多情况下，你选择使用标识符或字符串，这都不影响。即便如此，你可以决定在代码中执行一致的风格。\nThere are, however, some occasions when you must use quotes:\n然而，有一些场合，你必须使用引号：\n\nIf you are using an ECMAScript 3 JavaScript engine (such as IE8) and you want to use a keyword (such as if) as a property name. This restriction was removed in ECMAScript 5.\n如果你想在 ECMAScript 3 JavaScript 引擎（例如 IE8 ）中使用关键字（例如 if）作为属性名。这个限制在 ECMAScript 5 被移除。\nYou want to use a non-identifier character in your property name, such as having a property with a space like \"one two\".\n你想在你的属性名中使用非标识符的字符，比如一个属性中间有一个空格，像 \"one two\" 这样。\n\nAnother example where quotes do matter is when using numeric literals as property keys:\n另外一个示例说明引号的重要性，即在使用数字文本作为属性的键时。\nvar object = {\n    1e2: 1,\n    100: 2\n};\n\n\nThis may look alright at first sight, but this code in fact throws a syntax error in ECMAScript 5 strict mode. This happens because 1e2 and 100 are coerced into strings before getting used as the property name. Both String(1e2) and String(100) happen to be equal to \"100\", which causes the “Duplicate data property in object literal not allowed in strict mode” error. Issues like that can be tricky to debug, so some prefer to require quotes around all property names.\n这可能乍一看起来是没有问题的，但在 ECMAScript 5 严格模式下，这段代码实际上会抛出一个语法错误。因为 1e2 和 100在作为属性名使用之前被强制转换为字符串。String(1e2) 和 String(100) 正好是等于 \"100\"，造成了“严格模式下对象字面量中不允许重复的数据属性”的错误。这样的问题调试起来非常棘手，所以一些人喜欢要求所有的属性名都要有引号。\nRule Details\nThis rule requires quotes around object literal property names.\n该规则要求对象字面量属性名称使用引号。\nOptions\nThis rule has two options, a string option and an object option.\n该规则有两个选项，一个是字符串，一个是对象。\nString option:\n字符串选项：\n\n\"always\" (default) requires quotes around all object literal property names\n\"always\" (默认) 要求对象字面量属性名称都使用引号\n\"as-needed\" disallows quotes around object literal property names that are not strictly required\n\"as-needed\" 当没有严格要求时，禁止对象字面量属性名称使用引号\n\"consistent\" enforces a consistent quote style requires quotes around object literal property names\n\"consistent\" 要求对象字面量属性名称使用一致的引号\n\"consistent-as-needed\" requires quotes around all object literal property names if any name strictly requires quotes, otherwise disallows quotes around object property names\n\"consistent-as-needed\" 如果有属性名称要求使用引号，则所有的属性名称都要使用引号；否则，禁止所有的属性名称使用引号\n\nObject option:\n对象选项：\n\n\"keywords\": true requires quotes around language keywords used as object property names (only applies when using as-needed or consistent-as-needed)\n\"keywords\": true 如果关键字作为对象属性名称，要求使用引号 (当 as-needed 或 consistent-as-needed 时生效)\n\"unnecessary\": true (default) disallows quotes around object literal property names that are not strictly required (only applies when using as-needed)\n\"unnecessary\": true (默认) 如果没有严格要求，禁止对象属性名称使用引号 (当as-needed 时生效)\n\"unnecessary\": false allows quotes around object literal property names that are not strictly required (only applies when using as-needed)\n\"unnecessary\": false 如果没有严格要求，允许对象属性名称使用引号 (当 as-needed 时生效)\n\"numbers\": true requires quotes around numbers used as object property names (only applies when using as-needed)\n\"numbers\": true 当数字作为对象属性名称时，要求使用引号 (只当 as-needed 时生效)\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"always\"]*/\n\nvar object = {\n    foo: \"bar\",\n    baz: 42,\n    \"qux-lorem\": true\n};\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint quote-props: [\"error\", \"always\"]*/\n/*eslint-env es6*/\n\nvar object1 = {\n    \"foo\": \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    'baz': 42,\n    'qux-lorem': true\n};\n\nvar object3 = {\n    foo() {\n        return;\n    }\n};\n\n\nas-needed\nExamples of incorrect code for this rule with the \"as-needed\" option:\n选项 \"as-needed\" 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"as-needed\"]*/\n\nvar object = {\n    \"a\": 0,\n    \"0\": 0,\n    \"true\": 0,\n    \"null\": 0\n};\n\n\nExamples of correct code for this rule with the \"as-needed\" option:\n选项 \"as-needed\" 的 正确 代码示例：\n/*eslint quote-props: [\"error\", \"as-needed\"]*/\n/*eslint-env es6*/\n\nvar object1 = {\n    \"a-b\": 0,\n    \"0x0\": 0,\n    \"1e2\": 0\n};\n\nvar object2 = {\n    foo: 'bar',\n    baz: 42,\n    true: 0,\n    0: 0,\n    'qux-lorem': true\n};\n\nvar object3 = {\n    foo() {\n        return;\n    }\n};\n\n\nconsistent\nExamples of incorrect code for this rule with the \"consistent\" option:\n选项 \"consistent\" 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"consistent\"]*/\n\nvar object1 = {\n    foo: \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    baz: 42\n};\n\n\nExamples of correct code for this rule with the \"consistent\" option:\n选项 \"consistent\" 的 正确 代码示例：\n/*eslint quote-props: [\"error\", \"consistent\"]*/\n\nvar object1 = {\n    \"foo\": \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    'baz': 42\n};\n\nvar object3 = {\n    foo: 'bar',\n    baz: 42\n};\n\n\nconsistent-as-needed\nExamples of incorrect code for this rule with the \"consistent-as-needed\" option:\n选项 \"consistent-as-needed\" 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"consistent-as-needed\"]*/\n\nvar object1 = {\n    foo: \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    'foo': 'bar',\n    'baz': 42\n};\n\n\nExamples of correct code for this rule with the \"consistent-as-needed\" option:\n选项 \"consistent-as-needed\" 的 正确 代码示例：\n/*eslint quote-props: [\"error\", \"consistent-as-needed\"]*/\n\nvar object1 = {\n    \"foo\": \"bar\",\n    \"baz\": 42,\n    \"qux-lorem\": true\n};\n\nvar object2 = {\n    foo: 'bar',\n    baz: 42\n};\n\n\nkeywords\nExamples of additional incorrect code for this rule with the \"as-needed\", { \"keywords\": true } options:\n选项 \"as-needed\", { \"keywords\": true } 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"as-needed\", { \"keywords\": true }]*/\n\nvar x = {\n    while: 1,\n    volatile: \"foo\"\n};\n\n\nExamples of additional incorrect code for this rule with the \"consistent-as-needed\", { \"keywords\": true } options:\n选项 \"consistent-as-needed\", { \"keywords\": true } 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"consistent-as-needed\", { \"keywords\": true }]*/\n\nvar x = {\n    \"prop\": 1,\n    \"bar\": \"foo\"\n};\n\n\nunnecessary\nExamples of additional correct code for this rule with the \"as-needed\", { \"unnecessary\": false } options:\n选项 \"as-needed\", { \"unnecessary\": false } 的 正确 代码示例：\n/*eslint quote-props: [\"error\", \"as-needed\", { \"keywords\": true, \"unnecessary\": false }]*/\n\nvar x = {\n    \"while\": 1,\n    \"foo\": \"bar\"  // Would normally have caused a warning\n};\n\n\nnumbers\nExamples of additional incorrect code for this rule with the \"as-needed\", { \"numbers\": true } options:\n选项 \"as-needed\", { \"numbers\": true } 的 错误 代码示例：\n/*eslint quote-props: [\"error\", \"as-needed\", { \"numbers\": true }]*/\n\nvar x = {\n    100: 1\n}\n\n\nWhen Not To Use It\nIf you don’t care if property names are consistently wrapped in quotes or not, and you don’t target legacy ES3 environments, turn this rule off.\n如果你并不关心属性名是否始终被引号包裹，也不会弥留在 ES3 环境中，关闭此规则即可。\nFurther Reading\n\nReserved words as property names\nUnquoted property names / object keys in JavaScript\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/quote-props",
                "disable": false
            },
            {
                "real_name": "quotes",
                "display_name": "quotes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制使用一致的反勾号、双引号或单引号 (quotes)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce the consistent use of either backticks, double, or single quotes (quotes)\n强制使用一致的反勾号、双引号或单引号 (quotes)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript allows you to define strings in one of three ways: double quotes, single quotes, and backticks (as of ECMAScript 6). For example:\nJavascript 允许你用三种方式定义字符串：双引号，单引号和反勾号(在 ECMAScript 6 中)。例如：\n/*eslint-env es6*/\n\nvar double = \"double\";\nvar single = 'single';\nvar backtick = `backtick`;    // ES6 only\n\n\nEach of these lines creates a string and, in some cases, can be used interchangeably. The choice of how to define strings in a codebase is a stylistic one outside of template literals (which allow embedded of expressions to be interpreted).\n每一行创建了一个字符串，在某些情况下，可替换使用。在代码库中，如何定义字符串是模板文本(允许嵌入的表达式被解释执行)之外的风格上的问题。\nMany codebases require strings to be defined in a consistent manner.\n许多代码库要求以一致的方式定义字符串。\nRule Details\nThis rule enforces the consistent use of either backticks, double, or single quotes.\n该规则强制使用一致的反勾号、双引号或单引号。\nOptions\nThis rule has two options, a string option and an object option.\n该规则有两个选项，一个是字符串，一个是对象。\nString option:\n字符串选项：\n\n\"double\" (default) requires the use of double quotes wherever possible\n\"double\" (默认) 要求尽可能地使用双引号\n\"single\" requires the use of single quotes wherever possible\n\"single\" 要求尽可能地使用单引号\n\"backtick\" requires the use of backticks wherever possible\n\"backtick\" 要求尽可能地使用反勾号\n\nObject option:\n对象选项：\n\n\"avoidEscape\": true allows strings to use single-quotes or double-quotes so long as the string contains a quote that would have to be escaped otherwise\n\"avoidEscape\": true 允许字符串使用单引号或双引号，只要字符串中包含了一个其它引号，否则需要转义\n\"allowTemplateLiterals\": true allows strings to use backticks\n\"allowTemplateLiterals\": true 允许字符串使用反勾号\n\nDeprecated: The object property avoid-escape is deprecated; please use the object property avoidEscape instead.\n弃用：avoid-escape选项已被弃用；请使用 avoidEscape。\ndouble\nExamples of incorrect code for this rule with the default \"double\" option:\n默认选项 \"double\" 的 错误 代码示例：\n/*eslint quotes: [\"error\", \"double\"]*/\n\nvar single = 'single';\nvar unescaped = 'a string containing \"double\" quotes';\n\n\nExamples of correct code for this rule with the default \"double\" option:\n默认选项 \"double\" 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"double\"]*/\n/*eslint-env es6*/\n\nvar double = \"double\";\nvar backtick = `back\\ntick`;  // backticks are allowed due to newline\nvar backtick = tag`backtick`; // backticks are allowed due to tag\n\n\nsingle\nExamples of incorrect code for this rule with the \"single\" option:\n选项 \"single\" 的 错误 代码示例：\n/*eslint quotes: [\"error\", \"single\"]*/\n\nvar double = \"double\";\nvar unescaped = \"a string containing 'single' quotes\";\n\n\nExamples of correct code for this rule with the \"single\" option:\n选项 \"single\" 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"single\"]*/\n/*eslint-env es6*/\n\nvar single = 'single';\nvar backtick = `back${x}tick`; // backticks are allowed due to substitution\n\n\nbackticks\nExamples of incorrect code for this rule with the \"backtick\" option:\n选项 \"backtick\" 的 错误 代码示例：\n/*eslint quotes: [\"error\", \"backtick\"]*/\n\nvar single = 'single';\nvar double = \"double\";\nvar unescaped = 'a string containing `backticks`';\n\n\nExamples of correct code for this rule with the \"backtick\" option:\n选项 \"backtick\" 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"backtick\"]*/\n/*eslint-env es6*/\n\nvar backtick = `backtick`;\n\n\navoidEscape\nExamples of additional correct code for this rule with the \"double\", { \"avoidEscape\": true } options:\n选项呢 \"double\", { \"avoidEscape\": true } 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"double\", { \"avoidEscape\": true }]*/\n\nvar single = 'a string containing \"double\" quotes';\n\n\nExamples of additional correct code for this rule with the \"single\", { \"avoidEscape\": true } options:\n选项 \"single\", { \"avoidEscape\": true } 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"single\", { \"avoidEscape\": true }]*/\n\nvar double = \"a string containing 'single' quotes\";\n\n\nExamples of additional correct code for this rule with the \"backtick\", { \"avoidEscape\": true } options:\n选项 \"backtick\", { \"avoidEscape\": true } 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"backtick\", { \"avoidEscape\": true }]*/\n\nvar double = \"a string containing `backtick` quotes\"\n\n\nallowTemplateLiterals\nExamples of additional correct code for this rule with the \"double\", { \"allowTemplateLiterals\": true } options:\n选项 \"double\", { \"allowTemplateLiterals\": true } 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"double\", { \"allowTemplateLiterals\": true }]*/\n\nvar double = \"double\";\nvar double = `double`;\n\n\nExamples of additional correct code for this rule with the \"single\", { \"allowTemplateLiterals\": true } options:\n选项 \"single\", { \"allowTemplateLiterals\": true } 的 正确 代码示例：\n/*eslint quotes: [\"error\", \"single\", { \"allowTemplateLiterals\": true }]*/\n\nvar single = 'single';\nvar single = `single`;\n\n\nWhen Not To Use It\nIf you do not need consistency in your string styles, you can safely disable this rule.\n如果你不需要字符串风格保持一致，可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/quotes",
                "disable": false
            },
            {
                "real_name": "radix",
                "display_name": "radix",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求必须有基数 (radix)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Radix Parameter (radix)\n要求必须有基数 (radix)\nWhen using the parseInt() function it is common to omit the second argument, the radix, and let the function try to determine from the first argument what type of number it is. By default, parseInt() will autodetect decimal and hexadecimal (via 0x prefix). Prior to ECMAScript 5, parseInt() also autodetected octal literals, which caused problems because many developers assumed a leading 0 would be ignored.\n当使用parseInt()函数时，通常省略第二个参数，基数，并根据第一个参数确定它是什么类型的数字。\n默认情况下，parseInt()将自动检测十进制和十六进制(通过0x前缀)。在ECMAScript 5 之前，parseInt()也自动检测八进制文本，这会出现问题，因为许多开发人员认为前导0会被忽略。\nThis confusion led to the suggestion that you always use the radix parameter to parseInt() to eliminate unintended consequences. So instead of doing this:\n由于这种混乱，所以建议在parseInt()中始终使用基数以消除意想不到的后果。因此，不要这么做:\nvar num = parseInt(\"071\");      // 57\n\n\nDo this:\n要这么做：\nvar num = parseInt(\"071\", 10);  // 71\n\n\nECMAScript 5 changed the behavior of parseInt() so that it no longer autodetects octal literals and instead treats them as decimal literals. However, the differences between hexadecimal and decimal interpretation of the first parameter causes many developers to continue using the radix parameter to ensure the string is interpreted in the intended way.\nECMAScript 5 改变了parseInt()的这种行为，它不再自动检测八进制文本，而是把它们当作十进制文本。然而，对第一个参数的十六进制和十进制的解释之间的差异导致很多开发者继续使用基数来确保字符串是按预期的方式解释执行。\nOn the other hand, if the code is targeting only ES5-compliant environments passing the radix 10 may be redundant. In such a case you might want to disallow using such a radix.\n另一方面，如果代码只对兼容 ES5 环境，传递基数10可能是多余的。在这种情况下，你可能想禁止使用这样一个基数。\nRule Details\nThis rule is aimed at preventing the unintended conversion of a string to a number of a different base than intended or at preventing the redundant 10 radix if targeting modern environments only.\n该规则旨在防止出现不确定的字符串对数字的转换或防止在现代环境中出现多余的基数 10。\nOptions\nThere are two options for this rule:\n此规则有两个选项：\n\n\"always\" enforces providing a radix (default)\n\"always\"强制提供一个基数（默认的）\n\"as-needed\" disallows providing the 10 radix\n\"as-needed\"禁止提供基数10\n\nalways\nExamples of incorrect code for the default \"always\" option:\n\"always\"选项的 错误 代码示例：\n/*eslint radix: \"error\"*/\n\nvar num = parseInt(\"071\");\n\nvar num = parseInt(someValue);\n\nvar num = parseInt(\"071\", \"abc\");\n\nvar num = parseInt();\n\n\nExamples of correct code for the default \"always\" option:\n\"always\"选项的 正确 代码示例：\n/*eslint radix: \"error\"*/\n\nvar num = parseInt(\"071\", 10);\n\nvar num = parseInt(\"071\", 8);\n\nvar num = parseFloat(someValue);\n\n\nas-needed\nExamples of incorrect code for the \"as-needed\" option:\n\"as-needed\"选项的 错误 代码示例：\n/*eslint radix: [\"error\", \"as-needed\"]*/\n\nvar num = parseInt(\"071\", 10);\n\nvar num = parseInt(\"071\", \"abc\");\n\nvar num = parseInt();\n\n\nExamples of correct code for the \"as-needed\" option:\n\"as-needed\"选项的 正确 代码示例：\n/*eslint radix: [\"error\", \"as-needed\"]*/\n\nvar num = parseInt(\"071\");\n\nvar num = parseInt(\"071\", 8);\n\nvar num = parseFloat(someValue);\n\n\nWhen Not To Use It\nIf you don’t want to enforce either presence or omission of the 10 radix value you can turn this rule off.\n如果你不想强制约定是否有10这个基数，你可以关闭此规则。\nFurther Reading\n\nparseInt and radix\n\nVersion\nThis rule was introduced in ESLint 0.0.7.\n该规则在 ESLint 0.0.7 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/radix",
                "disable": false
            },
            {
                "real_name": "react/boolean-prop-naming",
                "display_name": "react/boolean-prop-naming",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforces consistent naming for boolean props",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "布尔值类型的 propTypes 的 name 必须为 is 或 has 开头\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/default-props-match-prop-types",
                "display_name": "react/default-props-match-prop-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce all defaultProps are defined and not \"required\" in propTypes.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "一个 defaultProps 必须有对应的 propTypes\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/display-name",
                "display_name": "react/display-name",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent missing displayName in a React component definition",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "组件必须有 displayName 属性\n@off 不强制要求写 displayName",
                "disable": false
            },
            {
                "real_name": "react/forbid-component-props",
                "display_name": "react/forbid-component-props",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Forbid certain props on components",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在自定义组件中使用一些指定的 props\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/forbid-elements",
                "display_name": "react/forbid-elements",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Forbid certain elements",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用一些指定的 elements\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/forbid-foreign-prop-types",
                "display_name": "react/forbid-foreign-prop-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Forbid using another component\\",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止直接使用别的组建的 propTypes\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/forbid-prop-types",
                "display_name": "react/forbid-prop-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Forbid certain propTypes",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用一些指定的 propTypes\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/jsx-boolean-value",
                "display_name": "react/jsx-boolean-value",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce boolean attributes notation in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 布尔值的属性必须显式的写 someprop={true}\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-closing-bracket-location",
                "display_name": "react/jsx-closing-bracket-location",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Validate closing bracket location in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 自闭和标签的反尖括号必须与尖括号的那一行对齐",
                "disable": false
            },
            {
                "real_name": "react/jsx-closing-tag-location",
                "display_name": "react/jsx-closing-tag-location",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Validate closing tag location for multiline JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 结束标签必须与开始标签的那一行对齐\n@off 已经在 jsx-indent 中限制了",
                "disable": false
            },
            {
                "real_name": "react/jsx-curly-spacing",
                "display_name": "react/jsx-curly-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce or disallow spaces inside of curly braces in JSX attributes",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 大括号内前后禁止有空格",
                "disable": false
            },
            {
                "real_name": "react/jsx-equals-spacing",
                "display_name": "react/jsx-equals-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow or enforce spaces around equal signs in JSX attributes",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable props 与 value 之间的等号前后禁止有空格",
                "disable": false
            },
            {
                "real_name": "react/jsx-filename-extension",
                "display_name": "react/jsx-filename-extension",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Restrict file extensions that may contain JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "限制文件后缀\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-first-prop-new-line",
                "display_name": "react/jsx-first-prop-new-line",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Ensure proper position of the first property in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 第一个 prop 必须得换行\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-handler-names",
                "display_name": "react/jsx-handler-names",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce event handler naming conventions in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "handler 的名称必须是 onXXX 或 handleXXX\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-indent",
                "display_name": "react/jsx-indent",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Validate JSX indentation",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable jsx 的 children 缩进必须为四个空格",
                "disable": false
            },
            {
                "real_name": "react/jsx-indent-props",
                "display_name": "react/jsx-indent-props",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Validate props indentation in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable jsx 的 props 缩进必须为四个空格",
                "disable": false
            },
            {
                "real_name": "react/jsx-key",
                "display_name": "react/jsx-key",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Report missing `key` props in iterators/collection literals",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "数组中的 jsx 必须有 key",
                "disable": false
            },
            {
                "real_name": "react/jsx-max-props-per-line",
                "display_name": "react/jsx-max-props-per-line",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Limit maximum of props on a single line in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 限制每行的 props 数量\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-no-bind",
                "display_name": "react/jsx-no-bind",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevents usage of Function.prototype.bind and arrow functions in React component definition",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "jsx 中禁止使用 bind\n@off 太严格了",
                "disable": false
            },
            {
                "real_name": "react/jsx-no-comment-textnodes",
                "display_name": "react/jsx-no-comment-textnodes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Comments inside children section of tag should be placed inside braces",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在 jsx 中使用像注释的字符串",
                "disable": false
            },
            {
                "real_name": "react/jsx-no-duplicate-props",
                "display_name": "react/jsx-no-duplicate-props",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce no duplicate props",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止出现重复的 props",
                "disable": false
            },
            {
                "real_name": "react/jsx-no-literals",
                "display_name": "react/jsx-no-literals",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent using string literals in React component definition",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在 jsx 中出现字符串\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-no-target-blank",
                "display_name": "react/jsx-no-target-blank",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Forbid target=\"_blank\" attribute without rel=\"noopener noreferrer\"",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 target=\"_blank\"\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-no-undef",
                "display_name": "react/jsx-no-undef",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow undeclared variables in JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用未定义的 jsx elemet",
                "disable": false
            },
            {
                "real_name": "react/jsx-pascal-case",
                "display_name": "react/jsx-pascal-case",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce PascalCase for user-defined JSX components",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 pascal 写法的 jsx，比如 <TEST_COMPONENT>",
                "disable": false
            },
            {
                "real_name": "react/jsx-sort-props",
                "display_name": "react/jsx-sort-props",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce props alphabetical sorting",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable props 必须排好序\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/jsx-tag-spacing",
                "display_name": "react/jsx-tag-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Validates whitespace in and around the JSX opening and closing brackets.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable jsx 的开始和闭合处禁止有空格",
                "disable": false
            },
            {
                "real_name": "react/jsx-uses-react",
                "display_name": "react/jsx-uses-react",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent React to be marked as unused",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "jsx 文件必须 import React",
                "disable": false
            },
            {
                "real_name": "react/jsx-uses-vars",
                "display_name": "react/jsx-uses-vars",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent variables used in JSX to be marked as unused",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "定义了的 jsx element 必须使用",
                "disable": false
            },
            {
                "real_name": "react/jsx-wrap-multilines",
                "display_name": "react/jsx-wrap-multilines",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent missing parentheses around multilines JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 多行的 jsx 必须有括号包起来\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/no-array-index-key",
                "display_name": "react/no-array-index-key",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of Array index in keys",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用数组的 index 作为 key\n@off 太严格了",
                "disable": false
            },
            {
                "real_name": "react/no-children-prop",
                "display_name": "react/no-children-prop",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent passing of children as props.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 children 做 props",
                "disable": false
            },
            {
                "real_name": "react/no-danger",
                "display_name": "react/no-danger",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of dangerous JSX props",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 dangerouslySetInnerHTML\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/no-danger-with-children",
                "display_name": "react/no-danger-with-children",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Report when a DOM element is using both children and dangerouslySetInnerHTML",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在使用了 dangerouslySetInnerHTML 的组建内添加 children",
                "disable": false
            },
            {
                "real_name": "react/no-deprecated",
                "display_name": "react/no-deprecated",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of deprecated methods",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用已废弃的 api",
                "disable": false
            },
            {
                "real_name": "react/no-did-mount-set-state",
                "display_name": "react/no-did-mount-set-state",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of setState in componentDidMount().",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在 componentDidMount 里面使用 setState\n@off 同构应用需要在 didMount 里写 setState",
                "disable": false
            },
            {
                "real_name": "react/no-did-update-set-state",
                "display_name": "react/no-did-update-set-state",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of setState in componentDidUpdate().",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在 componentDidUpdate 里面使用 setState",
                "disable": false
            },
            {
                "real_name": "react/no-direct-mutation-state",
                "display_name": "react/no-direct-mutation-state",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent direct mutation of this.state",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止直接修改 this.state",
                "disable": false
            },
            {
                "real_name": "react/no-find-dom-node",
                "display_name": "react/no-find-dom-node",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of findDOMNode",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 findDOMNode",
                "disable": false
            },
            {
                "real_name": "react/no-is-mounted",
                "display_name": "react/no-is-mounted",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of isMounted",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 isMounted",
                "disable": false
            },
            {
                "real_name": "react/no-multi-comp",
                "display_name": "react/no-multi-comp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent multiple component definition per file",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在一个文件创建两个组件\n@off 有一个 bug https:",
                "disable": false
            },
            {
                "real_name": "react/no-redundant-should-component-update",
                "display_name": "react/no-redundant-should-component-update",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Flag shouldComponentUpdate when extending PureComponent",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在 PureComponent 中使用 shouldComponentUpdate",
                "disable": false
            },
            {
                "real_name": "react/no-render-return-value",
                "display_name": "react/no-render-return-value",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of the return value of React.render",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 ReactDOM.render 的返回值",
                "disable": false
            },
            {
                "real_name": "react/no-set-state",
                "display_name": "react/no-set-state",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of setState",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 setState\n@off setState 很常用",
                "disable": false
            },
            {
                "real_name": "react/no-string-refs",
                "display_name": "react/no-string-refs",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent string definitions for references and prevent referencing this.refs",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用字符串 ref",
                "disable": false
            },
            {
                "real_name": "react/no-typos",
                "display_name": "react/no-typos",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent common typos",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止拼写错误",
                "disable": false
            },
            {
                "real_name": "react/no-unescaped-entities",
                "display_name": "react/no-unescaped-entities",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Detect unescaped HTML entities, which might represent malformed tags",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在组件的内部存在未转义的 >, \", ' 或 }",
                "disable": false
            },
            {
                "real_name": "react/no-unknown-property",
                "display_name": "react/no-unknown-property",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of unknown DOM property",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 禁止出现 HTML 中的属性，如 class",
                "disable": false
            },
            {
                "real_name": "react/no-unused-prop-types",
                "display_name": "react/no-unused-prop-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent definitions of unused prop types",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止出现未使用的 propTypes\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/no-unused-state",
                "display_name": "react/no-unused-state",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent definition of unused state fields",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "定义过的 state 必须使用\n@off 没有官方文档，并且存在很多 bug： https:",
                "disable": false
            },
            {
                "real_name": "react/no-will-update-set-state",
                "display_name": "react/no-will-update-set-state",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent usage of setState in componentWillUpdate().",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在 componentWillUpdate 中使用 setState",
                "disable": false
            },
            {
                "real_name": "react/prefer-es6-class",
                "display_name": "react/prefer-es6-class",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce ES5 or ES6 class for React Components",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "必须使用 Class 的形式创建组件",
                "disable": false
            },
            {
                "real_name": "react/prefer-stateless-function",
                "display_name": "react/prefer-stateless-function",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce stateless components to be written as a pure function",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "必须使用 pure function\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/prop-types",
                "display_name": "react/prop-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent missing props validation in a React component definition",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "组件必须写 propTypes\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/react-in-jsx-scope",
                "display_name": "react/react-in-jsx-scope",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent missing React when using JSX",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "出现 jsx 的地方必须 import React\n@off 已经在 no-undef 中限制了",
                "disable": false
            },
            {
                "real_name": "react/require-default-props",
                "display_name": "react/require-default-props",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce a defaultProps definition for every prop that is not a required prop.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "非 required 的 prop 必须有 defaultProps\n@off 不强制要求写 propTypes",
                "disable": false
            },
            {
                "real_name": "react/require-optimization",
                "display_name": "react/require-optimization",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce React components to have a shouldComponentUpdate method",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "组件必须有 shouldComponentUpdate\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/require-render-return",
                "display_name": "react/require-render-return",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce ES5 or ES6 class for returning value in render function",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "render 方法中必须有返回值",
                "disable": false
            },
            {
                "real_name": "react/self-closing-comp",
                "display_name": "react/self-closing-comp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent extra closing tags for components without children",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 组件内没有 children 时，必须使用自闭和写法\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/sort-comp",
                "display_name": "react/sort-comp",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce component methods order",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "@fixable 组件内方法必须按照一定规则排序",
                "disable": false
            },
            {
                "real_name": "react/sort-prop-types",
                "display_name": "react/sort-prop-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce propTypes declarations alphabetical sorting",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "propTypes 的熟悉必须按照字母排序\n@off 没必要限制",
                "disable": false
            },
            {
                "real_name": "react/style-prop-object",
                "display_name": "react/style-prop-object",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce style prop value is an object",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "style 属性的取值必须是 object",
                "disable": false
            },
            {
                "real_name": "react/void-dom-elements-no-children",
                "display_name": "react/void-dom-elements-no-children",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Prevent passing of children to void DOM elements (e.g. <br />).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "HTML 中的自闭和标签禁止有 children",
                "disable": false
            },
            {
                "real_name": "require-await",
                "display_name": "require-await",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow async functions which have no await expression (require-await).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow async functions which have no await expression (require-await)\nAsync functions which have no await expression may be the unintentional result of refactoring.\nRule Details\nThis rule warns async functions which have no await expression.\nExamples of incorrect code for this rule:\n/*eslint require-await: \"error\"*/\n\nasync function foo() {\n    doSomething();\n}\n\nbar(async () => {\n    doSomething();\n});\n\n\nExamples of correct code for this rule:\n/*eslint require-await: \"error\"*/\n\nasync function foo() {\n    await doSomething();\n}\n\nbar(async () => {\n    await doSomething();\n});\n\nfunction foo() {\n    doSomething();\n}\n\nbar(() => {\n    doSomething();\n});\n\n// Allow empty functions.\nasync function noop() {}\n\n\nWhen Not To Use It\nIf you don’t want to notify async functions which have no await expression, then it’s safe to disable this rule.\nRelated Rules\n\nrequire-yield\n\nVersion\nThis rule was introduced in ESLint 3.11.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/require-await",
                "disable": false
            },
            {
                "real_name": "require-jsdoc",
                "display_name": "require-jsdoc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求使用 JSDoc 注释 (require-jsdoc)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require JSDoc comments (require-jsdoc)\n要求使用 JSDoc 注释 (require-jsdoc)\nJSDoc is a JavaScript API documentation generator. It uses specially-formatted comments inside of code to generate API documentation automatically. For example, this is what a JSDoc comment looks like for a function:\nJSDoc 是一个 JavaScript API 文档生成器。它通过在代码中使用指定格式的注释自动生成 API 文档。例如，以下这个就是函数的 JSDoc 注释：\n/**\n * Adds two numbers together.\n * @param {int} num1 The first number.\n * @param {int} num2 The second number.\n * @returns {int} The sum of the two numbers.\n */\nfunction sum(num1, num2) {\n    return num1 + num2;\n}\n\n\nSome style guides require JSDoc comments for all functions as a way of explaining function behavior.\n一些风格指南要求对所有的函数使用 JSDoc 注释作为描述函数行为的一种方式。\nRule Details\nThis rule requires JSDoc comments for specified nodes. Supported nodes:\n该规则要求指定的节点使用 JSDoc 注释。支持的节点：\n\n\"FunctionDeclaration\"\n\"FunctionDeclaration\"\n\"ClassDeclaration\"\n\"ClassDeclaration\"\n\"MethodDefinition\"\n\"MethodDefinition\"\n\"ArrowFunctionExpression\"\n\"ArrowFunctionExpression\"\n\nOptions\nThis rule has a single object option:\n该规则有一个对象选项：\n\n\"require\" requires JSDoc comments for the specified nodes\n\"require\" 要求指定的节点使用 JSDoc 注释\n\nDefault option settings are:\n默认选项设置如下：\n{\n    \"require-jsdoc\": [\"error\", {\n        \"require\": {\n            \"FunctionDeclaration\": true,\n            \"MethodDefinition\": false,\n            \"ClassDeclaration\": false,\n            \"ArrowFunctionExpression\": false\n        }\n    }]\n}\n\n\nrequire\nExamples of incorrect code for this rule with the { \"require\": { \"FunctionDeclaration\": true, \"MethodDefinition\": true, \"ClassDeclaration\": true, \"ArrowFunctionExpression\": true } } option:\n选项 { \"require\": { \"FunctionDeclaration\": true, \"MethodDefinition\": true, \"ClassDeclaration\": true, \"ArrowFunctionExpression\": true } } 的 错误 代码示例：\n/*eslint \"require-jsdoc\": [\"error\", {\n    \"require\": {\n        \"FunctionDeclaration\": true,\n        \"MethodDefinition\": true,\n        \"ClassDeclaration\": true\n    }\n}]*/\n\nfunction foo() {\n    return 10;\n}\n\nvar foo = () => {\n    return 10;\n}\n\nclass Test{\n    getDate(){}\n}\n\n\nExamples of correct code for this rule with the { \"require\": { \"FunctionDeclaration\": true, \"MethodDefinition\": true, \"ClassDeclaration\": true, \"ArrowFunctionExpression\": true } } option:\n选项  { \"require\": { \"FunctionDeclaration\": true, \"MethodDefinition\": true, \"ClassDeclaration\": true, \"ArrowFunctionExpression\": true } } 的 正确 代码示例：\n/*eslint \"require-jsdoc\": [\"error\", {\n    \"require\": {\n        \"FunctionDeclaration\": true,\n        \"MethodDefinition\": true,\n        \"ClassDeclaration\": true\n    }\n}]*/\n\n/**\n * It returns 10\n */\nfunction foo() {\n    return 10;\n}\n\n/**\n * It returns test + 10\n * @params {int} test - some number\n * @returns {int} sum of test and 10\n */\nvar foo = (test) => {\n    return test + 10;\n}\n\n/**\n * It returns 10\n */\nvar foo = () => {\n    return 10;\n}\n\n/**\n * It returns 10\n */\nvar foo = function() {\n    return 10;\n}\n\nvar array = [1,2,3];\narray.filter(function(item) {\n    return item > 2;\n});\n\n/**\n * It returns 10\n */\nclass Test{\n    /**\n    * returns the date\n    */\n    getDate(){}\n}\n\nsetTimeout(() => {}, 10); // since it's an anonymous arrow function\n\n\nWhen Not To Use It\nIf you do not require JSDoc for your functions, then you can leave this rule off.\n如果你不需要为函数添加JSDoc注释，你可以关闭此规则。\nRelated Rules\n\nvalid-jsdoc\n\nVersion\nThis rule was introduced in ESLint 1.4.0.\n该规则在 ESLint 1.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/require-jsdoc",
                "disable": false
            },
            {
                "real_name": "require-yield",
                "display_name": "require-yield",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Disallow generator functions that do not have yield (require-yield).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow generator functions that do not have yield (require-yield)\n禁用函数内没有yield的 generator 函数\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nRule Details\nThis rule generates warnings for generator functions that do not have the yield keyword.\n如果 generator 函数内部没有yield关键字，该规则将发出警告。\nExamples\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint require-yield: \"error\"*/\n/*eslint-env es6*/\n\nfunction* foo() {\n  return 10;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint require-yield: \"error\"*/\n/*eslint-env es6*/\n\nfunction* foo() {\n  yield 5;\n  return 10;\n}\n\nfunction foo() {\n  return 10;\n}\n\n// This rule does not warn on empty generator functions.\nfunction* foo() { }\n\n\nWhen Not To Use It\nIf you don’t want to notify generator functions that have no yield expression, then it’s safe to disable this rule.\n如果伱不想被通知 generator 函数没有 yield 表达式，关闭此规则即可。\nRelated Rules\n\nrequire-await\n\nVersion\nThis rule was introduced in ESLint 1.0.0-rc-1.\n该规则在 ESLint 1.0.0-rc-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/require-yield",
                "disable": false
            },
            {
                "real_name": "rest-spread-spacing",
                "display_name": "rest-spread-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce spacing between rest and spread operators and their expressions (rest-spread-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce spacing between rest and spread operators and their expressions (rest-spread-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nES2015 introduced the rest and spread operators, which expand an iterable structure into its individual parts. Some examples of their usage are as follows:\nlet numArr = [1, 2, 3];\nfunction add(a, b, c) {\n    return a + b + c;\n}\nadd(...numArr); // -> 6\n\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\narr1.push(...arr2); // -> [1, 2, 3, 4, 5, 6]\n\nlet [a, b, ...arr] = [1, 2, 3, 4, 5];\na; // -> 1\nb // -> 2\narr; // ->  [3, 4, 5]\n\nfunction numArgs(...args) {\n  return args.length;\n}\nnumArgs(a, b, c); // -> 3\n\n\nIn addition to the above, there is currently a proposal to add object rest and spread properties to the spec. They can be used as follows:\n\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx; // -> 1\ny; // -> 2\nz; // -> { a: 3, b: 4 }\n\nlet n = { x, y, ...z };\nn; // -> { x: 1, y: 2, a: 3, b: 4 }\n\n\nAs with other operators, whitespace is allowed between the rest or spread operator and the expression it is operating on, which can lead to inconsistent spacing within a codebase.\nRule Details\nThis rule aims to enforce consistent spacing between rest and spread operators and their expressions. The rule also supports the currently experimental object rest and spread properties when enabled:\n{\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"ecmaFeatures\": {\n            \"experimentalObjectRestSpread\": true\n        }\n    }\n}\n\n\nPlease read the user guide’s section on configuring parser options to learn more.\nOptions\nThis rule takes one option: a string with the value of \"never\" or \"always\". The default value is \"never\".\n“never”\nWhen using the default \"never\" option, whitespace is not allowed between spread operators and their expressions.\nrest-spread-spacing: [\"error\"]\n\n\nor\nrest-spread-spacing: [\"error\", \"never\"]\n\n\nExamples of incorrect code for this rule with \"never\":\n/*eslint rest-spread-spacing: [\"error\", \"never\"]*/\n\nfn(... args)\n[... arr, 4, 5, 6]\nlet [a, b, ... arr] = [1, 2, 3, 4, 5];\nfunction fn(... args) { console.log(args); }\nlet { x, y, ... z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ... z };\n\n\nExamples of correct code for this rule with \"never\":\n/*eslint rest-spread-spacing: [\"error\", \"never\"]*/\n\nfn(...args)\n[...arr, 4, 5, 6]\nlet [a, b, ...arr] = [1, 2, 3, 4, 5];\nfunction fn(...args) { console.log(args); }\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ...z };\n\n\n“always”\nWhen using the \"always\" option, whitespace is required between spread operators and their expressions.\nrest-spread-spacing: [\"error\", \"always\"]\n\n\nExamples of incorrect code for this rule with \"always\":\n/*eslint rest-spread-spacing:[\"error\", \"always\"]*/\n\nfn(...args)\n[...arr, 4, 5, 6]\nlet [a, b, ...arr] = [1, 2, 3, 4, 5];\nfunction fn(...args) { console.log(args); }\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ...z };\n\n\nExamples of correct code for this rule with \"always\":\n/*eslint rest-spread-spacing: [\"error\", \"always\"]*/\n\nfn(... args)\n[... arr, 4, 5, 6]\nlet [a, b, ... arr] = [1, 2, 3, 4, 5];\nfunction fn(... args) { console.log(args); }\nlet { x, y, ... z } = { x: 1, y: 2, a: 3, b: 4 };\nlet n = { x, y, ... z };\n\n\nWhen Not To Use It\nYou can safely disable this rule if you do not care about enforcing consistent spacing between spread operators and their expressions.\nFurther Reading\n\nObject Rest/Spread Properties for ECMAScript\n\nVersion\nThis rule was introduced in ESLint 2.12.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/rest-spread-spacing",
                "disable": false
            },
            {
                "real_name": "semi",
                "display_name": "semi",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止使用分号代替 ASI (semi)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow semicolons instead of ASI (semi)\n要求或禁止使用分号代替 ASI (semi)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript is unique amongst the C-like languages in that it doesn’t require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as automatic semicolon insertion (ASI) and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\nJavaScript 在所有类 C 语言中是比较独特的，它不需要在每个语句的末尾有分号。在很多情况下，JavaScript 引擎可以确定一个分号应该在什么位置然后自动添加它。此特征被称为 自动分号插入 (ASI)，被认为是 JavaScript 中较为有争议的特征。例如，以下各行均有效：\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n第一行，JavaScript 引擎会自动插入分号，所以不会被认为是个语法错误。JavaScript 引擎还知道如何解释这一行，也知道行尾意味着语句的结束。\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn’t exist and always include semicolons manually. The rationale is that it’s easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n在 ASI 的争论中，一般有两大思想流派。第一个是，我们应该忽略 ASI 的存在，总是手动添加分号。理由是比起记住什么时候是否需要分号，把它们加进来更容易一些，并因此降低了引入错误的可能性。\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n然而，对使用分号的人而言，ASI 机制有时会很棘手。例如：\nreturn\n{\n    name: \"ESLint\"\n};\n\n\nThis may look like a return statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n这个看起来像是个return语句返回一个对象文本。然而，JavaScript 引擎将代码解释成：\nreturn;\n{\n    name: \"ESLint\";\n}\n\n\nEffectively, a semicolon is inserted after the return statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the no-unreachable rule will protect your code from such cases.\n事实上，一个分号插入到 return 语句之后，导致(块中的标签文本)下面的代码不可达。该规则和 no-unreachable 规则将会避免你的代码出现这种情况。\nOn the other side of the argument are those who says that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don’t use semicolons. For example, consider this code:\n争论的另一派别说由于分号的自动插入，它们是可选的，不需要手动添加。然而，对不使用分号的人而言，ASI 机制有时也会很棘手。例如，考虑以下代码：\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it’s a function). The no-unexpected-multiline rule can protect your code from such cases.\n在这个例子中，分号不会被插入到第一行末尾，导致一个运行时错误（因为一个空的对象被调用，犹如它是个函数）。no-unexpected-multiline 规则将会避免你的代码出现这种情况。\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a \\n character always ends a statement (just like a semicolon) unless one of the following is true:\n即使 ASI 允许在你的代码风格上提供更多的自由，不论你是否使用分号，它仍可以使你的代码表现的出乎意料。因此，最好是知道 ASI 什么时候插入分号，什么时候不插入分号，让 ESLint 帮你的代码避免这些潜在的意外情况。总之，正如 Isaac Schlueter 曾经描述的那样，一个 \\n 字符总是一个语句的结尾(像分号一样)，除非是下面情况之一:\n\nThe statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with . or ,.)\n该语句有一个没有闭合的括号，数组或对象或其它某种方式，不是有效结束一个语句的方式。（比如，以. 或,结尾）\nThe line is -- or ++ (in which case it will decrement/increment the next token.)\n该行是--或 ++（在这种情况下它将减少或增加下一个标记。）\nIt is a for(), while(), do, if(), or else, and there is no {\n它是个 for()，while()，do，if()或 else，没有{\nThe next line starts with [, (, +, *, /, -, ,, ., or some other binary operator that can only be found between two tokens in a single expression.\n下一行以[，(，+，*，/，-，,，.或一些其他在单个表达式中两个标记之间的二元操作符\n\nRule Details\nThis rule enforces consistent use of semicolons.\n该规则强制使用一致的分号。\nOptions\nThis rule has two options, a string option and an object option.\n该规则有两个选项，一个是字符串，一个是对象。\nString option:\n字符串选项：\n\n\"always\" (default) requires semicolons at the end of statements\n\"always\" (默认) 要求在语句末尾使用分号\n\"never\" disallows semicolons as the end of statements (except to disambiguate statements beginning with [, (, /, +, or -)\n\"never\" 禁止在语句末尾使用分号 (除了消除以 [、(、/、+ 或 - 开始的语句的歧义)\n\nObject option:\n对象选项：\n\n\"omitLastInOneLineBlock\": true ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\"omitLastInOneLineBlock\": true 忽略花括号在同一行（内容也就在同一行了）的语句块中的最后一个分号\n\nalways\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\n\nEven in \"never\" mode, semicolons are still allowed to disambiguate statements beginning with [, (, /, +, or -:\n即使是在 \"never\" 方式下，分号仍然是被允许的，用来消除以[、(、/、+ 或 -开头的语句的歧义：\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\n\nomitLastInOneLineBlock\nExamples of additional correct code for this rule with the \"always\", { \"omitLastInOneLineBlock\": true } options:\n选项 \"always\", { \"omitLastInOneLineBlock\": true } 的 正确 代码示例：\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n\n\nWhen Not To Use It\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n如果你不想以任何特定的方式强制分号的使用（或省略），你可以关闭此规则。\nFurther Reading\n\nAn Open Letter to JavaScript Leaders Regarding Semicolons\nJavaScript Semicolon Insertion\n\nRelated Rules\n\nno-extra-semi\nno-unexpected-multiline\nsemi-spacing\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/semi",
                "disable": false
            },
            {
                "real_name": "semi-spacing",
                "display_name": "semi-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制分号前后有空格 (semi-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce spacing before and after semicolons (semi-spacing)\n强制分号前后有空格 (semi-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nJavaScript allows you to place unnecessary spaces before or after a semicolon.\nJavaScript 允许你在分号前后放置不必要的空格。\nDisallowing or enforcing space around a semicolon can improve the readability of your program.\n禁止或强制分号周围的空格可以提高你程序的可读性。\nvar a = \"b\" ;\n\nvar c = \"d\";var e = \"f\";\n\n\nRule Details\nThis rule aims to enforce spacing around a semicolon. This rule prevents the use of spaces before a semicolon in expressions.\n该该规则旨在强制分号周围的空格。该规则防止在表达式中的分号之前使用空格。\nThis rule doesn’t check spacing in the following cases:\n该规则在以下情况下不会检查空格：\n\nThe spacing after the semicolon if it is the first token in the line.\n行首分号后面的空格\nThe spacing before the semicolon if it is after an opening parenthesis (( or {), or the spacing after the semicolon if it is before a closing parenthesis () or }). That spacing is checked by space-in-parens or block-spacing.\n开括号 (( 或 {) 之后、分号之前的空格，或分号之后、闭括号 () 或 }) 之前的空格。这个空格被 space-in-parens 或 block-spacing 规则检查。\nThe spacing around the semicolon in a for loop with an empty condition (for(;;)).\n空条件 (for(;;)) 的 for 循环语句中分号周围的空格。\n\nOptions\nThe rule takes one option, an object, which has two keys before and after having boolean values true or false.\n该规则有一个可选项，是个对象，有两个键 before 和 after 对应的值为布尔类型的值 true 或 false。\nIf before is true, space is enforced before semicolons and if it’s false, space is disallowed before semicolons.\n如果设置 before 为 true，分号之前强制有空格，如果设置为 false，分号之前禁止有空格。\nIf after is true, space is enforced after semicolons and if it’s false, space is disallowed after semicolons.\n如果设置 after 为 true.分号之后强制有空格，如果设置为 false，分号之后禁止有空格。\nThe after option will be only applied if a semicolon is not at the end of line.\nafter 选项只在分号不是行尾时起作用。\nThe default is {\"before\": false, \"after\": true}.\n默认选项为 {\"before\": false, \"after\": true}。\n    \"semi-spacing\": [\"error\", {\"before\": false, \"after\": true}]\n\n\n{\"before\": false, \"after\": true}\nThis is the default option. It enforces spacing after semicolons and disallows spacing before semicolons.\n这个是默认选项，它强制分号之后有空格，禁止分号之前有空格。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint semi-spacing: \"error\"*/\n\nvar foo ;\nvar foo;var bar;\nthrow new Error(\"error\") ;\nwhile (a) { break ; }\nfor (i = 0 ; i < 10 ; i++) {}\nfor (i = 0;i < 10;i++) {}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint semi-spacing: \"error\"*/\n\nvar foo;\nvar foo; var bar;\nthrow new Error(\"error\");\nwhile (a) { break; }\nfor (i = 0; i < 10; i++) {}\nfor (;;) {}\nif (true) {;}\n;foo();\n\n\n{\"before\": true, \"after\": false}\nThis option enforces spacing before semicolons and disallows spacing after semicolons.\n这个选项强制分号之前有空格，禁止分号之后有空格。\nExamples of incorrect code for this rule with the {\"before\": true, \"after\": false} option:\n选项 {\"before\": true, \"after\": false} 的 错误 代码示例：\n/*eslint semi-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo;\nvar foo ; var bar;\nthrow new Error(\"error\");\nwhile (a) { break; }\nfor (i = 0;i < 10;i++) {}\nfor (i = 0; i < 10; i++) {}\n\n\nExamples of correct code for this rule with the {\"before\": true, \"after\": false} option:\n选项 {\"before\": true, \"after\": false} 的 正确 代码示例：\n/*eslint semi-spacing: [\"error\", { \"before\": true, \"after\": false }]*/\n\nvar foo ;\nvar foo ;var bar ;\nthrow new Error(\"error\") ;\nwhile (a) {break ;}\nfor (i = 0 ;i < 10 ;i++) {}\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of spacing before or after semicolons.\n如果你不关心分号之前或之后的空格的一致性，你可以关闭此规则。\nRelated Rules\n\nsemi\nno-extra-semi\ncomma-spacing\nblock-spacing\nspace-in-parens\n\nVersion\nThis rule was introduced in ESLint 0.16.0.\n该规则在 ESLint 0.16.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/semi-spacing",
                "disable": false
            },
            {
                "real_name": "semi-style",
                "display_name": "semi-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce location of semicolons (semi-style)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce location of semicolons (semi-style)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nGenerally, semicolons are at the end of lines. However, in semicolon-less style, semicolons are at the beginning of lines. This rule enforces that semicolons are at the configured location.\nRule Details\nThis rule reports line terminators around semicolons.\nThis rule has an option.\n{\n    \"semi-style\": [\"error\", \"last\"],\n}\n\n\n\n\"last\" (Default) … enforces that semicolons are at the end of statements.\n\"first\" … enforces that semicolons are at the beginning of statements. Semicolons of for loop heads (for(a;b;c){}) should be at the end of lines even if you use this option.\n\nExamples of incorrect code for this rule with \"last\" option:\n/*eslint semi-style: [\"error\", \"last\"]*/\n\nfoo()\n;[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0\n    ; i < 10\n    ; ++i\n) {\n    foo()\n}\n\n\nExamples of correct code for this rule with \"last\" option:\n/*eslint semi-style: [\"error\", \"last\"]*/\n\nfoo();\n[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0;\n    i < 10;\n    ++i\n) {\n    foo()\n}\n\n\nExamples of incorrect code for this rule with \"first\" option:\n/*eslint semi-style: [\"error\", \"first\"]*/\n\nfoo();\n[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0\n    ; i < 10\n    ; ++i\n) {\n    foo()\n}\n\n\nExamples of correct code for this rule with \"first\" option:\n/*eslint semi-style: [\"error\", \"first\"]*/\n\nfoo()\n;[1, 2, 3].forEach(bar)\n\nfor (\n    var i = 0;\n    i < 10;\n    ++i\n) {\n    foo()\n}\n\n\nWhen Not To Use It\nIf you don’t want to notify the location of semicolons, then it’s safe to disable this rule.\nRelated rules\n\nno-extra-semi\nsemi\nsemi-spacing\n\nVersion\nThis rule was introduced in ESLint 4.0.0-beta.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/semi-style",
                "disable": false
            },
            {
                "real_name": "sort-imports",
                "display_name": "sort-imports",
                "severity": "error",
                "category": "correctness",
                "rule_title": "import 排序 (sort-imports)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Import Sorting (sort-imports)\nimport 排序 (sort-imports)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThe import statement is used to import members (functions, objects or primitives) that have been exported from an external module. Using a specific member syntax:\nimport 语句用来引入外部模块输出的成员 (函数、对象或原语)。使用一个特定的成员的语法：\n// single - Import single member.\nimport myMember from \"my-module.js\";\n\n// multiple - Import multiple members.\nimport {foo, bar} from \"my-module.js\";\n\n// all - Import all members, where myModule contains all the exported bindings.\nimport * as myModule from \"my-module.js\";\n\n\nThe import statement can also import a module without exported bindings. Used when the module does not export anything, but runs it own code or changes the global context object.\nimport 语句也可以引入不经输出绑定的模块。用于模块不作任何输入，就可运行或改变全局上下文对象。\n// none - Import module without exported bindings.\nimport \"my-module.js\"\n\n\nWhen declaring multiple imports, a sorted list of import declarations make it easier for developers to read the code and find necessary imports later. This rule is purely a matter of style.\n当什么多个 import ，一个排好序的 import 声明列表让开发者更容易阅读代码和找到必要的 import。该规则纯粹是一种风格。\nRule Details\nThis rule checks all import declarations and verifies that all imports are first sorted by the used member syntax and then alphabetically by the first member or alias name.\n该规则检查所有的 import 声明，验证所有的 import 都是首先按照使用的成员语法排序，其次是按照第一个成员或别名的字母顺序排序。\nThe --fix option on the command line automatically fixes some problems reported by this rule: multiple members on a single line are automatically sorted (e.g. import { b, a } from 'foo.js' is corrected to import { a, b } from 'foo.js'), but multiple lines are not reordered.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题：在同一行的多个元素会自动被排序（如， import { b, a } from 'foo.js' 会更正为 import { a, b } from 'foo.js'），但跨行的情况下不会重新排序。\nOptions\nThis rule accepts an object with its properties as\n该规则有一个对象选项：\n\nignoreCase (default: false)\nignoreCase (默认：false)\nignoreMemberSort (default: false)\nignoreMemberSort (默认：false)\nmemberSyntaxSortOrder (default: [\"none\", \"all\", \"multiple\", \"single\"]); all 4 items must be present in the array, but you can change the order:\nmemberSyntaxSortOrder (默认：[\"none\", \"all\", \"multiple\", \"single\"])；洗个选项都必须在数组中，但你可以改变它们的顺序：\n    \nnone = import module without exported bindings.\nnone = import 没有输出绑定的模块。\nall = import all members provided by exported bindings.\nall = import 所有经输出绑定的成员。\nmultiple = import multiple members.\nmultiple = import 多个成员。\nsingle = import single member.\nsingle = import 单个成员。\n\n\n\nDefault option settings are:\n默认选项设置：\n{\n    \"sort-imports\": [\"error\", {\n        \"ignoreCase\": false,\n        \"ignoreMemberSort\": false,\n        \"memberSyntaxSortOrder\": [\"none\", \"all\", \"multiple\", \"single\"]\n    }]\n}\n\n\nExamples\nDefault settings\nExamples of correct code for this rule when using default options:\n默认选项 正确 代码示例：\n/*eslint sort-imports: \"error\"*/\nimport 'module-without-export.js';\nimport * as foo from 'foo.js';\nimport * as bar from 'bar.js';\nimport {alpha, beta} from 'alpha.js';\nimport {delta, gamma} from 'delta.js';\nimport a from 'baz.js';\nimport b from 'qux.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport b from 'bar.js';\nimport c from 'baz.js';\n\n/*eslint sort-imports: \"error\"*/\nimport 'foo.js'\nimport * from 'bar.js';\nimport {a, b} from 'baz.js';\nimport c from 'qux.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {a, b, c} from 'foo.js'\n\n\nExamples of incorrect code for this rule when using default options:\n默认选项 错误 代码示例：\n/*eslint sort-imports: \"error\"*/\nimport b from 'foo.js';\nimport a from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport A from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {b, c} from 'foo.js';\nimport {a, b} from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport {b, c} from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport * as b from 'bar.js';\n\n/*eslint sort-imports: \"error\"*/\nimport {b, a, c} from 'foo.js'\n\n\nignoreCase\nWhen true the rule ignores the case-sensitivity of the imports local name.\n当为 true 时，该规则忽略 import 语句本地名称的大小写。\nExamples of incorrect code for this rule with the { \"ignoreCase\": true } option:\n选项 { \"ignoreCase\": true } 的 错误 代码示例：\n/*eslint sort-imports: [\"error\", { \"ignoreCase\": true }]*/\n\nimport B from 'foo.js';\nimport a from 'bar.js';\n\n\nExamples of correct code for this rule with the { \"ignoreCase\": true } option:\n选项 { \"ignoreCase\": true } 的 正确 代码示例：\n/*eslint sort-imports: [\"error\", { \"ignoreCase\": true }]*/\n\nimport a from 'foo.js';\nimport B from 'bar.js';\nimport c from 'baz.js';\n\n\nDefault is false.\n默认为 false。\nignoreMemberSort\nIgnores the member sorting within a multiple member import declaration.\n忽略有多个成员的 import 声明的排序。\nExamples of incorrect code for this rule with the default { \"ignoreMemberSort\": false } option:\n默认选项 { \"ignoreMemberSort\": false } 的 错误 代码示例：\n/*eslint sort-imports: [\"error\", { \"ignoreMemberSort\": false }]*/\nimport {b, a, c} from 'foo.js'\n\n\nExamples of correct code for this rule with the { \"ignoreMemberSort\": true } option:\n选项 { \"ignoreMemberSort\": true } 的 正确 代码示例：\n/*eslint sort-imports: [\"error\", { \"ignoreMemberSort\": true }]*/\nimport {b, a, c} from 'foo.js'\n\n\nDefault is false.\n默认为 false。\nmemberSyntaxSortOrder\nThere are four different styles and the default member syntax sort order is:\n有四种不同的风格，默认的成员语法排列顺序是：\n\nnone - import module without exported bindings.\nnone - import 没有输出绑定的模块。\nall - import all members provided by exported bindings.\nall - import 所有经输出绑定的成员。\nmultiple - import multiple members.\nmultiple - import 多个成员。\nsingle - import single member.\nsingle - import 单个成员。\n\nAll four options must be specified in the array, but you can customise their order.\n所有四个选项必须指定在数组中，但是你可以自定义它们的顺序。\nExamples of incorrect code for this rule with the default { \"memberSyntaxSortOrder\": [\"none\", \"all\", \"multiple\", \"single\"] } option:\n默认选项 { \"memberSyntaxSortOrder\": [\"none\", \"all\", \"multiple\", \"single\"] }  的 错误 代码示例：\n/*eslint sort-imports: \"error\"*/\nimport a from 'foo.js';\nimport * as b from 'bar.js';\n\n\nExamples of correct code for this rule with the { \"memberSyntaxSortOrder\": ['single', 'all', 'multiple', 'none'] } option:\n选项 { \"memberSyntaxSortOrder\": ['single', 'all', 'multiple', 'none'] } 的 正确 代码示例：\n/*eslint sort-imports: [\"error\", { \"memberSyntaxSortOrder\": ['single', 'all', 'multiple', 'none'] }]*/\n\nimport a from 'foo.js';\nimport * as b from 'bar.js';\n\n\nExamples of correct code for this rule with the { \"memberSyntaxSortOrder\": ['all', 'single', 'multiple', 'none'] } option:\n选项 { \"memberSyntaxSortOrder\": ['all', 'single', 'multiple', 'none'] } 的 正确 代码示例：\n/*eslint sort-imports: [\"error\", { \"memberSyntaxSortOrder\": ['all', 'single', 'multiple', 'none'] }]*/\n\nimport * as foo from 'foo.js';\nimport z from 'zoo.js';\nimport {a, b} from 'foo.js';\n\n\n\nDefault is [\"none\", \"all\", \"multiple\", \"single\"].\n默认为 [\"none\", \"all\", \"multiple\", \"single\"]。\nWhen Not To Use It\nThis rule is a formatting preference and not following it won’t negatively affect the quality of your code. If alphabetizing imports isn’t a part of your coding standards, then you can leave this rule disabled.\n该规则是个格式化偏好，不遵循它不会影响你的代码质量。如果按字母顺序排序的 import 不是你编码标准一部分，你可以关闭此规则。\nRelated Rules\n\nsort-keys\nsort-vars\n\nVersion\nThis rule was introduced in ESLint 2.0.0-beta.1.\n该规则在 ESLint 2.0.0-beta.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/sort-imports",
                "disable": false
            },
            {
                "real_name": "sort-keys",
                "display_name": "sort-keys",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require object keys to be sorted (sort-keys)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require object keys to be sorted (sort-keys)\nWhen declaring multiple properties, some developers prefer to sort property names alphabetically to be able to find necessary property easier at the later time. Others feel that it adds complexity and becomes burden to maintain.\nRule Details\nThis rule checks all property definitions of object expressions and verifies that all variables are sorted alphabetically.\nExamples of incorrect code for this rule:\n/*eslint sort-keys: \"error\"*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, c: 3, b: 2};\nlet obj = {a: 1, \"c\": 3, b: 2};\n\n// Case-sensitive by default.\nlet obj = {a: 1, b: 2, C: 3};\n\n// Non-natural order by default.\nlet obj = {1: a, 2: c, 10: b};\n\n// This rule checks computed properties which have a simple name as well.\n// Simple names are names which are expressed by an Identifier node or a Literal node.\nconst S = Symbol(\"s\")\nlet obj = {a: 1, [\"c\"]: 3, b: 2};\nlet obj = {a: 1, [S]: 3, b: 2};\n\n\nExamples of correct code for this rule:\n/*eslint sort-keys: \"error\"*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, b: 2, c: 3};\nlet obj = {a: 1, \"b\": 2, c: 3};\n\n// Case-sensitive by default.\nlet obj = {C: 3, a: 1, b: 2};\n\n// Non-natural order by default.\nlet obj = {1: a, 10: b, 2: c};\n\n// This rule checks computed properties which have a simple name as well.\nlet obj = {a: 1, [\"b\"]: 2, c: 3};\nlet obj = {a: 1, [b]: 2, c: 3};\n\n// This rule ignores computed properties which have a non-simple name.\nlet obj = {a: 1, [c + d]: 3, b: 2};\nlet obj = {a: 1, [\"c\" + \"d\"]: 3, b: 2};\nlet obj = {a: 1, [`${c}`]: 3, b: 2};\nlet obj = {a: 1, [tag`c`]: 3, b: 2};\n\n\nOptions\n{\n    \"sort-keys\": [\"error\", \"asc\", {\"caseSensitive\": true, \"natural\": false}]\n}\n\n\nThe 1st option is \"asc\" or \"desc\".\n\n\"asc\" (default) - enforce properties to be in ascending order.\n\"desc\" - enforce properties to be in descending order.\n\nThe 2nd option is an object which has 2 properties.\n\ncaseSensitive - if true, enforce properties to be in case-sensitive order. Default is true.\nnatural - if true, enforce properties to be in natural order. Default is false.\n\ndesc\nExamples of incorrect code for the \"desc\" option:\n/*eslint sort-keys: [\"error\", \"desc\"]*/\n/*eslint-env es6*/\n\nlet obj = {b: 2, c: 3, a: 1};\nlet obj = {\"b\": 2, c: 3, a: 1};\n\n// Case-sensitive by default.\nlet obj = {C: 1, b: 3, a: 2};\n\n// Non-natural order by default.\nlet obj = {10: b, 2: c, 1: a};\n\n\nExamples of correct code for the \"desc\" option:\n/*eslint sort-keys: [\"error\", \"desc\"]*/\n/*eslint-env es6*/\n\nlet obj = {c: 3, b: 2, a: 1};\nlet obj = {c: 3, \"b\": 2, a: 1};\n\n// Case-sensitive by default.\nlet obj = {b: 3, a: 2, C: 1};\n\n// Non-natural order by default.\nlet obj = {2: c, 10: b, 1: a};\n\n\ninsensitive\nExamples of incorrect code for the {caseSensitive: false} option:\n/*eslint sort-keys: [\"error\", \"asc\", {caseSensitive: false}]*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, c: 3, C: 4, b: 2};\nlet obj = {a: 1, C: 3, c: 4, b: 2};\n\n\nExamples of correct code for the {caseSensitive: false} option:\n/*eslint sort-keys: [\"error\", \"asc\", {caseSensitive: false}]*/\n/*eslint-env es6*/\n\nlet obj = {a: 1, b: 2, c: 3, C: 4};\nlet obj = {a: 1, b: 2, C: 3, c: 4};\n\n\nnatural\nExamples of incorrect code for the {natural: true} option:\n/*eslint sort-keys: [\"error\", \"asc\", {natural: true}]*/\n/*eslint-env es6*/\n\nlet obj = {1: a, 10: c, 2: b};\n\n\nExamples of correct code for the {natural: true} option:\n/*eslint sort-keys: [\"error\", \"asc\", {natural: true}]*/\n/*eslint-env es6*/\n\nlet obj = {1: a, 2: b, 10: c};\n\n\nWhen Not To Use It\nIf you don’t want to notify about properties’ order, then it’s safe to disable this rule.\nRelated Rules\n\nsort-imports\nsort-vars\n\nCompatibility\n\nJSCS: validateOrderInObjectKeys\n\nVersion\nThis rule was introduced in ESLint 3.3.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/sort-keys",
                "disable": false
            },
            {
                "real_name": "sort-vars",
                "display_name": "sort-vars",
                "severity": "error",
                "category": "correctness",
                "rule_title": "变量排序 (sort-vars)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Variable Sorting (sort-vars)\n变量排序 (sort-vars)\nWhen declaring multiple variables within the same block, some developers prefer to sort variable names alphabetically to be able to find necessary variable easier at the later time. Others feel that it adds complexity and becomes burden to maintain.\n当在同一个语句块中定义多个变量时，一些开发者比较喜欢将变量按字母顺序排序，以便在以后的时间更容易地找到需要的变量。其他人觉得，这样变得更复杂，甚至成了维护的负担。\nRule Details\nThis rule checks all variable declaration blocks and verifies that all variables are sorted alphabetically.\n该规则检查所有的变量声明块，并验证所有的变量都是按字母顺序排序的。\nThe default configuration of the rule is case-sensitive.\n该规则的默认配置是区分大小写的。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint sort-vars: \"error\"*/\n\nvar b, a;\n\nvar a, B, c;\n\nvar a, A;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint sort-vars: \"error\"*/\n\nvar a, b, c, d;\n\nvar _a = 10;\nvar _b = 20;\n\nvar A, a;\n\nvar B, a, c;\n\n\nAlphabetical list is maintained starting from the first variable and excluding any that are considered problems. So the following code will produce two problems:\n按字母顺序排序是指从第一个变量开始，排除任何被认为有问题的变量。所以下面的代码会产生两个问题：\n/*eslint sort-vars: \"error\"*/\n\nvar c, d, a, b;\n\n\nBut this one, will only produce one:\n但这个，只会产生一个问题：\n/*eslint sort-vars: \"error\"*/\n\nvar c, d, a, e;\n\n\nOptions\nThis rule has an object option:\n\n\"ignoreCase\": true (default false) ignores the case-sensitivity of the variables order\n\nignoreCase\nExamples of correct code for this rule with the { \"ignoreCase\": true } option:\n/*eslint sort-vars: [\"error\", { \"ignoreCase\": true }]*/\n\nvar a, A;\n\nvar a, B, c;\n\n\nWhen Not To Use It\nThis rule is a formatting preference and not following it won’t negatively affect the quality of your code. If you alphabetizing variables isn’t a part of your coding standards, then you can leave this rule off.\n该规则是一个格式化偏好，不遵循它，也不会对你的代码质量产生负面影响。如果按字母顺序排序的变量不是你编码标准的一部分，那么你可以关闭此规则。\nRelated Rules\n\nsort-keys\nsort-imports\n\nVersion\nThis rule was introduced in ESLint 0.2.0.\n该规则在 ESLint 0.2.0 被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/sort-vars",
                "disable": false
            },
            {
                "real_name": "space-before-blocks",
                "display_name": "space-before-blocks",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止语句块之前的空格 (space-before-blocks)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Or Disallow Space Before Blocks (space-before-blocks)\n要求或禁止语句块之前的空格 (space-before-blocks)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nConsistency is an important part of any style guide.\nWhile it is a personal preference where to put the opening brace of blocks,\nit should be consistent across a whole project.\nHaving an inconsistent style distracts the reader from seeing the important parts of the code.\n一致性是任何风格指南的重要组成部分。虽然在哪里放置块的开括号纯属个人偏好，但在整个项目中应该保持一致。不一致的风格将会分散读者阅读代码的注意力。\nRule Details\nThis rule will enforce consistency of spacing before blocks. It is only applied on blocks that don’t begin on a new line.\n该规则将强制块之前的空格的一致性。它只在非行首的块上起作用。\n\nThis rule ignores spacing which is between => and a block. The spacing is handled by the arrow-spacing rule.\n该规则忽略 => 和块之间的空格。arrow-spacing 规则处理这些空格。\nThis rule ignores spacing which is between a keyword and a block. The spacing is handled by the keyword-spacing rule.\n该规则忽略关键字和块之间的空格。keyword-spacing 规则处理这些空格。\n\nOptions\nThis rule takes one argument. If it is \"always\" then blocks must always have at least one preceding space. If \"never\" then all blocks should never have any preceding space. If different spacing is desired for function blocks, keyword blocks and classes, an optional configuration object can be passed as the rule argument to configure the cases separately. ( e.g. { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"always\" } )\n该规则有一个参数。如果为 \"always\"，块语句必须总是至少有一个前置空格。如果为\"never\"，所有的块永远不会有前置空格。如果函数块和关键字块要求不同的空格类型，可以单独传递一个可选配置的对象作为该规则的参数来配置这种情况。(比如：{ \"functions\": \"never\", \"keywords\": \"always\", classes: \"always\" } )\nThe default is \"always\".\n默认为 \"always\"。\n“always”\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint space-before-blocks: \"error\"*/\n\nif (a){\n    b();\n}\n\nfunction a(){}\n\nfor (;;){\n    b();\n}\n\ntry {} catch(a){}\n\nclass Foo{\n  constructor(){}\n}\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint space-before-blocks: \"error\"*/\n\nif (a) {\n    b();\n}\n\nif (a) {\n    b();\n} else{ /*no error. this is checked by `keyword-spacing` rule.*/\n    c();\n}\n\n\nfunction a() {}\n\nfor (;;) {\n    b();\n}\n\ntry {} catch(a) {}\n\n\n“never”\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint space-before-blocks: [\"error\", \"never\"]*/\n\nif (a) {\n    b();\n}\n\nfunction a() {}\n\nfor (;;) {\n    b();\n}\n\ntry {} catch(a) {}\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint space-before-blocks: [\"error\", \"never\"]*/\n\nif (a){\n    b();\n}\n\nfunction a(){}\n\nfor (;;){\n    b();\n}\n\ntry{} catch(a){}\n\nclass Foo{\n  constructor(){}\n}\n\n\nExamples of incorrect code for this rule when configured { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" }:\n选项 { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" } 的 错误 代码示例：\n/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction a() {}\n\ntry {} catch(a){}\n\nclass Foo{\n  constructor() {}\n}\n\n\nExamples of correct code for this rule when configured { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" }:\n选项 { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" } 的 正确 代码示例：\n/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"always\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nfor (;;) {\n  // ...\n}\n\ndescribe(function(){\n  // ...\n});\n\nclass Foo {\n  constructor(){}\n}\n\n\nExamples of incorrect code for this rule when configured { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" }:\n选项 { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" } 的 错误 代码示例：\n/*eslint space-before-blocks: [\"error\", { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nfunction a(){}\n\ntry {} catch(a) {}\n\nclass Foo {\n  constructor(){}\n}\n\n\nExamples of correct code for this rule when configured { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" }:\n选项 { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" } 的 正确 代码示例：\n/*eslint space-before-blocks: [\"error\", { \"functions\": \"always\", \"keywords\": \"never\", \"classes\": \"never\" }]*/\n/*eslint-env es6*/\n\nif (a){\n  b();\n}\n\nvar a = function() {}\n\nclass Foo{\n  constructor() {}\n}\n\n\nExamples of incorrect code for this rule when configured { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" }:\n选项 { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" } 的 错误 代码示例：\n/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" }]*/\n/*eslint-env es6*/\n\nclass Foo{\n  constructor(){}\n}\n\n\nExamples of correct code for this rule when configured { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" }:\n选项呢 { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" } 的 正确 代码示例：\n/*eslint space-before-blocks: [\"error\", { \"functions\": \"never\", \"keywords\": \"never\", \"classes\": \"always\" }]*/\n/*eslint-env es6*/\n\nclass Foo {\n  constructor(){}\n}\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of spacing before blocks.\n如果你不关心块之前的空格的一致性，你可以关闭此规则。\nRelated Rules\n\nkeyword-spacing\narrow-spacing\nbrace-style\n\nVersion\nThis rule was introduced in ESLint 0.9.0.\n该规则在 ESLint 0.9.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/space-before-blocks",
                "disable": false
            },
            {
                "real_name": "space-before-function-paren",
                "display_name": "space-before-function-paren",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止函数圆括号之前有一个空格 (space-before-function-paren)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow a space before function parenthesis (space-before-function-paren)\n要求或禁止函数圆括号之前有一个空格 (space-before-function-paren)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhen formatting a function, whitespace is allowed between the function name or function keyword and the opening paren. Named functions also require a space between the function keyword and the function name, but anonymous functions require no whitespace. For example:\n当格式化一个函数，函数名或 function 关键字与左括号之间允许有空白。命名函数要求函数名和 function 关键字之间有空格，但是匿名函数要求不加空格。例如：\nfunction withoutSpace(x) {\n    // ...\n}\n\nfunction withSpace (x) {\n    // ...\n}\n\nvar anonymousWithoutSpace = function() {};\n\nvar anonymousWithSpace = function () {};\n\n\nStyle guides may require a space after the function keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.\n一些风格指南可能要求匿名函数的 function 关键字后面有一个空格，而其他函数指定不要空格。同样的，函数名后可能会也可能不会要求有空格。\nRule Details\nThis rule aims to enforce consistent spacing before function parentheses and as such, will warn whenever whitespace doesn’t match the preferences specified.\n该规则旨在强制函数括号之前的空格的一致性，因此，当空格值不匹配指定首选参数时，该规则将发出警告。\nOptions\nThis rule has a string option or an object option:\n该规则有一个字符串选项或一个对象选项：\n{\n    \"space-before-function-paren\": [\"error\", \"always\"],\n    // or\n    \"space-before-function-paren\": [\"error\", {\n        \"anonymous\": \"always\",\n        \"named\": \"always\",\n        \"asyncArrow\": \"always\"\n    }],\n}\n\n\n\nalways (default) requires a space followed by the ( of arguments.\nalways (默认) 要求在参数的 ( 前面有一个空格。\nnever disallows any space followed by the ( of arguments.\nnever 禁止在参数的 ( 前面有空格。\n\nThe string option does not check async arrow function expressions for backward compatibility.\n字符串选项不会检查异步的箭头函数表达式以向后兼容。\nYou can also use a separate option for each type of function.\nEach of the following options can be set to \"always\", \"never\", or \"ignore\". The default is \"always\".\n你也可以对每种类型的函数分别设置选项。以下每个选项可以设置为 \"always\"、\"never\" 或 \"ignore\"。默认为 \"always\"。\n\nanonymous is for anonymous function expressions (e.g. function () {}).\nanonymous 针对匿名函数表达式 (比如 function () {})。\nnamed is for named function expressions (e.g. function foo () {}).\nnamed 针对命名的函数表达式 (比如 function foo () {})。\nasyncArrow is for async arrow function expressions (e.g. async () => {}).\nasyncArrow 针对异步的箭头函数表达式 (比如 async () => {})。\n\n“always”\nExamples of incorrect code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 错误 代码示例：\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n\n\nExamples of correct code for this rule with the default \"always\" option:\n默认选项 \"always\" 的 正确 代码示例：\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n\n\n“never”\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n\n\n{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}\nExamples of incorrect code for this rule with the {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"} option:\n选项 {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"} 的 错误 代码示例：\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async(a) => await a\n\n\nExamples of correct code for this rule with the {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"} option:\n选项 {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"} 的 正确 代码示例：\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async (a) => await a\n\n\n{\"anonymous\": \"never\", \"named\": \"always\"}\nExamples of incorrect code for this rule with the {\"anonymous\": \"never\", \"named\": \"always\"} option:\n选项 {\"anonymous\": \"never\", \"named\": \"always\"} 的 错误 代码示例：\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\n\nExamples of correct code for this rule with the {\"anonymous\": \"never\", \"named\": \"always\"} option:\n选项 {\"anonymous\": \"never\", \"named\": \"always\"} 的 正确 代码示例：\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\n\n{\"anonymous\": \"ignore\", \"named\": \"always\"}\nExamples of incorrect code for this rule with the {\"anonymous\": \"ignore\", \"named\": \"always\"} option:\n选项 {\"anonymous\": \"ignore\", \"named\": \"always\"} 的 错误 代码示例：\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\n\nExamples of correct code for this rule with the {\"anonymous\": \"ignore\", \"named\": \"always\"} option:\n选项 {\"anonymous\": \"ignore\", \"named\": \"always\"} 的 正确 代码示例：\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function () {\n    // ...\n};\n\nfunction foo () {\n    // ...\n}\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of spacing before function parenthesis.\n如果你不关心函数圆括号之前的空格的一致性，你可以关闭此规则。\nRelated Rules\n\nspace-after-keywords\nspace-return-throw-case\n\nVersion\nThis rule was introduced in ESLint 0.18.0.\n该规则在 ESLint 0.18.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/space-before-function-paren",
                "disable": false
            },
            {
                "real_name": "space-in-parens",
                "display_name": "space-in-parens",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止或强制圆括号内的空格 (space-in-parens)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Disallow or enforce spaces inside of parentheses (space-in-parens)\n禁止或强制圆括号内的空格 (space-in-parens)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSome style guides require or disallow spaces inside of parentheses:\n一些风格指南禁止或强制圆括号内有空格：\nfoo( 'bar' );\nvar x = ( 1 + 2 ) * 3;\n\nfoo('bar');\nvar x = (1 + 2) * 3;\n\n\nRule Details\nThis rule will enforce consistency of spacing directly inside of parentheses, by disallowing or requiring one or more spaces to the right of ( and to the left of ). In either case, () will still be allowed.\n该规则将通过禁止或要求 ( 右边或 ) 左边有一个或多个空格来强制圆括号内空格的一致性。在任一情况下，仍将允许 ()。\nOptions\nThere are two options for this rule:\n该规则有两个选项：\n\n\"never\" (default) enforces zero spaces inside of parentheses\n\"never\" (默认) 强制圆括号内没有空格\n\"always\" enforces a space inside of parentheses\n\"always\" 强制圆括号内有一个空格\n\nDepending on your coding conventions, you can choose either option by specifying it in your configuration:\n根据您的编码约定，您可以在您的配置中选择使用任一选项：\n\"space-in-parens\": [\"error\", \"always\"]\n\n\n“never”\nExamples of incorrect code for this rule with the default \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\"]*/\n\nfoo( 'bar');\nfoo('bar' );\nfoo( 'bar' );\n\nvar foo = ( 1 + 2 ) * 3;\n( function () { return 'bar'; }() );\n\n\nExamples of correct code for this rule with the default \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\"]*/\n\nfoo();\n\nfoo('bar');\n\nvar foo = (1 + 2) * 3;\n(function () { return 'bar'; }());\n\n\n“always”\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\"]*/\n\nfoo( 'bar');\nfoo('bar' );\nfoo('bar');\n\nvar foo = (1 + 2) * 3;\n(function () { return 'bar'; }());\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\"]*/\n\nfoo();\n\nfoo( 'bar' );\n\nvar foo = ( 1 + 2 ) * 3;\n( function () { return 'bar'; }() );\n\n\nExceptions\nAn object literal may be used as a third array item to specify exceptions, with the key \"exceptions\" and an array as the value. These exceptions work in the context of the first option. That is, if \"always\" is set to enforce spacing, then any “exception” will disallow spacing. Conversely, if \"never\" is set to disallow spacing, then any “exception” will enforce spacing.\n一个对象文本可以作为规则数组的第三个元素来制定例外情况，使用 \"exceptions\" 做主键，对应的值是一个数组。这些例外作用在第一个选项的基础上。如果 \"always\" 设置为强制使用空格，那么任何例外情况将 不允许使用空格。同样的，如果 \"never\"设置为禁止使用空格那么，任何例外情况将强制使用空格。\nThe following exceptions are available: [\"{}\", \"[]\", \"()\", \"empty\"].\n以下例外情况是有效的：[\"{}\", \"[]\", \"()\", \"empty\"].\nExamples of incorrect code for this rule with the \"never\", { \"exceptions\": [\"{}\"] } option:\n选项 \"never\", { \"exceptions\": [\"{}\"] } 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo({bar: 'baz'});\nfoo(1, {bar: 'baz'});\n\n\nExamples of correct code for this rule with the \"never\", { \"exceptions\": [\"{}\"] } option:\n选项 \"never\", { \"exceptions\": [\"{}\"] } 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo( {bar: 'baz'} );\nfoo(1, {bar: 'baz'} );\n\n\nExamples of incorrect code for this rule with the \"always\", { \"exceptions\": [\"{}\"] } option:\n选项 \"always\", { \"exceptions\": [\"{}\"] } 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo( {bar: 'baz'} );\nfoo( 1, {bar: 'baz'} );\n\n\nExamples of correct code for this rule with the \"always\", { \"exceptions\": [\"{}\"] } option:\n选项 \"always\", { \"exceptions\": [\"{}\"] } 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\"] }]*/\n\nfoo({bar: 'baz'});\nfoo( 1, {bar: 'baz'});\n\n\nExamples of incorrect code for this rule with the \"never\", { \"exceptions\": [\"[]\"] } option:\n选项 \"never\", { \"exceptions\": [\"[]\"] } 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo([bar, baz]);\nfoo([bar, baz], 1);\n\n\nExamples of correct code for this rule with the \"never\", { \"exceptions\": [\"[]\"] } option:\n选项 \"never\", { \"exceptions\": [\"[]\"] } 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo( [bar, baz] );\nfoo( [bar, baz], 1);\n\n\nExamples of incorrect code for this rule with the \"always\", { \"exceptions\": [\"[]\"] } option:\n选项 \"always\", { \"exceptions\": [\"[]\"] } 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo( [bar, baz] );\nfoo( [bar, baz], 1 );\n\n\nExamples of correct code for this rule with the \"always\", { \"exceptions\": [\"[]\"] } option:\n选项 \"always\", { \"exceptions\": [\"[]\"] } 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"[]\"] }]*/\n\nfoo([bar, baz]);\nfoo([bar, baz], 1 );\n\n\nExamples of incorrect code for this rule with the \"never\", { \"exceptions\": [\"()\"] }] option:\n选项 \"never\", { \"exceptions\": [\"()\"] }] 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"()\"] }]*/\n\nfoo((1 + 2));\nfoo((1 + 2), 1);\n\n\nExamples of correct code for this rule with the \"never\", { \"exceptions\": [\"()\"] }] option:\n选项 \"never\", { \"exceptions\": [\"()\"] }] 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"()\"] }]*/\n\nfoo( (1 + 2) );\nfoo( (1 + 2), 1);\n\n\nExamples of incorrect code for this rule with the \"always\", { \"exceptions\": [\"()\"] }] option:\n选项 \"always\", { \"exceptions\": [\"()\"] }] 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"()\"] }]*/\n\nfoo( ( 1 + 2 ) );\nfoo( ( 1 + 2 ), 1 );\n\n\nExamples of correct code for this rule with the \"always\", { \"exceptions\": [\"()\"] }] option:\n选项 \"always\", { \"exceptions\": [\"()\"] }] 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"()\"] }]*/\n\nfoo(( 1 + 2 ));\nfoo(( 1 + 2 ), 1 );\n\n\nThe \"empty\" exception concerns empty parentheses, and works the same way as the other exceptions, inverting the first option.\n\"empty\" 例外关注空括号，与其他例外作用一样，与第一个选项相反。\nExample of incorrect code for this rule with the \"never\", { \"exceptions\": [\"empty\"] }] option:\n选项 \"never\", { \"exceptions\": [\"empty\"] }] 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo();\n\n\nExample of correct code for this rule with the \"never\", { \"exceptions\": [\"empty\"] }] option:\n选项 \"never\", { \"exceptions\": [\"empty\"] }] 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"never\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo( );\n\n\nExample of incorrect code for this rule with the \"always\", { \"exceptions\": [\"empty\"] }] option:\n选项 \"always\", { \"exceptions\": [\"empty\"] }] 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo( );\n\n\nExample of correct code for this rule with the \"always\", { \"exceptions\": [\"empty\"] }] option:\n选项 \"always\", { \"exceptions\": [\"empty\"] }] 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"empty\"] }]*/\n\nfoo();\n\n\nYou can include multiple entries in the \"exceptions\" array.\n你可以在 \"exceptions\" 数组中包含多个项。\nExamples of incorrect code for this rule with the \"always\", { \"exceptions\": [\"{}\", \"[]\"] }] option:\n选项 \"always\", { \"exceptions\": [\"{}\", \"[]\"] }] 的 错误 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\", \"[]\"] }]*/\n\nbar( {bar:'baz'} );\nbaz( 1, [1,2] );\nfoo( {bar: 'baz'}, [1, 2] );\n\n\nExamples of correct code for this rule with the \"always\", { \"exceptions\": [\"{}\", \"[]\"] }] option:\n选项 \"always\", { \"exceptions\": [\"{}\", \"[]\"] }] 的 正确 代码示例：\n/*eslint space-in-parens: [\"error\", \"always\", { \"exceptions\": [\"{}\", \"[]\"] }]*/\n\nbar({bar:'baz'});\nbaz( 1, [1,2]);\nfoo({bar: 'baz'}, [1, 2]);\n\n\nWhen Not To Use It\nYou can turn this rule off if you are not concerned with the consistency of spacing between parentheses.\n如果你不关心圆括号直接空格的一致性，你可以关闭此规则。\nRelated Rules\n\nspace-in-brackets (deprecated)\n\nVersion\nThis rule was introduced in ESLint 0.8.0.\n该规则在 ESLint 0.8.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/space-in-parens",
                "disable": false
            },
            {
                "real_name": "space-infix-ops",
                "display_name": "space-infix-ops",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求中缀操作符周围有空格 (space-infix-ops)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require spacing around infix operators (space-infix-ops)\n要求中缀操作符周围有空格 (space-infix-ops)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhile formatting preferences are very personal, a number of style guides require spaces around operators, such as:\n虽然格式化首选项都非常个人化，但大量的风格指南要求运算符周围有空格，例如：\nvar sum = 1 + 2;\n\n\nThe proponents of these extra spaces believe it make the code easier to read and can more easily highlight potential errors, such as:\n这些额外空格的支持者认为它将使代码易于阅读，可以更轻易地突出潜在的错误，例如：\nvar sum = i+++2;\n\n\nWhile this is valid JavaScript syntax, it is hard to determine what the author intended.\n虽然这是有效的 JavaScript 语法，但很难确定作者的意图。\nRule Details\nThis rule is aimed at ensuring there are spaces around infix operators.\n此规则旨在确保中缀运算符周围有空格。\nOptions\nThis rule accepts a single options argument with the following defaults:\n该规则接收唯一一个可选项参数，具有以下默认值：\n\"space-infix-ops\": [\"error\", {\"int32Hint\": false}]\n\n\nint32Hint\nSet the int32Hint option to true (default is false) to allow write a|0 without space.\n设置 int32Hint 选项为 true (默认 false) 允许 a|0 不带空格.\nvar foo = bar|0; // `foo` is forced to be signed 32 bit integer\n\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint space-infix-ops: \"error\"*/\n/*eslint-env es6*/\n\na+b\n\na+ b\n\na +b\n\na?b:c\n\nconst a={b:1};\n\nvar {a=0}=bar;\n\nfunction foo(a=0) { }\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint space-infix-ops: \"error\"*/\n/*eslint-env es6*/\n\na + b\n\na       + b\n\na ? b : c\n\nconst a = {b:1};\n\nvar {a = 0} = bar;\n\nfunction foo(a = 0) { }\n\n\nVersion\nThis rule was introduced in ESLint 0.2.0.\n该规则在 ESLint 0.2.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/space-infix-ops",
                "disable": false
            },
            {
                "real_name": "space-unary-ops",
                "display_name": "space-unary-ops",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止在一元操作符之前或之后存在空格 (space-unary-ops)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow spaces before/after unary operators (space-unary-ops)\n要求或禁止在一元操作符之前或之后存在空格 (space-unary-ops)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSome style guides require or disallow spaces before or after unary operators. This is mainly a stylistic issue, however, some JavaScript expressions can be written without spacing which makes it harder to read and maintain.\n一些风格指南要求或禁止在一元操作符之前或之后存在空格。这主要是一个风格问题，然而，一些 JavaScript 表达式如果不写空格将会使其难以阅读和维护。\nRule Details\nThis rule enforces consistency regarding the spaces after words unary operators and after/before nonwords unary operators.\n该规则强制 words 一元操作符后空格和 nonwords 一元操作符之前或之后的空格的一致性。\nExamples of unary words operators:\n一元 words 操作符的例子：\n// new\nvar joe = new Person();\n\n// delete\nvar obj = {\n    foo: 'bar'\n};\ndelete obj.foo;\n\n// typeof\ntypeof {} // object\n\n// void\nvoid 0 // undefined\n\n\nExamples of unary nonwords operators:\n一元 nonwords 操作符的例子：\nif ([1,2,3].indexOf(1) !== -1) {};\nfoo = --foo;\nbar = bar++;\nbaz = !foo;\nqux = !!baz;\n\n\nOptions\nThis rule has three options:\n该规则有三个可选项：\n\nwords - applies to unary word operators such as: new, delete, typeof, void, yield\nwords - 适用于单词类一元操作符，例如：new、delete、typeof、void、yield\nnonwords - applies to unary operators such as: -, +, --, ++, !, !!\nnonwords - 适用于这些一元操作符: -、+、--、++、!、!!\noverrides - specifies overwriting usage of spacing for each\noperator, word or non word. This is empty by default, but can be used\nto enforce or disallow spacing around operators. For example:\noverrides - 覆盖操作符周围空格的用法。默认为空，但可用来强制或禁止操作符周围有空格。例如：\n\n    \"space-unary-ops\": [\n        2, {\n          \"words\": true,\n          \"nonwords\": false,\n          \"overrides\": {\n            \"new\": false,\n            \"++\": true\n          }\n    }]\n\n\nIn this case, spacing will be disallowed after a new operator and required before/after a ++ operator.\n在这个例子中，new 操作符之后禁用空格，++ 操作左右要求有空格。\nExamples of incorrect code for this rule with the {\"words\": true, \"nonwords\": false} option:\n选项 {\"words\": true, \"nonwords\": false} 的 错误 代码示例：\n/*eslint space-unary-ops: \"error\"*/\n\ntypeof!foo;\n\nvoid{foo:0};\n\nnew[foo][0];\n\ndelete(foo.bar);\n\n++ foo;\n\nfoo --;\n\n- foo;\n\n+ \"3\";\n\n\n/*eslint space-unary-ops: \"error\"*/\n/*eslint-env es6*/\n\nfunction *foo() {\n    yield(0)\n}\n\n\nExamples of correct code for this rule with the {\"words\": true, \"nonwords\": false} option:\n选项 {\"words\": true, \"nonwords\": false} 的 正确 代码示例：\n/*eslint space-unary-ops: \"error\"*/\n\n// Word unary operator \"delete\" is followed by a whitespace.\ndelete foo.bar;\n\n// Word unary operator \"new\" is followed by a whitespace.\nnew Foo;\n\n// Word unary operator \"void\" is followed by a whitespace.\nvoid 0;\n\n// Unary operator \"++\" is not followed by whitespace.\n++foo;\n\n// Unary operator \"--\" is not preceded by whitespace.\nfoo--;\n\n// Unary operator \"-\" is not followed by whitespace.\n-foo;\n\n// Unary operator \"+\" is not followed by whitespace.\n+\"3\";\n\n\n/*eslint space-unary-ops: \"error\"*/\n/*eslint-env es6*/\n\nfunction *foo() {\n    yield (0)\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.10.0.\n该规则在 ESLint 0.10.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/space-unary-ops",
                "disable": false
            },
            {
                "real_name": "spaced-comment",
                "display_name": "spaced-comment",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止在注释前有空白 (space 或 tab) (spaced-comment)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Requires or disallows a whitespace (space or tab) beginning a comment (spaced-comment)\n要求或禁止在注释前有空白 (space 或 tab) (spaced-comment)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nSome style guides require or disallow a whitespace immediately after the initial // or /* of a comment.\n一些风格指南要求或禁止注释 // 或 /* 后的空白。\nWhitespace after the // or /* makes it easier to read text in comments.\nOn the other hand, commenting out code is easier without having to put a whitespace right after the // or /*.\n// 或 /* 后的空白使注释中的文本更容易阅读。另一方面，// 或 /* 后面不加空白的话，给代码添加注释会变得更容易。\nRule Details\nThis rule will enforce consistency of spacing after the start of a comment // or /*. It also provides several exceptions for various documentation styles.\n该规则强制注释中 // 或 /* 后空格的一致性。它还为各种文档风格提供了一些例外情况。\nOptions\nThe rule takes two options.\n该规则有两个可选项。\n\nThe first is a string which be either \"always\" or \"never\". The default is \"always\".\n第一个是个字符串，值为 \"always\" 或 \"never\"。默认是 \"always\"。\n    \nIf \"always\" then the // or /* must be followed by at least one whitespace.\n如果是 \"always\"，// 或 /* 必须跟随至少一个空白。\nIf \"never\" then there should be no whitespace following.\n如果是 \"never\"，其后不允许有空白。\n\n\nThis rule can also take a 2nd option, an object with any of the following keys: \"exceptions\" and \"markers\".\n该规则可以设置第二个选项，是一个对象，其属性的键为 \"exceptions\" 和 \"markers\"。\n    \nThe \"exceptions\" value is an array of string patterns which are considered exceptions to the rule.\n  Please note that exceptions are ignored if the first argument is \"never\".\n\"exceptions\" 的值是一个字符串形式的数组，这些字符串也就是该规则的例外。\n  请注意，如果第一个参数是 \"never\"，例外情况会被忽略。\n          \"spaced-comment\": [\"error\", \"always\", { \"exceptions\": [\"-\", \"+\"] }]\n\n\n\nThe \"markers\" value is an array of string patterns which are considered markers for docblock-style comments, such as an additional /, used to denote documentation read by doxygen, vsdoc, etc. which must have additional characters. The \"markers\" array will apply regardless of the value of the first argument, e.g. \"always\" or \"never\".\n\"markers\"的值是一个字符串形式的数组，这些字符串也就是块级注释的标记，例如一个额外的 /，被用来表示是由 doxygen、vsdoc 等系统读取的文档，这些系统必须有额外的字符。\n  不管第一个参数是 \"always\" 还是 \"never\"、\"markers\"数组都会起作用。\n          \"spaced-comment\": [\"error\", \"always\", { \"markers\": [\"/\"] }]\n\n\n\n\n\n\nThe difference between a marker and an exception is that a marker only appears at the beginning of the comment whereas\nexceptions can occur anywhere in the comment string.\n标记和例外的区别是，标记值只出现在注释的开头，而例外是可以出现在注释中任何地方。\nYou can also define separate exceptions and markers for block and line comments. The \"block\" object can have an additional key \"balanced\", a boolean that specifies if inline block comments should have balanced spacing. The default value is false.\n你可以为块级注释和单行注释定义不同的例外和标记。\"block\" 对象可以有一个 boolean 类型的属性 \"balanced\"，用来指定内联块注释是否应该有对称的空格。默认为 false。\n\nIf \"balanced\": true and \"always\" then the /* must be followed by at least one whitespace, and the */ must be preceded by at least one whitespace.\n如果 \"balanced\": true 而且是 \"always\" 那么 /* 后必须有只上一个空白，*/之前必须至少有一个空白。\nIf \"balanced\": true and \"never\" then there should be no whitespace following /* or preceding */.\n如果 \"balanced\": true 而且是 \"never\" 那么 /* 之后或 */ 之前不应该有空白。\nIf \"balanced\": false then balanced whitespace is not enforced.\n如果 \"balanced\": false 不强制有对称的空白。\n\n\"spaced-comment\": [\"error\", \"always\", {\n    \"line\": {\n        \"markers\": [\"/\"],\n        \"exceptions\": [\"-\", \"+\"]\n    },\n    \"block\": {\n        \"markers\": [\"!\"],\n        \"exceptions\": [\"*\"],\n        \"balanced\": true\n    }\n}]\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint spaced-comment: [\"error\", \"always\"]*/\n\n//This is a comment with no whitespace at the beginning\n\n/*This is a comment with no whitespace at the beginning */\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"balanced\": true } }] */\n/* This is a comment with whitespace at the beginning but not the end*/\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/* eslint spaced-comment: [\"error\", \"always\"] */\n\n// This is a comment with a whitespace at the beginning\n\n/* This is a comment with a whitespace at the beginning */\n\n/*\n * This is a comment with a whitespace at the beginning\n */\n\n/*\nThis comment has a newline\n*/\n\n\n/* eslint spaced-comment: [\"error\", \"always\"] */\n\n/**\n* I am jsdoc\n*/\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint spaced-comment: [\"error\", \"never\"]*/\n\n// This is a comment with a whitespace at the beginning\n\n/* This is a comment with a whitespace at the beginning */\n\n/* \\nThis is a comment with a whitespace at the beginning */\n\n\n/*eslint spaced-comment: [\"error\", \"never\", { \"block\": { \"balanced\": true } }]*/\n/*This is a comment with whitespace at the end */\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint spaced-comment: [\"error\", \"never\"]*/\n\n/*This is a comment with no whitespace at the beginning */\n\n\n/*eslint spaced-comment: [\"error\", \"never\"]*/\n\n/**\n* I am jsdoc\n*/\n\n\nexceptions\nExamples of incorrect code for this rule with the \"always\" option combined with \"exceptions\":\n选项 \"always\" 结合 \"exceptions\" 的 错误 代码示例：\n/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"exceptions\": [\"-\"] } }] */\n\n//--------------\n// Comment block\n//--------------\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-\", \"+\"] }] */\n\n//------++++++++\n// Comment block\n//------++++++++\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-\", \"+\"] }] */\n\n/*------++++++++*/\n/* Comment block */\n/*------++++++++*/\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"line\": { \"exceptions\": [\"-+\"] } }] */\n\n/*-+-+-+-+-+-+-+*/\n// Comment block\n/*-+-+-+-+-+-+-+*/\n\n\nExamples of correct code for this rule with the \"always\" option combined with \"exceptions\":\n选项 \"always\" 结合 \"exceptions\" 的 正确 代码示例：\n/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-\"] }] */\n\n//--------------\n// Comment block\n//--------------\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"line\": { \"exceptions\": [\"-\"] } }] */\n\n//--------------\n// Comment block\n//--------------\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"*\"] }] */\n\n/****************\n * Comment block\n ****************/\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"exceptions\": [\"-+\"] }] */\n\n//-+-+-+-+-+-+-+\n// Comment block\n//-+-+-+-+-+-+-+\n\n/*-+-+-+-+-+-+-+*/\n// Comment block\n/*-+-+-+-+-+-+-+*/\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"exceptions\": [\"-+\"] } }] */\n\n/*-+-+-+-+-+-+-+*/\n// Comment block\n/*-+-+-+-+-+-+-+*/\n\n\nmarkers\nExamples of incorrect code for this rule with the \"always\" option combined with \"markers\":\n选项 \"always\" 结合 \"markers\" 的 错误 代码示例：\n/* eslint spaced-comment: [\"error\", \"always\", { \"markers\": [\"/\"] }] */\n\n///This is a comment with a marker but without whitespace\n\n\n/*eslint spaced-comment: [\"error\", \"always\", { \"block\": { \"markers\": [\"!\"], \"balanced\": true } }]*/\n/*! This is a comment with a marker but without whitespace at the end*/\n\n\n/*eslint spaced-comment: [\"error\", \"never\", { \"block\": { \"markers\": [\"!\"], \"balanced\": true } }]*/\n/*!This is a comment with a marker but with whitespace at the end */\n\n\nExamples of correct code for this rule with the \"always\" option combined with \"markers\":\n选项 \"always\" 结合 \"markers\" 的 正确 代码示例：\n/* eslint spaced-comment: [\"error\", \"always\", { \"markers\": [\"/\"] }] */\n\n/// This is a comment with a marker\n\n\n/*eslint spaced-comment: [\"error\", \"never\", { \"markers\": [\"!<\"] }]*/\n\n//!<This is a line comment with a marker\n\n/*!<this is a block comment with a marker\nsubsequent lines are ignored\n*/\n\n\n/* eslint spaced-comment: [\"error\", \"always\", { \"markers\": [\"global\"] }] */\n\n/*global ABC*/\n\n\nRelated Rules\n\nspaced-line-comment\n\nVersion\nThis rule was introduced in ESLint 0.23.0.\n该规则在 ESLint 0.23.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/spaced-comment",
                "disable": false
            },
            {
                "real_name": "strict",
                "display_name": "strict",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止使用严格模式指令 (strict)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require or disallow strict mode directives (strict)\n要求或禁止使用严格模式指令 (strict)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nA strict mode directive is a \"use strict\" literal at the beginning of a script or function body. It enables strict mode semantics.\n严格模式指令是在脚本或函数体开始位置放置一个 \"use strict\" 字面量。它启用了严格模式语义。\nWhen a directive occurs in global scope, strict mode applies to the entire script:\n当指令出现在全局作用域，严格模式指令适用于整个脚本：\n\"use strict\";\n\n// strict mode\n\nfunction foo() {\n    // strict mode\n}\n\n\nWhen a directive occurs at the beginning of a function body, strict mode applies only to that function, including all contained functions:\n当指令出现在函数体开始位置，严格模式指令只适用于那个函数，包括其内部函数：\nfunction foo() {\n    \"use strict\";\n    // strict mode\n}\n\nfunction foo2() {\n    // not strict mode\n};\n\n(function() {\n    \"use strict\";\n    function bar() {\n        // strict mode\n    }\n}());\n\n\nIn the CommonJS module system, a hidden function wraps each module and limits the scope of a “global” strict mode directive.\n在 CommonJS 模块系统，a hidden function wraps each module and limits the scope of a “global” strict mode directive。\nIn ECMAScript modules, which always have strict mode semantics, the directives are unnecessary.\n在 ECMAScript 模块中，总是处于严格模式语义下，严格模式指令也就没必要了。\nRule Details\nThis rule requires or disallows strict mode directives.\n该规则要求或禁止严格模式指令。\nThis rule disallows strict mode directives, no matter which option is specified, if ESLint configuration specifies either of the following as parser options:\n该规则禁止严格模式指令，无论指定了下面的哪个选项 parser options：\n\n\"sourceType\": \"module\" that is, files are ECMAScript modules\n\"sourceType\": \"module\" 也就是说，文件是 ECMAScript 模块\n\"impliedStrict\": true property in the ecmaFeatures object\n\"impliedStrict\": true ecmaFeatures 对象中的属性\n\nThis rule disallows strict mode directives, no matter which option is specified, in functions with non-simple parameter lists (for example, parameter lists with default parameter values) because that is a syntax error in ECMAScript 2016 and later. See the examples of the function option.\n在有非常规参数列表（例如，有默认参数值）的函数中，不管指定的了什么选项，该规则禁止指定严格模式指令，因为 在 ECMAScript 2016 和以后的版本中将会报语法错误。查看function 选项。\nThe --fix option on the command line does not insert new \"use strict\" statements, but only removes unneeded statements.\n命令行的 --fix 选项不会插入新的 \"use strict\" 语句，只会移除不再需要的语句。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"safe\" (default) corresponds either of the following options:\n\"safe\" (默认) 对应下面的选项：\n    \n\"global\" if ESLint considers a file to be a CommonJS module\n\"global\" 如果 ESLint 认为一个文件是 CommonJS 模块\n\"function\" otherwise\n\"function\" 如果 ESLint 认为一个文件不是 CommonJS 模块\n\n\n\"global\" requires one strict mode directive in the global scope (and disallows any other strict mode directives)\n\"global\" 要求在全局作用域下有一个严格模式指令（不允许任何其它严格模式指令）\n\"function\" requires one strict mode directive in each top-level function declaration or expression (and disallows any other strict mode directives)\n\"function\" 要求在函数声明或表达式开始位置有一个严格模式指令（不允许任何其它严格模式指令）\n\"never\" disallows strict mode directives\n\"never\" 禁用严格模式指令\n\nsafe\nThe \"safe\" option corresponds to the \"global\" option if ESLint considers a file to be a Node.js or CommonJS module because the configuration specifies either of the following:\n如果 ESLint 认为一个文件是 Node.js 或 CommonJS 模块，\"safe\" 选项就对应 \"global\" 选项，因为配置指定了下面中的一个：\n\nnode or commonjs environments\nnode 或 commonjs environments\n\"globalReturn\": true property in the ecmaFeatures object of parser options\n\"globalReturn\": true parser options 的 ecmaFeatures 对象中的属性\n\nOtherwise the \"safe\" option corresponds to the \"function\" option.\n否则 \"safe\" 选项就对应 \"function\" 选项。\nglobal\nExamples of incorrect code for this rule with the \"global\" option:\n选项 \"global\" 的 错误 代码示例：\n/*eslint strict: [\"error\", \"global\"]*/\n\nfunction foo() {\n}\n\n\n/*eslint strict: [\"error\", \"global\"]*/\n\nfunction foo() {\n    \"use strict\";\n}\n\n\n/*eslint strict: [\"error\", \"global\"]*/\n\n\"use strict\";\n\nfunction foo() {\n    \"use strict\";\n}\n\n\nExamples of correct code for this rule with the \"global\" option:\n选项 \"global\" 的 正确 代码示例：\n/*eslint strict: [\"error\", \"global\"]*/\n\n\"use strict\";\n\nfunction foo() {\n}\n\n\nfunction\nThis option ensures that all function bodies are strict mode code, while global code is not. Particularly if a build step concatenates multiple scripts, a strict mode directive in global code of one script could unintentionally enable strict mode in another script that was not intended to be strict code.\n该个选项确保所有的函数体都是严格模式代码，而全局代码不是。特别是如果一个构建步骤链接多个脚本，一个脚本中的全局作用域的严格模式指令会无意间启用另一个脚本的严格模式。\nExamples of incorrect code for this rule with the \"function\" option:\n选项 \"function\" 的 错误 代码示例：\n/*eslint strict: [\"error\", \"function\"]*/\n\n\"use strict\";\n\nfunction foo() {\n}\n\n\n/*eslint strict: [\"error\", \"function\"]*/\n\nfunction foo() {\n}\n\n(function() {\n    function bar() {\n        \"use strict\";\n    }\n}());\n\n\n/*eslint strict: [\"error\", \"function\"]*/\n/*eslint-env es6*/\n\n// Illegal \"use strict\" directive in function with non-simple parameter list.\n// This is a syntax error since ES2016.\nfunction foo(a = 1) {\n    \"use strict\";\n}\n\n// We cannot write \"use strict\" directive in this function.\n// So we have to wrap this function with a function with \"use strict\" directive.\nfunction foo(a = 1) {\n}\n\n\nExamples of correct code for this rule with the \"function\" option:\n选项 \"function\" 的 正确 代码示例：\n/*eslint strict: [\"error\", \"function\"]*/\n\nfunction foo() {\n    \"use strict\";\n}\n\n(function() {\n    \"use strict\";\n\n    function bar() {\n    }\n\n    function baz(a = 1) {\n    }\n}());\n\nvar foo = (function() {\n    \"use strict\";\n\n    return function foo(a = 1) {\n    };\n}());\n\n\nnever\nExamples of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint strict: [\"error\", \"never\"]*/\n\n\"use strict\";\n\nfunction foo() {\n}\n\n\n/*eslint strict: [\"error\", \"never\"]*/\n\nfunction foo() {\n    \"use strict\";\n}\n\n\nExamples of correct code for this rule with the \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint strict: [\"error\", \"never\"]*/\n\nfunction foo() {\n}\n\n\nWhen Not To Use It\nIn a codebase that has both strict and non-strict code, either turn this rule off, or selectively disable it where necessary. For example, functions referencing arguments.callee are invalid in strict mode. A full list of strict mode differences is available on MDN.\n在既有严格模式也有非严格模式的代码库中，可以关闭此规则，或必要时选择性地禁用严格模式。例如，函数引用 arguments.callee在严格模式下是无效的。可以看一下 MDN 上的这篇文章《严格模式的区别》。\nVersion\nThis rule was introduced in ESLint 0.1.0.\n该规则在 ESLint 0.1.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/strict",
                "disable": false
            },
            {
                "real_name": "switch-colon-spacing",
                "display_name": "switch-colon-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Enforce spacing around colons of switch statements (switch-colon-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce spacing around colons of switch statements (switch-colon-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nSpacing around colons improves readability of case/default clauses.\nRule Details\nThis rule controls spacing around colons of case and default clauses in switch statements.\nThis rule does the check only if the consecutive tokens exist on the same line.\nThis rule has 2 options that are boolean value.\n{\n    \"switch-colon-spacing\": [\"error\", {\"after\": true, \"before\": false}]\n}\n\n\n\n\"after\": true (Default) … requires one or more spaces after colons.\n\"after\": false … disallows spaces after colons.\n\"before\": true … requires one or more spaces before colons.\n\"before\": false (Default) … disallows before colons.\n\nExamples of incorrect code for this rule:\n/*eslint switch-colon-spacing: \"error\"*/\n\nswitch (a) {\n    case 0 :break;\n    default :foo();\n}\n\n\nExamples of correct code for this rule:\n/*eslint switch-colon-spacing: \"error\"*/\n\nswitch (a) {\n    case 0: foo(); break;\n    case 1:\n        bar();\n        break;\n    default:\n        baz();\n        break;\n}\n\n\nExamples of incorrect code for this rule with {\"after\": false, \"before\": true} option:\n/*eslint switch-colon-spacing: [\"error\", {\"after\": false, \"before\": true}]*/\n\nswitch (a) {\n    case 0: break;\n    default: foo();\n}\n\n\nExamples of correct code for this rule with {\"after\": false, \"before\": true} option:\n/*eslint switch-colon-spacing: [\"error\", {\"after\": false, \"before\": true}]*/\n\nswitch (a) {\n    case 0 :foo(); break;\n    case 1 :\n        bar();\n        break;\n    default :\n        baz();\n        break;\n}\n\n\nWhen Not To Use It\nIf you don’t want to notify spacing around colons of switch statements, then it’s safe to disable this rule.\nVersion\nThis rule was introduced in ESLint 4.0.0-beta.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/switch-colon-spacing",
                "disable": false
            },
            {
                "real_name": "symbol-description",
                "display_name": "symbol-description",
                "severity": "error",
                "category": "correctness",
                "rule_title": "require symbol description (symbol-description)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require symbol description (symbol-description)\nThe Symbol function may have optional description:\nvar foo = Symbol(\"some description\");\n\nvar someString = \"some description\";\nvar bar = Symbol(someString);\n\n\nUsing description promotes easier debugging: when a symbol is logged the description is used:\nvar foo = Symbol(\"some description\");\n\n> console.log(foo);\n// Symbol(some description)\n\n\nIt may facilitate identifying symbols when one is observed during debugging.\nRule Details\nThis rules requires a description when creating symbols.\nExamples\nExamples of incorrect code for this rule:\n/*eslint symbol-description: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = Symbol();\n\n\nExamples of correct code for this rule:\n/*eslint symbol-description: \"error\"*/\n/*eslint-env es6*/\n\nvar foo = Symbol(\"some description\");\n\nvar someString = \"some description\";\nvar bar = Symbol(someString);\n\n\nWhen Not To Use It\nThis rule should not be used in ES3/5 environments.\nIn addition, this rule can be safely turned off if you don’t want to enforce presence of description when creating Symbols.\nFurther Reading\n\nSymbol Objects specification: Symbol description\n\nVersion\nThis rule was introduced in ESLint 3.4.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/symbol-description",
                "disable": false
            },
            {
                "real_name": "template-curly-spacing",
                "display_name": "template-curly-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制模板字符串中空格的使用 (template-curly-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce Usage of Spacing in Template Strings (template-curly-spacing)\n强制模板字符串中空格的使用 (template-curly-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWe can embed expressions in template strings with using a pair of ${ and }.\n我们可以在模板字符串中使用 ${ 和 } 嵌入表达式。\nThis rule can force usage of spacing within the curly brace pair according to style guides.\n该规则可以根据风格指南强制花括号内空格的使用。\nlet hello = `hello, ${people.name}!`;\n\n\nRule Details\nThis rule aims to maintain consistency around the spacing inside of template literals.\n该规则只在维护模板字面量中空格的一致性。\nOptions\n{\n    \"template-curly-spacing\": [\"error\", \"never\"]\n}\n\n\nThis rule has one option which has either \"never\" or \"always\" as value.\n该规则有一个选项：\n\n\"never\" (by default) - Disallows spaces inside of the curly brace pair.\n\"never\" (默认) - 禁止花括号内出现空格。\n\"always\" - Requires one or more spaces inside of the curly brace pair.\n\"always\" - 要求花括号内有一个或多个空格。\n\nExamples\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 错误 代码示例：\n/*eslint template-curly-spacing: \"error\"*/\n\n`hello, ${ people.name}!`;\n`hello, ${people.name }!`;\n\n`hello, ${ people.name }!`;\n\n\nExamples of correct code for this rule with the default \"never\" option:\n默认选项 \"never\" 的 正确 代码示例：\n/*eslint template-curly-spacing: \"error\"*/\n\n`hello, ${people.name}!`;\n\n`hello, ${\n    people.name\n}!`;\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint template-curly-spacing: [\"error\", \"always\"]*/\n\n`hello, ${ people.name}!`;\n`hello, ${people.name }!`;\n\n`hello, ${people.name}!`;\n\n\nExamples of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint template-curly-spacing: [\"error\", \"always\"]*/\n\n`hello, ${ people.name }!`;\n\n`hello, ${\n    people.name\n}!`;\n\n\nWhen Not To Use It\nIf you don’t want to be notified about usage of spacing inside of template strings, then it’s safe to disable this rule.\n如果你不想收到关于模板字符串中空格的使用情况的通知，可以禁用此规则。\nVersion\nThis rule was introduced in ESLint 2.0.0-rc.0.\n该规则在 ESLint 2.0.0-rc.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/template-curly-spacing",
                "disable": false
            },
            {
                "real_name": "template-tag-spacing",
                "display_name": "template-tag-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "Require or disallow spacing between template tags and their literals (template-tag-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow spacing between template tags and their literals (template-tag-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\nWith ES6, it’s possible to create functions called tagged template literals where the function parameters consist of a template literal’s strings and expressions.\nWhen using tagged template literals, it’s possible to insert whitespace between the tag function and the template literal. Since this whitespace is optional, the following lines are equivalent:\nlet hello = func`Hello world`;\nlet hello = func `Hello world`;\n\n\nRule Details\nThis rule aims to maintain consistency around the spacing between template tag functions and their template literals.\nOptions\n{\n    \"template-tag-spacing\": [\"error\", \"never\"]\n}\n\n\nThis rule has one option whose value can be set to “never” or “always”\n\n\"never\" (default) - Disallows spaces between a tag function and its template literal.\n\"always\" - Requires one or more spaces between a tag function and its template literal.\n\nExamples\nnever\nExamples of incorrect code for this rule with the default \"never\" option:\n/*eslint template-tag-spacing: \"error\"*/\n\nfunc `Hello world`;\n\n\nExamples of correct code for this rule with the default \"never\" option:\n/*eslint template-tag-spacing: \"error\"*/\n\nfunc`Hello world`;\n\n\nalways\nExamples of incorrect code for this rule with the \"always\" option:\n/*eslint template-tag-spacing: [\"error\", \"always\"]*/\n\nfunc`Hello world`;\n\n\nExamples of correct code for this rule with the \"always\" option:\n/*eslint template-tag-spacing: [\"error\", \"always\"]*/\n\nfunc `Hello world`;\n\n\nWhen Not To Use It\nIf you don’t want to be notified about usage of spacing between tag functions and their template literals, then it’s safe to disable this rule.\nFurther Reading\nIf you want to learn more about tagged template literals, check out the links below:\n\nTemplate literals (MDN)\nExamples of using tagged template literals (Exploring ES6)\n\nVersion\nThis rule was introduced in ESLint 3.15.0.\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/template-tag-spacing",
                "disable": false
            },
            {
                "real_name": "typescript/adjacent-overload-signatures",
                "display_name": "typescript/adjacent-overload-signatures",
                "severity": "error",
                "category": "correctness",
                "rule_title": "函数有重载时，必须将重载成员分组在一起",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "函数有重载时，必须将重载成员分组在一起。该规则现在有 bug https://github.com/AlloyTeam/eslint-config-alloy/issues/38",
                "disable": false
            },
            {
                "real_name": "typescript/array-type",
                "display_name": "typescript/array-type",
                "severity": "warning",
                "category": "convention",
                "rule_title": "限制数组类型必须使用 Array<T> 或 T[]",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Using the same style for array definitions across your codebase makes it easier for your developers to read and understand the types.详见: https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/array-type.md",
                "disable": false
            },
            {
                "real_name": "typescript/await-thenable",
                "display_name": "typescript/await-thenable",
                "severity": "warning",
                "category": "convention",
                "rule_title": "禁止对没有 then 方法的对象使用 await",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule disallows awaiting a value that is not a \"Thenable\" (an object which has then method, such as a Promise). While it is valid JavaScript to await a non-Promise-like value (it will resolve immediately), this pattern is often a programmer error, such as forgetting to add parenthesis to call a function that returns a Promise.详见： https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/await-thenable.md",
                "disable": false
            },
            {
                "real_name": "typescript/ban-ts-ignore",
                "display_name": "typescript/ban-ts-ignore",
                "severity": "warning",
                "category": "convention",
                "rule_title": "是否允许使用 // @ts-ignore 来忽略编译错误",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Does not allow the use of `// @ts-ignore` comments.详见：https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/ban-ts-ignore.md",
                "disable": false
            },
            {
                "real_name": "typescript/ban-types",
                "display_name": "typescript/ban-types",
                "severity": "warning",
                "category": "convention",
                "rule_title": "禁止使用指定的类型",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule bans specific types and can suggest alternatives. It does not ban the corresponding runtime objects from being used.详见: https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/ban-types.md",
                "disable": false
            },
            {
                "real_name": "typescript/camelcase",
                "display_name": "typescript/camelcase",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforce camelCase naming convention (camelcase)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "When it comes to naming variables, style guides generally fall into one of two\ncamps: camelcase (`variableName`) and underscores (`variable_name`). This rule\nfocuses on using the camelcase approach. If your style guide calls for\ncamelCasing your variable names, then this rule is for you!\n\n## Rule Details\n\nThis rule looks for any underscores (`_`) located within the source code.\nIt ignores leading and trailing underscores and only checks those in the middle\nof a variable name. If ESLint decides that the variable is a constant\n(all uppercase), then no warning will be thrown. Otherwise, a warning will be\nthrown. This rule only flags definitions and assignments but not function calls.\nIn case of ES6 `import` statements, this rule only targets the name of the\nvariable that will be imported into the local module scope.\n\n**_This rule was taken from the ESLint core rule `camelcase`._**\n**_Available options and test cases may vary depending on the version of ESLint installed in the system._**\n\n## Options\n\n```cjson\n{\n    // note you must disable the base rule as it can report incorrect errors\n    \"camelcase\": \"off\",\n    \"@typescript-eslint/camelcase\": [\"error\", { \"properties\": \"always\" }]\n}\n```\n\nThis rule has an object option:\n\n- `\"properties\": \"always\"` (default) enforces camelcase style for property names\n- `\"properties\": \"never\"` does not check property names\n- `\"ignoreDestructuring\": false` (default) enforces camelcase style for destructured identifiers\n- `\"ignoreDestructuring\": true` does not check destructured identifiers\n- `allow` (`string[]`) list of properties to accept. Accept regex.\n\n### properties: \"always\"\n\nExamples of **incorrect** code for this rule with the default `{ \"properties\": \"always\" }` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: \"error\"*/\n\nimport { no_camelcased } from 'external-module';\n\nvar my_favorite_color = '#112C85';\n\nfunction do_something() {\n  // ...\n}\n\nobj.do_something = function() {\n  // ...\n};\n\nfunction foo({ no_camelcased }) {\n  // ...\n}\n\nfunction foo({ isCamelcased: no_camelcased }) {\n  // ...\n}\n\nfunction foo({ no_camelcased = 'default value' }) {\n  // ...\n}\n\nvar obj = {\n  my_pref: 1,\n};\n\nvar { category_id = 1 } = query;\n\nvar { foo: no_camelcased } = bar;\n\nvar { foo: bar_baz = 1 } = quz;\n```\n\nExamples of **correct** code for this rule with the default `{ \"properties\": \"always\" }` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: \"error\"*/\n\nimport { no_camelcased as camelCased } from 'external-module';\n\nvar myFavoriteColor = '#112C85';\nvar _myFavoriteColor = '#112C85';\nvar myFavoriteColor_ = '#112C85';\nvar MY_FAVORITE_COLOR = '#112C85';\nvar foo = bar.baz_boom;\nvar foo = { qux: bar.baz_boom };\n\nobj.do_something();\ndo_something();\nnew do_something();\n\nvar { category_id: category } = query;\n\nfunction foo({ isCamelCased }) {\n  // ...\n}\n\nfunction foo({ isCamelCased: isAlsoCamelCased }) {\n  // ...\n}\n\nfunction foo({ isCamelCased = 'default value' }) {\n  // ...\n}\n\nvar { categoryId = 1 } = query;\n\nvar { foo: isCamelCased } = bar;\n\nvar { foo: isCamelCased = 1 } = quz;\n```\n\n### properties: \"never\"\n\nExamples of **correct** code for this rule with the `{ \"properties\": \"never\" }` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: [\"error\", {properties: \"never\"}]*/\n\nvar obj = {\n  my_pref: 1,\n};\n```\n\n### ignoreDestructuring: false\n\nExamples of **incorrect** code for this rule with the default `{ \"ignoreDestructuring\": false }` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: \"error\"*/\n\nvar { category_id } = query;\n\nvar { category_id = 1 } = query;\n\nvar { category_id: category_id } = query;\n\nvar { category_id: category_alias } = query;\n\nvar { category_id: categoryId, ...other_props } = query;\n```\n\n### ignoreDestructuring: true\n\nExamples of **incorrect** code for this rule with the `{ \"ignoreDestructuring\": true }` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: [\"error\", {ignoreDestructuring: true}]*/\n\nvar { category_id: category_alias } = query;\n\nvar { category_id, ...other_props } = query;\n```\n\nExamples of **correct** code for this rule with the `{ \"ignoreDestructuring\": true }` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: [\"error\", {ignoreDestructuring: true}]*/\n\nvar { category_id } = query;\n\nvar { category_id = 1 } = query;\n\nvar { category_id: category_id } = query;\n```\n\n## allow\n\nExamples of **correct** code for this rule with the `allow` option:\n\n```js\n/*eslint @typescript-eslint/camelcase: [\"error\", {allow: [\"UNSAFE_componentWillMount\"]}]*/\n\nfunction UNSAFE_componentWillMount() {\n  // ...\n}\n```\n\n```js\n/*eslint @typescript-eslint/camelcase: [\"error\", {allow: [\"^UNSAFE_\"]}]*/\n\nfunction UNSAFE_componentWillMount() {\n  // ...\n}\n\nfunction UNSAFE_componentWillMount() {\n  // ...\n}\n```\n\n## When Not To Use It\n\nIf you have established coding standards using a different naming convention (separating words with underscores), turn this rule off.\n\n<sup>Taken with ❤️ [from ESLint core](https://github.com/eslint/eslint/blob/master/docs/rules/camelcase.md)</sup>",
                "disable": false
            },
            {
                "real_name": "typescript/class-literal-property-style",
                "display_name": "typescript/class-literal-property-style",
                "severity": "error",
                "category": "correctness",
                "rule_title": "类的只读属性若是一个字面量，则必须使用只读属性而不是 getter",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "类的只读属性若是一个字面量，则必须使用只读属性而不是 getter",
                "owner": null,
                "labels": [],
                "description": "类的只读属性若是一个字面量，则必须使用只读属性而不是 getter",
                "disable": false
            },
            {
                "real_name": "typescript/class-name-casing",
                "display_name": "typescript/class-name-casing",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "类和接口的命名必须遵守帕斯卡命名法，比如 PersianCat",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "类和接口的命名必须遵守帕斯卡命名法，比如 PersianCat",
                "disable": false
            },
            {
                "real_name": "typescript/consistent-type-assertions",
                "display_name": "typescript/consistent-type-assertions",
                "severity": "error",
                "category": "convention",
                "rule_title": "类型断言必须使用 as Type，禁止使用 <Type>，禁止对对象字面量进行类型断言（断言成 any 是允许的）",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule aims to standardise the use of type assertion style across the codebase.\n\nType assertions are also commonly referred as \"type casting\" in TypeScript (even though it is technically slightly different to what is understood by type casting in other languages), so you can think of type assertions and type casting referring to the same thing. It is essentially you saying to the TypeScript compiler, \"in this case, I know better than you!\".",
                "disable": false
            },
            {
                "real_name": "typescript/consistent-type-definitions",
                "display_name": "typescript/consistent-type-definitions",
                "severity": "error",
                "category": "convention",
                "rule_title": "Consistent with type definition either interface or type (consistent-type-definitions)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "详见： https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/consistent-type-definitions.md",
                "disable": false
            },
            {
                "real_name": "typescript/explicit-function-return-type",
                "display_name": "typescript/explicit-function-return-type",
                "severity": "warning",
                "category": "convention",
                "rule_title": "函数返回值必须与声明的类型一致",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Explicit types for function return values makes it clear to any calling code what type is returned. This ensures that the return value is assigned to a variable of the correct type; or in the case where there is no return value, that the calling code doesn't try to use the undefined value when it shouldn't.详见： https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/explicit-function-return-type.md",
                "disable": false
            },
            {
                "real_name": "typescript/explicit-member-accessibility",
                "display_name": "typescript/explicit-member-accessibility",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "必须手动指定类的属性和方法的可访问性（private 或 public）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "必须手动指定类的属性和方法的可访问性（private 或 public）。",
                "disable": false
            },
            {
                "real_name": "typescript/generic-type-naming",
                "display_name": "typescript/generic-type-naming",
                "severity": "warning",
                "category": "convention",
                "rule_title": "约束泛型的命名规则",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "It can be helpful to enforce a consistent naming style for generic type variables used within a type. For example, prefixing them with T and ensuring a somewhat descriptive name, or enforcing Hungarian notation.详见： https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/generic-type-naming.md",
                "disable": false
            },
            {
                "real_name": "typescript/indent",
                "display_name": "typescript/indent",
                "severity": "warning",
                "category": "convention",
                "rule_title": "There are several common guidelines which require specific indentation of nested blocks and statements",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "This rule enforces a consistent indentation style. The default style is 4 spaces.",
                "owner": null,
                "labels": [],
                "description": "This rule enforces a consistent indentation style. The default style is 4 spaces.\n\n参考[官方文档](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/indent.md)",
                "disable": false
            },
            {
                "real_name": "typescript/interface-name-prefix",
                "display_name": "typescript/interface-name-prefix",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "接口必须以 I 开头",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "接口必须以 I 开头",
                "disable": false
            },
            {
                "real_name": "typescript/member-delimiter-style",
                "display_name": "typescript/member-delimiter-style",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "接口和类型字面量中每一行都必须以分号结尾",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "接口和类型字面量中每一行都必须以分号结尾",
                "disable": false
            },
            {
                "real_name": "typescript/member-naming",
                "display_name": "typescript/member-naming",
                "severity": "warning",
                "category": "convention",
                "rule_title": "私有成员必须以 _ 开头",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "It can be helpful to enforce naming conventions for private (and sometimes protected) members of an object. For example, prefixing private properties with a _ allows them to be easily discerned when being inspected by tools that do not have knowledge of TypeScript (such as most debuggers).详见： https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/member-naming.md",
                "disable": false
            },
            {
                "real_name": "typescript/member-ordering",
                "display_name": "typescript/member-ordering",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "属性和方法必须按照排序规则排序",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "属性和方法必须按照排序规则排序",
                "disable": false
            },
            {
                "real_name": "typescript/no-angle-bracket-type-assertion",
                "display_name": "typescript/no-angle-bracket-type-assertion",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "必须使用 as 进行类型断言",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "必须使用 as 进行类型断言。默认是关闭的，@off 没必要限制，在 React 项目中需要限制",
                "disable": false
            },
            {
                "real_name": "typescript/no-array-constructor",
                "display_name": "typescript/no-array-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止使用 Array 构造函数来初始化数组，除非指定了泛型，或传入的是单个数字",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 Array 构造函数来初始化数组，除非指定了泛型，或传入的是单个数字。开启该规则，可以帮助发现错误。",
                "disable": false
            },
            {
                "real_name": "typescript/no-empty-function",
                "display_name": "typescript/no-empty-function",
                "severity": "warning",
                "category": "convention",
                "rule_title": "Empty functions can reduce readability because readers need to guess whether it’s intentional or not. So writing a clear comment for empty functions is a good practice.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "依照详情解决。",
                "owner": null,
                "labels": [],
                "description": "The @typescript-eslint/no-empty-function rule extends the no-empty-function rule from ESLint core, and adds support for handling TypeScript specific code that would otherwise trigger the rule.\n\nOne example of valid TypeScript specific code that would otherwise trigger the no-empty-function rule is the use of parameter properties in constructor functions:\n\nclass Person {\n  constructor(private firstName: string, private surname: string) {}\n}\nThe above code is functionally equivalent to:\n\nclass Person {\n  private firstName: string;\n  private surname: string;\n\n  constructor(firstName: string, surname: string) {\n    this.firstName = firstName;\n    this.surname = surname;\n  }\n}\nParameter properties enable both the declaration and initialization of member properties in a single location, avoiding the boilerplate & duplication that is common when initializing member properties from parameter values in a constructor function.\n\nIn these cases, although the constructor has an empty function body, it is technically valid and should not trigger an error.\n\nSee the ESLint documentation for more details on the no-empty-function rule.\n\n参考[官方文档](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-empty-function.md)",
                "disable": false
            },
            {
                "real_name": "typescript/no-empty-interface",
                "display_name": "typescript/no-empty-interface",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "禁止使用空接口",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用空接口.",
                "disable": false
            },
            {
                "real_name": "typescript/no-explicit-any",
                "display_name": "typescript/no-explicit-any",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "禁止使用 any",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 any",
                "disable": false
            },
            {
                "real_name": "typescript/no-extranseous-calss",
                "display_name": "typescript/no-extraneous-class",
                "severity": "warning",
                "category": "convention",
                "rule_title": "禁止定义没必要的类，比如只有静态方法的类",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "详见： https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-extraneous-class.md",
                "disable": false
            },
            {
                "real_name": "typescript/no-for-in-array",
                "display_name": "typescript/no-for-in-array",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallow iterating over an array with a for-in loop (no-for-in-array)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule prohibits iterating over an array with a for-in loop.\n\n## Rule Details\n\nRationale from TSLint:\n\nA for-in loop (`for (var k in o)`) iterates over the properties of an Object.\nWhile it is legal to use for-in loops with array types, it is not common.\nfor-in will iterate over the indices of the array as strings, omitting any \"holes\" in\nthe array.\nMore common is to use for-of, which iterates over the values of an array.\nIf you want to iterate over the indices, alternatives include:\n\n```js\narray.forEach((value, index) => { ... });\nfor (const [index, value] of array.entries()) { ... }\nfor (let i = 0; i < array.length; i++) { ... }\n```\n\nExamples of **incorrect** code for this rule:\n\n```js\nfor (const x in [3, 4, 5]) {\n  console.log(x);\n}\n```\n\nExamples of **correct** code for this rule:\n\n```js\nfor (const x in { a: 3, b: 4, c: 5 }) {\n  console.log(x);\n}\n```\n\n## When Not To Use It\n\nIf you want to iterate through a loop using the indices in an array as strings, you can turn off this rule.\n\n## Related to\n\n- TSLint: ['no-for-in-array'](https://palantir.github.io/tslint/rules/no-for-in-array/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-inferrable-types",
                "display_name": "typescript/no-inferrable-types",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean. (no-inferrable-types)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Explicit types where they can be easily inferred may add unnecessary verbosity.\n\n## Rule Details\n\nThis rule disallows explicit type declarations on parameters, variables\nand properties where the type can be easily inferred from its value.\n\n## Options\n\nThis rule accepts the following options:\n\n```ts\ninterface Options {\n  ignoreParameters?: boolean;\n  ignoreProperties?: boolean;\n}\n```\n\n### Default\n\nThe default options are:\n\n```JSON\n{\n  \"ignoreParameters\": false,\n  \"ignoreProperties\": false,\n}\n```\n\nWith these options, the following patterns are valid:\n\n```ts\nconst a = 10n;\nconst a = -10n;\nconst a = BigInt(10);\nconst a = -BigInt(10);\nconst a = false;\nconst a = true;\nconst a = Boolean(null);\nconst a = !0;\nconst a = 10;\nconst a = +10;\nconst a = -10;\nconst a = Number('1');\nconst a = +Number('1');\nconst a = -Number('1');\nconst a = Infinity;\nconst a = +Infinity;\nconst a = -Infinity;\nconst a = NaN;\nconst a = +NaN;\nconst a = -NaN;\nconst a = null;\nconst a = /a/;\nconst a = RegExp('a');\nconst a = new RegExp('a');\nconst a = 'str';\nconst a = `str`;\nconst a = String(1);\nconst a = Symbol('a');\nconst a = undefined;\nconst a = void someValue;\n\nclass Foo {\n  prop = 5;\n}\n\nfunction fn(a = 5, b = true) {}\n\nfunction fn(a: number, b: boolean, c: string) {}\n```\n\nThe following are invalid:\n\n```ts\nconst a: bigint = 10n;\nconst a: bigint = -10n;\nconst a: bigint = BigInt(10);\nconst a: bigint = -BigInt(10);\nconst a: boolean = false;\nconst a: boolean = true;\nconst a: boolean = Boolean(null);\nconst a: boolean = !0;\nconst a: number = 10;\nconst a: number = +10;\nconst a: number = -10;\nconst a: number = Number('1');\nconst a: number = +Number('1');\nconst a: number = -Number('1');\nconst a: number = Infinity;\nconst a: number = +Infinity;\nconst a: number = -Infinity;\nconst a: number = NaN;\nconst a: number = +NaN;\nconst a: number = -NaN;\nconst a: null = null;\nconst a: RegExp = /a/;\nconst a: RegExp = RegExp('a');\nconst a: RegExp = new RegExp('a');\nconst a: string = 'str';\nconst a: string = `str`;\nconst a: string = String(1);\nconst a: symbol = Symbol('a');\nconst a: undefined = undefined;\nconst a: undefined = void someValue;\n\nclass Foo {\n  prop: number = 5;\n}\n\nfunction fn(a: number = 5, b: boolean = true) {}\n```\n\n### `ignoreParameters`\n\nWhen set to true, the following pattern is considered valid:\n\n```ts\nfunction foo(a: number = 5, b: boolean = true) {\n  // ...\n}\n```\n\n### `ignoreProperties`\n\nWhen set to true, the following pattern is considered valid:\n\n```ts\nclass Foo {\n  prop: number = 5;\n}\n```\n\n## When Not To Use It\n\nIf you do not want to enforce inferred types.\n\n## Further Reading\n\nTypeScript [Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n\n## Compatibility\n\nTSLint: [no-inferrable-types](https://palantir.github.io/tslint/rules/no-inferrable-types/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-magic-numbers",
                "display_name": "typescript/no-magic-numbers",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallow Magic Numbers (@typescript-eslint/no-magic-numbers)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "'Magic numbers' are numbers that occur multiple times in code without an explicit meaning.\nThey should preferably be replaced by named constants.\n\n## Rule Details\n\nThe `@typescript-eslint/no-magic-numbers` rule extends the `no-magic-numbers` rule from ESLint core, and adds support for handling Typescript specific code that would otherwise trigger the rule.\n\nSee the [ESLint documentation](https://eslint.org/docs/rules/no-magic-numbers) for more details on the `no-magic-numbers` rule.\n\n## Rule Changes\n\n```cjson\n{\n    // note you must disable the base rule as it can report incorrect errors\n    \"no-magic-numbers\": \"off\",\n    \"@typescript-eslint/no-magic-numbers\": [\"error\", { \"ignoreNumericLiteralTypes\": true }]\n}\n```\n\nIn addition to the options supported by the `no-magic-numbers` rule in ESLint core, the rule adds the following options:\n\n### ignoreNumericLiteralTypes\n\nA boolean to specify if numbers used in Typescript numeric literal types are considered okay. `false` by default.\n\nExamples of **incorrect** code for the `{ \"ignoreNumericLiteralTypes\": false }` option:\n\n```ts\n/*eslint @typescript-eslint/no-magic-numbers: [\"error\", { \"ignoreNumericLiteralTypes\": false }]*/\n\ntype SmallPrimes = 2 | 3 | 5 | 7 | 11;\n```\n\nExamples of **correct** code for the `{ \"ignoreNumericLiteralTypes\": true }` option:\n\n```ts\n/*eslint @typescript-eslint/no-magic-numbers: [\"error\", { \"ignoreNumericLiteralTypes\": true }]*/\n\ntype SmallPrimes = 2 | 3 | 5 | 7 | 11;\n```\n\n### ignoreReadonlyClassProperties\n\nExamples of **incorrect** code for the `{ \"ignoreReadonlyClassProperties\": false }` option:\n\n```ts\n/*eslint @typescript-eslint/no-magic-numbers: [\"error\", { \"ignoreReadonlyClassProperties\": false }]*/\n\nclass Foo {\n  readonly A = 1;\n  readonly B = 2;\n  public static readonly C = 1;\n  static readonly D = 1;\n}\n```\n\nExamples of **correct** code for the `{ \"ignoreReadonlyClassProperties\": true }` option:\n\n```ts\n/*eslint @typescript-eslint/no-magic-numbers: [\"error\", { \"ignoreReadonlyClassProperties\": true }]*/\n\nclass Foo {\n  readonly A = 1;\n  readonly B = 2;\n  public static readonly C = 1;\n  static readonly D = 1;\n}\n```\n\n### ignoreEnums\n\nA boolean to specify if enums used in Typescript are considered okay. `false` by default.\n\nExamples of **incorrect** code for the `{ \"ignoreEnums\": false }` option:\n\n```ts\n/*eslint @typescript-eslint/no-magic-numbers: [\"error\", { \"ignoreEnums\": false }]*/\n\nenum foo = {\n    SECOND = 1000,\n}\n```\n\nExamples of **correct** code for the `{ \"ignoreEnums\": true }` option:\n\n```ts\n/*eslint @typescript-eslint/no-magic-numbers: [\"error\", { \"ignoreEnums\": true }]*/\n\nenum foo = {\n    SECOND = 1000,\n}\n```\n\n<sup>Taken with ❤️ [from ESLint core](https://github.com/eslint/eslint/blob/master/docs/rules/no-magic-numbers.md)</sup>",
                "disable": false
            },
            {
                "real_name": "typescript/no-misused-new",
                "display_name": "typescript/no-misused-new",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforce valid definition of `new` and `constructor`. (no-misused-new)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Warns on apparent attempts to define constructors for interfaces or `new` for classes.\n\n## Rule Details\n\nExamples of **incorrect** code for this rule.\n\n```ts\nclass C {\n  new(): C;\n}\n\ninterface I {\n  new (): I;\n  constructor(): void;\n}\n```\n\nExamples of **correct** code for this rule.\n\n```ts\nclass C {\n  constructor() {}\n}\ninterface I {\n  new (): C;\n}\n```\n\n## Options\n\n```json\n{\n  \"@typescript-eslint/no-misused-new\": \"error\"\n}\n```\n\n## Compatibility\n\n- TSLint: [no-misused-new](https://palantir.github.io/tslint/rules/no-misused-new/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-misused-promises",
                "display_name": "typescript/no-misused-promises",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Avoid using promises in places not designed to handle them (no-misused-promises)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule forbids using promises in places where the Typescript compiler\nallows them but they are not handled properly. These situations can often arise\ndue to a missing `await` keyword or just a misunderstanding of the way async\nfunctions are handled/awaited.\n\n## Rule Details\n\nExamples of **incorrect** code for this rule with `checksConditionals: true`:\n\n```ts\nconst promise = Promise.resolve('value');\n\nif (promise) {\n  // Do something\n}\n\nconst val = promise ? 123 : 456;\n\nwhile (promise) {\n  // Do something\n}\n```\n\nExamples of **incorrect** code for this rule with `checksVoidReturn: true`:\n\n```ts\n[1, 2, 3].forEach(async value => {\n  await doSomething(value);\n});\n\nnew Promise(async (resolve, reject) => {\n  await doSomething();\n  resolve();\n});\n\nconst eventEmitter = new EventEmitter();\neventEmitter.on('some-event', async () => {\n  await doSomething();\n});\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nconst promise = Promise.resolve('value');\n\nif (await promise) {\n  // Do something\n}\n\nconst val = (await promise) ? 123 : 456;\n\nwhile (await promise) {\n  // Do something\n}\n\nfor (const value of [1, 2, 3]) {\n  await doSomething(value);\n}\n\nnew Promise((resolve, reject) => {\n  // Do something\n  resolve();\n});\n\nconst eventEmitter = new EventEmitter();\neventEmitter.on('some-event', () => {\n  doSomething();\n});\n```\n\n## Options\n\nThis rule accepts a single option which is an object with `checksConditionals`\nand `checksVoidReturn` properties indicating which types of misuse to flag.\nBoth are enabled by default\n\nIf you don't want functions that return promises where a void return is\nexpected to be checked, your configuration will look like this:\n\n```json\n{\n  \"@typescript-eslint/no-misused-promises\": [\n    \"error\",\n    {\n      \"checksVoidReturn\": false\n    }\n  ]\n}\n```\n\nLikewise, if you don't want to check conditionals, you can configure the rule\nlike this:\n\n```json\n{\n  \"@typescript-eslint/no-misused-promises\": [\n    \"error\",\n    {\n      \"checksConditionals\": false\n    }\n  ]\n}\n```\n\n## When Not To Use It\n\nIf you do not use Promises in your codebase or are not concerned with possible\nmisuses of them outside of what the Typescript compiler will check.\n\n## Related to\n\n- [`no-floating-promises`](./no-floating-promises.md)\n\n## Further Reading\n\n- [Typescript void function assignability](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)",
                "disable": false
            },
            {
                "real_name": "typescript/no-namespace",
                "display_name": "typescript/no-namespace",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "禁止使用 namespace 和 module",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用 namespace 和 module。用 namespace 或 module 来定义模块是以前的用法，现在已经有了 import 和 export",
                "disable": false
            },
            {
                "real_name": "typescript/no-non-null-asserted-optional-chain",
                "display_name": "typescript/no-non-null-asserted-optional-chain",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁止在 optional chaining 之后使用 non-null 断言（感叹号）",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "禁止在 optional chaining 之后使用 non-null 断言（感叹号）",
                "owner": null,
                "labels": [],
                "description": "禁止在 optional chaining 之后使用 non-null 断言（感叹号）",
                "disable": false
            },
            {
                "real_name": "typescript/no-non-null-assertion",
                "display_name": "typescript/no-non-null-assertion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallows non-null assertions using the `!` postfix operator (no-non-null-assertion)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "## Rule Details\n\nUsing non-null assertions cancels the benefits of the strict null-checking mode.\n\nExamples of **incorrect** code for this rule:\n\n```ts\ninterface Foo {\n  bar?: string;\n}\n\nconst foo: Foo = getFoo();\nconst includesBaz: boolean = foo.bar!.includes('baz');\n```\n\nExamples of **correct** code for this rule:\n\n```ts\ninterface Foo {\n  bar?: string;\n}\n\nconst foo: Foo = getFoo();\nconst includesBaz: boolean = foo.bar && foo.bar.includes('baz');\n```\n\n## When Not To Use It\n\nIf you don't care about strict null-checking, then you will not need this rule.\n\n## Further Reading\n\n- [`no-non-null-assertion`](https://palantir.github.io/tslint/rules/no-non-null-assertion/) in [TSLint](https://palantir.github.io/tslint/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-parameter-properties",
                "display_name": "typescript/no-parameter-properties",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "禁止在给构造函数的参数添加修饰符",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止在给构造函数的参数添加修饰符",
                "disable": false
            },
            {
                "real_name": "typescript/no-require-imports",
                "display_name": "typescript/no-require-imports",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallows invocation of `require()` (no-require-imports)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Prefer the newer ES6-style imports over `require()`.\n\n## Rule Details\n\nExamples of **incorrect** code for this rule:\n\n```ts\nvar lib = require('lib');\nlet lib2 = require('lib2');\nvar lib5 = require('lib5'),\n  lib6 = require('lib6');\nimport lib8 = require('lib8');\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nimport { l } from 'lib';\nvar lib3 = load('not_an_import');\nvar lib4 = lib2.subImport;\nvar lib7 = 700;\nimport lib9 = lib2.anotherSubImport;\nimport lib10 from 'lib10';\n```\n\n## When Not To Use It\n\nIf you don't care about TypeScript module syntax, then you will not need this rule.\n\n## Compatibility\n\n- TSLint: [no-require-imports](https://palantir.github.io/tslint/rules/no-require-imports/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-this-alias",
                "display_name": "typescript/no-this-alias",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallow aliasing `this` (no-this-alias)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule prohibts assigning variables to `this`.\n\n## Rule Details\n\nRationale from TSLint:\n\n> Assigning a variable to `this` instead of properly using arrow lambdas may be a symptom of pre-ES6 practices\n> or not managing scope well.\n>\n> Instead of storing a reference to `this` and using it inside a `function () {`:\n>\n> ```js\n> const self = this;\n>\n> setTimeout(function() {\n>   self.doWork();\n> });\n> ```\n>\n> Use `() =>` arrow lambdas, as they preserve `this` scope for you:\n>\n> ```js\n> setTimeout(() => {\n>   this.doWork();\n> });\n> ```\n\nExamples of **incorrect** code for this rule:\n\n(see the rationale above)\n\nExamples of **correct** code for this rule:\n\n(see the rationale above)\n\n### Options\n\nYou can pass an object option:\n\n```json5\n{\n  '@typescript-eslint/no-this-alias': [\n    'error',\n    {\n      allowDestructuring: true, // Allow `const { props, state } = this`; false by default\n      allowedNames: ['self'], // Allow `const self = this`; `[]` by default\n    },\n  ],\n}\n```\n\n## When Not To Use It\n\nIf you need to assign `this` to variables, you shouldn’t use this rule.\n\n## Related to\n\n- TSLint: [`no-this-assignment`](https://palantir.github.io/tslint/rules/no-this-assignment/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-triple-slash-reference",
                "display_name": "typescript/no-triple-slash-reference",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "禁止使用三斜线注释",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "禁止使用三斜线注释",
                "disable": false
            },
            {
                "real_name": "typescript/no-type-alias",
                "display_name": "typescript/no-type-alias",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "限制 type 的使用",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "限制 type 的使用",
                "disable": false
            },
            {
                "real_name": "typescript/no-unnecessary-qualifier",
                "display_name": "typescript/no-unnecessary-qualifier",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Warns when a namespace qualifier is unnecessary. (no-unnecessary-qualifier)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "## Rule Details\n\nThis rule aims to let users know when a namespace or enum qualifier is unnecessary,\nwhether used for a type or for a value.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nnamespace A {\n  export type B = number;\n  const x: A.B = 3;\n}\n```\n\n```ts\nnamespace A {\n  export const x = 3;\n  export const y = A.x;\n}\n```\n\n```ts\nenum A {\n  B,\n  C = A.B,\n}\n```\n\n```ts\nnamespace A {\n  export namespace B {\n    export type T = number;\n    const x: A.B.T = 3;\n  }\n}\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nnamespace X {\n  export type T = number;\n}\n\nnamespace Y {\n  export const x: X.T = 3;\n}\n```\n\n```ts\nenum A {\n  X,\n  Y,\n}\n\nenum B {\n  Z = A.X,\n}\n```\n\n```ts\nnamespace X {\n  export type T = number;\n  namespace Y {\n    type T = string;\n    const x: X.T = 0;\n  }\n}\n```\n\n## When Not To Use It\n\nIf you don't care about having unneeded namespace or enum qualifiers, then you don't need to use this rule.\n\n## Further Reading\n\n- TSLint: [no-unnecessary-qualifier](https://palantir.github.io/tslint/rules/no-unnecessary-qualifier/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-unnecessary-type-assertion",
                "display_name": "typescript/no-unnecessary-type-assertion",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Warns if a type assertion does not change the type of an expression (no-unnecessary-type-assertion)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule prohibits using a type assertion that does not change the type of an expression.\n\n## Rule Details\n\nThis rule aims to prevent unnecessary type assertions.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nconst foo = 3;\nconst bar = foo!;\n```\n\n```ts\nconst foo = <3>3;\n```\n\n```ts\ntype Foo = 3;\nconst foo = <Foo>3;\n```\n\n```ts\ntype Foo = 3;\nconst foo = 3 as Foo;\n```\n\n```ts\nfunction foo(x: number): number {\n  return x!; // unnecessary non-null\n}\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nconst foo = <number>3;\n```\n\n```ts\nconst foo = 3 as number;\n```\n\n```ts\nfunction foo(x: number | undefined): number {\n  return x!;\n}\n```\n\n### Options\n\nThis rule optionally takes an object with a single property `typesToIgnore`, which can be set to a list of type names to ignore.\n\nFor example, with `@typescript-eslint/no-unnecessary-type-assertion: [\"error\", { typesToIgnore: ['Foo'] }]`, the following is **correct** code\":\n\n```ts\ntype Foo = 3;\nconst foo: Foo = 3;\n```\n\n## When Not To Use It\n\nIf you don't care about having no-op type assertions in your code, then you can turn off this rule.\n\n## Related to\n\n- TSLint: ['no-unnecessary-type-assertion`](https://palantir.github.io/tslint/rules/no-unnecessary-type-assertion/)",
                "disable": false
            },
            {
                "real_name": "typescript/no-unused-expressions",
                "display_name": "typescript/no-unused-expressions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "禁用无用的表达式",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "对程序状态没有影响的未使用表达式往往是个逻辑错误。\n\n例如，n + 1; 不是语法错误，但它可能是程序员的书写错误，原本是想写赋值语句 n += 1;。有时，生产环境中的一些构建工具可能会消除这些未使用的表达式，这可能会破坏应用程序逻辑。",
                "owner": null,
                "labels": [
                    "规范"
                ],
                "description": "对程序状态没有影响的未使用表达式往往是个逻辑错误。\n\n例如，n + 1; 不是语法错误，但它可能是程序员的书写错误，原本是想写赋值语句 n += 1;。有时，生产环境中的一些构建工具可能会消除这些未使用的表达式，这可能会破坏应用程序逻辑。",
                "disable": false
            },
            {
                "real_name": "typescript/no-unused-vars",
                "display_name": "typescript/no-unused-vars",
                "severity": "error",
                "category": "correctness",
                "rule_title": "定义过的变量必须使用",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "定义过的变量必须使用。eslint 原生的 no-unused-vars 无法使用，需要使用 typescript/no-unused-vars",
                "disable": false
            },
            {
                "real_name": "typescript/no-use-before-define",
                "display_name": "typescript/no-use-before-define",
                "severity": "error",
                "category": "correctness",
                "rule_title": "变量必须先定义后使用",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "变量必须先定义后使用。eslint 原生已支持 no-use-before-define",
                "disable": false
            },
            {
                "real_name": "typescript/no-useless-constructor",
                "display_name": "typescript/no-useless-constructor",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallow unnecessary constructors (no-useless-constructor)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "ES2015 provides a default class constructor if one is not specified. As such, it is unnecessary to provide an empty constructor or one that simply delegates into its parent class, as in the following examples:\n\n```js\nclass A {\n  constructor() {}\n}\n\nclass A extends B {\n  constructor(value) {\n    super(value);\n  }\n}\n```\n\n## Rule Details\n\nThis rule flags class constructors that can be safely removed without changing how the class works.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint @typescript-eslint/no-useless-constructor: \"error\"*/\n\nclass A {\n  constructor() {}\n}\n\nclass A extends B {\n  constructor(...args) {\n    super(...args);\n  }\n}\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint @typescript-eslint/no-useless-constructor: \"error\"*/\n\nclass A {}\n\nclass A {\n  constructor() {\n    doSomething();\n  }\n}\n\nclass A extends B {\n  constructor() {\n    super('foo');\n  }\n}\n\nclass A extends B {\n  constructor() {\n    super();\n    doSomething();\n  }\n}\n\nclass A extends B {\n  constructor(protected name: string) {}\n}\n\nclass A extends B {\n  protected constructor() {}\n}\n```\n\n## Rule Changes\n\n```cjson\n{\n    // note you must disable the base rule as it can report incorrect errors\n    \"no-useless-constructor\": \"off\",\n    \"@typescript-eslint/no-useless-constructor\": \"error\",\n}\n```\n\n## When Not To Use It\n\nIf you don't want to be notified about unnecessary constructors, you can safely disable this rule.\n\n<sup>Taken with ❤️ [from ESLint core](https://github.com/eslint/eslint/blob/master/docs/rules/no-useless-constructor.md)</sup>",
                "disable": false
            },
            {
                "real_name": "typescript/no-var-requires",
                "display_name": "typescript/no-var-requires",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallows the use of require statements except in import statements (no-var-requires)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "In other words, the use of forms such as `var foo = require(\"foo\")` are banned. Instead use ES6 style imports or `import foo = require(\"foo\")` imports.\n\n## Rule Details\n\nExamples of **incorrect** code for this rule:\n\n```ts\nvar foo = require('foo');\nconst foo = require('foo');\nlet foo = require('foo');\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nimport foo = require('foo');\nrequire('foo');\nimport foo from 'foo';\n```\n\n## When Not To Use It\n\nIf you don't care about TypeScript module syntax, then you will not need this rule.\n\n## Compatibility\n\n- TSLint: [no-var-requires](https://palantir.github.io/tslint/rules/no-var-requires/)",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-for-of",
                "display_name": "typescript/prefer-for-of",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Use for-of loops instead of standard for loops over arrays (prefer-for-of)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule recommends a for-of loop when the loop index is only used to read from an array that is being iterated.\n\n## Rule Details\n\nFor cases where the index is only used to read from the array being iterated, a for-of loop is easier to read and write.\n\nExamples of **incorrect** code for this rule:\n\n```js\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n```\n\nExamples of **correct** code for this rule:\n\n```js\nfor (const x of arr) {\n  console.log(x);\n}\n\nfor (let i = 0; i < arr.length; i++) {\n  // i is used to write to arr, so for-of could not be used.\n  arr[i] = 0;\n}\n\nfor (let i = 0; i < arr.length; i++) {\n  // i is used independent of arr, so for-of could not be used.\n  console.log(i, arr[i]);\n}\n```\n\n## When Not To Use It\n\nIf you transpile for browsers that do not support for-of loops, you may wish to use traditional for loops that produce more compact code.\n\n## Related to\n\n- TSLint: ['prefer-for-of'](https://palantir.github.io/tslint/rules/prefer-for-of/)",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-function-type",
                "display_name": "typescript/prefer-function-type",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Use function types instead of interfaces with call signatures (prefer-function-type)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "## Rule Details\n\nThis rule suggests using a function type instead of an interface or object type literal with a single call signature.\n\nExamples of **incorrect** code for this rule:\n\n```ts\ninterface Foo {\n  (): string;\n}\n```\n\n```ts\nfunction foo(bar: { (): number }): number {\n  return bar();\n}\n```\n\n```ts\ninterface Foo extends Function {\n  (): void;\n}\n```\n\nExamples of **correct** code for this rule:\n\n```ts\ninterface Foo {\n  (): void;\n  bar: number;\n}\n```\n\n```ts\nfunction foo(bar: { (): string; baz: number }): string {\n  return bar();\n}\n```\n\n```ts\ninterface Foo {\n  bar: string;\n}\ninterface Bar extends Foo {\n  (): void;\n}\n```\n\n## When Not To Use It\n\nIf you specifically want to use an interface or type literal with a single call signature for stylistic reasons, you can disable this rule.\n\n## Further Reading\n\n- TSLint: [`callable-types`](https://palantir.github.io/tslint/rules/callable-types/)",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-includes",
                "display_name": "typescript/prefer-includes",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforce `includes` method over `indexOf` method (@typescript-eslint/prefer-includes)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Until ES5, we were using `String#indexOf` method to check whether a string contains an arbitrary substring or not.\nUntil ES2015, we were using `Array#indexOf` method to check whether an array contains an arbitrary value or not.\n\nES2015 has added `String#includes` and ES2016 has added `Array#includes`.\nIt makes code more understandable if we use those `includes` methods for the purpose.\n\n## Rule Details\n\nThis rule is aimed at suggesting `includes` method if `indexOf` method was used to check whether an object contains an arbitrary value or not.\n\nIf the receiver object of the `indexOf` method call has `includes` method and the two methods have the same parameters, this rule does suggestion.\nThere are such types: `String`, `Array`, `ReadonlyArray`, and typed arrays.\n\nAdditionally, this rule reports the tests of simple regular expressions in favor of `String#includes`.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nlet str: string;\nlet array: any[];\nlet readonlyArray: ReadonlyArray<any>;\nlet typedArray: UInt8Array;\nlet userDefined: {\n  indexOf(x: any): number;\n  includes(x: any): boolean;\n};\n\nstr.indexOf(value) !== -1;\narray.indexOf(value) !== -1;\nreadonlyArray.indexOf(value) === -1;\ntypedArray.indexOf(value) > -1;\nuserDefined.indexOf(value) >= 0;\n\n// simple RegExp test\n/foo/.test(str);\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nlet array: any[];\nlet readonlyArray: ReadonlyArray<any>;\nlet typedArray: UInt8Array;\nlet userDefined: {\n  indexOf(x: any): number;\n  includes(x: any): boolean;\n};\nlet mismatchExample: {\n  indexOf(x: any, fromIndex?: number): number;\n  includes(x: any): boolean;\n};\n\nstr.includes(value);\narray.includes(value);\nreadonlyArray.includes(value);\ntypedArray.includes(value);\nuserDefined.includes(value);\n\n// the two methods have different parameters.\nmismatchExample.indexOf(value) >= 0;\n```\n\n## Options\n\nThere are no options.\n\n## When Not To Use It\n\nIf you don't want to suggest `includes`, you can safely turn this rule off.",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-namespace-keyword",
                "display_name": "typescript/prefer-namespace-keyword",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "使用 namespace 代替 module",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "使用 namespace 代替 module。默认关闭，@off typescirpt/no-namespace 已经禁用了 namespace 和 module",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-optional-chain",
                "display_name": "typescript/prefer-optional-chain",
                "severity": "error",
                "category": "convention",
                "rule_title": "使用 optional chaining 替代 &&",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "使用 optional chaining 替代 &&",
                "owner": null,
                "labels": [],
                "description": "使用 optional chaining 替代 &&",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-readonly",
                "display_name": "typescript/prefer-readonly",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# require never-modified private members be marked as `readonly` (prefer-readonly)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule enforces that private members are marked as `readonly` if they're never modified outside of the constructor.\n\n## Rule Details\n\nMember variables with the privacy `private` are never permitted to be modified outside of their declaring class.\nIf that class never modifies their value, they may safely be marked as `readonly`.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nclass Container {\n  // These member variables could be marked as readonly\n  private neverModifiedMember = true;\n  private onlyModifiedInConstructor: number;\n\n  public constructor(\n    onlyModifiedInConstructor: number,\n    // Private parameter properties can also be marked as reaodnly\n    private neverModifiedParameter: string,\n  ) {\n    this.onlyModifiedInConstructor = onlyModifiedInConstructor;\n  }\n}\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nclass Container {\n  // Public members might be modified externally\n  public publicMember: boolean;\n\n  // Protected members might be modified by child classes\n  protected protectedMember: number;\n\n  // This is modified later on by the class\n  private modifiedLater = 'unchanged';\n\n  public mutate() {\n    this.modifiedLater = 'mutated';\n  }\n}\n```\n\n## Options\n\nThis rule, in its default state, does not require any argument.\n\n### onlyInlineLambdas\n\nYou may pass `\"onlyInlineLambdas\": true` as a rule option within an object to restrict checking only to members immediately assigned a lambda value.\n\n```cjson\n{\n    \"@typescript-eslint/prefer-readonly\": [\"error\", { \"onlyInlineLambdas\": true }]\n}\n```\n\nExample of **correct** code for the `{ \"onlyInlineLambdas\": true }` options:\n\n```ts\nclass Container {\n  private neverModifiedPrivate = 'unchanged';\n}\n```\n\nExample of **incorrect** code for the `{ \"onlyInlineLambdas\": true }` options:\n\n```ts\nclass Container {\n  private onClick = () => {\n    /* ... */\n  };\n}\n```\n\n## Related to\n\n- TSLint: ['prefer-readonly'](https://palantir.github.io/tslint/rules/prefer-readonly)",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-regexp-exec",
                "display_name": "typescript/prefer-regexp-exec",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforce to use `RegExp#exec` over `String#match` (prefer-regexp-exec)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "`RegExp#exec` is faster than `String#match` and both work the same when not using the `/g` flag.\n\n## Rule Details\n\nThis rule is aimed at enforcing the more performant way of applying regular expressions on strings.\n\nFrom [`String#match` on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match):\n\n> If the regular expression does not include the g flag, returns the same result as RegExp.exec().\n\nFrom [Stack Overflow](https://stackoverflow.com/questions/9214754/what-is-the-difference-between-regexp-s-exec-function-and-string-s-match-fun)\n\n> `RegExp.prototype.exec` is a lot faster than `String.prototype.match`, but that’s because they are not exactly the same thing, they are different.\n\nExamples of **incorrect** code for this rule:\n\n```ts\n'something'.match(/thing/);\n\n'some things are just things'.match(/thing/);\n\nconst text = 'something';\nconst search = /thing/;\ntext.match(search);\n```\n\nExamples of **correct** code for this rule:\n\n```ts\n/thing/.exec('something');\n\n'some things are just things'.match(/thing/g);\n\nconst text = 'something';\nconst search = /thing/;\nsearch.exec(text);\n```\n\n## Options\n\nThere are no options.\n\n```json\n{\n  \"@typescript-eslint/prefer-regexp-exec\": \"error\"\n}\n```\n\n## When Not To Use It\n\nIf you prefer consistent use of `String#match` for both, with `g` flag and without it, you can turn this rule off.",
                "disable": false
            },
            {
                "real_name": "typescript/prefer-string-starts-ends-with",
                "display_name": "typescript/prefer-string-starts-ends-with",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforce the use of `String#startsWith` and `String#endsWith` instead of other equivalent methods of checking substrings (prefer-string-starts-ends-with)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "There are multiple ways to verify if a string starts or ends with a specific string, such as `foo.indexOf('bar') === 0`.\n\nSince ES2015 has added `String#startsWith` and `String#endsWith`, this rule reports other ways to be consistent.\n\n## Rule Details\n\nThis rule is aimed at enforcing a consistent way to check whether a string starts or ends with a specific string.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nlet foo: string;\n\n// starts with\nfoo[0] === 'b';\nfoo.charAt(0) === 'b';\nfoo.indexOf('bar') === 0;\nfoo.slice(0, 3) === 'bar';\nfoo.substring(0, 3) === 'bar';\nfoo.match(/^bar/) != null;\n/^bar/.test(foo);\n\n// ends with\nfoo[foo.length - 1] === 'b';\nfoo.charAt(foo.length - 1) === 'b';\nfoo.lastIndexOf('bar') === foo.length - 3;\nfoo.slice(-3) === 'bar';\nfoo.substring(foo.length - 3) === 'bar';\nfoo.match(/bar$/) != null;\n/bar$/.test(foo);\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nfoo.startsWith('bar');\nfoo.endsWith('bar');\n```\n\n## Options\n\nThere are no options.\n\n```JSON\n{\n    \"@typescript-eslint/prefer-string-starts-ends-with\": \"error\"\n}\n```\n\n## When Not To Use It\n\nIf you don't mind that style, you can turn this rule off safely.",
                "disable": false
            },
            {
                "real_name": "typescript/promise-function-async",
                "display_name": "typescript/promise-function-async",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Functions that return promises must be async (promise-function-async)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Requires any function or method that returns a Promise to be marked async.\nEnsures that each function is only capable of:\n\n- returning a rejected promise, or\n- throwing an Error object.\n\nIn contrast, non-`async` `Promise`-returning functions are technically capable of either.\nCode that handles the results of those functions will often need to handle both cases, which can get complex.\nThis rule's practice removes a requirement for creating code to handle both cases.\n\n## Rule Details\n\nExamples of **incorrect** code for this rule\n\n```ts\nconst arrowFunctionReturnsPromise = () => Promise.resolve('value');\n\nfunction functionDeturnsPromise() {\n  return Math.random() > 0.5 ? Promise.resolve('value') : false;\n}\n```\n\nExamples of **correct** code for this rule\n\n```ts\nconst arrowFunctionReturnsPromise = async () => 'value';\n\nasync function functionDeturnsPromise() {\n  return Math.random() > 0.5 ? 'value' : false;\n}\n```\n\n## Options\n\nOptions may be provided as an object with:\n\n- `allowAny` to indicate that `any` or `unknown` shouldn't be considered Promises (`true` by default).\n- `allowedPromiseNames` to indicate any extra names of classes or interfaces to be considered Promises when returned.\n\nIn addition, each of the following properties may be provided, and default to `true`:\n\n- `checkArrowFunctions`\n- `checkFunctionDeclarations`\n- `checkFunctionExpressions`\n- `checkMethodDeclarations`\n\n```json\n{\n  \"@typescript-eslint/promise-function-async\": [\n    \"error\",\n    {\n      \"allowedPromiseNames\": [\"Thenable\"],\n      \"checkArrowFunctions\": true,\n      \"checkFunctionDeclarations\": true,\n      \"checkFunctionExpressions\": true,\n      \"checkMethodDeclarations\": true\n    }\n  ]\n}\n```\n\n## Related To\n\n- TSLint: [promise-function-async](https://palantir.github.io/tslint/rules/promise-function-async)",
                "disable": false
            },
            {
                "real_name": "typescript/require-array-sort-compare",
                "display_name": "typescript/require-array-sort-compare",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforce giving `compare` argument to `Array#sort` (require-array-sort-compare)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "This rule prevents to invoke `Array#sort()` method without `compare` argument.\n\n`Array#sort()` method sorts that element by the alphabet order.\n\n```ts\n[1, 2, 3, 10, 20, 30].sort(); //→ [1, 10, 2, 20, 3, 30]\n```\n\nThe language specification also noted this trap.\n\n> NOTE 2: Method calls performed by the ToString abstract operations in steps 5 and 7 have the potential to cause SortCompare to not behave as a consistent comparison function.<br> > https://www.ecma-international.org/ecma-262/9.0/#sec-sortcompare\n\n## Rule Details\n\nThis rule is aimed at preventing the calls of `Array#sort` method.\nThis rule ignores the `sort` methods of user-defined types.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nconst array: any[];\nconst stringArray: string[];\n\narray.sort();\n\n// Even if a string array, warns it in favor of `String#localeCompare` method.\nstringArray.sort();\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nconst array: any[];\nconst userDefinedType: { sort(): void };\n\narray.sort((a, b) => a - b);\narray.sort((a, b) => a.localeCompare(b));\n\nuserDefinedType.sort();\n```\n\n### Options\n\nThere is no option.\n\n## When Not To Use It\n\nIf you understand the language specification enough, you can turn this rule off safely.",
                "disable": false
            },
            {
                "real_name": "typescript/require-await",
                "display_name": "typescript/require-await",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Disallow async functions which have no await expression (@typescript-eslint/require-await)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Asynchronous functions that don’t use `await` might not need to be asynchronous functions and could be the unintentional result of refactoring.\n\n## Rule Details\n\nThe `@typescript-eslint/require-await` rule extends the `require-await` rule from ESLint core, and allows for cases where the additional typing information can prevent false positives that would otherwise trigger the rule.\n\nOne example is when a function marked as `async` returns a value that is:\n\n1. already a promise; or\n2. the result of calling another `async` function\n\n```typescript\nasync function numberOne(): Promise<number> {\n  return Promise.resolve(1);\n}\n\nasync function getDataFromApi(endpoint: string): Promise<Response> {\n  return fetch(endpoint);\n}\n```\n\nIn the above examples, the core `require-await` triggers the following warnings:\n\n```\nasync function 'numberOne' has no 'await' expression\nasync function 'getDataFromApi' has no 'await' expression\n```\n\nOne way to resolve these errors is to remove the `async` keyword. However doing so can cause a conflict with the [`@typescript-eslint/promise-function-async`](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/promise-function-async.md) rule (if enabled), which requires any function returning a promise to be marked as `async`.\n\nAnother way to resolve these errors is to add an `await` keyword to the return statements. However doing so can cause a conflict with the [`no-return-await`](https://eslint.org/docs/rules/no-return-await) rule (if enabled), which warns against using `return await` since the return value of an `async` function is always wrapped in `Promise.resolve` anyway.\n\nWith the additional typing information available in Typescript code, this extension to the `require-await` rule is able to look at the _actual_ return types of an `async` function (before being implicitly wrapped in `Promise.resolve`), and avoid the need for an `await` expression when the return value is already a promise.\n\nSee the [ESLint documentation](https://eslint.org/docs/rules/require-await) for more details on the `require-await` rule.\n\n## Rule Changes\n\n```cjson\n{\n    // note you must disable the base rule as it can report incorrect errors\n    \"require-await\": \"off\",\n    \"@typescript-eslint/require-await\": \"error\"\n}\n```\n\n<sup>Taken with ❤️ [from ESLint core](https://github.com/eslint/eslint/blob/master/docs/rules/require-await.md)</sup>",
                "disable": false
            },
            {
                "real_name": "typescript/restrict-plus-operands",
                "display_name": "typescript/restrict-plus-operands",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# When adding two variables, operands must both be of type number or of type string. (restrict-plus-operands)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Examples of **correct** code:\n\n```ts\nvar foo = parseInt('5.5', 10) + 10;\nvar foo = 1n + 1n;\n```\n\nExamples of **incorrect** code:\n\n```ts\nvar foo = '5.5' + 5;\nvar foo = 1n + 1;\n```\n\n## Options\n\n```json\n{\n  \"@typescript-eslint/restrict-plus-operands\": \"error\"\n}\n```\n\n## Compatibility\n\n- TSLint: [restrict-plus-operands](https://palantir.github.io/tslint/rules/restrict-plus-operands/)",
                "disable": false
            },
            {
                "real_name": "typescript/semi",
                "display_name": "typescript/semi",
                "severity": "warning",
                "category": "convention",
                "rule_title": "This rule enforces consistent use of semicolons after statements.",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": "This rule enforces consistent use of semicolons after statements.",
                "owner": null,
                "labels": [],
                "description": "This rule extends the base eslint/semi rule. It supports all options and features of the base rule. This version adds support for numerous typescript features.\n\nSee also the @typescript-eslint/member-delimiter-style rule, which allows you to specify the delimiter for type and interface members.\n\n参考[官方文档](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/semi.md)",
                "disable": false
            },
            {
                "real_name": "typescript/strict-boolean-expressions",
                "display_name": "typescript/strict-boolean-expressions",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Boolean expressions are limited to booleans (strict-boolean-expressions)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Requires that any boolean expression is limited to true booleans rather than\ncasting another primitive to a boolean at runtime.\n\nIt is useful to be explicit, for example, if you were trying to check if a\nnumber was defined. Doing `if (number)` would evaluate to `false` if `number`\nwas defined and `0`. This rule forces these expressions to be explicit and to\nstrictly use booleans.\n\nThe following nodes are checked:\n\n- Arguments to the `!`, `&&`, and `||` operators\n- The condition in a conditional expression `(cond ? x : y)`\n- Conditions for `if`, `for`, `while`, and `do-while` statements.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nconst number = 0;\nif (number) {\n  return;\n}\n\nlet foo = bar || 'foobar';\n\nlet undefinedItem;\nlet foo = undefinedItem ? 'foo' : 'bar';\n\nlet str = 'foo';\nwhile (str) {\n  break;\n}\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nconst number = 0;\nif (typeof number !== 'undefined') {\n  return;\n}\n\nlet foo = typeof bar !== 'undefined' ? bar : 'foobar';\n\nlet undefinedItem;\nlet foo = typeof undefinedItem !== 'undefined' ? 'foo' : 'bar';\n\nlet str = 'foo';\nwhile (typeof str !== 'undefined') {\n  break;\n}\n```\n\n## Options\n\nOptions may be provided as an object with:\n\n- `allowNullable` to allow `undefined` and `null` in addition to `boolean` as a type of all boolean expressions. (`false` by default).\n- `ignoreRhs` to skip the check on the right hand side of expressions like `a && b` or `a || b` - allows these operators to be used for their short-circuiting behavior. (`false` by default).\n\n## Related To\n\n- TSLint: [strict-boolean-expressions](https://palantir.github.io/tslint/rules/strict-boolean-expressions)\n\n- [no-unnecessary-condition](./no-unnecessary-condition.md) - a looser alternative to this rule.",
                "disable": false
            },
            {
                "real_name": "typescript/triple-slash-reference",
                "display_name": "typescript/triple-slash-reference",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Sets preference level for triple slash directives versus ES6-style import declarations. (triple-slash-reference)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Use of triple-slash reference type directives is discouraged in favor of the newer `import` style. This rule allows you to ban use of `/// <reference path=\"\" />`, `/// <reference types=\"\" />`, or `/// <reference lib=\"\" />` directives.\n\nConsider using this rule in place of [`no-triple-slash-reference`](./no-triple-slash-reference.md) which has been deprecated.\n\n## Rule Details\n\nWith `{ \"path\": \"never\", \"types\": \"never\", \"lib\": \"never\" }` options set, the following will all be **incorrect** usage:\n\n```ts\n/// <reference path=\"foo\" />\n/// <reference types=\"bar\" />\n/// <reference lib=\"baz\" />\n```\n\nExamples of **incorrect** code for the `{ \"types\": \"prefer-import\" }` option. Note that these are only errors when **both** stlyes are used for the **same** module:\n\n```ts\n/// <reference types=\"foo\" />\nimport * as foo from 'foo';\n```\n\n```ts\n/// <reference types=\"foo\" />\nimport foo = require('foo');\n```\n\nWith `{ \"path\": \"always\", \"types\": \"always\", \"lib\": \"always\" }` options set, the following will all be **correct** usage:\n\n```ts\n/// <reference path=\"foo\" />\n/// <reference types=\"bar\" />\n/// <reference lib=\"baz\" />\n```\n\nExamples of **correct** code for the `{ \"types\": \"prefer-import\" }` option:\n\n```ts\nimport * as foo from 'foo';\n```\n\n```ts\nimport foo = require('foo');\n```\n\n## When To Use It\n\nIf you want to ban use of one or all of the triple slash reference directives, or any time you might use triple-slash type reference directives and ES6 import declarations in the same file.\n\n## When Not To Use It\n\nIf you want to use all flavors of triple slash reference directives.\n\n## Compatibility\n\n- TSLint: [no-reference](http://palantir.github.io/tslint/rules/no-reference/)\n- TSLint: [no-reference-import](https://palantir.github.io/tslint/rules/no-reference-import/)",
                "disable": false
            },
            {
                "real_name": "typescript/type-annotation-spacing",
                "display_name": "typescript/type-annotation-spacing",
                "severity": "warning",
                "category": "correctness",
                "rule_title": "类型定义的冒号前后是否需要空格",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "默认冒号前必须没有空格，冒号后必须有空格",
                "disable": false
            },
            {
                "real_name": "typescript/typedef",
                "display_name": "typescript/typedef",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Require type annotations to exist (typedef)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "TypeScript cannot always infer types for all places in code.\nSome locations require type annotations for their types to be inferred.\n\n```ts\nclass ContainsText {\n  // There must be a type annotation here to infer the type\n  delayedText: string;\n\n  // `typedef` requires a type annotation here to maintain consistency\n  immediateTextExplicit: string = 'text';\n\n  // This is still a string type because of its initial value\n  immediateTextImplicit = 'text';\n}\n```\n\n> Note: requiring type annotations unnecessarily can be cumbersome to maintain and generally reduces code readability.\n> TypeScript is often better at inferring types than easily written type annotations would allow.\n> Instead of enabling `typedef`, it is generally recommended to use the `--noImplicitAny` and/or `--strictPropertyInitialization` compiler options to enforce type annotations only when useful.\n\n## Rule Details\n\nThis rule can enforce type annotations in locations regardless of whether they're required.\nThis is typically used to maintain consistency for element types that sometimes require them.\n\n> To enforce type definitions existing on call signatures as per TSLint's `arrow-call-signature` and `call-signature` options, use `explicit-function-return-type`.\n\n## Options\n\nThis rule has an object option that may receive any of the following as booleans:\n\n- `\"arrayDestructuring\"`\n- `\"arrowParameter\"`: `true` by default\n- `\"memberVariableDeclaration\"`: `true` by default\n- `\"objectDestructuring\"`\n- `\"parameter\"`: `true` by default\n- `\"propertyDeclaration\"`: `true` by default\n- `\"variableDeclaration\"`\n\nFor example, with the following configuration:\n\n```json\n{\n  \"rules\": {\n    \"@typescript-eslint/typedef\": [\n      \"error\",\n      {\n        \"arrowParameter\": false,\n        \"variableDeclaration\": true\n      }\n    ]\n  }\n}\n```\n\n- Type annotations on arrow function parameters are not required\n- Type annotations on variables are required\n- Options otherwise adhere to the defaults\n\n### arrayDestructuring\n\nWhether to enforce type annotations on variables declared using array destructuring.\n\nExamples of **incorrect** code with `{ \"arrayDestructuring\": true }`:\n\n```ts\nconst [a] = [1];\nconst [b, c] = [1, 2];\n```\n\nExamples of **correct** code with `{ \"arrayDestructuring\": true }`:\n\n```ts\nconst [a]: number[] = [1];\nconst [b]: [number] = [2];\nconst [c, d]: [boolean, string] = [true, 'text'];\n```\n\n### arrowParameter\n\nWhether to enforce type annotations for parameters of arrow functions.\n\nExamples of **incorrect** code with `{ \"arrowParameter\": true }`:\n\n```ts\nconst logsSize = size => console.log(size);\n\n['hello', 'world'].map(text => text.length);\n\nconst mapper = {\n  map: text => text + '...',\n};\n```\n\nExamples of **correct** code with `{ \"arrowParameter\": true }`:\n\n```ts\nconst logsSize = (size: number) => console.log(text);\n\n['hello', 'world'].map((text: string) => text.length);\n\nconst mapper = {\n  map: (text: string) => text + '...',\n};\n```\n\n### memberVariableDeclaration\n\nWhether to enforce type annotations on member variables of classes.\n\nExamples of **incorrect** code with `{ \"memberVariableDeclaration\": true }`:\n\n```ts\nclass ContainsText {\n  delayedText;\n  immediateTextImplicit = 'text';\n}\n```\n\nExamples of **correct** code with `{ \"memberVariableDeclaration\": true }`:\n\n```ts\nclass ContainsText {\n  delayedText: string;\n  immediateTextImplicit: string = 'text';\n}\n```\n\n### objectDestructuring\n\nWhether to enforce type annotations on variables declared using object destructuring.\n\nExamples of **incorrect** code with `{ \"objectDestructuring\": true }`:\n\n```ts\nconst { length } = 'text';\nconst [b, c] = Math.random() ? [1, 2] : [3, 4];\n```\n\nExamples of **correct** code with `{ \"objectDestructuring\": true }`:\n\n```ts\nconst { length }: { length: number } = 'text';\nconst [b, c]: [number, number] = Math.random() ? [1, 2] : [3, 4];\n```\n\n### parameter\n\nWhether to enforce type annotations for parameters of functions and methods.\n\nExamples of **incorrect** code with `{ \"parameter\": true }`:\n\n```ts\nfunction logsSize(size): void {\n  console.log(size);\n}\n\nconst doublesSize = function(size): numeber {\n  return size * 2;\n};\n\nconst divider = {\n  curriesSize(size): number {\n    return size;\n  },\n  dividesSize: function(size): number {\n    return size / 2;\n  },\n};\n\nclass Logger {\n  log(text): boolean {\n    console.log('>', text);\n    return true;\n  }\n}\n```\n\nExamples of **correct** code with `{ \"parameter\": true }`:\n\n```ts\nfunction logsSize(size: number): void {\n  console.log(size);\n}\n\nconst doublesSize = function(size: number): numeber {\n  return size * 2;\n};\n\nconst divider = {\n  curriesSize(size: number): number {\n    return size;\n  },\n  dividesSize: function(size: number): number {\n    return size / 2;\n  },\n};\n\nclass Logger {\n  log(text: boolean): boolean {\n    console.log('>', text);\n    return true;\n  }\n}\n```\n\n### propertyDeclaration\n\nWhether to enforce type annotations for properties of interfaces and types.\n\nExamples of **incorrect** code with `{ \"propertyDeclaration\": true }`:\n\n```ts\ntype Members = {\n  member;\n  otherMember;\n};\n```\n\nExamples of **correct** code with `{ \"propertyDeclaration\": true }`:\n\n```ts\ntype Members = {\n  member: boolean;\n  otherMember: string;\n};\n```\n\n### variableDeclaration\n\nWhether to enforce type annotations for variable declarations, excluding array and object destructuring.\n\nExamples of **incorrect** code with `{ \"variableDeclaration\": true }`:\n\n```ts\nconst text = 'text';\nlet initialText = 'text';\nlet delayedText;\n```\n\nExamples of **correct** code with `{ \"variableDeclaration\": true }`:\n\n```ts\nconst text: string = 'text';\nlet initialText: string = 'text';\nlet delayedText: string;\n```\n\n## When Not To Use It\n\nIf you are using stricter TypeScript compiler options, particularly `--noImplicitAny` and/or `--strictPropertyInitialization`, you likely don't need this rule.\n\nIn general, if you do not consider the cost of writing unnecessary type annotations reasonable, then do not use this rule.\n\n## Further Reading\n\n- [TypeScript Type System](https://basarat.gitbooks.io/typescript/docs/types/type-system.html)\n- [Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n\n## Compatibility\n\n- TSLint: [typedef](https://palantir.github.io/tslint/rules/typedef)",
                "disable": false
            },
            {
                "real_name": "typescript/unbound-method",
                "display_name": "typescript/unbound-method",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Enforces unbound methods are called with their expected scope (unbound-method)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Warns when a method is used outside of a method call.\n\nClass functions don't preserve the class scope when passed as standalone variables.\n\n## Rule Details\n\nExamples of **incorrect** code for this rule\n\n```ts\nclass MyClass {\n  public log(): void {\n    console.log(this);\n  }\n}\n\nconst instance = new MyClass();\n\n// This logs the global scope (`window`/`global`), not the class instance\nconst myLog = instance.log;\nmyLog();\n\n// This log might later be called with an incorrect scope\nconst { log } = instance;\n```\n\nExamples of **correct** code for this rule\n\n```ts\nclass MyClass {\n  public logUnbound(): void {\n    console.log(this);\n  }\n\n  public logBound = () => console.log(this);\n}\n\nconst instance = new MyClass();\n\n// logBound will always be bound with the correct scope\nconst { logBound } = instance;\nlogBound();\n\n// .bind and lambdas will also add a correct scope\nconst dotBindLog = instance.log.bind(instance);\nconst innerLog = () => instance.log();\n```\n\n## Options\n\nThe rule accepts an options object with the following property:\n\n- `ignoreStatic` to not check whether `static` methods are correctly bound\n\n### `ignoreStatic`\n\nExamples of **correct** code for this rule with `{ ignoreStatic: true }`:\n\n```ts\nclass OtherClass {\n  static log() {\n    console.log(OtherClass);\n  }\n}\n\n// With `ignoreStatic`, statics are assumed to not rely on a particular scope\nconst { log } = OtherClass;\n\nlog();\n```\n\n### Example\n\n```json\n{\n  \"@typescript-eslint/unbound-method\": [\n    \"error\",\n    {\n      \"ignoreStatic\": true\n    }\n  ]\n}\n```\n\n## When Not To Use It\n\nIf your code intentionally waits to bind methods after use, such as by passing a `scope: this` along with the method, you can disable this rule.\n\n## Related To\n\n- TSLint: [no-unbound-method](https://palantir.github.io/tslint/rules/no-unbound-method/)",
                "disable": false
            },
            {
                "real_name": "typescript/unified-signatures",
                "display_name": "typescript/unified-signatures",
                "severity": "error",
                "category": "correctness",
                "rule_title": "# Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter. (unified-signatures)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter.\n\n## Rule Details\n\nThis rule aims to keep the source code as maintanable as posible by reducing the amount of overloads.\n\nExamples of **incorrect** code for this rule:\n\n```ts\nfunction f(x: number): void;\nfunction f(x: string): void;\n```\n\n```ts\nf(): void;\nf(...x: number[]): void;\n```\n\nExamples of **correct** code for this rule:\n\n```ts\nfunction f(x: number | string): void;\n```\n\n```ts\nfunction f(x?: ...number[]): void;\n```\n\n## Related to\n\n- TSLint: [`unified-signatures`](https://palantir.github.io/tslint/rules/unified-signatures/)",
                "disable": false
            },
            {
                "real_name": "unicode-bom",
                "display_name": "unicode-bom",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或禁止使用 Unicode 字节顺序标记 (BOM) (unicode-bom)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow the Unicode Byte Order Mark (BOM) (unicode-bom)\n要求或禁止使用 Unicode 字节顺序标记 (BOM) (unicode-bom)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nThe Unicode Byte Order Mark (BOM) is used to specify whether code units are big\nendian or little endian. That is, whether the most significant or least\nsignificant bytes come first. UTF-8 does not require a BOM because byte ordering\ndoes not matter when characters are a single byte. Since UTF-8 is the dominant\nencoding of the web, we make \"never\" the default option.\nUnicode 字节顺序标记 (BOM) 用来指定代码单元是高字节序还是低字节序。也就是说，是高位在前还是低位在前。UTF-8 不需要 BOM 来表明字节顺序，因为单个字节并不影响字节顺序。因为 UTF-8 在网络编码中占有重要位置，我们设置 \"never\" 作为其默认选项。\nRule Details\nIf the \"always\" option is used, this rule requires that files always begin\nwith the Unicode BOM character U+FEFF. If \"never\" is used, files must never\nbegin with U+FEFF.\n如果使用了 \"always\" 选项，该规则要求文件始终以 Unicode BOM 字符 U+FEFF 开头。如果是 \"never\"，文件决不能以 U+FEFF 开始。\nOptions\nThis rule has a string option:\n该规则有一个字符串选项：\n\n\"always\" files must begin with the Unicode BOM\n\"always\" 文件必须以 Unicode BOM 开头\n\"never\" (default) files must not begin with the Unicode BOM\n\"never\" (默认) 文件不能以 Unicode BOM 开头\n\nalways\nExample of correct code for this rule with the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint unicode-bom: \"error\"*/\n\nU+FEFF\nvar abc;\n\n\nExample of incorrect code for this rule with the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint unicode-bom: \"error\"*/\n\nvar abc;\n\n\nnever\nExample of correct code for this rule with the default \"never\" option:\n选项 \"never\" 的 正确 代码示例：\n/*eslint unicode-bom: [\"error\", \"never\"]*/\n\nvar abc;\n\n\nExample of incorrect code for this rule with the \"never\" option:\n选项 \"never\" 的 错误 代码示例：\n/*eslint unicode-bom: [\"error\", \"never\"]*/\n\nU+FEFF\nvar abc;\n\n\nWhen Not To Use It\nIf you use some UTF-16 or UTF-32 files and you want to allow a file to\noptionally begin with a Unicode BOM, you should turn this rule off.\n如果你使用 UTF-16 或 UTF-32 文件，而且你想允许文件以 Unicode BOM 开始，你应该关闭此规则。\nVersion\nThis rule was introduced in ESLint 2.11.0.\n该规则在 ESLint 2.11.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/unicode-bom",
                "disable": false
            },
            {
                "real_name": "use-isnan",
                "display_name": "use-isnan",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求调用 isNaN()检查 NaN (use-isnan).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "require calls to isNaN() when checking for NaN (use-isnan)\n要求调用 isNaN()检查 NaN (use-isnan)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nIn JavaScript, NaN is a special value of the Number type. It’s used to represent any of the “not-a-number” values represented by the double-precision 64-bit format as specified by the IEEE Standard for Binary Floating-Point Arithmetic.\n在 JavaScript 中，NaN 是 Number 类型的一个特殊值。它被用来表示非数值，这里的数值是指在 IEEE 浮点数算术标准中定义的双精度64位格式的值。\nBecause NaN is unique in JavaScript by not being equal to anything, including itself, the results of comparisons to NaN are confusing:\n因为在 JavaScript 中 NaN 独特之处在于它不等于任何值，包括它本身，与 NaN 进行比较的结果是令人困惑：\n\nNaN === NaN or NaN == NaN evaluate to false\nNaN !== NaN or NaN != NaN evaluate to true\n\nTherefore, use Number.isNaN() or global isNaN() functions to test whether a value is NaN.\n因此，使用 Number.isNaN() 或 全局的 isNaN() 函数来测试一个值是否是 NaN。\nRule Details\nThis rule disallows comparisons to ‘NaN’.\n该规则禁止与 ‘NaN’ 的比较。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint use-isnan: \"error\"*/\n\nif (foo == NaN) {\n    // ...\n}\n\nif (foo != NaN) {\n    // ...\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint use-isnan: \"error\"*/\n\nif (isNaN(foo)) {\n    // ...\n}\n\nif (!isNaN(foo)) {\n    // ...\n}\n\n\nFurther Reading\n\nUse the isNaN function to compare with NaN\n\nVersion\nThis rule was introduced in ESLint 0.0.6.\n该规则在 ESLint 0.0.6 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/use-isnan",
                "disable": false
            },
            {
                "real_name": "valid-jsdoc",
                "display_name": "valid-jsdoc",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制使用有效的 JSDoc 注释 (valid-jsdoc)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce valid JSDoc comments (valid-jsdoc)\n强制使用有效的 JSDoc 注释 (valid-jsdoc)\nJSDoc generates application programming interface (API) documentation from specially-formatted comments in JavaScript code. For example, this is a JSDoc comment for a function:\nJSDoc 根据 JavaScript 代码中的特殊格式的注释生成应用程序接口（API）文档。例如，下面的是一个函数的 JSDoc 注释：\n/**\n * Add two numbers.\n * @param {number} num1 The first number.\n * @param {number} num2 The second number.\n * @returns {number} The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n\nIf comments are invalid because of typing mistakes, then documentation will be incomplete.\n如果由于书写错误导致注释是无效的，那么文档将是不完整的。\nIf comments are inconsistent because they are not updated when function definitions are modified, then readers might become confused.\n如果由于函数定义修改了，注释没有得到更新，导致了注释出现不一致的情况，那么读者可能会感到困惑。\nRule Details\nThis rule enforces valid and consistent JSDoc comments. It reports any of the following problems:\n该规则强制使用有效的和一致的 JSDoc 注释。它将报告以下问题：\n\nmissing parameter tag: @arg, @argument, or @param\n缺少参数标签：@arg、@argument 或 @param\ninconsistent order of parameter names in a comment compared to the function or method\n对函数或方法注释，参数名的顺序不一致\nmissing return tag: @return or @returns\n缺少返回标题： @return 或 @returns\nmissing parameter or return type\n缺少参数或返回类型\nmissing parameter or return description\n缺少参数或返回描述\nsyntax error\n语法错误\n\nThis rule does not report missing JSDoc comments for classes, functions, or methods.\n该规则对类、函数或方法报告缺失 JSDoc 注释的情况。\nNote: This rule does not support all of the Google Closure documentation tool’s use cases. As such, some code such as (/**number*/ n => n * 2); will be flagged as missing appropriate function JSDoc comments even though /**number*/ is intended to be a type hint and not a documentation block for the function. We don’t recommend using this rule if you use type hints in this way.\n注意：该规则不支持所有的 Google Closure Tools 文档的所有用例。因此，(/**number*/ n => n * 2); 这样的代码将被标记为缺少适当的的函数 JSDoc 注释，即使有 /**number*/ 暗示是个数字，而且不是一个函数的文档块。如果你以这种方式使用类型提示，我们不推荐你使用这个规则。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint valid-jsdoc: \"error\"*/\n\n// expected @param tag for parameter num1 but found num instead\n// missing @param tag for parameter num2\n// missing return type\n/**\n * Add two numbers.\n * @param {number} num The first number.\n * @returns The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n// missing brace\n// missing @returns tag\n/**\n * @param {string name Whom to greet.\n */\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\n// missing parameter type for num1\n// missing parameter description for num2\n/**\n * Represents a sum.\n * @constructor\n * @param num1 The first number.\n * @param {number} num2\n */\nfunction sum(num1, num2) {\n    this.num1 = num1;\n    this.num2 = num2;\n}\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint valid-jsdoc: \"error\"*/\n/*eslint-env es6*/\n\n/**\n * Add two numbers.\n * @param {number} num1 The first number.\n * @param {number} num2 The second number.\n * @returns {number} The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n// default options allow missing function description\n// return type `void` means the function has no `return` statement\n/**\n * @param {string} name Whom to greet.\n * @returns {void}\n */\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\n// @constructor tag allows missing @returns tag\n/**\n * Represents a sum.\n * @constructor\n * @param {number} num1 The first number.\n * @param {number} num2 The second number.\n */\nfunction sum(num1, num2) {\n    this.num1 = num1;\n    this.num2 = num2;\n}\n\n// class constructor allows missing @returns tag\n/**\n * Represents a sum.\n */\nclass Sum {\n    /**\n     * @param {number} num1 The first number.\n     * @param {number} num2 The second number.\n     */\n    constructor(num1, num2) {\n        this.num1 = num1;\n        this.num2 = num2;\n    }\n}\n\n// @abstract tag allows @returns tag without `return` statement\nclass Widget {\n    /**\n    * When the state changes, does it affect the rendered appearance?\n    * @abstract\n    * @param {Object} state The new state of the widget.\n    * @returns {boolean} Is current appearance inconsistent with new state?\n    */\n    mustRender (state) {\n        throw new Error(\"Widget subclass did not implement mustRender\");\n    }\n}\n\n// @override tag allows missing @param and @returns tags\nclass WonderfulWidget extends Widget {\n    /**\n     * @override\n     */\n    mustRender (state) {\n        return state !== this.state; // shallow comparison\n    }\n}\n\n\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"prefer\" enforces consistent documentation tags specified by an object whose properties mean instead of key use value (for example, \"return\": \"returns\" means instead of @return use @returns)\n\"prefer\" 强制使用一致的文档标签，这些标签使用一个对象进行指定，其属性的意思是要使用的是值而不是键 (例如，\"return\": \"returns\" 意思是使用 @returns 而不是 @return)\n\"preferType\" enforces consistent type strings specified by an object whose properties mean instead of key use value (for example, \"object\": \"Object\" means instead of object use Object)\n\"preferType\" 强制使用一致的类型字符串，这些标签使用一个对象进行指定，其属性的意思是要使用的是值而不是键 (比如, \"object\": \"Object\" 意思是使用 Object而不是 object)\n\"requireReturn\" requires a return tag:\n\"requireReturn\" 要求使用一个返回标签：\n    \ntrue (default) even if the function or method does not have a return statement (this option value does not apply to constructors)\ntrue (默认) 即使 函数或方法没有 return 语句 (该选项不适用于构造函数)\nfalse if and only if the function or method has a return statement (this option value does apply to constructors)\nfalse 当且仅当 函数或方法有一个 return 语句 (该选项不适用于构造函数)\n\n\n\"requireReturnType\": false allows missing type in return tags\n\"requireReturnType\": false 允许在返回标签中缺少类型\n\"matchDescription\" specifies (as a string) a regular expression to match the description in each JSDoc comment (for example, \".+\" requires a description; this option does not apply to descriptions in parameter or return tags)\n\"matchDescription\" 指定一个正则表达式去匹配每个 JSDoc 注释中的描述 (例如， \".+\" 要求有一个描述；该选项不适用于参数或返回标签中的描述)\n\"requireParamDescription\": false allows missing description in parameter tags\n\"requireParamDescription\": false 允许在参数标签缺少描述\n\"requireReturnDescription\": false allows missing description in return tags\n\"requireReturnDescription\": false 允许在返回标签缺少描述\n\nprefer\nExamples of additional incorrect code for this rule with sample \"prefer\": { \"arg\": \"param\", \"argument\": \"param\", \"class\": \"constructor\", \"return\": \"returns\", \"virtual\": \"abstract\" } options:\n选项 \"prefer\": { \"arg\": \"param\", \"argument\": \"param\", \"class\": \"constructor\", \"return\": \"returns\", \"virtual\": \"abstract\" } 的 错误 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"prefer\": { \"arg\": \"param\", \"argument\": \"param\", \"class\": \"constructor\", \"return\": \"returns\", \"virtual\": \"abstract\" } }]*/\n/*eslint-env es6*/\n\n/**\n * Add two numbers.\n * @arg {int} num1 The first number.\n * @arg {int} num2 The second number.\n * @return {int} The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n/**\n * Represents a sum.\n * @class\n * @argument {number} num1 The first number.\n * @argument {number} num2 The second number.\n */\nfunction sum(num1, num2) {\n    this.num1 = num1;\n    this.num2 = num2;\n}\n\nclass Widget {\n    /**\n     * When the state changes, does it affect the rendered appearance?\n     * @virtual\n     * @argument {Object} state The new state of the widget.\n     * @return {boolean} Is current appearance inconsistent with new state?\n     */\n    mustRender (state) {\n        throw new Error(\"Widget subclass did not implement mustRender\");\n    }\n}\n\n\npreferType\nExamples of additional incorrect code for this rule with sample \"preferType\": { \"Boolean\": \"boolean\", \"Number\": \"number\", \"object\": \"Object\", \"String\": \"string\" } options:\n选项 \"preferType\": { \"Boolean\": \"boolean\", \"Number\": \"number\", \"object\": \"Object\", \"String\": \"string\" } 的 错误 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"preferType\": { \"Boolean\": \"boolean\", \"Number\": \"number\", \"object\": \"Object\", \"String\": \"string\" } }]*/\n/*eslint-env es6*/\n\n/**\n * Add two numbers.\n * @param {Number} num1 The first number.\n * @param {Number} num2 The second number.\n * @returns {Number} The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n/**\n * Output a greeting as a side effect.\n * @param {String} name Whom to greet.\n * @returns {void}\n */\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\nclass Widget {\n    /**\n     * When the state changes, does it affect the rendered appearance?\n     * @abstract\n     * @param {object} state The new state of the widget.\n     * @returns {Boolean} Is current appearance inconsistent with new state?\n     */\n    mustRender (state) {\n        throw new Error(\"Widget subclass did not implement mustRender\");\n    }\n}\n\n\nrequireReturn\nExamples of additional incorrect code for this rule with the \"requireReturn\": false option:\n选项 \"requireReturn\": false 的 错误 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"requireReturn\": false }]*/\n\n// unexpected @returns tag because function has no `return` statement\n/**\n * @param {string} name Whom to greet.\n * @returns {string} The greeting.\n */\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\n// add @abstract tag to allow @returns tag without `return` statement\nclass Widget {\n    /**\n     * When the state changes, does it affect the rendered appearance?\n     * @param {Object} state The new state of the widget.\n     * @returns {boolean} Is current appearance inconsistent with new state?\n     */\n    mustRender (state) {\n        throw new Error(\"Widget subclass did not implement mustRender\");\n    }\n}\n\n\nExample of additional correct code for this rule with the \"requireReturn\": false option:\n选项 \"requireReturn\": false 的 正确 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"requireReturn\": false }]*/\n\n/**\n * @param {string} name Whom to greet.\n */\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\n\nrequireReturnType\nExample of additional correct code for this rule with the \"requireReturnType\": false option:\n选项 \"requireReturnType\": false 的 正确 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"requireReturnType\": false }]*/\n\n/**\n * Add two numbers.\n * @param {number} num1 The first number.\n * @param {number} num2 The second number.\n * @returns The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n\nmatchDescription\nExample of additional incorrect code for this rule with a sample \"matchDescription\": \".+\" option:\n选项 \"matchDescription\": \".+\" 的 错误 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"matchDescription\": \".+\" }]*/\n\n// missing function description\n/**\n * @param {string} name Whom to greet.\n * @returns {void}\n */\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\n\nrequireParamDescription\nExample of additional correct code for this rule with the \"requireParamDescription\": false option:\n选项 \"requireParamDescription\": false 的 正确 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"requireParamDescription\": false }]*/\n\n/**\n * Add two numbers.\n * @param {int} num1\n * @param {int} num2\n * @returns {int} The sum of the two numbers.\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n\nrequireReturnDescription\nExample of additional correct code for this rule with the \"requireReturnDescription\": false option:\n选项 \"requireReturnDescription\": false 的 正确 代码示例：\n/*eslint valid-jsdoc: [\"error\", { \"requireReturnDescription\": false }]*/\n\n/**\n * Add two numbers.\n * @param {number} num1 The first number.\n * @param {number} num2 The second number.\n * @returns {number}\n */\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\n\nWhen Not To Use It\nIf you aren’t using JSDoc, then you can safely turn this rule off.\n如果你不使用 JSDoc，你可以关闭此规则。\nFurther Reading\n\nJSDoc\n\nRelated Rules\n\nrequire-jsdoc\n\nVersion\nThis rule was introduced in ESLint 0.4.0.\n该规则在 ESLint 0.4.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/valid-jsdoc",
                "disable": false
            },
            {
                "real_name": "valid-typeof",
                "display_name": "valid-typeof",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制 typeof 表达式与有效的字符串进行比较 (valid-typeof).",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "enforce comparing typeof expressions against valid strings (valid-typeof)\n强制 typeof 表达式与有效的字符串进行比较 (valid-typeof)\nThe \"extends\": \"eslint:recommended\" property in a configuration file enables this rule.\n配置文件中的 \"extends\": \"eslint:recommended\" 属性启用了此规则。\nFor a vast majority of use cases, the result of the typeof operator is one of the following string literals: \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\" and \"symbol\". It is usually a typing mistake to compare the result of a typeof operator to other string literals.\n对于绝大多数用例而言，typeof 操作符的结果是以下字符串字面量中的一个：\"undefined\"、\"object\"、\"boolean\"、\"number\"、\"string\"、\"function\" 和 \"symbol\"。把 typeof 操作符的结果与其它字符串进行比较，通常是个书写错误。\nRule Details\nThis rule enforces comparing typeof expressions to valid string literals.\n该规则强制 typeof 表达式与有效的字符串进行比较。\nOptions\nThis rule has an object option:\n该规则有一个对象选项：\n\n\"requireStringLiterals\": true requires typeof expressions to only be compared to string literals or other typeof expressions, and disallows comparisons to any other value.\n\"requireStringLiterals\": true 要求 typeof 表达式只与字符串字面量或其它 typeof 表达式 进行比较，禁止与其它值进行比较。\n\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint valid-typeof: \"error\"*/\n\ntypeof foo === \"strnig\"\ntypeof foo == \"undefimed\"\ntypeof bar != \"nunber\"\ntypeof bar !== \"fucntion\"\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint valid-typeof: \"error\"*/\n\ntypeof foo === \"string\"\ntypeof bar == \"undefined\"\ntypeof foo === baz\ntypeof bar === typeof qux\n\n\nExamples of incorrect code with the { \"requireStringLiterals\": true } option:\n选项 { \"requireStringLiterals\": true } 的 错误 代码示例：\ntypeof foo === undefined\ntypeof bar == Object\ntypeof baz === \"strnig\"\ntypeof qux === \"some invalid type\"\ntypeof baz === anotherVariable\ntypeof foo == 5\n\n\nExamples of correct code with the { \"requireStringLiterals\": true } option:\n选项 { \"requireStringLiterals\": true } 的 正确 代码示例：\ntypeof foo === \"undefined\"\ntypeof bar == \"object\"\ntypeof baz === \"string\"\ntypeof bar === typeof qux\n\n\nWhen Not To Use It\nYou may want to turn this rule off if you will be using the typeof operator on host objects.\n如果你将在宿主对象上使用 typeof 操作符，你可以关闭此规则。\nVersion\nThis rule was introduced in ESLint 0.5.0.\n该规则在 ESLint 0.5.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/valid-typeof",
                "disable": false
            },
            {
                "real_name": "vars-on-top",
                "display_name": "vars-on-top",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求将变量声明放在它们作用域的顶部 (vars-on-top)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Variable Declarations to be at the top of their scope (vars-on-top)\n要求将变量声明放在它们作用域的顶部 (vars-on-top)\nThe vars-on-top rule generates warnings when variable declarations are not used serially at the top of a function scope or the top of a program.\nBy default variable declarations are always moved (“hoisted”) invisibly to the top of their containing scope by the JavaScript interpreter.\nThis rule forces the programmer to represent that behaviour by manually moving the variable declaration to the top of its containing scope.\n该规则会生成警告，当变量的声明不是在函数作用域顶部或者项目顶部被连续使用时。默认的，JavaScript 的解析器会隐式的将变量的声明移到它们所在作用域的顶部。这个规则迫使程序员通过手动移动变量声明到其作用域的顶部来实现这个行为。\nRule Details\nThis rule aims to keep all variable declarations in the leading series of statements.\nAllowing multiple declarations helps promote maintainability and is thus allowed.\n此规则目的在于保持所有的变量声明在一系列的语句中处于前导地位。允许多行声明有助于提高可维护性因此是被允许的。\nExamples of incorrect code for this rule:\n错误 代码示例：\n/*eslint vars-on-top: \"error\"*/\n\n// Variable declarations in a block:\nfunction doSomething() {\n    var first;\n    if (true) {\n        first = true;\n    }\n    var second;\n}\n\n// Variable declaration in for initializer:\nfunction doSomething() {\n    for (var i=0; i<10; i++) {}\n}\n\n\n/*eslint vars-on-top: \"error\"*/\n\n// Variables after other statements:\nf();\nvar a;\n\n\nExamples of correct code for this rule:\n正确 代码示例：\n/*eslint vars-on-top: \"error\"*/\n\nfunction doSomething() {\n    var first;\n    var second; //multiple declarations are allowed at the top\n    if (true) {\n        first = true;\n    }\n}\n\nfunction doSomething() {\n    var i;\n    for (i=0; i<10; i++) {}\n}\n\n\n/*eslint vars-on-top: \"error\"*/\n\nvar a;\nf();\n\n\n/*eslint vars-on-top: \"error\"*/\n\n// Directives may precede variable declarations.\n\"use strict\";\nvar a;\nf();\n\n// Comments can describe variables.\nfunction doSomething() {\n    // this is the first var.\n    var first;\n    // this is the second var.\n    var second\n}\n\n\nFurther Reading\n\nJavaScript Scoping and Hoisting\nvar Hoisting\nA criticism of the Single Var Pattern in JavaScript, and a simple alternative\nMultiple var statements in JavaScript, not superfluous\n\nVersion\nThis rule was introduced in ESLint 0.8.0.\n该规则在 ESLint 0.8.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/vars-on-top",
                "disable": false
            },
            {
                "real_name": "wrap-iife",
                "display_name": "wrap-iife",
                "severity": "error",
                "category": "correctness",
                "rule_title": "需要把立即执行的函数包裹起来 (wrap-iife)",
                "rule_params": "",
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require IIFEs to be Wrapped (wrap-iife)\r\n需要把立即执行的函数包裹起来 (wrap-iife)\r\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\r\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\r\nYou can immediately invoke function expressions, but not function declarations. A common technique to create an immediately-invoked function expression (IIFE) is to wrap a function declaration in parentheses. The opening parentheses causes the contained function to be parsed as an expression, rather than a declaration.\r\n你可以立即调用函数表达式，而不是函数声明。创建一个立即执行函数 (IIFE) 的一个通用技术是用括号包裹一个函数声明。括号内的函数被解析为一个表达式，而不是一个声明。\r\n// function expression could be unwrapped\r\nvar x = function () { return { y: 1 };}();\r\n\r\n// function declaration must be wrapped\r\nfunction () { /* side effects */ }(); // SyntaxError\r\n\r\n\r\nRule Details\r\nThis rule requires all immediately-invoked function expressions to be wrapped in parentheses.\r\n该规则要求所有的立即执行函数表达式使用括号包裹起来。\r\nOptions\r\nThis rule has two options, a string option and an object option.\r\n该规则有两个选项，一个是字符串，一个是对象。\r\nString option:\r\n字符串选项：\r\n\r\n\"outside\" enforces always wrapping the call expression. The default is \"outside\".\r\n\"outside\" 强制总是包裹 call 表达式。默认是 \"outside\"。\r\n\"inside\" enforces always wrapping the function expression.\r\n\"inside\" 强制总是包裹 function 表达式。\r\n\"any\" enforces always wrapping, but allows either style.\r\n\"any\"强制总是包裹，但允许其它风格。\r\n\r\nObject option:\r\n对象选项：\r\n\r\n\"functionPrototypeMethods\": true additionally enforces wrapping function expressions invoked using .call and .apply. The default is false.\r\n\"functionPrototypeMethods\": true 使用 .call 和 .apply 调用时，强制要求包裹函数表达式。默认为 false。\r\n\r\noutside\r\nExamples of incorrect code for the default \"outside\" option:\r\n默认选项 \"outside\" 的 错误 代码示例：\r\n/*eslint wrap-iife: [\"error\", \"outside\"]*/\r\n\r\nvar x = function () { return { y: 1 };}(); // unwrapped\r\nvar x = (function () { return { y: 1 };})(); // wrapped function expression\r\n\r\n\r\nExamples of correct code for the default \"outside\" option:\r\n默认选项 \"outside\" 的 正确 代码示例：\r\n/*eslint wrap-iife: [\"error\", \"outside\"]*/\r\n\r\nvar x = (function () { return { y: 1 };}()); // wrapped call expression\r\n\r\n\r\ninside\r\nExamples of incorrect code for the \"inside\" option:\r\n选项 \"inside\" 的 错误 代码示例：\r\n/*eslint wrap-iife: [\"error\", \"inside\"]*/\r\n\r\nvar x = function () { return { y: 1 };}(); // unwrapped\r\nvar x = (function () { return { y: 1 };}()); // wrapped call expression\r\n\r\n\r\nExamples of correct code for the \"inside\" option:\r\n选项 \"inside\" 的 正确 代码示例：\r\n/*eslint wrap-iife: [\"error\", \"inside\"]*/\r\n\r\nvar x = (function () { return { y: 1 };})(); // wrapped function expression\r\n\r\n\r\nany\r\nExamples of incorrect code for the \"any\" option:\r\n选项 \"any\" 的 错误 代码示例：\r\n/*eslint wrap-iife: [\"error\", \"any\"]*/\r\n\r\nvar x = function () { return { y: 1 };}(); // unwrapped\r\n\r\n\r\nExamples of correct code for the \"any\" option:\r\n选项 \"any\" 的 正确 代码示例：\r\n/*eslint wrap-iife: [\"error\", \"any\"]*/\r\n\r\nvar x = (function () { return { y: 1 };}()); // wrapped call expression\r\nvar x = (function () { return { y: 1 };})(); // wrapped function expression\r\n\r\n\r\nfunctionPrototypeMethods\r\nExamples of incorrect code for this rule with the \"inside\", { \"functionPrototypeMethods\": true } options:\r\n选项 \"inside\", { \"functionPrototypeMethods\": true } 的 错误 代码示例：\r\n/* eslint wrap-iife: [2, \"inside\", { functionPrototypeMethods: true }] */\r\n\r\nvar x = function(){ foo(); }()\r\nvar x = (function(){ foo(); }())\r\nvar x = function(){ foo(); }.call(bar)\r\nvar x = (function(){ foo(); }.call(bar))\r\n\r\n\r\nExamples of correct code for this rule with the \"inside\", { \"functionPrototypeMethods\": true } options:\r\n选项 \"inside\", { \"functionPrototypeMethods\": true } 的 正确 代码示例：\r\n/* eslint wrap-iife: [2, \"inside\", { functionPrototypeMethods: true }] */\r\n\r\nvar x = (function(){ foo(); })()\r\nvar x = (function(){ foo(); }).call(bar)\r\n\r\n\r\nVersion\r\nThis rule was introduced in ESLint 0.0.9.\r\n该规则在 ESLint 0.0.9 中被引入。\r\nResources\r\n\r\nRule source\r\nDocumentation source\r\n\r\n\r\n\r\n可参考官网：\r\nhttps://cn.eslint.org/docs/rules/wrap-iife",
                "disable": false
            },
            {
                "real_name": "wrap-regex",
                "display_name": "wrap-regex",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求正则表达式被包裹起来 (wrap-regex)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require Regex Literals to be Wrapped (wrap-regex)\n要求正则表达式被包裹起来 (wrap-regex)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nWhen a regular expression is used in certain situations, it can end up looking like a division operator. For example:\n在某些情况下，使用正则表达式时，它看起来会像一个除法运算符。例如：\nfunction a() {\n    return /foo/.test(\"bar\");\n}\n\n\nRule Details\nThis is used to disambiguate the slash operator and facilitates more readable code.\n该规则旨在消除斜线运算符造成的歧义，增加代码的可读性。\nExample of incorrect code for this rule:\n错误 代码示例：\n/*eslint wrap-regex: \"error\"*/\n\nfunction a() {\n    return /foo/.test(\"bar\");\n}\n\n\nExample of correct code for this rule:\n正确 代码示例：\n/*eslint wrap-regex: \"error\"*/\n\nfunction a() {\n    return (/foo/).test(\"bar\");\n}\n\n\nVersion\nThis rule was introduced in ESLint 0.1.0.\n该规则在 ESLint 0.1.0 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/wrap-regex",
                "disable": false
            },
            {
                "real_name": "yield-star-spacing",
                "display_name": "yield-star-spacing",
                "severity": "error",
                "category": "correctness",
                "rule_title": "强制在 yield* 表达式中 * 周围使用空格  (yield-star-spacing)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Enforce spacing around the * in yield* expressions (yield-star-spacing)\n强制在 yield* 表达式中 * 周围使用空格  (yield-star-spacing)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nRule Details\nThis rule enforces spacing around the * in yield* expressions.\n该规则强制在 yield* 表达式中 * 左右使用空格。\nTo use this rule you either need to use the es6 environment or\nset ecmaVersion to 6 in parserOptions.\n使用此规则，你需要使用 es6 环境 或\n在 parserOptions中设置 ecmaVersion 为 6。\nOptions\nThe rule takes one option, an object, which has two keys before and after having boolean values true or false.\n该规则有一个对象选项，两个属性 before 和 after，值为 true 或 false。\n\nbefore enforces spacing between the yield and the *.\nIf true, a space is required, otherwise spaces are disallowed.\nbefore 强制在 yield 和 * 之间有空格。\n如果为 true，要求有一个空格，否则禁止有空格。\nafter enforces spacing between the * and the argument.\nIf it is true, a space is required, otherwise spaces are disallowed.\nafter 强制在 * 和 参数之间有空格。\n如果为 true，要求有一个空格，否则禁止有空格。\n\nThe default is {\"before\": false, \"after\": true}.\n默认为 {\"before\": false, \"after\": true} 。\n\"yield-star-spacing\": [\"error\", {\"before\": true, \"after\": false}]\n\n\nThe option also has a string shorthand:\n该选项也有简写形式：\n\n{\"before\": false, \"after\": true} → \"after\"\n{\"before\": false, \"after\": true} → \"after\"\n{\"before\": true, \"after\": false} → \"before\"\n{\"before\": true, \"after\": false} → \"before\"\n{\"before\": true, \"after\": true} → \"both\"\n{\"before\": true, \"after\": true} → \"both\"\n{\"before\": false, \"after\": false} → \"neither\"\n{\"before\": false, \"after\": false} → \"neither\"\n\n\"yield-star-spacing\": [\"error\", \"after\"]\n\n\nExamples\nafter\nExamples of correct code for this rule with the default \"after\" option:\n默认选项 \"after\" 的 正确 代码示例：\n/*eslint yield-star-spacing: [\"error\", \"after\"]*/\n/*eslint-env es6*/\n\nfunction* generator() {\n  yield* other();\n}\n\n\nbefore\nExamples of correct code for this rule with the \"before\" option:\n选项 \"before\" 的 正确 代码示例：\n/*eslint yield-star-spacing: [\"error\", \"before\"]*/\n/*eslint-env es6*/\n\nfunction *generator() {\n  yield *other();\n}\n\n\nboth\nExamples of correct code for this rule with the \"both\" option:\n选项 \"both\" 的 正确 代码示例：\n/*eslint yield-star-spacing: [\"error\", \"both\"]*/\n/*eslint-env es6*/\n\nfunction * generator() {\n  yield * other();\n}\n\n\nneither\nExamples of correct code for this rule with the \"neither\" option:\n选项 \"neither\" 的 正确 代码示例：\n/*eslint yield-star-spacing: [\"error\", \"neither\"]*/\n/*eslint-env es6*/\n\nfunction*generator() {\n  yield*other();\n}\n\n\nWhen Not To Use It\nIf your project will not be using generators or you are not concerned with spacing consistency, you do not need this rule.\n如果你的项目不使用 generator 函数或你不关心空格的一致性，你不需要使用此规则。\nFurther Reading\n\nUnderstanding ES6: Generators\n\nVersion\nThis rule was introduced in ESLint 2.0.0-alpha-1.\n该规则在 ESLint 2.0.0-alpha-1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/yield-star-spacing",
                "disable": false
            },
            {
                "real_name": "yoda",
                "display_name": "yoda",
                "severity": "error",
                "category": "correctness",
                "rule_title": "要求或者禁止Yoda条件 (yoda)",
                "rule_params": null,
                "custom": false,
                "languages": [
                    "ts"
                ],
                "solution": null,
                "owner": null,
                "labels": [],
                "description": "Require or disallow Yoda Conditions (yoda)\n要求或者禁止Yoda条件 (yoda)\nThe --fix option on the command line can automatically fix some of the problems reported by this rule.\n命令行中的 --fix 选项可以自动修复一些该规则报告的问题。\nYoda conditions are so named because the literal value of the condition comes first while the variable comes second. For example, the following is a Yoda condition:\nYoda 条件被如此命名，是因为在条件判断中字面量在先而变量在第二的位置。例如，以下是 Yoda 条件：\nif (\"red\" === color) {\n    // ...\n}\n\n\nThis is called a Yoda condition because it reads as, “if red equals the color”, similar to the way the Star Wars character Yoda speaks. Compare to the other way of arranging the operands:\n它被叫做 Yoda 条件是因为它这样读：”红色是颜色”，类似于星球大战中 Yoda 的讲话方式。对比另一种操作数的排序方式：\nif (color === \"red\") {\n    // ...\n}\n\n\nThis typically reads, “if the color equals red”, which is arguably a more natural way to describe the comparison.\n这通常读作，”颜色是红的”，这是一种更自然的方式去描述对比。\nProponents of Yoda conditions highlight that it is impossible to mistakenly use = instead of == because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available.\nYoda 条件的支持者强调，错误地使用 = 代替 == 是不可能的，因为你不能分配给一个文本值。这样做将导致一个语法错误，并且你会被提早告知。因此在工具尚不可用的早期编程中，这种做法是非常常见的。\nOpponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of = instead of == (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn’t outweigh the readability hit the code takes while using Yoda conditions.\nYoda 条件的反对者指出工具使我们成为更好的程序员，因为工具将捕获使用 = 代替 == 的错误（ESLint 将为你捕获这个错误）。因此,他们认为当使用 Yoda 条件时，该模式的实用性并不高于代码的可读性。\nRule Details\nThis rule aims to enforce consistent style of conditions which compare a variable to a literal value.\n这条规则需要一个参数。如果是 \"never\" 那么比较绝不能是一个 Yoda 条件。\nOptions\nThis rule can take a string option:\n该规则只有一个字符串选项：\n\nIf it is the default \"never\", then comparisons must never be Yoda conditions.\n如果是默认的 \"never\"，则比较绝不能是 Yoda 条件。\nIf it is \"always\", then the literal value must always come first.\n如果是 \"always\"，那么字面量值必须放在首位。\n\nThe default \"never\" option can have exception options in an object literal:\n默认选项 \"never\" 可以有例外情况，是个对象：\n\nIf the \"exceptRange\" property is true, the rule allows yoda conditions in range comparisons which are wrapped directly in parentheses, including the parentheses of an if or while condition. The default value is false. A range comparison tests whether a variable is inside or outside the range between two literal values.\n如果 \"exceptRange\" 为 true，该规则 允许 yoda 条件 出现在被括号包裹的范围比较中，包括 if 或 while 条件的括号。默认为 false。一个 范围 比较测试一个变量是在两个字面量内部还是外部。\nIf the \"onlyEquality\" property is true, the rule reports yoda conditions only for the equality operators == and ===. The default value is false.\n如果 \"onlyEquality\" 为 true，该规则 只 对等号操作符 == 和 === 报告 yoda 条件。默认为 false。\n\nThe onlyEquality option allows a superset of the exceptions which exceptRange allows, thus both options are not useful together.\nonlyEquality 选项所允许的是 exceptRange 所允许的例外的超集，因此同时使用它们什么用。\nnever\nExamples of incorrect code for the default \"never\" option:\n默认选项\"never\"的 错误 代码示例：\n/*eslint yoda: \"error\"*/\n\nif (\"red\" === color) {\n    // ...\n}\n\nif (true == flag) {\n    // ...\n}\n\nif (5 > count) {\n    // ...\n}\n\nif (-1 < str.indexOf(substr)) {\n    // ...\n}\n\nif (0 <= x && x < 1) {\n    // ...\n}\n\n\nExamples of correct code for the default \"never\" option:\n默认选项 \"never\" 的 正确 代码示例：\n/*eslint yoda: \"error\"*/\n\nif (5 & value) {\n    // ...\n}\n\nif (value === \"red\") {\n    // ...\n}\n\n\nexceptRange\nExamples of correct code for the \"never\", { \"exceptRange\": true } options:\n选项 \"never\", { \"exceptRange\": true } 的 正确 代码示例：\n/*eslint yoda: [\"error\", \"never\", { \"exceptRange\": true }]*/\n\nfunction isReddish(color) {\n    return (color.hue < 60 || 300 < color.hue);\n}\n\nif (x < -1 || 1 < x) {\n    // ...\n}\n\nif (count < 10 && (0 <= rand && rand < 1)) {\n    // ...\n}\n\nfunction howLong(arr) {\n    return (0 <= arr.length && arr.length < 10) ? \"short\" : \"long\";\n}\n\n\nonlyEquality\nExamples of correct code for the \"never\", { \"onlyEquality\": true } options:\n选项 \"never\", { \"onlyEquality\": true } 的 正确 代码示例：\n/*eslint yoda: [\"error\", \"never\", { \"onlyEquality\": true }]*/\n\nif (x < -1 || 9 < x) {\n}\n\nif (x !== 'foo' && 'bar' != x) {\n}\n\n\nalways\nExamples of incorrect code for the \"always\" option:\n选项 \"always\" 的 错误 代码示例：\n/*eslint yoda: [\"error\", \"always\"]*/\n\nif (color == \"blue\") {\n    // ...\n}\n\n\nExamples of correct code for the \"always\" option:\n选项 \"always\" 的 正确 代码示例：\n/*eslint yoda: [\"error\", \"always\"]*/\n\nif (\"blue\" == value) {\n    // ...\n}\n\nif (-1 < str.indexOf(substr)) {\n    // ...\n}\n\n\nFurther Reading\n\nYoda Conditions\nYoda Notation and Safe Switching\n\nVersion\nThis rule was introduced in ESLint 0.7.1.\n该规则在 ESLint 0.7.1 中被引入。\nResources\n\nRule source\nDocumentation source\n\n\n\n可参考官网：\nhttps://cn.eslint.org/docs/rules/yoda",
                "disable": false
            }
        ],
        "open_user": true,
        "open_saas": false
    }
]